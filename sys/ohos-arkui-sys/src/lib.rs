/* automatically generated by rust-bindgen 0.65.1 */

#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(clippy::missing_safety_doc)]

use napi_sys_ohos::*;
use ohos_native_drawing_sys::*;

#[link(name = "ace_ndk.z")]
unsafe extern "C" {}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DrawableDescriptor {
    _unused: [u8; 0],
}
#[doc = " @brief Introduces the native pixel map information defined by Image Kit.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PixelmapNative {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to OH_PixelmapNative.\n\n @since 12"]
pub type OH_PixelmapNativeHandle = *mut OH_PixelmapNative;
#[doc = " @brief Defines the ArkUI native component object.\n\n @since 22"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Node {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to the ArkUI native component object.\n\n @since 22"]
pub type ArkUI_NodeHandle = *mut ArkUI_Node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DrawableDescriptor_AnimationController {
    _unused: [u8; 0],
}
#[doc = " animation is initial."]
#[cfg(feature = "api-22")]
pub const DrawableDescriptor_AnimationStatus_DRAWABLE_DESCRIPTOR_ANIMATION_STATUS_INITIAL:
    DrawableDescriptor_AnimationStatus = 0;
#[doc = " animation is playing."]
#[cfg(feature = "api-22")]
pub const DrawableDescriptor_AnimationStatus_DRAWABLE_DESCRIPTOR_ANIMATION_STATUS_RUNNING:
    DrawableDescriptor_AnimationStatus = 1;
#[doc = " animation is paused."]
#[cfg(feature = "api-22")]
pub const DrawableDescriptor_AnimationStatus_DRAWABLE_DESCRIPTOR_ANIMATION_STATUS_PAUSED:
    DrawableDescriptor_AnimationStatus = 2;
#[doc = " animation is stopped."]
#[cfg(feature = "api-22")]
pub const DrawableDescriptor_AnimationStatus_DRAWABLE_DESCRIPTOR_ANIMATION_STATUS_STOPPED:
    DrawableDescriptor_AnimationStatus = 3;
#[doc = " @brief Defines the animation status of the drawable descriptor.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type DrawableDescriptor_AnimationStatus = u32;
extern "C" {
    #[doc = " @brief Creates a DrawableDescriptor from a Pixelmap.\n\n @param pixelMap Indicates the pointer to a Pixelmap\n @return Returns the pointer to the drawableDescriptor.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_CreateFromPixelMap(
        pixelMap: OH_PixelmapNativeHandle,
    ) -> *mut ArkUI_DrawableDescriptor;
}
extern "C" {
    #[doc = " @brief Creates a DrawableDescriptor from a Pixelmap array.\n\n @param array Indicates the pointer to a Pixelmap array.\n @param size Indicates the size of the Pixelmap array.\n @return Returns the pointer to the drawableDescriptor.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_CreateFromAnimatedPixelMap(
        array: *mut OH_PixelmapNativeHandle,
        size: i32,
    ) -> *mut ArkUI_DrawableDescriptor;
}
extern "C" {
    #[doc = " @brief Destroys the pointer to the drawableDescriptor.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_Dispose(drawableDescriptor: *mut ArkUI_DrawableDescriptor);
}
extern "C" {
    #[doc = " @brief Obtains the Pixelmap object.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Returns the pointer to the PixelMap.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetStaticPixelMap(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> OH_PixelmapNativeHandle;
}
extern "C" {
    #[doc = " @brief Obtains the Pixelmap array used to play the animation.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Returns the pointer to the PixelMap array.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimatedPixelMapArray(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> *mut OH_PixelmapNativeHandle;
}
extern "C" {
    #[doc = " @brief Obtains the size of the Pixelmap array used to play the animation.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Returns the size of the Pixelmap array.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimatedPixelMapArraySize(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the total playback duration.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @param duration Indicates the total playback duration. The unit is millisecond.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_SetAnimationDuration(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
        duration: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the total playback duration.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Return the total playback duration. The unit is millisecond.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimationDuration(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the number of playback times.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @param iteration Indicates the number of playback times.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_SetAnimationIteration(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
        iteration: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the number of playback times.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Returns the number of playback times.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimationIteration(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the frame duration array.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @param durations Indicates the pointer to the frame duration array.\n @param size Indicates the size of the frame duration array.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_SetAnimationFrameDurations(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
        durations: *mut u32,
        size: usize,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the frame duration array.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @param durations Indicates the pointer to the frame duration array.\n @param size Indicates the size of the frame duration array.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimationFrameDurations(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
        durations: *mut u32,
        size: *mut usize,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to play the animation automatically.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @param autoPlay Indicates whether to play the animation automatically.\n                 default value is 1, which means to play the animation automatically.\n                 value 0 means not to play the animation automatically.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_SetAnimationAutoPlay(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
        autoPlay: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether to play the animation automatically.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @param autoPlay Indicates whether to play the animation automatically.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimationAutoPlay(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
        autoPlay: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the animation controller.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @param node Indicates the node handle.\n @param controller Indicates the pointer to the animation controller.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_CreateAnimationController(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
        node: ArkUI_NodeHandle,
        controller: *mut *mut ArkUI_DrawableDescriptor_AnimationController,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Releases the animation controller.\n\n @param controller Indicates the pointer to the animation controller.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_DisposeAnimationController(
        controller: *mut ArkUI_DrawableDescriptor_AnimationController,
    );
}
extern "C" {
    #[doc = " @brief Starts the animation from first frame.\n\n @param controller Indicates the pointer to the animation controller.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_StartAnimation(
        controller: *mut ArkUI_DrawableDescriptor_AnimationController,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Stops the animation and back to first frame.\n\n @param controller Indicates the pointer to the animation controller.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_StopAnimation(
        controller: *mut ArkUI_DrawableDescriptor_AnimationController,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Resumes the animation at the current frame.\n\n @param controller Indicates the pointer to the animation controller.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_ResumeAnimation(
        controller: *mut ArkUI_DrawableDescriptor_AnimationController,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Pauses the animation at the current frame.\n\n @param controller Indicates the pointer to the animation controller.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_PauseAnimation(
        controller: *mut ArkUI_DrawableDescriptor_AnimationController,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the animation playback status.\n\n @param controller Indicates the pointer to the animation controller.\n @param status Indicates the pointer to the animation playback status.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful;\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimationStatus(
        controller: *mut ArkUI_DrawableDescriptor_AnimationController,
        status: *mut DrawableDescriptor_AnimationStatus,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeContent {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer type of the ArkUI node content\n\n @since 12"]
pub type ArkUI_NodeContentHandle = *mut ArkUI_NodeContent;
#[doc = " @brief Defines the custom dialog box controller of ArkUI on the native side.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeDialog {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_LayoutConstraint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DrawContext {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to the custom dialog box controller of ArkUI on the native side.\n\n @since 12"]
pub type ArkUI_NativeDialogHandle = *mut ArkUI_NativeDialog;
#[doc = " @brief Defines the return value structure for the <b>onGetIrregularSizeByIndex</b> callback\n in <b>Grid</b> layout options.\n\n @since 22"]
#[cfg(feature = "api-22")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GridItemSize {
    #[doc = " Number of rows occupied by the <b>GridItem</b> component."]
    pub rowSpan: u32,
    #[doc = " Number of columns occupied by the <b>GridItem</b> component."]
    pub columnSpan: u32,
}
#[doc = " @brief Defines the return value structure for the <b>onGetRectByIndex</b> callback in <b>Grid</b> layout options.\n\n @since 22"]
#[cfg(feature = "api-22")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GridItemRect {
    #[doc = " Starting row position of the <b>GridItem</b> component."]
    pub rowStart: u32,
    #[doc = " Starting column position of the <b>GridItem</b> component."]
    pub columnStart: u32,
    #[doc = " Number of rows occupied by the <b>GridItem</b> component."]
    pub rowSpan: u32,
    #[doc = " Number of columns occupied by the <b>GridItem</b> component."]
    pub columnSpan: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GridLayoutOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_WaterFlowSectionOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ListItemSwipeActionItem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ListItemSwipeActionOption {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the ArkUI native context object.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Context {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to the context instance object pointer definition of ArkUI on the native side.\n\n @since 12"]
pub type ArkUI_ContextHandle = *mut ArkUI_Context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_SwiperIndicator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_SwiperDigitIndicator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_SwiperArrowStyle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_StyledString_Descriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AlignmentRuleOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GuidelineOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_BarrierOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ListChildrenMainSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ImageAnimatorFrameInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AccessibilityState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AccessibilityValue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CustomProperty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_HostWindowInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ActiveChildrenInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ProgressLinearStyleOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CrossLanguageOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AbilityBase_Want {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_EmbeddedComponentOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_PositionEdges {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_PixelRoundPolicy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ShowCounterConfig {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the event callback type.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ContextCallback {
    #[doc = " Custom type."]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " Event callback."]
    pub callback:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
}
#[doc = " @brief Provides the number types of ArkUI in the native code.\n\n @since 12"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ArkUI_NumberValue {
    #[doc = " Floating-point type."]
    pub f32_: f32,
    #[doc = " Signed integer."]
    pub i32_: i32,
    #[doc = " Unsigned integer."]
    pub u32_: u32,
}
#[doc = " Top start."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_TOP_START: ArkUI_Alignment = 0;
#[doc = " Top center."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_TOP: ArkUI_Alignment = 1;
#[doc = " Top end."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_TOP_END: ArkUI_Alignment = 2;
#[doc = " Vertically centered start."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_START: ArkUI_Alignment = 3;
#[doc = " Horizontally and vertically centered."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_CENTER: ArkUI_Alignment = 4;
#[doc = " Vertically centered end."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_END: ArkUI_Alignment = 5;
#[doc = " Bottom start."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_BOTTOM_START: ArkUI_Alignment = 6;
#[doc = " Horizontally centered on the bottom."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_BOTTOM: ArkUI_Alignment = 7;
#[doc = " Bottom end."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_BOTTOM_END: ArkUI_Alignment = 8;
#[doc = " @brief Enumerates the alignment modes.\n\n @since 12"]
pub type ArkUI_Alignment = u32;
#[doc = " The image is not repeatedly drawn."]
pub const ArkUI_ImageRepeat_ARKUI_IMAGE_REPEAT_NONE: ArkUI_ImageRepeat = 0;
#[doc = " The image is repeatedly drawn only along the x-axis."]
pub const ArkUI_ImageRepeat_ARKUI_IMAGE_REPEAT_X: ArkUI_ImageRepeat = 1;
#[doc = " The image is repeatedly drawn only along the y-axis."]
pub const ArkUI_ImageRepeat_ARKUI_IMAGE_REPEAT_Y: ArkUI_ImageRepeat = 2;
#[doc = " The image is repeatedly drawn along both axes."]
pub const ArkUI_ImageRepeat_ARKUI_IMAGE_REPEAT_XY: ArkUI_ImageRepeat = 3;
#[doc = " @brief Enumerates the image repeat patterns.\n\n @since 12"]
pub type ArkUI_ImageRepeat = u32;
#[doc = " Standard font style."]
pub const ArkUI_FontStyle_ARKUI_FONT_STYLE_NORMAL: ArkUI_FontStyle = 0;
#[doc = " Italic font style."]
pub const ArkUI_FontStyle_ARKUI_FONT_STYLE_ITALIC: ArkUI_FontStyle = 1;
#[doc = " @brief Enumerates the font styles.\n\n @since 12"]
pub type ArkUI_FontStyle = u32;
#[doc = " 100"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W100: ArkUI_FontWeight = 0;
#[doc = " 200"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W200: ArkUI_FontWeight = 1;
#[doc = " 300"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W300: ArkUI_FontWeight = 2;
#[doc = " 400"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W400: ArkUI_FontWeight = 3;
#[doc = " 500"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W500: ArkUI_FontWeight = 4;
#[doc = " 600"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W600: ArkUI_FontWeight = 5;
#[doc = " 700"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W700: ArkUI_FontWeight = 6;
#[doc = " 800"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W800: ArkUI_FontWeight = 7;
#[doc = " 900"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W900: ArkUI_FontWeight = 8;
#[doc = " The font weight is bold."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_BOLD: ArkUI_FontWeight = 9;
#[doc = " The font weight is normal."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_NORMAL: ArkUI_FontWeight = 10;
#[doc = " The font weight is bolder."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_BOLDER: ArkUI_FontWeight = 11;
#[doc = " The font weight is lighter."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_LIGHTER: ArkUI_FontWeight = 12;
#[doc = " The font weight is medium."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_MEDIUM: ArkUI_FontWeight = 13;
#[doc = " The font weight is normal."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_REGULAR: ArkUI_FontWeight = 14;
#[doc = " @brief Enumerates the font weights.\n\n @since 12"]
pub type ArkUI_FontWeight = u32;
#[doc = " Aligned with the start."]
pub const ArkUI_TextAlignment_ARKUI_TEXT_ALIGNMENT_START: ArkUI_TextAlignment = 0;
#[doc = " Horizontally centered."]
pub const ArkUI_TextAlignment_ARKUI_TEXT_ALIGNMENT_CENTER: ArkUI_TextAlignment = 1;
#[doc = " Aligned with the end."]
pub const ArkUI_TextAlignment_ARKUI_TEXT_ALIGNMENT_END: ArkUI_TextAlignment = 2;
#[doc = " Aligned with both margins."]
pub const ArkUI_TextAlignment_ARKUI_TEXT_ALIGNMENT_JUSTIFY: ArkUI_TextAlignment = 3;
#[doc = " @brief Enumerates the text alignment mode.\n\n @since 12"]
pub type ArkUI_TextAlignment = u32;
#[doc = " Aligned to the baseline."]
#[cfg(feature = "api-20")]
pub const ArkUI_TextVerticalAlignment_ARKUI_TEXT_VERTICAL_ALIGNMENT_BASELINE:
    ArkUI_TextVerticalAlignment = 0;
#[doc = " Bottom aligned."]
#[cfg(feature = "api-20")]
pub const ArkUI_TextVerticalAlignment_ARKUI_TEXT_VERTICAL_ALIGNMENT_BOTTOM:
    ArkUI_TextVerticalAlignment = 1;
#[doc = " Center aligned."]
#[cfg(feature = "api-20")]
pub const ArkUI_TextVerticalAlignment_ARKUI_TEXT_VERTICAL_ALIGNMENT_CENTER:
    ArkUI_TextVerticalAlignment = 2;
#[doc = " Top aligned."]
#[cfg(feature = "api-20")]
pub const ArkUI_TextVerticalAlignment_ARKUI_TEXT_VERTICAL_ALIGNMENT_TOP:
    ArkUI_TextVerticalAlignment = 3;
#[doc = " @brief Enumerates text vertical alignment styles.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type ArkUI_TextVerticalAlignment = u32;
#[doc = " Top aligned."]
#[cfg(feature = "api-21")]
pub const ArkUI_TextContentAlign_ARKUI_TEXT_CONTENT_ALIGN_TOP: ArkUI_TextContentAlign = 0;
#[doc = " Center aligned."]
#[cfg(feature = "api-21")]
pub const ArkUI_TextContentAlign_ARKUI_TEXT_CONTENT_ALIGN_CENTER: ArkUI_TextContentAlign = 1;
#[doc = " Bottom aligned."]
#[cfg(feature = "api-21")]
pub const ArkUI_TextContentAlign_ARKUI_TEXT_CONTENT_ALIGN_BOTTOM: ArkUI_TextContentAlign = 2;
#[doc = " @brief Enumerates text content align styles.\n\n @since 21"]
#[cfg(feature = "api-21")]
pub type ArkUI_TextContentAlign = u32;
#[doc = " The Enter key is labeled \"Go.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_GO: ArkUI_EnterKeyType = 2;
#[doc = " The Enter key is labeled \"Search.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_SEARCH: ArkUI_EnterKeyType = 3;
#[doc = " The Enter key is labeled \"Send.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_SEND: ArkUI_EnterKeyType = 4;
#[doc = " The Enter key is labeled \"Next.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_NEXT: ArkUI_EnterKeyType = 5;
#[doc = " The Enter key is labeled \"Done.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_DONE: ArkUI_EnterKeyType = 6;
#[doc = " The Enter key is labeled \"Previous.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_PREVIOUS: ArkUI_EnterKeyType = 7;
#[doc = " The Enter key is labeled \"New Line.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_NEW_LINE: ArkUI_EnterKeyType = 8;
#[doc = " @brief Enumerates the types of the Enter key for a single-line text box.\n\n @since 12"]
pub type ArkUI_EnterKeyType = u32;
#[doc = " Normal input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NORMAL: ArkUI_TextInputType = 0;
#[doc = " Number input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NUMBER: ArkUI_TextInputType = 2;
#[doc = " Phone number input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_PHONE_NUMBER: ArkUI_TextInputType = 3;
#[doc = " Email address input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_EMAIL: ArkUI_TextInputType = 5;
#[doc = " Password input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_PASSWORD: ArkUI_TextInputType = 7;
#[doc = " Numeric password input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NUMBER_PASSWORD: ArkUI_TextInputType = 8;
#[doc = " Lock screen password input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_SCREEN_LOCK_PASSWORD: ArkUI_TextInputType = 9;
#[doc = " Username input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_USER_NAME: ArkUI_TextInputType = 10;
#[doc = " New password input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NEW_PASSWORD: ArkUI_TextInputType = 11;
#[doc = " Number input mode with a decimal point."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NUMBER_DECIMAL: ArkUI_TextInputType = 12;
#[doc = " One time code input mode.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_ONE_TIME_CODE: ArkUI_TextInputType = 14;
#[doc = " @brief Enumerates the text input types.\n\n @since 12"]
pub type ArkUI_TextInputType = u32;
#[doc = " Normal input mode."]
pub const ArkUI_TextAreaType_ARKUI_TEXTAREA_TYPE_NORMAL: ArkUI_TextAreaType = 0;
#[doc = " Number input mode."]
pub const ArkUI_TextAreaType_ARKUI_TEXTAREA_TYPE_NUMBER: ArkUI_TextAreaType = 2;
#[doc = " Phone number input mode."]
pub const ArkUI_TextAreaType_ARKUI_TEXTAREA_TYPE_PHONE_NUMBER: ArkUI_TextAreaType = 3;
#[doc = " Email address input mode."]
pub const ArkUI_TextAreaType_ARKUI_TEXTAREA_TYPE_EMAIL: ArkUI_TextAreaType = 5;
#[doc = " One time code input mode.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_TextAreaType_ARKUI_TEXTAREA_TYPE_ONE_TIME_CODE: ArkUI_TextAreaType = 14;
#[doc = " @brief Enumerates the text box types.\n\n @since 12"]
pub type ArkUI_TextAreaType = u32;
#[doc = " The Cancel button is always displayed."]
pub const ArkUI_CancelButtonStyle_ARKUI_CANCELBUTTON_STYLE_CONSTANT: ArkUI_CancelButtonStyle = 0;
#[doc = " The Cancel button is always hidden."]
pub const ArkUI_CancelButtonStyle_ARKUI_CANCELBUTTON_STYLE_INVISIBLE: ArkUI_CancelButtonStyle = 1;
#[doc = " The Cancel button is displayed when there is text input."]
pub const ArkUI_CancelButtonStyle_ARKUI_CANCELBUTTON_STYLE_INPUT: ArkUI_CancelButtonStyle = 2;
#[doc = " @brief Enumerates the styles of the Cancel button.\n\n @since 12"]
pub type ArkUI_CancelButtonStyle = u32;
#[doc = " The custom content of EGL/OpenGL ES and media data is displayed individually on the screen."]
pub const ArkUI_XComponentType_ARKUI_XCOMPONENT_TYPE_SURFACE: ArkUI_XComponentType = 0;
#[doc = " The custom content of EGL/OpenGL ES and media data is grouped and displayed together with content\n of the component."]
pub const ArkUI_XComponentType_ARKUI_XCOMPONENT_TYPE_TEXTURE: ArkUI_XComponentType = 2;
#[doc = " @brief Enumerates the types of the <b><XComponent></b> component.\n\n @since 12"]
pub type ArkUI_XComponentType = u32;
#[doc = " Linear style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_LINEAR: ArkUI_ProgressType = 0;
#[doc = " Indeterminate ring style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_RING: ArkUI_ProgressType = 1;
#[doc = " Eclipse style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_ECLIPSE: ArkUI_ProgressType = 2;
#[doc = " Determinate ring style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_SCALE_RING: ArkUI_ProgressType = 3;
#[doc = " Capsule style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_CAPSULE: ArkUI_ProgressType = 4;
#[doc = " @brief Enumerates the styles of the progress indicator.\n\n @since 12"]
pub type ArkUI_ProgressType = u32;
#[doc = " No text decoration."]
pub const ArkUI_TextDecorationType_ARKUI_TEXT_DECORATION_TYPE_NONE: ArkUI_TextDecorationType = 0;
#[doc = " Line under the text."]
pub const ArkUI_TextDecorationType_ARKUI_TEXT_DECORATION_TYPE_UNDERLINE: ArkUI_TextDecorationType =
    1;
#[doc = " Line over the text."]
pub const ArkUI_TextDecorationType_ARKUI_TEXT_DECORATION_TYPE_OVERLINE: ArkUI_TextDecorationType =
    2;
#[doc = " Line through the text."]
pub const ArkUI_TextDecorationType_ARKUI_TEXT_DECORATION_TYPE_LINE_THROUGH:
    ArkUI_TextDecorationType = 3;
#[doc = " @brief Enumerates the text decoration types.\n\n @since 12"]
pub type ArkUI_TextDecorationType = u32;
#[doc = " Single solid line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_SOLID: ArkUI_TextDecorationStyle =
    0;
#[doc = " Double solid line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_DOUBLE: ArkUI_TextDecorationStyle =
    1;
#[doc = " Dotted line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_DOTTED: ArkUI_TextDecorationStyle =
    2;
#[doc = " Dashed line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_DASHED: ArkUI_TextDecorationStyle =
    3;
#[doc = " Wavy line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_WAVY: ArkUI_TextDecorationStyle = 4;
#[doc = " @brief Enumerates the text decoration styles.\n\n @since 12"]
pub type ArkUI_TextDecorationStyle = u32;
#[doc = " The original case of the text is retained."]
pub const ArkUI_TextCase_ARKUI_TEXT_CASE_NORMAL: ArkUI_TextCase = 0;
#[doc = " All letters in the text are in lowercase."]
pub const ArkUI_TextCase_ARKUI_TEXT_CASE_LOWER: ArkUI_TextCase = 1;
#[doc = " All letters in the text are in uppercase."]
pub const ArkUI_TextCase_ARKUI_TEXT_CASE_UPPER: ArkUI_TextCase = 2;
#[doc = " @brief Enumerates the text cases.\n\n @since 12"]
pub type ArkUI_TextCase = u32;
#[doc = " Copy is not allowed."]
pub const ArkUI_CopyOptions_ARKUI_COPY_OPTIONS_NONE: ArkUI_CopyOptions = 0;
#[doc = " Intra-application copy is allowed."]
pub const ArkUI_CopyOptions_ARKUI_COPY_OPTIONS_IN_APP: ArkUI_CopyOptions = 1;
#[doc = " Intra-device copy is allowed."]
pub const ArkUI_CopyOptions_ARKUI_COPY_OPTIONS_LOCAL_DEVICE: ArkUI_CopyOptions = 2;
#[doc = " Cross-device copy is allowed."]
pub const ArkUI_CopyOptions_ARKUI_COPY_OPTIONS_CROSS_DEVICE: ArkUI_CopyOptions = 3;
#[doc = " @brief Enumerates the text copy and paste modes.\n\n @since 12"]
pub type ArkUI_CopyOptions = u32;
#[doc = " Color."]
pub const ArkUI_ShadowType_ARKUI_SHADOW_TYPE_COLOR: ArkUI_ShadowType = 0;
#[doc = " Blur."]
pub const ArkUI_ShadowType_ARKUI_SHADOW_TYPE_BLUR: ArkUI_ShadowType = 1;
#[doc = " @brief Enumerates the shadow types.\n\n @since 12"]
pub type ArkUI_ShadowType = u32;
#[doc = " A mode that displays the date in months, days of month, and years."]
#[cfg(feature = "api-18")]
pub const ArkUI_DatePickerMode_ARKUI_DATEPICKER_MODE_DATE: ArkUI_DatePickerMode = 0;
#[doc = " A mode that displays the date in months and years."]
#[cfg(feature = "api-18")]
pub const ArkUI_DatePickerMode_ARKUI_DATEPICKER_YEAR_AND_MONTH: ArkUI_DatePickerMode = 1;
#[doc = " A mode that displays the date in months and days of the month."]
#[cfg(feature = "api-18")]
pub const ArkUI_DatePickerMode_ARKUI_DATEPICKER_MONTH_AND_DAY: ArkUI_DatePickerMode = 2;
#[doc = " @brief Enumerates the modes of the date picker.\n\n @since 18"]
#[cfg(feature = "api-18")]
pub type ArkUI_DatePickerMode = u32;
#[doc = " Single-column text picker."]
pub const ArkUI_TextPickerRangeType_ARKUI_TEXTPICKER_RANGETYPE_SINGLE: ArkUI_TextPickerRangeType =
    0;
#[doc = " Multi-column text picker."]
pub const ArkUI_TextPickerRangeType_ARKUI_TEXTPICKER_RANGETYPE_MULTI: ArkUI_TextPickerRangeType = 1;
#[doc = " Single-column text picker with image resources."]
pub const ArkUI_TextPickerRangeType_ARKUI_TEXTPICKER_RANGETYPE_RANGE_CONTENT:
    ArkUI_TextPickerRangeType = 2;
#[doc = " Interconnected multi-column text picker."]
pub const ArkUI_TextPickerRangeType_ARKUI_TEXTPICKER_RANGETYPE_CASCADE_RANGE_CONTENT:
    ArkUI_TextPickerRangeType = 3;
#[doc = " @brief Enumerates the types of the text picker.\n\n @since 12"]
pub type ArkUI_TextPickerRangeType = u32;
#[doc = " @brief Defines the input structure of the single-column text picker with image resources.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARKUI_TextPickerRangeContent {
    #[doc = " Image resource."]
    pub icon: *const ::std::os::raw::c_char,
    #[doc = " Text information."]
    pub text: *const ::std::os::raw::c_char,
}
#[doc = " @brief Defines the input structure of the interconnected multi-column text picker.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARKUI_TextPickerCascadeRangeContent {
    #[doc = " Text information."]
    pub text: *const ::std::os::raw::c_char,
    #[doc = " Interconnected data."]
    pub children: *const ARKUI_TextPickerRangeContent,
    #[doc = " Size of the interconnected data array."]
    pub size: i32,
}
#[doc = " Spring effect. When at one of the edges, the component can move beyond the bounds based on the initial\n  speed or through touches, and produces a bounce effect when the user releases their finger."]
pub const ArkUI_EdgeEffect_ARKUI_EDGE_EFFECT_SPRING: ArkUI_EdgeEffect = 0;
#[doc = " Fade effect. When at one of the edges, the component produces a fade effect."]
pub const ArkUI_EdgeEffect_ARKUI_EDGE_EFFECT_FADE: ArkUI_EdgeEffect = 1;
#[doc = " No effect after the scrollbar is moved to the edge."]
pub const ArkUI_EdgeEffect_ARKUI_EDGE_EFFECT_NONE: ArkUI_EdgeEffect = 2;
#[doc = " @brief Enumerates the effects used at the edges of the component when the boundary of the scrollable content is\n reached.\n\n @since 12"]
pub type ArkUI_EdgeEffect = u32;
#[doc = " Not displayed."]
#[cfg(feature = "api-22")]
pub const ArkUI_BarState_ARKUI_BAR_STATE_OFF: ArkUI_BarState = 0;
#[doc = " On-demand display."]
#[cfg(feature = "api-22")]
pub const ArkUI_BarState_ARKUI_BAR_STATE_AUTO: ArkUI_BarState = 1;
#[doc = " Resident display."]
#[cfg(feature = "api-22")]
pub const ArkUI_BarState_ARKUI_BAR_STATE_ON: ArkUI_BarState = 2;
#[doc = " @brief Enumerates the status of the scroll bar.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_BarState = u32;
#[doc = " Start edge."]
#[cfg(feature = "api-18")]
pub const ArkUI_EffectEdge_ARKUI_EFFECT_EDGE_START: ArkUI_EffectEdge = 1;
#[doc = " End edge."]
#[cfg(feature = "api-18")]
pub const ArkUI_EffectEdge_ARKUI_EFFECT_EDGE_END: ArkUI_EffectEdge = 2;
#[doc = " @brief Enumerates the edges for which the effect takes effect when the boundary of the scrollable content is reached.\n\n @since 18"]
#[cfg(feature = "api-18")]
pub type ArkUI_EffectEdge = u32;
#[doc = " Default mode, where focus does not wrap when arrow keys are used."]
#[cfg(feature = "api-20")]
pub const ArkUI_FocusWrapMode_ARKUI_FOCUS_WRAP_MODE_DEFAULT: ArkUI_FocusWrapMode = 0;
#[doc = " Focus wraps automatically when arrow keys are used."]
#[cfg(feature = "api-20")]
pub const ArkUI_FocusWrapMode_ARKUI_FOCUS_WRAP_WITH_ARROW: ArkUI_FocusWrapMode = 1;
#[doc = " @brief Enumerates the focus wrap mode of components.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type ArkUI_FocusWrapMode = u32;
#[doc = " No responsive breakpoint configuration."]
#[cfg(feature = "api-22")]
pub const ArkUI_ItemFillPolicy_ARKUI_ITEMFILLPOLICY_NONE: ArkUI_ItemFillPolicy = -1;
#[doc = " Default responsive layout:\n <b>List</b> or <b>Swiper</b> component: 1 column (SM or smaller), 2 columns (MD), 3 columns (LG or larger).\n <b>Grid</b> or <b>WaterFlow</b> component: 2 columns (SM or smaller), 3 columns (MD), 5 columns (LG or larger)."]
#[cfg(feature = "api-22")]
pub const ArkUI_ItemFillPolicy_ARKUI_ITEMFILLPOLICY_DEFAULT: ArkUI_ItemFillPolicy = 0;
#[doc = " 1 column (SM or smaller), 2 columns (MD), 3 columns (LG or larger)."]
#[cfg(feature = "api-22")]
pub const ArkUI_ItemFillPolicy_ARKUI_ITEMFILLPOLICY_SM1MD2LG3: ArkUI_ItemFillPolicy = 1;
#[doc = " 2 columns (SM or smaller), 3 columns (MD), 5 columns (LG or larger)."]
#[cfg(feature = "api-22")]
pub const ArkUI_ItemFillPolicy_ARKUI_ITEMFILLPOLICY_SM2MD3LG5: ArkUI_ItemFillPolicy = 2;
#[doc = " @brief Specifies the number of columns for different responsive breakpoint specifications.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_ItemFillPolicy = i32;
#[doc = " Use the default alignment mode of the grid."]
#[cfg(feature = "api-22")]
pub const ArkUI_GridItemAlignment_GRID_ITEM_ALIGNMENT_DEFAULT: ArkUI_GridItemAlignment = 0;
#[doc = " Set the height of all grid items in a row to match the height of the tallest item in that row."]
#[cfg(feature = "api-22")]
pub const ArkUI_GridItemAlignment_GRID_ITEM_ALIGNMENT_STRETCH: ArkUI_GridItemAlignment = 1;
#[doc = " @brief Enumerates the grid item alignment modes.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_GridItemAlignment = u32;
#[doc = " No style."]
#[cfg(feature = "api-22")]
pub const ArkUI_GridItemStyle_GRID_ITEM_STYLE_NONE: ArkUI_GridItemStyle = 0;
#[doc = " Hover or press style."]
#[cfg(feature = "api-22")]
pub const ArkUI_GridItemStyle_GRID_ITEM_STYLE_PLAIN: ArkUI_GridItemStyle = 1;
#[doc = " @brief Enumerates styles of grid items.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_GridItemStyle = u32;
#[doc = " Only vertical scrolling is supported."]
pub const ArkUI_ScrollDirection_ARKUI_SCROLL_DIRECTION_VERTICAL: ArkUI_ScrollDirection = 0;
#[doc = " Only horizontal scrolling is supported."]
pub const ArkUI_ScrollDirection_ARKUI_SCROLL_DIRECTION_HORIZONTAL: ArkUI_ScrollDirection = 1;
#[doc = " Scrolling is not allowed."]
pub const ArkUI_ScrollDirection_ARKUI_SCROLL_DIRECTION_NONE: ArkUI_ScrollDirection = 3;
#[doc = " Free scrolling in both directions.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_ScrollDirection_ARKUI_SCROLL_DIRECTION_FREE: ArkUI_ScrollDirection = 4;
#[doc = " @brief Enumerates the scroll directions for the <b><Scroll></b> component.\n\n @since 12"]
pub type ArkUI_ScrollDirection = u32;
#[doc = " No alignment. This is the default value."]
pub const ArkUI_ScrollSnapAlign_ARKUI_SCROLL_SNAP_ALIGN_NONE: ArkUI_ScrollSnapAlign = 0;
#[doc = " The first item in the view is aligned at the start of the list."]
pub const ArkUI_ScrollSnapAlign_ARKUI_SCROLL_SNAP_ALIGN_START: ArkUI_ScrollSnapAlign = 1;
#[doc = " The middle items in the view are aligned in the center of the list."]
pub const ArkUI_ScrollSnapAlign_ARKUI_SCROLL_SNAP_ALIGN_CENTER: ArkUI_ScrollSnapAlign = 2;
#[doc = " The last item in the view is aligned at the end of the list."]
pub const ArkUI_ScrollSnapAlign_ARKUI_SCROLL_SNAP_ALIGN_END: ArkUI_ScrollSnapAlign = 3;
#[doc = " @brief Enumerates the alignment modes of list items when scrolling ends.\n\n @since 12"]
pub type ArkUI_ScrollSnapAlign = u32;
#[doc = " Normal scroll snap animation speed."]
#[cfg(feature = "api-22")]
pub const ArkUI_ScrollSnapAnimationSpeed_ARKUI_SCROLL_SNAP_ANIMATION_NORMAL:
    ArkUI_ScrollSnapAnimationSpeed = 0;
#[doc = " Slow scroll snap animation speed."]
#[cfg(feature = "api-22")]
pub const ArkUI_ScrollSnapAnimationSpeed_ARKUI_SCROLL_SNAP_ANIMATION_SLOW:
    ArkUI_ScrollSnapAnimationSpeed = 1;
#[doc = " @brief Enumerates the scroll snap animation speeds for lists.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_ScrollSnapAnimationSpeed = u32;
#[doc = " Hide."]
pub const ArkUI_ScrollBarDisplayMode_ARKUI_SCROLL_BAR_DISPLAY_MODE_OFF: ArkUI_ScrollBarDisplayMode =
    0;
#[doc = " Display on demand (displays when the screen is touched and disappears after 2s)."]
pub const ArkUI_ScrollBarDisplayMode_ARKUI_SCROLL_BAR_DISPLAY_MODE_AUTO:
    ArkUI_ScrollBarDisplayMode = 1;
#[doc = " Always display."]
pub const ArkUI_ScrollBarDisplayMode_ARKUI_SCROLL_BAR_DISPLAY_MODE_ON: ArkUI_ScrollBarDisplayMode =
    2;
#[doc = " @brief Enumerates the scrollbar display modes.\n\n @since 12"]
pub type ArkUI_ScrollBarDisplayMode = u32;
#[doc = " Only vertical scrolling is supported."]
pub const ArkUI_Axis_ARKUI_AXIS_VERTICAL: ArkUI_Axis = 0;
#[doc = " Only horizontal scrolling is supported."]
pub const ArkUI_Axis_ARKUI_AXIS_HORIZONTAL: ArkUI_Axis = 1;
#[doc = " @brief Enumerates the scroll directions for the <b><List></b> component.\n\n @since 12"]
pub type ArkUI_Axis = u32;
#[doc = " In the list item group, the header is not pinned to the top, and the footer is not pinned to the bottom."]
pub const ArkUI_StickyStyle_ARKUI_STICKY_STYLE_NONE: ArkUI_StickyStyle = 0;
#[doc = " In the list item group, the header is pinned to the top, and the footer is not pinned to the bottom."]
pub const ArkUI_StickyStyle_ARKUI_STICKY_STYLE_HEADER: ArkUI_StickyStyle = 1;
#[doc = " In the list item group, the footer is pinned to the bottom, and the header is not pinned to the top."]
pub const ArkUI_StickyStyle_ARKUI_STICKY_STYLE_FOOTER: ArkUI_StickyStyle = 2;
#[doc = " In the list item group, the footer is pinned to the bottom, and the header is pinned to the top."]
pub const ArkUI_StickyStyle_ARKUI_STICKY_STYLE_BOTH: ArkUI_StickyStyle = 3;
#[doc = " @brief Enumerates the modes for pinning the header to the top or the footer to the bottom.\n\n @since 12"]
pub type ArkUI_StickyStyle = u32;
#[doc = " clip by content"]
#[cfg(feature = "api-18")]
pub const ArkUI_ContentClipMode_ARKUI_CONTENT_CLIP_MODE_CONTENT_ONLY: ArkUI_ContentClipMode = 0;
#[doc = " clip by boundary"]
#[cfg(feature = "api-18")]
pub const ArkUI_ContentClipMode_ARKUI_CONTENT_CLIP_MODE_BOUNDARY: ArkUI_ContentClipMode = 1;
#[doc = " clip by safe area padding"]
#[cfg(feature = "api-18")]
pub const ArkUI_ContentClipMode_ARKUI_CONTENT_CLIP_MODE_SAFE_AREA: ArkUI_ContentClipMode = 2;
#[doc = " @brief Enumerates the content clipping modes of scrollable components.\n\n @since 18"]
#[cfg(feature = "api-18")]
pub type ArkUI_ContentClipMode = u32;
#[doc = " Layout items from top to viewport."]
#[cfg(feature = "api-18")]
pub const ArkUI_WaterFlowLayoutMode_ARKUI_WATER_FLOW_LAYOUT_MODE_ALWAYS_TOP_DOWN:
    ArkUI_WaterFlowLayoutMode = 0;
#[doc = " Layout items in viewport."]
#[cfg(feature = "api-18")]
pub const ArkUI_WaterFlowLayoutMode_ARKUI_WATER_FLOW_LAYOUT_MODE_SLIDING_WINDOW:
    ArkUI_WaterFlowLayoutMode = 1;
#[doc = " @brief Enumerates the layout modes of the WaterFlow component.\n\n @since 18"]
#[cfg(feature = "api-18")]
pub type ArkUI_WaterFlowLayoutMode = u32;
#[doc = " Solid border."]
pub const ArkUI_BorderStyle_ARKUI_BORDER_STYLE_SOLID: ArkUI_BorderStyle = 0;
#[doc = " Dashed border."]
pub const ArkUI_BorderStyle_ARKUI_BORDER_STYLE_DASHED: ArkUI_BorderStyle = 1;
#[doc = " Dotted border."]
pub const ArkUI_BorderStyle_ARKUI_BORDER_STYLE_DOTTED: ArkUI_BorderStyle = 2;
#[doc = " @brief Enumerates the border styles.\n\n @since 12"]
pub type ArkUI_BorderStyle = u32;
#[doc = " Both the node and its child node respond to the hit test of a touch event, but its sibling node is blocked from\n  the hit test."]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_DEFAULT: ArkUI_HitTestMode = 0;
#[doc = " The node responds to the hit test of a touch event, but its child node and sibling node are blocked from the\n  hit test."]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_BLOCK: ArkUI_HitTestMode = 1;
#[doc = " Both the node and its child node respond to the hit test of a touch event, and its sibling node is also\n considered during the hit test."]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_TRANSPARENT: ArkUI_HitTestMode = 2;
#[doc = " The node does not respond to the hit test of a touch event."]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_NONE: ArkUI_HitTestMode = 3;
#[doc = " The node and its child nodes participate in hit tests, while blocking hit tests for all sibling nodes and\n parent nodes with lower priority.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_BLOCK_HIERARCHY: ArkUI_HitTestMode = 4;
#[doc = " The node does not respond to hit tests, and none of its descendants (including children and grandchildren)\n participate in hit tests either.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_BLOCK_DESCENDANTS: ArkUI_HitTestMode = 5;
#[doc = " @brief Enumerates the hit test modes.\n\n @since 12"]
pub type ArkUI_HitTestMode = u32;
#[doc = " Mini shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_DEFAULT_XS: ArkUI_ShadowStyle = 0;
#[doc = " Little shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_DEFAULT_SM: ArkUI_ShadowStyle = 1;
#[doc = " Medium shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_DEFAULT_MD: ArkUI_ShadowStyle = 2;
#[doc = " Large shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_DEFAULT_LG: ArkUI_ShadowStyle = 3;
#[doc = " Floating small shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_FLOATING_SM: ArkUI_ShadowStyle = 4;
#[doc = " Floating medium shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_FLOATING_MD: ArkUI_ShadowStyle = 5;
#[doc = " @brief Enumerates the shadow styles.\n\n @since 12"]
pub type ArkUI_ShadowStyle = u32;
#[doc = " The animation speed keeps unchanged."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_LINEAR: ArkUI_AnimationCurve = 0;
#[doc = " The animation starts slowly, accelerates, and then slows down towards the end."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EASE: ArkUI_AnimationCurve = 1;
#[doc = " The animation starts at a low speed and then picks up speed until the end."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EASE_IN: ArkUI_AnimationCurve = 2;
#[doc = " The animation ends at a low speed."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EASE_OUT: ArkUI_AnimationCurve = 3;
#[doc = " The animation starts and ends at a low speed."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EASE_IN_OUT: ArkUI_AnimationCurve = 4;
#[doc = " The animation uses the standard curve"]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_FAST_OUT_SLOW_IN: ArkUI_AnimationCurve = 5;
#[doc = " The animation uses the deceleration curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_LINEAR_OUT_SLOW_IN: ArkUI_AnimationCurve = 6;
#[doc = " The animation uses the acceleration curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_FAST_OUT_LINEAR_IN: ArkUI_AnimationCurve = 7;
#[doc = " The animation uses the extreme deceleration curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EXTREME_DECELERATION: ArkUI_AnimationCurve = 8;
#[doc = " The animation uses the sharp curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_SHARP: ArkUI_AnimationCurve = 9;
#[doc = " The animation uses the rhythm curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_RHYTHM: ArkUI_AnimationCurve = 10;
#[doc = " The animation uses the smooth curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_SMOOTH: ArkUI_AnimationCurve = 11;
#[doc = " The animation uses the friction curve"]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_FRICTION: ArkUI_AnimationCurve = 12;
#[doc = " @brief Enumerates the animation curves.\n\n @since 12"]
pub type ArkUI_AnimationCurve = u32;
#[doc = " The arrow is not displayed for the navigation point indicator."]
pub const ArkUI_SwiperArrow_ARKUI_SWIPER_ARROW_HIDE: ArkUI_SwiperArrow = 0;
#[doc = " The arrow is displayed for the navigation point indicator."]
pub const ArkUI_SwiperArrow_ARKUI_SWIPER_ARROW_SHOW: ArkUI_SwiperArrow = 1;
#[doc = " The arrow is displayed only when the mouse pointer hovers over the navigation point indicator."]
pub const ArkUI_SwiperArrow_ARKUI_SWIPER_ARROW_SHOW_ON_HOVER: ArkUI_SwiperArrow = 2;
#[doc = " @brief Enumerates arrow styles of the navigation point indicator.\n\n @since 12"]
pub type ArkUI_SwiperArrow = u32;
#[doc = " Swiper only scrolls on its own and is not linked to its parent component."]
pub const ArkUI_SwiperNestedScrollMode_ARKUI_SWIPER_NESTED_SRCOLL_SELF_ONLY:
    ArkUI_SwiperNestedScrollMode = 0;
#[doc = " The Swiper itself scrolls first, and the parent component scrolls after it reaches the edge. After the parent\n component scrolls to the edge, if the parent component has an edge effect, the parent component triggers the edge\n effect; otherwise, the Swiper triggers the edge effect."]
pub const ArkUI_SwiperNestedScrollMode_ARKUI_SWIPER_NESTED_SRCOLL_SELF_FIRST:
    ArkUI_SwiperNestedScrollMode = 1;
#[doc = " @brief Nested scrolling mode for Swiper components and parent components.\n\n @since 12"]
pub type ArkUI_SwiperNestedScrollMode = u32;
#[doc = " When the mouse wheel is scrolled continuously, multiple pages are flipped, which is determined by the number of\n  times that mouse events are reported."]
#[cfg(feature = "api-15")]
pub const ArkUI_PageFlipMode_ARKUI_PAGE_FLIP_MODE_CONTINUOUS: ArkUI_PageFlipMode = 0;
#[doc = " The system does not respond to other mouse wheel events until the page flipping animation ends."]
#[cfg(feature = "api-15")]
pub const ArkUI_PageFlipMode_ARKUI_PAGE_FLIP_MODE_SINGLE: ArkUI_PageFlipMode = 1;
#[doc = " @brief Enumerates the page flipping modes using the mouse wheel for the <b>Swiper</b> component.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_PageFlipMode = u32;
#[doc = " Jump to target index without animation."]
#[cfg(feature = "api-15")]
pub const ArkUI_SwiperAnimationMode_ARKUI_SWIPER_NO_ANIMATION: ArkUI_SwiperAnimationMode = 0;
#[doc = " Scroll to target index with animation."]
#[cfg(feature = "api-15")]
pub const ArkUI_SwiperAnimationMode_ARKUI_SWIPER_DEFAULT_ANIMATION: ArkUI_SwiperAnimationMode = 1;
#[doc = " Jump to some index near the target index without animation, then scroll to target index with animation."]
#[cfg(feature = "api-15")]
pub const ArkUI_SwiperAnimationMode_ARKUI_SWIPER_FAST_ANIMATION: ArkUI_SwiperAnimationMode = 2;
#[doc = " @brief Enumerates the animation modes for {@link NODE_SWIPER_INDEX}.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_SwiperAnimationMode = u32;
#[doc = " Whether the component can be identified by the accessibility service is dependent on the component."]
pub const ArkUI_AccessibilityMode_ARKUI_ACCESSIBILITY_MODE_AUTO: ArkUI_AccessibilityMode = 0;
#[doc = " The component can be identified by the accessibility service."]
pub const ArkUI_AccessibilityMode_ARKUI_ACCESSIBILITY_MODE_ENABLED: ArkUI_AccessibilityMode = 1;
#[doc = " The component cannot be identified by the accessibility service."]
pub const ArkUI_AccessibilityMode_ARKUI_ACCESSIBILITY_MODE_DISABLED: ArkUI_AccessibilityMode = 2;
#[doc = " The component and all its child components cannot be identified by the accessibility service."]
pub const ArkUI_AccessibilityMode_ARKUI_ACCESSIBILITY_MODE_DISABLED_FOR_DESCENDANTS:
    ArkUI_AccessibilityMode = 3;
#[doc = " @brief Enumerates the accessibility modes.\n\n @since 12"]
pub type ArkUI_AccessibilityMode = u32;
#[doc = " Copy is not allowed."]
pub const ArkUI_TextCopyOptions_ARKUI_TEXT_COPY_OPTIONS_NONE: ArkUI_TextCopyOptions = 0;
#[doc = " Intra-application copy is allowed."]
pub const ArkUI_TextCopyOptions_ARKUI_TEXT_COPY_OPTIONS_IN_APP: ArkUI_TextCopyOptions = 1;
#[doc = " Intra-device copy is allowed."]
pub const ArkUI_TextCopyOptions_ARKUI_TEXT_COPY_OPTIONS_LOCAL_DEVICE: ArkUI_TextCopyOptions = 2;
#[doc = " Cross-device copy is allowed."]
pub const ArkUI_TextCopyOptions_ARKUI_TEXT_COPY_OPTIONS_CROSS_DEVICE: ArkUI_TextCopyOptions = 3;
#[doc = " @brief Defines whether copy and paste is allowed for text content.\n\n @since 12"]
pub type ArkUI_TextCopyOptions = u32;
#[doc = " Prioritize the <b>maxLines</b> settings."]
pub const ArkUI_TextHeightAdaptivePolicy_ARKUI_TEXT_HEIGHT_ADAPTIVE_POLICY_MAX_LINES_FIRST:
    ArkUI_TextHeightAdaptivePolicy = 0;
#[doc = " Prioritize the <b>minFontSize</b> settings."]
pub const ArkUI_TextHeightAdaptivePolicy_ARKUI_TEXT_HEIGHT_ADAPTIVE_POLICY_MIN_FONT_SIZE_FIRST:
    ArkUI_TextHeightAdaptivePolicy = 1;
#[doc = " Prioritize the layout constraint settings in terms of height."]
pub const ArkUI_TextHeightAdaptivePolicy_ARKUI_TEXT_HEIGHT_ADAPTIVE_POLICY_LAYOUT_CONSTRAINT_FIRST : ArkUI_TextHeightAdaptivePolicy = 2 ;
#[doc = " @brief Defines how the adaptive height is determined for the text.\n\n @since 12"]
pub type ArkUI_TextHeightAdaptivePolicy = u32;
#[doc = " The scrolling is contained within the component, and no scroll chaining occurs, that is, the parent component\n does not scroll when the component scrolling reaches the boundary."]
pub const ArkUI_ScrollNestedMode_ARKUI_SCROLL_NESTED_MODE_SELF_ONLY: ArkUI_ScrollNestedMode = 0;
#[doc = " The component scrolls first, and when it hits the boundary, the parent component scrolls.\n  When the parent component hits the boundary, its edge effect is displayed. If no edge\n  effect is specified for the parent component, the edge effect of the child component is displayed instead."]
pub const ArkUI_ScrollNestedMode_ARKUI_SCROLL_NESTED_MODE_SELF_FIRST: ArkUI_ScrollNestedMode = 1;
#[doc = " The parent component scrolls first, and when it hits the boundary, the component scrolls.\n  When the component hits the boundary, its edge effect is displayed. If no edge effect is specified for the\n  component, the edge effect of the parent component is displayed instead."]
pub const ArkUI_ScrollNestedMode_ARKUI_SCROLL_NESTED_MODE_PARENT_FIRST: ArkUI_ScrollNestedMode = 2;
#[doc = " The component and its parent component scroll at the same time. When both the component and its parent component\n  hit the boundary, the edge effect of the component is displayed. If no edge effect is specified for the\n  component, the edge effect of the parent component is displayed instead."]
pub const ArkUI_ScrollNestedMode_ARKUI_SCROLL_NESTED_MODE_PARALLEL: ArkUI_ScrollNestedMode = 3;
#[doc = " @brief Defines nested scrolling options.\n\n @since 12"]
pub type ArkUI_ScrollNestedMode = u32;
#[doc = " Top edge in the vertical direction."]
pub const ArkUI_ScrollEdge_ARKUI_SCROLL_EDGE_TOP: ArkUI_ScrollEdge = 0;
#[doc = " Bottom edge in the vertical direction."]
pub const ArkUI_ScrollEdge_ARKUI_SCROLL_EDGE_BOTTOM: ArkUI_ScrollEdge = 1;
#[doc = " Start position in the horizontal direction."]
pub const ArkUI_ScrollEdge_ARKUI_SCROLL_EDGE_START: ArkUI_ScrollEdge = 2;
#[doc = " End position in the horizontal direction."]
pub const ArkUI_ScrollEdge_ARKUI_SCROLL_EDGE_END: ArkUI_ScrollEdge = 3;
#[doc = " @brief Defines the edge to which the component scrolls.\n\n @since 12"]
pub type ArkUI_ScrollEdge = u32;
#[doc = " Align the head. Align the head of the specified item with the head of the container."]
pub const ArkUI_ScrollAlignment_ARKUI_SCROLL_ALIGNMENT_START: ArkUI_ScrollAlignment = 0;
#[doc = " Center alignment. Align the axis direction of the specified item to the center of the container."]
pub const ArkUI_ScrollAlignment_ARKUI_SCROLL_ALIGNMENT_CENTER: ArkUI_ScrollAlignment = 1;
#[doc = " Tail alignment. Align the tail of the specified item with the tail of the container."]
pub const ArkUI_ScrollAlignment_ARKUI_SCROLL_ALIGNMENT_END: ArkUI_ScrollAlignment = 2;
#[doc = " Automatic alignment. If the specified item is completely in the display area, no adjustments will be made.\n Otherwise, according to the principle of the shortest sliding distance, align the head or tail of the specified\n item with the container, so that the specified item is completely in the display area."]
pub const ArkUI_ScrollAlignment_ARKUI_SCROLL_ALIGNMENT_AUTO: ArkUI_ScrollAlignment = 3;
#[doc = " @brief Alignment when scrolling to specific items.\n\n @since 12"]
pub type ArkUI_ScrollAlignment = u32;
#[doc = " Idle state. Trigger when using the method provided by the controller to control scrolling, and trigger when\n dragging the scroll bar to scroll."]
pub const ArkUI_ScrollState_ARKUI_SCROLL_STATE_IDLE: ArkUI_ScrollState = 0;
#[doc = " Scroll state. Triggered when dragging the container with fingers to scroll."]
pub const ArkUI_ScrollState_ARKUI_SCROLL_STATE_SCROLL: ArkUI_ScrollState = 1;
#[doc = " Inertial rolling state. Triggered when inertia rolling and bouncing back to the edge are performed after\n releasing the hand quickly."]
pub const ArkUI_ScrollState_ARKUI_SCROLL_STATE_FLING: ArkUI_ScrollState = 2;
#[doc = " @brief Define the current scrolling state.\n\n @since 12"]
pub type ArkUI_ScrollState = u32;
#[doc = " Round slider."]
pub const ArkUI_SliderBlockStyle_ARKUI_SLIDER_BLOCK_STYLE_DEFAULT: ArkUI_SliderBlockStyle = 0;
#[doc = " Slider with an image background."]
pub const ArkUI_SliderBlockStyle_ARKUI_SLIDER_BLOCK_STYLE_IMAGE: ArkUI_SliderBlockStyle = 1;
#[doc = " Slider in a custom shape."]
pub const ArkUI_SliderBlockStyle_ARKUI_SLIDER_BLOCK_STYLE_SHAPE: ArkUI_SliderBlockStyle = 2;
#[doc = " @brief Enumerates the types of the slider in the block direction.\n\n @since 12"]
pub type ArkUI_SliderBlockStyle = u32;
#[doc = " Vertical direction."]
pub const ArkUI_SliderDirection_ARKUI_SLIDER_DIRECTION_VERTICAL: ArkUI_SliderDirection = 0;
#[doc = " Horizontal direction."]
pub const ArkUI_SliderDirection_ARKUI_SLIDER_DIRECTION_HORIZONTAL: ArkUI_SliderDirection = 1;
#[doc = " @brief Enumerates the scroll directions of the slider.\n\n @since 12"]
pub type ArkUI_SliderDirection = u32;
#[doc = " The slider is on the slider track."]
pub const ArkUI_SliderStyle_ARKUI_SLIDER_STYLE_OUT_SET: ArkUI_SliderStyle = 0;
#[doc = " The slider is in the slider track."]
pub const ArkUI_SliderStyle_ARKUI_SLIDER_STYLE_IN_SET: ArkUI_SliderStyle = 1;
#[doc = " No slider."]
pub const ArkUI_SliderStyle_ARKUI_SLIDER_STYLE_NONE: ArkUI_SliderStyle = 2;
#[doc = " @brief Enumerates the slider styles.\n\n @since 12"]
pub type ArkUI_SliderStyle = u32;
#[doc = " Circle."]
pub const ArkUI_CheckboxShape_ArkUI_CHECKBOX_SHAPE_CIRCLE: ArkUI_CheckboxShape = 0;
#[doc = " Rounded square."]
pub const ArkUI_CheckboxShape_ArkUI_CHECKBOX_SHAPE_ROUNDED_SQUARE: ArkUI_CheckboxShape = 1;
#[doc = " @brief Enumerates the shapes of the check box\n\n @since 12"]
pub type ArkUI_CheckboxShape = u32;
#[doc = " The animation is played forwards."]
pub const ArkUI_AnimationPlayMode_ARKUI_ANIMATION_PLAY_MODE_NORMAL: ArkUI_AnimationPlayMode = 0;
#[doc = " The animation is played reversely."]
pub const ArkUI_AnimationPlayMode_ARKUI_ANIMATION_PLAY_MODE_REVERSE: ArkUI_AnimationPlayMode = 1;
#[doc = " The animation is played normally for an odd number of times (1, 3, 5...) and reversely for an even number\n  of times (2, 4, 6...)."]
pub const ArkUI_AnimationPlayMode_ARKUI_ANIMATION_PLAY_MODE_ALTERNATE: ArkUI_AnimationPlayMode = 2;
#[doc = " The animation is played reversely for an odd number of times (1, 3, 5...) and normally for an even number\n  of times (2, 4, 6...)."]
pub const ArkUI_AnimationPlayMode_ARKUI_ANIMATION_PLAY_MODE_ALTERNATE_REVERSE:
    ArkUI_AnimationPlayMode = 3;
#[doc = " @brief Enumerates the animation playback modes.\n\n @since 12"]
pub type ArkUI_AnimationPlayMode = u32;
#[doc = " The original image aspect ratio is retained."]
pub const ArkUI_ImageSize_ARKUI_IMAGE_SIZE_AUTO: ArkUI_ImageSize = 0;
#[doc = " The image is scaled with its aspect ratio retained for both sides to be greater than or equal\n  to the display boundaries."]
pub const ArkUI_ImageSize_ARKUI_IMAGE_SIZE_COVER: ArkUI_ImageSize = 1;
#[doc = " The image is scaled with its aspect ratio retained for the content to be completely displayed within the display\n  boundaries."]
pub const ArkUI_ImageSize_ARKUI_IMAGE_SIZE_CONTAIN: ArkUI_ImageSize = 2;
#[doc = " @brief Defines the image size.\n\n @since 12"]
pub type ArkUI_ImageSize = u32;
#[doc = " Adaptive color mode is not used."]
pub const ArkUI_AdaptiveColor_ARKUI_ADAPTIVE_COLOR_DEFAULT: ArkUI_AdaptiveColor = 0;
#[doc = " Adaptive color mode is used."]
pub const ArkUI_AdaptiveColor_ARKUI_ADAPTIVE_COLOR_AVERAGE: ArkUI_AdaptiveColor = 1;
#[doc = " @brief Enumerates the adaptive color modes.\n\n @since 12"]
pub type ArkUI_AdaptiveColor = u32;
#[doc = " Following the system color mode."]
pub const ArkUI_ColorMode_ARKUI_COLOR_MODE_SYSTEM: ArkUI_ColorMode = 0;
#[doc = " Light color mode."]
pub const ArkUI_ColorMode_ARKUI_COLOR_MODE_LIGHT: ArkUI_ColorMode = 1;
#[doc = " Dark color mode."]
pub const ArkUI_ColorMode_ARKUI_COLOR_MODE_DARK: ArkUI_ColorMode = 2;
#[doc = " @brief Enumerates the color modes.\n\n @since 12"]
pub type ArkUI_ColorMode = u32;
#[doc = " Light color mode."]
pub const ArkUI_SystemColorMode_ARKUI_SYSTEM_COLOR_MODE_LIGHT: ArkUI_SystemColorMode = 0;
#[doc = " Dark color mode."]
pub const ArkUI_SystemColorMode_ARKUI_SYSTEM_COLOR_MODE_DARK: ArkUI_SystemColorMode = 1;
#[doc = " @brief Enumerates the system color modes.\n\n @since 12"]
pub type ArkUI_SystemColorMode = u32;
#[doc = " Thin material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_THIN: ArkUI_BlurStyle = 0;
#[doc = " Regular material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_REGULAR: ArkUI_BlurStyle = 1;
#[doc = " Thick material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_THICK: ArkUI_BlurStyle = 2;
#[doc = " Material that creates the minimum depth of field effect."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_BACKGROUND_THIN: ArkUI_BlurStyle = 3;
#[doc = " Material that creates a medium shallow depth of field effect."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_BACKGROUND_REGULAR: ArkUI_BlurStyle = 4;
#[doc = " Material that creates a high shallow depth of field effect."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_BACKGROUND_THICK: ArkUI_BlurStyle = 5;
#[doc = " Material that creates the maximum depth of field effect."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_BACKGROUND_ULTRA_THICK: ArkUI_BlurStyle = 6;
#[doc = " No blur."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_NONE: ArkUI_BlurStyle = 7;
#[doc = " Component ultra-thin material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_ULTRA_THIN: ArkUI_BlurStyle = 8;
#[doc = " Component thin material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_THIN: ArkUI_BlurStyle = 9;
#[doc = " Component regular material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_REGULAR: ArkUI_BlurStyle = 10;
#[doc = " Component thick material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_THICK: ArkUI_BlurStyle = 11;
#[doc = " Component ultra-thick material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_ULTRA_THICK: ArkUI_BlurStyle = 12;
#[doc = " @brief Enumerates the blur styles.\n\n @since 12"]
pub type ArkUI_BlurStyle = u32;
#[doc = " The blur effect changes according to the window's focus state;\n  it is inactive when the window is not in focus and active when the window is in focus."]
#[cfg(feature = "api-19")]
pub const ArkUI_BlurStyleActivePolicy_ARKUI_BLUR_STYLE_ACTIVE_POLICY_FOLLOWS_WINDOW_ACTIVE_STATE:
    ArkUI_BlurStyleActivePolicy = 0;
#[doc = " The blur effect is always active."]
#[cfg(feature = "api-19")]
pub const ArkUI_BlurStyleActivePolicy_ARKUI_BLUR_STYLE_ACTIVE_POLICY_ALWAYS_ACTIVE:
    ArkUI_BlurStyleActivePolicy = 1;
#[doc = " The blur effect is always inactive."]
#[cfg(feature = "api-19")]
pub const ArkUI_BlurStyleActivePolicy_ARKUI_BLUR_STYLE_ACTIVE_POLICY_ALWAYS_INACTIVE:
    ArkUI_BlurStyleActivePolicy = 2;
#[doc = " @brief Enumerates the activation policies for the background blur effect.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub type ArkUI_BlurStyleActivePolicy = u32;
#[doc = " Top aligned."]
pub const ArkUI_VerticalAlignment_ARKUI_VERTICAL_ALIGNMENT_TOP: ArkUI_VerticalAlignment = 0;
#[doc = " Center aligned. This is the default alignment mode."]
pub const ArkUI_VerticalAlignment_ARKUI_VERTICAL_ALIGNMENT_CENTER: ArkUI_VerticalAlignment = 1;
#[doc = " Bottom aligned."]
pub const ArkUI_VerticalAlignment_ARKUI_VERTICAL_ALIGNMENT_BOTTOM: ArkUI_VerticalAlignment = 2;
#[doc = " @brief Enumerates the vertical alignment modes.\n\n @since 12"]
pub type ArkUI_VerticalAlignment = u32;
#[doc = " Aligned with the start edge in the same direction as the language in use."]
pub const ArkUI_HorizontalAlignment_ARKUI_HORIZONTAL_ALIGNMENT_START: ArkUI_HorizontalAlignment = 0;
#[doc = " Center aligned. This is the default alignment mode."]
pub const ArkUI_HorizontalAlignment_ARKUI_HORIZONTAL_ALIGNMENT_CENTER: ArkUI_HorizontalAlignment =
    1;
#[doc = " Aligned with the end edge in the same direction as the language in use."]
pub const ArkUI_HorizontalAlignment_ARKUI_HORIZONTAL_ALIGNMENT_END: ArkUI_HorizontalAlignment = 2;
#[doc = " @brief Enumerates the alignment mode in the horizontal direction.\n\n @since 12"]
pub type ArkUI_HorizontalAlignment = u32;
#[doc = " Extra-long text is not clipped."]
pub const ArkUI_TextOverflow_ARKUI_TEXT_OVERFLOW_NONE: ArkUI_TextOverflow = 0;
#[doc = " Extra-long text is clipped."]
pub const ArkUI_TextOverflow_ARKUI_TEXT_OVERFLOW_CLIP: ArkUI_TextOverflow = 1;
#[doc = " An ellipsis (...) is used to represent text overflow."]
pub const ArkUI_TextOverflow_ARKUI_TEXT_OVERFLOW_ELLIPSIS: ArkUI_TextOverflow = 2;
#[doc = " Text continuously scrolls when text overflow occurs."]
pub const ArkUI_TextOverflow_ARKUI_TEXT_OVERFLOW_MARQUEE: ArkUI_TextOverflow = 3;
#[doc = " @brief Enumerates the display modes when the text is too long.\n\n @since 12"]
pub type ArkUI_TextOverflow = u32;
#[doc = " The image is bottom aligned with the text baseline."]
pub const ArkUI_ImageSpanAlignment_ARKUI_IMAGE_SPAN_ALIGNMENT_BASELINE: ArkUI_ImageSpanAlignment =
    0;
#[doc = " The image is bottom aligned with the text."]
pub const ArkUI_ImageSpanAlignment_ARKUI_IMAGE_SPAN_ALIGNMENT_BOTTOM: ArkUI_ImageSpanAlignment = 1;
#[doc = " The image is centered aligned with the text."]
pub const ArkUI_ImageSpanAlignment_ARKUI_IMAGE_SPAN_ALIGNMENT_CENTER: ArkUI_ImageSpanAlignment = 2;
#[doc = " The image is top aligned with the text."]
pub const ArkUI_ImageSpanAlignment_ARKUI_IMAGE_SPAN_ALIGNMENT_TOP: ArkUI_ImageSpanAlignment = 3;
#[doc = " The image alignment mode follows the text component's alignment mode.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_ImageSpanAlignment_ARKUI_IMAGE_SPAN_ALIGNMENT_FOLLOW_PARAGRAPH:
    ArkUI_ImageSpanAlignment = 4;
#[doc = " @brief Enumerates the alignment mode of the image with the text.\n\n @since 12"]
pub type ArkUI_ImageSpanAlignment = u32;
#[doc = " The image is scaled with its aspect ratio retained for the content to be completely displayed within the\n  display boundaries."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_CONTAIN: ArkUI_ObjectFit = 0;
#[doc = " The image is scaled with its aspect ratio retained for both sides to be greater than or equal to the\n  display boundaries."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_COVER: ArkUI_ObjectFit = 1;
#[doc = " The image is scaled automatically to fit the display area."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_AUTO: ArkUI_ObjectFit = 2;
#[doc = " The image is scaled to fill the display area, and its aspect ratio is not retained."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_FILL: ArkUI_ObjectFit = 3;
#[doc = " The image content is displayed with its aspect ratio retained. The size is smaller than or equal to the\n  original size."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_SCALE_DOWN: ArkUI_ObjectFit = 4;
#[doc = " The original size is retained."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE: ArkUI_ObjectFit = 5;
#[doc = " Not resized, the image is aligned with the start edge of the top of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_TOP_START: ArkUI_ObjectFit = 6;
#[doc = " Not resized, the image is horizontally centered at the top of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_TOP: ArkUI_ObjectFit = 7;
#[doc = " Not resized, the image is aligned with the end edge at the top of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_TOP_END: ArkUI_ObjectFit = 8;
#[doc = " Not resized, the image is vertically centered on the start edge of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_START: ArkUI_ObjectFit = 9;
#[doc = " Not resized, the image is horizontally and vertically centered in the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_CENTER: ArkUI_ObjectFit = 10;
#[doc = " Not resized, the image is vertically centered on the end edge of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_END: ArkUI_ObjectFit = 11;
#[doc = " Not resized, the image is aligned with the start edge at the bottom of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_BOTTOM_START: ArkUI_ObjectFit = 12;
#[doc = " Not resized, the image is horizontally centered at the bottom of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_BOTTOM: ArkUI_ObjectFit = 13;
#[doc = " Not resized, the image is aligned with the end edge at the bottom of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_BOTTOM_END: ArkUI_ObjectFit = 14;
#[doc = " Not resized, and is used in conjunction with NODE_IMAGE_IMAGE_MATRIX.\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_MATRIX: ArkUI_ObjectFit = 15;
#[doc = " @brief Defines how the image is resized to fit its container.\nImageSpanAlignment\n @since 12"]
pub type ArkUI_ObjectFit = u32;
#[doc = " No image interpolation."]
pub const ArkUI_ImageInterpolation_ARKUI_IMAGE_INTERPOLATION_NONE: ArkUI_ImageInterpolation = 0;
#[doc = " Low quality interpolation."]
pub const ArkUI_ImageInterpolation_ARKUI_IMAGE_INTERPOLATION_LOW: ArkUI_ImageInterpolation = 1;
#[doc = " Medium quality interpolation."]
pub const ArkUI_ImageInterpolation_ARKUI_IMAGE_INTERPOLATION_MEDIUM: ArkUI_ImageInterpolation = 2;
#[doc = " High quality interpolation. This mode produces scaled images of the highest possible quality."]
pub const ArkUI_ImageInterpolation_ARKUI_IMAGE_INTERPOLATION_HIGH: ArkUI_ImageInterpolation = 3;
#[doc = " @brief Enumerates the image interpolation effect.\n\n @since 12"]
pub type ArkUI_ImageInterpolation = u32;
#[doc = " high dynamic range mode."]
#[cfg(feature = "api-21")]
pub const ArkUI_DynamicRangeMode_ARKUI_DYNAMIC_RANGE_MODE_HIGH: ArkUI_DynamicRangeMode = 0;
#[doc = " constraint dynamic range mode."]
#[cfg(feature = "api-21")]
pub const ArkUI_DynamicRangeMode_ARKUI_DYNAMIC_RANGE_MODE_CONSTRAINT: ArkUI_DynamicRangeMode = 1;
#[doc = " standard dynamic range mode."]
#[cfg(feature = "api-21")]
pub const ArkUI_DynamicRangeMode_ARKUI_DYNAMIC_RANGE_MODE_STANDARD: ArkUI_DynamicRangeMode = 2;
#[doc = " @brief Enumerates the image dynamic range mode.\n\n @since 21"]
#[cfg(feature = "api-21")]
pub type ArkUI_DynamicRangeMode = u32;
#[doc = " Use EXIF metadata for display orientation, with support for rotation and mirroring."]
#[cfg(feature = "api-21")]
pub const ArkUI_ImageRotateOrientation_ARKUI_ORIENTATION_AUTO: ArkUI_ImageRotateOrientation = 0;
#[doc = " Display original pixel data without transformation."]
#[cfg(feature = "api-21")]
pub const ArkUI_ImageRotateOrientation_ARKUI_ORIENTATION_UP: ArkUI_ImageRotateOrientation = 1;
#[doc = " Display the image after rotating it 90 degrees clockwise."]
#[cfg(feature = "api-21")]
pub const ArkUI_ImageRotateOrientation_ARKUI_ORIENTATION_RIGHT: ArkUI_ImageRotateOrientation = 2;
#[doc = " Display the image after rotating it 180 degrees clockwise."]
#[cfg(feature = "api-21")]
pub const ArkUI_ImageRotateOrientation_ARKUI_ORIENTATION_DOWN: ArkUI_ImageRotateOrientation = 3;
#[doc = " Display the image after rotating it 270 degrees clockwise."]
#[cfg(feature = "api-21")]
pub const ArkUI_ImageRotateOrientation_ARKUI_ORIENTATION_LEFT: ArkUI_ImageRotateOrientation = 4;
#[doc = " Display the image after flipping it horizontally."]
#[cfg(feature = "api-21")]
pub const ArkUI_ImageRotateOrientation_ARKUI_ORIENTATION_UP_MIRRORED: ArkUI_ImageRotateOrientation =
    5;
#[doc = " Display the image after flipping it horizontally and then rotating it 90 degrees clockwise."]
#[cfg(feature = "api-21")]
pub const ArkUI_ImageRotateOrientation_ARKUI_ORIENTATION_RIGHT_MIRRORED:
    ArkUI_ImageRotateOrientation = 6;
#[doc = " Display the image after flipping it vertically."]
#[cfg(feature = "api-21")]
pub const ArkUI_ImageRotateOrientation_ARKUI_ORIENTATION_DOWN_MIRRORED:
    ArkUI_ImageRotateOrientation = 7;
#[doc = " Display the image after flipping it horizontally and then rotating it 270 degrees clockwise."]
#[cfg(feature = "api-21")]
pub const ArkUI_ImageRotateOrientation_ARKUI_ORIENTATION_LEFT_MIRRORED:
    ArkUI_ImageRotateOrientation = 8;
#[doc = " @brief Enumerates the image rotate orientation.\n\n @since 21"]
#[cfg(feature = "api-21")]
pub type ArkUI_ImageRotateOrientation = u32;
#[doc = " The top image is superimposed on the bottom image without any blending."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_NONE: ArkUI_BlendMode = 0;
#[doc = " The target pixels covered by the source pixels are erased by being turned to completely transparent."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_CLEAR: ArkUI_BlendMode = 1;
#[doc = " r = s: Only the source pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC: ArkUI_BlendMode = 2;
#[doc = " r = d: Only the target pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST: ArkUI_BlendMode = 3;
#[doc = " r = s + (1 - sa) * d: The source pixels are blended based on opacity and cover the target pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC_OVER: ArkUI_BlendMode = 4;
#[doc = " r = d + (1 - da) * s: The target pixels are blended based on opacity and cover on the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST_OVER: ArkUI_BlendMode = 5;
#[doc = " r = s * da: Only the part of the source pixels that overlap with the target pixels is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC_IN: ArkUI_BlendMode = 6;
#[doc = " r = d * sa: Only the part of the target pixels that overlap with the source pixels is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST_IN: ArkUI_BlendMode = 7;
#[doc = " r = s * (1 - da): Only the part of the source pixels that do not overlap with the target pixels is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC_OUT: ArkUI_BlendMode = 8;
#[doc = " r = d * (1 - sa): Only the part of the target pixels that do not overlap with the source pixels is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST_OUT: ArkUI_BlendMode = 9;
#[doc = " r = s * da + d * (1 - sa): The part of the source pixels that overlap with the target pixels is displayed and\n  the part of the target pixels that do not overlap with the source pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC_ATOP: ArkUI_BlendMode = 10;
#[doc = " r = d * sa + s * (1 - da): The part of the target pixels that overlap with the source pixels and the part of\n  the source pixels that do not overlap with the target pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST_ATOP: ArkUI_BlendMode = 11;
#[doc = " r = s * (1 - da) + d * (1 - sa): Only the non-overlapping part between the source pixels and the target pixels\n is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_XOR: ArkUI_BlendMode = 12;
#[doc = " r = min(s + d, 1): New pixels resulting from adding the source pixels to the target pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_PLUS: ArkUI_BlendMode = 13;
#[doc = " r = s * d: New pixels resulting from multiplying the source pixels with the target pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_MODULATE: ArkUI_BlendMode = 14;
#[doc = " r = s + d - s * d: Pixels are blended by adding the source pixels to the target pixels and subtracting the\n  product of their multiplication."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SCREEN: ArkUI_BlendMode = 15;
#[doc = " The MULTIPLY or SCREEN mode is used based on the target pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_OVERLAY: ArkUI_BlendMode = 16;
#[doc = " rc = s + d - max(s * da, d * sa), ra = kSrcOver: When two colors overlap, whichever is darker is used."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DARKEN: ArkUI_BlendMode = 17;
#[doc = " rc = s + d - min(s * da, d * sa), ra =\nkSrcOver: The final pixels are composed of the lightest values of pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_LIGHTEN: ArkUI_BlendMode = 18;
#[doc = " The colors of the target pixels are lightened to reflect the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_COLOR_DODGE: ArkUI_BlendMode = 19;
#[doc = " The colors of the target pixels are darkened to reflect the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_COLOR_BURN: ArkUI_BlendMode = 20;
#[doc = " The MULTIPLY or SCREEN mode is used, depending on the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_HARD_LIGHT: ArkUI_BlendMode = 21;
#[doc = " The LIGHTEN or DARKEN mode is used, depending on the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SOFT_LIGHT: ArkUI_BlendMode = 22;
#[doc = " rc = s + d - 2 * (min(s * da, d * sa)), ra =\nkSrcOver: The final pixel is the result of subtracting the darker of the two pixels (source and target) from\nthe lighter one."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DIFFERENCE: ArkUI_BlendMode = 23;
#[doc = " rc = s + d - two(s * d), ra = kSrcOver: The final pixel is similar to <b>DIFFERENCE</b>, but with less contrast."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_EXCLUSION: ArkUI_BlendMode = 24;
#[doc = " r = s * (1 - da) + d * (1 - sa) + s * d: The final pixel is the result of multiplying the source pixel\n  by the target pixel."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_MULTIPLY: ArkUI_BlendMode = 25;
#[doc = " The resultant image is created with the luminance and saturation of the source image and the hue of the target\n  image."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_HUE: ArkUI_BlendMode = 26;
#[doc = " The resultant image is created with the luminance and hue of the target image and the saturation of the source\n  image."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SATURATION: ArkUI_BlendMode = 27;
#[doc = " The resultant image is created with the saturation and hue of the source image and the luminance of the target\n  image."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_COLOR: ArkUI_BlendMode = 28;
#[doc = " The resultant image is created with the saturation and hue of the target image and the luminance of the source\n  image."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_LUMINOSITY: ArkUI_BlendMode = 29;
#[doc = " @brief Enumerates the blend modes.\n\n @since 12"]
pub type ArkUI_BlendMode = u32;
#[doc = " Components are arranged from left to right."]
pub const ArkUI_Direction_ARKUI_DIRECTION_LTR: ArkUI_Direction = 0;
#[doc = " Components are arranged from right to left."]
pub const ArkUI_Direction_ARKUI_DIRECTION_RTL: ArkUI_Direction = 1;
#[doc = " The default layout direction is used."]
pub const ArkUI_Direction_ARKUI_DIRECTION_AUTO: ArkUI_Direction = 3;
#[doc = " @brief Enumerates the modes in which components are laid out along the main axis of the container.\n\n @since 12"]
pub type ArkUI_Direction = u32;
#[doc = " The default configuration in the container is used."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_AUTO: ArkUI_ItemAlignment = 0;
#[doc = " The items in the container are aligned with the cross-start edge."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_START: ArkUI_ItemAlignment = 1;
#[doc = " The items in the container are centered along the cross axis."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_CENTER: ArkUI_ItemAlignment = 2;
#[doc = " The items in the container are aligned with the cross-end edge."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_END: ArkUI_ItemAlignment = 3;
#[doc = " The items in the container are stretched and padded along the cross axis."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_STRETCH: ArkUI_ItemAlignment = 4;
#[doc = " The items in the container are aligned in such a manner that their text baselines are aligned along the\n  cross axis."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_BASELINE: ArkUI_ItemAlignment = 5;
#[doc = " @brief Enumerates the modes in which components are laid out along the cross axis of the container.\n\n @since 12"]
pub type ArkUI_ItemAlignment = u32;
#[doc = " The foreground colors are the inverse of the component background colors."]
pub const ArkUI_ColorStrategy_ARKUI_COLOR_STRATEGY_INVERT: ArkUI_ColorStrategy = 0;
#[doc = " The shadow colors of the component are the average color obtained from the component background shadow area."]
pub const ArkUI_ColorStrategy_ARKUI_COLOR_STRATEGY_AVERAGE: ArkUI_ColorStrategy = 1;
#[doc = " The shadow colors of the component are the primary color obtained from the component background shadow area."]
pub const ArkUI_ColorStrategy_ARKUI_COLOR_STRATEGY_PRIMARY: ArkUI_ColorStrategy = 2;
#[doc = " @brief Enumerates the foreground colors.\n\n @since 12"]
pub type ArkUI_ColorStrategy = u32;
#[doc = " The child components are aligned with the start edge of the main axis."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_START: ArkUI_FlexAlignment = 1;
#[doc = " The child components are aligned in the center of the main axis."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_CENTER: ArkUI_FlexAlignment = 2;
#[doc = " The child components are aligned with the end edge of the main axis."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_END: ArkUI_FlexAlignment = 3;
#[doc = " The child components are evenly distributed along the main axis. The space between any two adjacent components\n  is the same. The first component is aligned with the main-start, and the last component is aligned with\n  the main-end."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_SPACE_BETWEEN: ArkUI_FlexAlignment = 6;
#[doc = " The child components are evenly distributed along the main axis. The space between any two adjacent components\n  is the same. The space between the first component and main-start, and that between the last component and\n  cross-main are both half the size of the space between two adjacent components."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_SPACE_AROUND: ArkUI_FlexAlignment = 7;
#[doc = " The child components are evenly distributed along the main axis. The space between the first component\n  and main-start, the space between the last component and main-end, and the space between any two adjacent\n  components are the same."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_SPACE_EVENLY: ArkUI_FlexAlignment = 8;
#[doc = " @brief Enumerates the vertical alignment modes.\n\n @since 12"]
pub type ArkUI_FlexAlignment = u32;
#[doc = " The child components are arranged in the same direction as the main axis runs along the rows."]
pub const ArkUI_FlexDirection_ARKUI_FLEX_DIRECTION_ROW: ArkUI_FlexDirection = 0;
#[doc = " The child components are arranged in the same direction as the main axis runs down the columns."]
pub const ArkUI_FlexDirection_ARKUI_FLEX_DIRECTION_COLUMN: ArkUI_FlexDirection = 1;
#[doc = " The child components are arranged opposite to the <b>ROW</b> direction."]
pub const ArkUI_FlexDirection_ARKUI_FLEX_DIRECTION_ROW_REVERSE: ArkUI_FlexDirection = 2;
#[doc = " The child components are arranged opposite to the <b>COLUMN</b> direction."]
pub const ArkUI_FlexDirection_ARKUI_FLEX_DIRECTION_COLUMN_REVERSE: ArkUI_FlexDirection = 3;
#[doc = " @brief Enumerates the directions of the main axis in the flex container.\n\n @since 12"]
pub type ArkUI_FlexDirection = u32;
#[doc = " The child components in the flex container are arranged in a single line, and they cannot overflow."]
pub const ArkUI_FlexWrap_ARKUI_FLEX_WRAP_NO_WRAP: ArkUI_FlexWrap = 0;
#[doc = " The child components in the flex container are arranged in multiple lines, and they may overflow."]
pub const ArkUI_FlexWrap_ARKUI_FLEX_WRAP_WRAP: ArkUI_FlexWrap = 1;
#[doc = " The child components in the flex container are reversely arranged in multiple lines, and they may overflow."]
pub const ArkUI_FlexWrap_ARKUI_FLEX_WRAP_WRAP_REVERSE: ArkUI_FlexWrap = 2;
#[doc = " @brief Defines whether the flex container has a single line or multiple lines.\n\n @since 12"]
pub type ArkUI_FlexWrap = u32;
#[doc = " The component is visible."]
pub const ArkUI_Visibility_ARKUI_VISIBILITY_VISIBLE: ArkUI_Visibility = 0;
#[doc = " The component is hidden, and a placeholder is used for it in the layout."]
pub const ArkUI_Visibility_ARKUI_VISIBILITY_HIDDEN: ArkUI_Visibility = 1;
#[doc = " The component is hidden. It is not involved in the layout, and no placeholder is used for it."]
pub const ArkUI_Visibility_ARKUI_VISIBILITY_NONE: ArkUI_Visibility = 2;
#[doc = " @brief Enumerates the visibility values.\n\n @since 12"]
pub type ArkUI_Visibility = u32;
#[doc = " Left aligned."]
pub const ArkUI_CalendarAlignment_ARKUI_CALENDAR_ALIGNMENT_START: ArkUI_CalendarAlignment = 0;
#[doc = " Center aligned."]
pub const ArkUI_CalendarAlignment_ARKUI_CALENDAR_ALIGNMENT_CENTER: ArkUI_CalendarAlignment = 1;
#[doc = " Right aligned."]
pub const ArkUI_CalendarAlignment_ARKUI_CALENDAR_ALIGNMENT_END: ArkUI_CalendarAlignment = 2;
#[doc = " @brief Enumerates the alignment modes between the calendar picker and the entry component.\n\n @since 12"]
pub type ArkUI_CalendarAlignment = u32;
#[doc = " Rectangle."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_RECTANGLE: ArkUI_MaskType = 0;
#[doc = " Circle."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_CIRCLE: ArkUI_MaskType = 1;
#[doc = " Ellipse."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_ELLIPSE: ArkUI_MaskType = 2;
#[doc = " Path."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_PATH: ArkUI_MaskType = 3;
#[doc = " Progress indicator."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_PROGRESS: ArkUI_MaskType = 4;
#[doc = " @brief Enumerates the mask types.\n\n @since 12"]
pub type ArkUI_MaskType = u32;
#[doc = " Rectangle."]
pub const ArkUI_ClipType_ARKUI_CLIP_TYPE_RECTANGLE: ArkUI_ClipType = 0;
#[doc = " Circle."]
pub const ArkUI_ClipType_ARKUI_CLIP_TYPE_CIRCLE: ArkUI_ClipType = 1;
#[doc = " Ellipse."]
pub const ArkUI_ClipType_ARKUI_CLIP_TYPE_ELLIPSE: ArkUI_ClipType = 2;
#[doc = " Path."]
pub const ArkUI_ClipType_ARKUI_CLIP_TYPE_PATH: ArkUI_ClipType = 3;
#[doc = " @brief Enumerates the clipping region types.\n\n @since 12"]
pub type ArkUI_ClipType = u32;
#[doc = " @brief Defines the gradient color stop structure.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ColorStop {
    #[doc = " Color array."]
    pub colors: *const u32,
    #[doc = " Position array."]
    pub stops: *mut f32,
    #[doc = " Length array."]
    pub size: ::std::os::raw::c_int,
}
#[doc = " Rectangle."]
pub const ArkUI_ShapeType_ARKUI_SHAPE_TYPE_RECTANGLE: ArkUI_ShapeType = 0;
#[doc = " Circle."]
pub const ArkUI_ShapeType_ARKUI_SHAPE_TYPE_CIRCLE: ArkUI_ShapeType = 1;
#[doc = " Ellipse."]
pub const ArkUI_ShapeType_ARKUI_SHAPE_TYPE_ELLIPSE: ArkUI_ShapeType = 2;
#[doc = " Path."]
pub const ArkUI_ShapeType_ARKUI_SHAPE_TYPE_PATH: ArkUI_ShapeType = 3;
#[doc = " @brief Enumerates the custom shapes.\n\n @since 12"]
pub type ArkUI_ShapeType = u32;
#[doc = " From right to left."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_LEFT:
    ArkUI_LinearGradientDirection = 0;
#[doc = " From bottom to top."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_TOP:
    ArkUI_LinearGradientDirection = 1;
#[doc = " From left to right."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_RIGHT:
    ArkUI_LinearGradientDirection = 2;
#[doc = " From top to bottom."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_BOTTOM:
    ArkUI_LinearGradientDirection = 3;
#[doc = " From lower right to upper left."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_LEFT_TOP:
    ArkUI_LinearGradientDirection = 4;
#[doc = " From upper right to lower left."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_LEFT_BOTTOM:
    ArkUI_LinearGradientDirection = 5;
#[doc = " From lower left to upper right."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_RIGHT_TOP:
    ArkUI_LinearGradientDirection = 6;
#[doc = " From upper left to lower right."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_RIGHT_BOTTOM:
    ArkUI_LinearGradientDirection = 7;
#[doc = " No gradient."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_NONE:
    ArkUI_LinearGradientDirection = 8;
#[doc = " Custom direction."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_CUSTOM:
    ArkUI_LinearGradientDirection = 9;
#[doc = " @brief Enumerates the gradient directions.\n\n @since 12"]
pub type ArkUI_LinearGradientDirection = u32;
#[doc = " Word breaks can occur between any two characters for Chinese, Japanese, and Korean (CJK) text, but can occur\n  only at a space character for non-CJK text (such as English)."]
pub const ArkUI_WordBreak_ARKUI_WORD_BREAK_NORMAL: ArkUI_WordBreak = 0;
#[doc = " Word breaks can occur between any two characters for non-CJK text. CJK text behavior is the same as for\n  <b>NORMAL</b>."]
pub const ArkUI_WordBreak_ARKUI_WORD_BREAK_BREAK_ALL: ArkUI_WordBreak = 1;
#[doc = " This option has the same effect as <b>BREAK_ALL</b> for non-CJK text, except that if it preferentially wraps\n  lines at appropriate characters (for example, spaces) whenever possible.\nCJK text behavior is the same as for <b>NORMAL</b>."]
pub const ArkUI_WordBreak_ARKUI_WORD_BREAK_BREAK_WORD: ArkUI_WordBreak = 2;
#[doc = " @brief Line breaks can occur between any two syllabic units for non-CJK text.\n CJK text behavior is the same as for <b>NORMAL</b>.\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_WordBreak_ARKUI_WORD_BREAK_HYPHENATION: ArkUI_WordBreak = 3;
#[doc = " @brief Enumerates the word break rules.\n\n @since 12"]
pub type ArkUI_WordBreak = u32;
#[doc = " An ellipsis is used at the start of the line of text."]
pub const ArkUI_EllipsisMode_ARKUI_ELLIPSIS_MODE_START: ArkUI_EllipsisMode = 0;
#[doc = " An ellipsis is used at the center of the line of text."]
pub const ArkUI_EllipsisMode_ARKUI_ELLIPSIS_MODE_CENTER: ArkUI_EllipsisMode = 1;
#[doc = " An ellipsis is used at the end of the line of text."]
pub const ArkUI_EllipsisMode_ARKUI_ELLIPSIS_MODE_END: ArkUI_EllipsisMode = 2;
#[doc = " @brief Enumerates the ellipsis positions.\n\n @since 12"]
pub type ArkUI_EllipsisMode = u32;
#[doc = " Render image pixels as they are in the original source image."]
pub const ArkUI_ImageRenderMode_ARKUI_IMAGE_RENDER_MODE_ORIGINAL: ArkUI_ImageRenderMode = 0;
#[doc = " Render image pixels to create a monochrome template image."]
pub const ArkUI_ImageRenderMode_ARKUI_IMAGE_RENDER_MODE_TEMPLATE: ArkUI_ImageRenderMode = 1;
#[doc = " @brief Enumerates the image rendering modes.\n\n @since 12"]
pub type ArkUI_ImageRenderMode = u32;
#[doc = " Top edge of the window."]
pub const ArkUI_TransitionEdge_ARKUI_TRANSITION_EDGE_TOP: ArkUI_TransitionEdge = 0;
#[doc = " Bottom edge of the window."]
pub const ArkUI_TransitionEdge_ARKUI_TRANSITION_EDGE_BOTTOM: ArkUI_TransitionEdge = 1;
#[doc = " Left edge of the window."]
pub const ArkUI_TransitionEdge_ARKUI_TRANSITION_EDGE_START: ArkUI_TransitionEdge = 2;
#[doc = " Right edge of the window."]
pub const ArkUI_TransitionEdge_ARKUI_TRANSITION_EDGE_END: ArkUI_TransitionEdge = 3;
#[doc = " @brief Enumerates the slide-in and slide-out positions of the component from the screen edge during transition.\n\n @since 12"]
pub type ArkUI_TransitionEdge = u32;
#[doc = " The content of the view is blended in sequence on the target image."]
pub const ArkUI_BlendApplyType_BLEND_APPLY_TYPE_FAST: ArkUI_BlendApplyType = 0;
#[doc = " The content of the component and its child components are drawn on the offscreen canvas, and then blended with\n  the existing content on the canvas."]
pub const ArkUI_BlendApplyType_BLEND_APPLY_TYPE_OFFSCREEN: ArkUI_BlendApplyType = 1;
#[doc = " @brief Defines how the specified blend mode is applied.\n\n @since 12"]
pub type ArkUI_BlendApplyType = u32;
#[doc = " @brief Defines a mask area.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Rect {
    #[doc = " X coordinate of the mask area."]
    pub x: f32,
    #[doc = " Y coordinate of the mask area."]
    pub y: f32,
    #[doc = " Width of the mask area."]
    pub width: f32,
    #[doc = " Height of the mask area."]
    pub height: f32,
}
#[doc = " @brief Describes the width and height of a component.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_IntSize {
    #[doc = " Width, in px."]
    pub width: i32,
    #[doc = " Height, in px."]
    pub height: i32,
}
#[doc = " @brief Describes the position of a component.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_IntOffset {
    #[doc = " Horizontal coordinate, in px."]
    pub x: i32,
    #[doc = " Vertical coordinate, in px."]
    pub y: i32,
}
#[doc = " The callback is invoked when the entire animation is removed once it has finished."]
pub const ArkUI_FinishCallbackType_ARKUI_FINISH_CALLBACK_REMOVED: ArkUI_FinishCallbackType = 0;
#[doc = " The callback is invoked when the animation logically enters the falling state, though it may still be in its\n long tail state."]
pub const ArkUI_FinishCallbackType_ARKUI_FINISH_CALLBACK_LOGICALLY: ArkUI_FinishCallbackType = 1;
#[doc = " @brief Enumerates the animation onFinish callback types.\n\n @since 12"]
pub type ArkUI_FinishCallbackType = u32;
#[doc = " The list items are packed toward the start edge of the list container along the cross axis."]
pub const ArkUI_ListItemAlignment_ARKUI_LIST_ITEM_ALIGNMENT_START: ArkUI_ListItemAlignment = 0;
#[doc = " The list items are centered in the list container along the cross axis."]
pub const ArkUI_ListItemAlignment_ARKUI_LIST_ITEM_ALIGNMENT_CENTER: ArkUI_ListItemAlignment = 1;
#[doc = " The list items are packed toward the end edge of the list container along the cross axis."]
pub const ArkUI_ListItemAlignment_ARKUI_LIST_ITEM_ALIGNMENT_END: ArkUI_ListItemAlignment = 2;
#[doc = " @brief Enumerates the alignment modes of items along the cross axis.\n\n @since 12"]
pub type ArkUI_ListItemAlignment = u32;
#[doc = " The barrier is the leftmost of all its referencedIds."]
pub const ArkUI_BarrierDirection_ARKUI_BARRIER_DIRECTION_START: ArkUI_BarrierDirection = 0;
#[doc = " The barrier is on the rightmost side of all its referencedIds."]
pub const ArkUI_BarrierDirection_ARKUI_BARRIER_DIRECTION_END: ArkUI_BarrierDirection = 1;
#[doc = " The barrier is at the top of all its referencedIds."]
pub const ArkUI_BarrierDirection_ARKUI_BARRIER_DIRECTION_TOP: ArkUI_BarrierDirection = 2;
#[doc = " The barrier is at the bottom of all its referencedIds."]
pub const ArkUI_BarrierDirection_ARKUI_BARRIER_DIRECTION_BOTTOM: ArkUI_BarrierDirection = 3;
#[doc = " @brief defines the direction of the barrier line.\n\n @since 12"]
pub type ArkUI_BarrierDirection = u32;
#[doc = " Components are evenly distributed among constraint anchor points."]
pub const ArkUI_RelativeLayoutChainStyle_ARKUI_RELATIVE_LAYOUT_CHAIN_STYLE_SPREAD:
    ArkUI_RelativeLayoutChainStyle = 0;
#[doc = " Except for the first and last two sub-components,\n other components are evenly distributed between the constraint anchor points."]
pub const ArkUI_RelativeLayoutChainStyle_ARKUI_RELATIVE_LAYOUT_CHAIN_STYLE_SPREAD_INSIDE:
    ArkUI_RelativeLayoutChainStyle = 1;
#[doc = " No gaps in subcomponents within the chain."]
pub const ArkUI_RelativeLayoutChainStyle_ARKUI_RELATIVE_LAYOUT_CHAIN_STYLE_PACKED:
    ArkUI_RelativeLayoutChainStyle = 2;
#[doc = " @brief defines the style of the chain.\n\n @since 12"]
pub type ArkUI_RelativeLayoutChainStyle = u32;
#[doc = " @brief Describes the margins of a component.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Margin {
    #[doc = " Top margin, in vp."]
    pub top: f32,
    #[doc = " Right margin, in vp."]
    pub right: f32,
    #[doc = " Bottom margin, in vp."]
    pub bottom: f32,
    #[doc = " Left margin, in vp."]
    pub left: f32,
}
#[doc = " Default, which is fp for fonts and vp for non-fonts."]
pub const ArkUI_LengthMetricUnit_ARKUI_LENGTH_METRIC_UNIT_DEFAULT: ArkUI_LengthMetricUnit = -1;
#[doc = " px."]
pub const ArkUI_LengthMetricUnit_ARKUI_LENGTH_METRIC_UNIT_PX: ArkUI_LengthMetricUnit = 0;
#[doc = " vp."]
pub const ArkUI_LengthMetricUnit_ARKUI_LENGTH_METRIC_UNIT_VP: ArkUI_LengthMetricUnit = 1;
#[doc = " fp."]
pub const ArkUI_LengthMetricUnit_ARKUI_LENGTH_METRIC_UNIT_FP: ArkUI_LengthMetricUnit = 2;
#[doc = " @brief Enumerates the component units.\n\n @since 12"]
pub type ArkUI_LengthMetricUnit = i32;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always centered with the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_CENTER: ArkUI_RenderFit = 0;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always aligned with the top center of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_TOP: ArkUI_RenderFit = 1;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always aligned with the bottom center of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_BOTTOM: ArkUI_RenderFit = 2;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always aligned to the left of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_LEFT: ArkUI_RenderFit = 3;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always right-aligned with the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RIGHT: ArkUI_RenderFit = 4;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always aligned with the top left corner of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_TOP_LEFT: ArkUI_RenderFit = 5;
#[doc = " Keep the content size of the animation final state,\n and the content is always aligned with the upper right corner of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_TOP_RIGHT: ArkUI_RenderFit = 6;
#[doc = " Keep the content size of the animation final state,\n and the content always aligns with the lower-left corner of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_BOTTOM_LEFT: ArkUI_RenderFit = 7;
#[doc = " Keep the content size of the animation final state,\nand the content always aligns with the lower-right corner of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_BOTTOM_RIGHT: ArkUI_RenderFit = 8;
#[doc = " The aspect ratio of the animation's final state content is not considered,\nand the content is always scaled to the size of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_FILL: ArkUI_RenderFit = 9;
#[doc = " Reduce or enlarge the aspect ratio of the animation final state content,\n so that the content is fully displayed in the component,\n and keep the center aligned with the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_CONTAIN: ArkUI_RenderFit = 10;
#[doc = " Keep the aspect ratio of the animation final state content to reduce or enlarge,\n so that the content is fully displayed in the component.\n When there is left over in the broad direction of the component,\n the content is aligned to the left of the component,\n and when there is left over in the high direction of the component,\n the content is aligned to the top of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_CONTAIN_TOP_LEFT: ArkUI_RenderFit = 11;
#[doc = " Keep the aspect ratio of the animation final state content to reduce or enlarge,\n so that the content is fully displayed in the component.\n When there is left in the wide direction of the component,\n the content is aligned with the component on the right.\n When there is left in the high direction of the component,\n the content is aligned with the component on the bottom."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_CONTAIN_BOTTOM_RIGHT: ArkUI_RenderFit = 12;
#[doc = " Keep the aspect ratio of the animation final state content reduced or enlarged,\n so that both sides of the content are greater than or equal to both sides of the component,\n and keep the center aligned with the component to display the middle part of the content."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_COVER: ArkUI_RenderFit = 13;
#[doc = " Keep the aspect ratio of the final content of the animation reduced or enlarged\n so that both sides of the content are exactly greater than or equal to both sides of the component.\n When the content width is left, the content is aligned to the left of the component,\n and the left portion of the content is displayed. When the content is left in the high direction,\n the content and the component remain top aligned, showing the top side of the content."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_COVER_TOP_LEFT: ArkUI_RenderFit = 14;
#[doc = " Keep the aspect ratio of the final content of the animation reduced or enlarged so\n that both sides of the content are exactly greater than or equal to both sides of the component.\n When the content width is left, the content and the component remain right aligned,\n and the right part of the content is displayed. When the content is left in the high direction,\n the content and the component remain aligned at the bottom,\n and the bottom part of the content is displayed."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_COVER_BOTTOM_RIGHT: ArkUI_RenderFit = 15;
#[doc = " @brief Enumerates the render fit.\n\n @since 12"]
pub type ArkUI_RenderFit = u32;
#[doc = " Normal button (without rounded corners by default)."]
pub const ArkUI_ButtonType_ARKUI_BUTTON_TYPE_NORMAL: ArkUI_ButtonType = 0;
#[doc = " Capsule-type button (the round corner is half of the height by default)."]
pub const ArkUI_ButtonType_ARKUI_BUTTON_TYPE_CAPSULE: ArkUI_ButtonType = 1;
#[doc = " Circle button."]
pub const ArkUI_ButtonType_ARKUI_BUTTON_TYPE_CIRCLE: ArkUI_ButtonType = 2;
#[doc = " Rounded rectangle button.\n @since 19"]
#[cfg(feature = "api-19")]
pub const ArkUI_ButtonType_ARKUI_BUTTON_ROUNDED_RECTANGLE: ArkUI_ButtonType = 8;
#[doc = " @brief Enumerates the button types.\n\n @since 12"]
pub type ArkUI_ButtonType = u32;
#[doc = " Username. Password Vault, when enabled, can automatically save and fill in usernames."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_USER_NAME:
    ArkUI_TextInputContentType = 0;
#[doc = " Password. Password Vault, when enabled, can automatically save and fill in passwords."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PASSWORD:
    ArkUI_TextInputContentType = 1;
#[doc = " New password. Password Vault, when enabled, can automatically generate a new password."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_NEW_PASSWORD:
    ArkUI_TextInputContentType = 2;
#[doc = " Full street address. The scenario-based autofill feature, when enabled, can automatically save and fill in full\n  street addresses."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_FULL_STREET_ADDRESS:
    ArkUI_TextInputContentType = 3;
#[doc = " House number. The scenario-based autofill feature, when enabled, can automatically save and fill in house\n  numbers."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_HOUSE_NUMBER:
    ArkUI_TextInputContentType = 4;
#[doc = " District and county. The scenario-based autofill feature, when enabled, can automatically save and fill in\n  districts and counties."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_DISTRICT_ADDRESS:
    ArkUI_TextInputContentType = 5;
#[doc = " City. The scenario-based autofill feature, when enabled, can automatically save and fill in cities."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_CITY_ADDRESS:
    ArkUI_TextInputContentType = 6;
#[doc = " Province. The scenario-based autofill feature, when enabled, can automatically save and fill in provinces."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PROVINCE_ADDRESS:
    ArkUI_TextInputContentType = 7;
#[doc = " Country. The scenario-based autofill feature, when enabled, can automatically save and fill in countries."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_COUNTRY_ADDRESS:
    ArkUI_TextInputContentType = 8;
#[doc = " Full name. The scenario-based autofill feature, when enabled, can automatically save and fill in full names."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PERSON_FULL_NAME:
    ArkUI_TextInputContentType = 9;
#[doc = " Last name. The scenario-based autofill feature, when enabled, can automatically save and fill in last names."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PERSON_LAST_NAME:
    ArkUI_TextInputContentType = 10;
#[doc = " First name. The scenario-based autofill feature, when enabled, can automatically save and fill in first names."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PERSON_FIRST_NAME:
    ArkUI_TextInputContentType = 11;
#[doc = " Phone number. The scenario-based autofill feature, when enabled, can automatically save and fill in phone\n  numbers."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PHONE_NUMBER:
    ArkUI_TextInputContentType = 12;
#[doc = " Country code. The scenario-based autofill feature, when enabled, can automatically save and fill in country\n  codes."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PHONE_COUNTRY_CODE:
    ArkUI_TextInputContentType = 13;
#[doc = " Phone number with country code. The scenario-based autofill feature, when enabled, can automatically save and\n  fill in phone numbers with country codes."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_FULL_PHONE_NUMBER:
    ArkUI_TextInputContentType = 14;
#[doc = " Email address. The scenario-based autofill feature, when enabled, can automatically save and fill in email\n  addresses."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_EMAIL_ADDRESS:
    ArkUI_TextInputContentType = 15;
#[doc = " Bank card number. The scenario-based autofill feature, when enabled, can automatically save and fill in bank\n  card numbers."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_BANK_CARD_NUMBER:
    ArkUI_TextInputContentType = 16;
#[doc = " ID card number. The scenario-based autofill feature, when enabled, can automatically save and fill in ID card\n  numbers."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_ID_CARD_NUMBER:
    ArkUI_TextInputContentType = 17;
#[doc = " Nickname. The scenario-based autofill feature, when enabled, can automatically save and fill in nicknames."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_NICKNAME:
    ArkUI_TextInputContentType = 18;
#[doc = " Address information without street address. The scenario-based autofill feature, when enabled, can automatically\n  save and fill in address information without street addresses."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_DETAIL_INFO_WITHOUT_STREET:
    ArkUI_TextInputContentType = 19;
#[doc = " Standard address. The scenario-based autofill feature, when enabled, can automatically save and fill in standard\n  addresses."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_FORMAT_ADDRESS:
    ArkUI_TextInputContentType = 20;
#[doc = " Passport number. The scenario-based autofill feature, when enabled, can automatically save and fill in passport\n numbers.\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PASSPORT_NUMBER:
    ArkUI_TextInputContentType = 21;
#[doc = "  Passport validity. The scenario-based autofill feature, when enabled, can automatically save and fill in\n  passport validities.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_VALIDITY:
    ArkUI_TextInputContentType = 22;
#[doc = "  Place of issue. The scenario-based autofill feature, when enabled, can automatically save and fill in\n  place of issues.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_ISSUE_AT:
    ArkUI_TextInputContentType = 23;
#[doc = "  Tax organization. The scenario-based autofill feature, when enabled, can automatically save and fill in tax\n  organizations.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_ORGANIZATION:
    ArkUI_TextInputContentType = 24;
#[doc = "  Tax id. The scenario-based autofill feature, when enabled, can automatically save and fill in standard Tax ids.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_TAX_ID:
    ArkUI_TextInputContentType = 25;
#[doc = "  City name and state name or state code. The scenario-based autofill feature, when enabled, can automatically\n  save and fill in city names and state names or state codes.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_ADDRESS_CITY_AND_STATE:
    ArkUI_TextInputContentType = 26;
#[doc = "  Flight number. The scenario-based autofill feature, when enabled, can automatically save and fill in flight\n  numbers.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_FLIGHT_NUMBER:
    ArkUI_TextInputContentType = 27;
#[doc = "  License number. The scenario-based autofill feature, when enabled, can automatically save and fill in license\n  numbers.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_LICENSE_NUMBER:
    ArkUI_TextInputContentType = 28;
#[doc = "  License file number. The scenario-based autofill feature, when enabled, can automatically save and fill in\n  license file numbers.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_LICENSE_FILE_NUMBER:
    ArkUI_TextInputContentType = 29;
#[doc = "  License plate number. The scenario-based autofill feature, when enabled, can automatically save and fill in\n  license plate numbers.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_LICENSE_PLATE:
    ArkUI_TextInputContentType = 30;
#[doc = "  Engine number. The scenario-based autofill feature, when enabled, can automatically save and fill in engine\n  numbers.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_ENGINE_NUMBER:
    ArkUI_TextInputContentType = 31;
#[doc = "  License chassis number. The scenario-based autofill feature, when enabled, can automatically save and fill in\n  license chassis numbers.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_LICENSE_CHASSIS_NUMBER:
    ArkUI_TextInputContentType = 32;
#[doc = " @brief Enumerates the autofill types.\n\n @since 12"]
pub type ArkUI_TextInputContentType = u32;
#[doc = " Default style. The caret width is fixed at 1.5 vp, and the caret height is subject to the background height and\n  font size of the selected text."]
pub const ArkUI_TextInputStyle_ARKUI_TEXTINPUT_STYLE_DEFAULT: ArkUI_TextInputStyle = 0;
#[doc = " Inline input style. The background height of the selected text is the same as the height of the text box."]
pub const ArkUI_TextInputStyle_ARKUI_TEXTINPUT_STYLE_INLINE: ArkUI_TextInputStyle = 1;
#[doc = " @brief Defines the text input style.\n\n @since 12"]
pub type ArkUI_TextInputStyle = u32;
#[doc = " Default appearance mode, won't adopt immersive styles.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyboardAppearance_ARKUI_KEYBOARD_APPEARANCE_NONE_IMMERSIVE:
    ArkUI_KeyboardAppearance = 0;
#[doc = " Immersive mode.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyboardAppearance_ARKUI_KEYBOARD_APPEARANCE_IMMERSIVE: ArkUI_KeyboardAppearance =
    1;
#[doc = " Light immersive style.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyboardAppearance_ARKUI_KEYBOARD_APPEARANCE_LIGHT_IMMERSIVE:
    ArkUI_KeyboardAppearance = 2;
#[doc = " Dark immersive style.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyboardAppearance_ARKUI_KEYBOARD_APPEARANCE_DARK_IMMERSIVE:
    ArkUI_KeyboardAppearance = 3;
#[doc = " @brief Defines the keyboard style of input box\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_KeyboardAppearance = u32;
#[doc = " Phone Number."]
pub const ArkUI_TextDataDetectorType_ARKUI_TEXT_DATA_DETECTOR_TYPE_PHONE_NUMBER:
    ArkUI_TextDataDetectorType = 0;
#[doc = " Link."]
pub const ArkUI_TextDataDetectorType_ARKUI_TEXT_DATA_DETECTOR_TYPE_URL: ArkUI_TextDataDetectorType =
    1;
#[doc = " Mailbox."]
pub const ArkUI_TextDataDetectorType_ARKUI_TEXT_DATA_DETECTOR_TYPE_EMAIL:
    ArkUI_TextDataDetectorType = 2;
#[doc = " Address."]
pub const ArkUI_TextDataDetectorType_ARKUI_TEXT_DATA_DETECTOR_TYPE_ADDRESS:
    ArkUI_TextDataDetectorType = 3;
#[doc = " @brief Defines the entity type for text recognition.\n\n @since 12"]
pub type ArkUI_TextDataDetectorType = u32;
#[doc = " dot type."]
pub const ArkUI_SwiperIndicatorType_ARKUI_SWIPER_INDICATOR_TYPE_DOT: ArkUI_SwiperIndicatorType = 0;
#[doc = " digit type."]
pub const ArkUI_SwiperIndicatorType_ARKUI_SWIPER_INDICATOR_TYPE_DIGIT: ArkUI_SwiperIndicatorType =
    1;
#[doc = " @brief Define the navigation indicator type of the swiper.\n\n @since 12"]
pub type ArkUI_SwiperIndicatorType = u32;
#[doc = " In the folded state, when the ListItem slides in the opposite direction to the main axis,\n the operation item is hidden."]
pub const ArkUI_ListItemSwipeActionState_ARKUI_LIST_ITEM_SWIPE_ACTION_STATE_COLLAPSED:
    ArkUI_ListItemSwipeActionState = 0;
#[doc = " In the folded state, when the ListItem slides in the opposite direction to the spindle,\n the operation item is displayed."]
pub const ArkUI_ListItemSwipeActionState_ARKUI_LIST_ITEM_SWIPE_ACTION_STATE_EXPANDED:
    ArkUI_ListItemSwipeActionState = 1;
#[doc = " Long distance state, the state of deleting a ListItem after it enters the long distance deletion area."]
pub const ArkUI_ListItemSwipeActionState_ARKUI_LIST_ITEM_SWIPE_ACTION_STATE_ACTIONING:
    ArkUI_ListItemSwipeActionState = 2;
#[doc = " @brief Define the pattern of element arrangement in the main axis direction of the Swiper component.\n\n @since 12"]
pub type ArkUI_ListItemSwipeActionState = u32;
#[doc = " The ListItem can continue to be scratched after the distance exceeds the size of the scratched component."]
pub const ArkUI_ListItemSwipeEdgeEffect_ARKUI_LIST_ITEM_SWIPE_EDGE_EFFECT_SPRING:
    ArkUI_ListItemSwipeEdgeEffect = 0;
#[doc = " The sliding distance of the ListItem cannot exceed the size of the scratched component."]
pub const ArkUI_ListItemSwipeEdgeEffect_ARKUI_LIST_ITEM_SWIPE_EDGE_EFFECT_NONE:
    ArkUI_ListItemSwipeEdgeEffect = 1;
#[doc = " @brief Define the explicit and implicit mode of the SwipeAction method for the Listitem component.\n\n @since 12"]
pub type ArkUI_ListItemSwipeEdgeEffect = u32;
#[doc = " @error No errors."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NO_ERROR: ArkUI_ErrorCode = 0;
#[doc = " @error Parameter error."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_PARAM_INVALID: ArkUI_ErrorCode = 401;
#[doc = " @error CAPI init error.\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_CAPI_INIT_ERROR: ArkUI_ErrorCode = 500;
#[doc = " @error Internal error occurs, such as failure occurs because of the internal environment error,\n or operation failed because of the internal execution failed.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_INTERNAL_ERROR: ArkUI_ErrorCode = 100001;
#[doc = " @error The XComponent is in invalid state.\n @since 19"]
#[cfg(feature = "api-19")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_XCOMPONENT_STATE_INVALID: ArkUI_ErrorCode = 103501;
#[doc = " @error The component does not support specific properties or events."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED: ArkUI_ErrorCode =
    106102;
#[doc = " @error The corresponding operation does not support nodes created by ArkTS."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_ARKTS_NODE_NOT_SUPPORTED: ArkUI_ErrorCode = 106103;
#[doc = " @error The lazy loading adapter is not bound to the component."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_ADAPTER_NOT_BOUND: ArkUI_ErrorCode = 106104;
#[doc = " @error The adapter already exists."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_ADAPTER_EXIST: ArkUI_ErrorCode = 106105;
#[doc = " @error The corresponding node already has a child node and cannot add an adapter."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_CHILD_NODE_EXIST: ArkUI_ErrorCode = 106106;
#[doc = " The parameter length in the parameter event exceeds the limit."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INDEX_OUT_OF_RANGE: ArkUI_ErrorCode =
    106107;
#[doc = " The data does not exist in the component event."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INVALID: ArkUI_ErrorCode = 106108;
#[doc = " The component event does not support return values."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_EVENT_NO_RETURN: ArkUI_ErrorCode = 106109;
#[doc = " @error The event type is not supported by the node.\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_UNSUPPORTED_EVENT_TYPE: ArkUI_ErrorCode = 106110;
#[doc = " The index value is invalid."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_INDEX_INVALID: ArkUI_ErrorCode = 106200;
#[doc = "  Failed to query route navigation information."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_GET_INFO_FAILED: ArkUI_ErrorCode = 106201;
#[doc = " The buffer size is not large enough."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR: ArkUI_ErrorCode = 106202;
#[doc = " @error The node is not on main tree.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_NOT_ON_MAIN_TREE: ArkUI_ErrorCode = 106203;
#[doc = " @error The node is running on invalid thread.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_ON_INVALID_THREAD: ArkUI_ErrorCode = 106204;
#[doc = " @error Force dark config is invalid.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_FORCE_DARK_CONFIG_INVALID: ArkUI_ErrorCode = 106205;
#[doc = " @error The node has already been adopted.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_IS_ADOPTED: ArkUI_ErrorCode = 106206;
#[doc = " @error This node already has a parent node.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_HAS_PARENT: ArkUI_ErrorCode = 106207;
#[doc = " @error The node cannot be adopted.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_CAN_NOT_BE_ADOPTED: ArkUI_ErrorCode = 106208;
#[doc = " @error The node cannot adopt children.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_CAN_NOT_ADOPT_TO: ArkUI_ErrorCode = 106209;
#[doc = " @error This child node is not adopted by the parent node.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_IS_NOT_IN_ADOPTED_CHILDREN: ArkUI_ErrorCode =
    106210;
#[doc = " @error The node type is not custom node.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NOT_CUSTOM_NODE: ArkUI_ErrorCode = 106401;
#[doc = " @error Node already has children.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_CHILD_EXISTED: ArkUI_ErrorCode = 106402;
#[doc = " @error RenderNode parent is existed.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_RENDER_PARENT_EXISTED: ArkUI_ErrorCode = 106403;
#[doc = " @error RenderNode child is not exist.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_RENDER_CHILD_NOT_EXIST: ArkUI_ErrorCode = 106404;
#[doc = " @error Param is out of range.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_PARAM_OUT_OF_RANGE: ArkUI_ErrorCode = 106405;
#[doc = " @error The RenderNode is obtained from a FrameNode.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_RENDER_IS_FROM_FRAME_NODE: ArkUI_ErrorCode = 106406;
#[doc = " @error The RenderNode is obtained from a FrameNode,\n and its corresponding FrameNode is no longer in the adopted state.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_RENDER_HAS_INVALID_FRAME_NODE: ArkUI_ErrorCode = 106407;
#[doc = " @error The node is not adopted.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_RENDER_NOT_ADOPTED_NODE: ArkUI_ErrorCode = 106408;
#[doc = " @error The node requesting focus is not focusable.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_FOCUS_NON_FOCUSABLE: ArkUI_ErrorCode = 150001;
#[doc = " @error The node requesting focus has unfocusable ancestor.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_FOCUS_NON_FOCUSABLE_ANCESTOR: ArkUI_ErrorCode = 150002;
#[doc = " @error The node requesting focus does not exists.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_FOCUS_NON_EXISTENT: ArkUI_ErrorCode = 150003;
#[doc = " @error The snapshot taking is timeout.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_COMPONENT_SNAPSHOT_TIMEOUT: ArkUI_ErrorCode = 160002;
#[doc = " The component is not a scroll container."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NON_SCROLLABLE_CONTAINER: ArkUI_ErrorCode = 180001;
#[doc = " The buffer is not large enough."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_BUFFER_SIZE_NOT_ENOUGH: ArkUI_ErrorCode = 180002;
#[doc = " @error The event is not a clone event.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NOT_CLONED_POINTER_EVENT: ArkUI_ErrorCode = 180003;
#[doc = " @error The component status is abnormal.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_POST_CLONED_COMPONENT_STATUS_ABNORMAL: ArkUI_ErrorCode =
    180004;
#[doc = " @error No component hit to respond to the event.\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_POST_CLONED_NO_COMPONENT_HIT_TO_RESPOND_TO_THE_EVENT:
    ArkUI_ErrorCode = 180005;
#[doc = " @error Input event type not supported.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_INPUT_EVENT_TYPE_NOT_SUPPORTED: ArkUI_ErrorCode = 180006;
#[doc = " @error invalid styled string.\n @since 14"]
#[cfg(feature = "api-14")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_INVALID_STYLED_STRING: ArkUI_ErrorCode = 180101;
#[doc = " @error The gesture recognizer type is not supported.\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED: ArkUI_ErrorCode = 180102;
#[doc = " @error The uiContext is invalid.\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_UI_CONTEXT_INVALID: ArkUI_ErrorCode = 190001;
#[doc = " @error The callback function is invalid.\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_CALLBACK_INVALID: ArkUI_ErrorCode = 190002;
#[doc = " @error operation is not allowed for current drag drop pharse.\n @since 19"]
#[cfg(feature = "api-19")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_DRAG_DROP_OPERATION_NOT_ALLOWED: ArkUI_ErrorCode =
    190004;
#[doc = " @error Parameter error.\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_PARAM_ERROR: ArkUI_ErrorCode = 100023;
#[doc = " @brief Define error code enumeration values.\n\n @since 12"]
pub type ArkUI_ErrorCode = u32;
#[doc = " The animation is in the initial state."]
pub const ArkUI_AnimationStatus_ARKUI_ANIMATION_STATUS_INITIAL: ArkUI_AnimationStatus = 0;
#[doc = " The animation is being played."]
pub const ArkUI_AnimationStatus_ARKUI_ANIMATION_STATUS_RUNNING: ArkUI_AnimationStatus = 1;
#[doc = " The animation is paused."]
pub const ArkUI_AnimationStatus_ARKUI_ANIMATION_STATUS_PAUSED: ArkUI_AnimationStatus = 2;
#[doc = " The animation is stopped."]
pub const ArkUI_AnimationStatus_ARKUI_ANIMATION_STATUS_STOPPED: ArkUI_AnimationStatus = 3;
#[doc = " @brief Defines the playback status for the image animator.\n\n @since 12"]
pub type ArkUI_AnimationStatus = u32;
#[doc = " Before execution, the animation does not apply any styles to the target component.\n After execution, the animation restores the target component to its default state."]
pub const ArkUI_AnimationFillMode_ARKUI_ANIMATION_FILL_MODE_NONE: ArkUI_AnimationFillMode = 0;
#[doc = " The target component retains the state set by the last keyframe encountered\n during execution of the animation."]
pub const ArkUI_AnimationFillMode_ARKUI_ANIMATION_FILL_MODE_FORWARDS: ArkUI_AnimationFillMode = 1;
#[doc = " The animation applies the values defined in the first relevant keyframe once it is applied to\n the target component, and retains the values during the period set by delay."]
pub const ArkUI_AnimationFillMode_ARKUI_ANIMATION_FILL_MODE_BACKWARDS: ArkUI_AnimationFillMode = 2;
#[doc = " The animation follows the rules for both Forwards and Backwards,\n extending the animation attributes in both directions."]
pub const ArkUI_AnimationFillMode_ARKUI_ANIMATION_FILL_MODE_BOTH: ArkUI_AnimationFillMode = 3;
#[doc = " @brief Defines the status before and after execution of the animation in the current playback direction.\n\n @since 12"]
pub type ArkUI_AnimationFillMode = u32;
#[doc = " The Checkbox unchecked."]
pub const ArkUI_AccessibilityCheckedState_ARKUI_ACCESSIBILITY_UNCHECKED:
    ArkUI_AccessibilityCheckedState = 0;
#[doc = " The Checkbox checked."]
pub const ArkUI_AccessibilityCheckedState_ARKUI_ACCESSIBILITY_CHECKED:
    ArkUI_AccessibilityCheckedState = 1;
#[doc = " @brief Defines the state type for the accessibility checkbox.\n\n @since 12"]
pub type ArkUI_AccessibilityCheckedState = u32;
#[doc = " The animation plays in forward loop mode."]
pub const ArkUI_AnimationDirection_ARKUI_ANIMATION_DIRECTION_NORMAL: ArkUI_AnimationDirection = 0;
#[doc = " The animation plays in reverse loop mode."]
pub const ArkUI_AnimationDirection_ARKUI_ANIMATION_DIRECTION_REVERSE: ArkUI_AnimationDirection = 1;
#[doc = " The animation plays in alternating loop mode. When the animation is played for an odd number of times, the\n  playback is in forward direction. When the animation is played for an even number of times, the playback is in\n  reverse direction."]
pub const ArkUI_AnimationDirection_ARKUI_ANIMATION_DIRECTION_ALTERNATE: ArkUI_AnimationDirection =
    2;
#[doc = " The animation plays in reverse alternating loop mode. When the animation is played for an odd number of times,\n  the playback is in reverse direction. When the animation is played for an even number of times, the playback is\n  in forward direction."]
pub const ArkUI_AnimationDirection_ARKUI_ANIMATION_DIRECTION_ALTERNATE_REVERSE:
    ArkUI_AnimationDirection = 3;
#[doc = "/**\n @brief Enumerates the animation playback modes.\n\n @since 12"]
pub type ArkUI_AnimationDirection = u32;
#[doc = " Finger drag."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_DRAG: ArkUI_ScrollSource = 0;
#[doc = " Inertial roll after finger drag."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_FLING: ArkUI_ScrollSource = 1;
#[doc = " Execute the EdgeEffect.Spring edge effect when crossing the boundary."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_EDGE_EFFECT: ArkUI_ScrollSource = 2;
#[doc = " Other user input other than dragging, such as mouse wheel, keyboard events, etc."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_OTHER_USER_INPUT: ArkUI_ScrollSource = 3;
#[doc = " Drag the scroll bar."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_SCROLL_BAR: ArkUI_ScrollSource = 4;
#[doc = " Inertia scrolling after dragging the scroll bar."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_SCROLL_BAR_FLING: ArkUI_ScrollSource = 5;
#[doc = " The scroll controller causes unanimated scrolling."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_SCROLLER: ArkUI_ScrollSource = 6;
#[doc = " The scroll controller causes the scroll to drive the painting."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_ANIMATION: ArkUI_ScrollSource = 7;
#[doc = " @brief Define the rolling source enumeration value.\n\n @since 12"]
pub type ArkUI_ScrollSource = u32;
#[doc = " click action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_CLICK:
    ArkUI_AccessibilityActionType = 1;
#[doc = " long click action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_LONG_CLICK:
    ArkUI_AccessibilityActionType = 2;
#[doc = " cut action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_CUT:
    ArkUI_AccessibilityActionType = 4;
#[doc = " copy action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_COPY:
    ArkUI_AccessibilityActionType = 8;
#[doc = " paste action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_PASTE:
    ArkUI_AccessibilityActionType = 16;
#[doc = " @brief Define accessible action types.\n\n @since 12"]
pub type ArkUI_AccessibilityActionType = u32;
#[doc = " @brief Defines the translation options for component transition.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TranslationOptions {
    #[doc = " Translation distance along the x-axis."]
    pub x: f32,
    #[doc = " Translation distance along the y-axis."]
    pub y: f32,
    #[doc = " Translation distance along the z-axis."]
    pub z: f32,
}
#[doc = " @brief Defines the scaling options for component transition.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ScaleOptions {
    #[doc = " Scale ratio along the x-axis."]
    pub x: f32,
    #[doc = " Scale ratio along the y-axis."]
    pub y: f32,
    #[doc = " Scale factor along the z-axis (not effective for the current 2D graphics)."]
    pub z: f32,
    #[doc = " X coordinate of the center point."]
    pub centerX: f32,
    #[doc = " Y coordinate of the center point."]
    pub centerY: f32,
}
#[doc = " @brief Defines the rotation options for component transition.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_RotationOptions {
    #[doc = " X-component of the rotation vector."]
    pub x: f32,
    #[doc = " Y-component of the rotation vector."]
    pub y: f32,
    #[doc = " Z-component of the rotation vector."]
    pub z: f32,
    #[doc = " Rotation angle."]
    pub angle: f32,
    #[doc = " X coordinate of the center point."]
    pub centerX: f32,
    #[doc = " Y coordinate of the center point."]
    pub centerY: f32,
    #[doc = " Z-axis anchor, that is, the z-component of the 3D rotation center point."]
    pub centerZ: f32,
    #[doc = " Distance from the user to the z=0 plane."]
    pub perspective: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CustomSpanMeasureInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CustomSpanMetrics {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CustomSpanDrawInfo {
    _unused: [u8; 0],
}
#[doc = " The NavDestination show."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_SHOW: ArkUI_NavDestinationState =
    0;
#[doc = " The NavDestination hide."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_HIDE: ArkUI_NavDestinationState =
    1;
#[doc = " The NavDestination is mounted to the component tree."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_APPEAR:
    ArkUI_NavDestinationState = 2;
#[doc = " The NavDestination removed from the component tree."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_DISAPPEAR:
    ArkUI_NavDestinationState = 3;
#[doc = " Before the NavDestination show."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_WILL_SHOW:
    ArkUI_NavDestinationState = 4;
#[doc = " Before the NavDestination hide."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_WILL_HIDE:
    ArkUI_NavDestinationState = 5;
#[doc = " Before the NavDestination mount to the component tree."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_WILL_APPEAR:
    ArkUI_NavDestinationState = 6;
#[doc = " Before the NavDestination removed from the component tree."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_WILL_DISAPPEAR:
    ArkUI_NavDestinationState = 7;
#[doc = " The NavDestination returns from the component."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_BACK_PRESS:
    ArkUI_NavDestinationState = 100;
#[doc = " @brief Defines the state of the NavDestination component.\n\n @since 12"]
pub type ArkUI_NavDestinationState = u32;
#[doc = " The Router Page is about to be created."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ABOUT_TO_APPEAR: ArkUI_RouterPageState = 0;
#[doc = " The Router Page is about to be destroyed."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ABOUT_TO_DISAPPEAR: ArkUI_RouterPageState =
    1;
#[doc = " The Router Page show."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ON_SHOW: ArkUI_RouterPageState = 2;
#[doc = " The Router Page hide."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ON_HIDE: ArkUI_RouterPageState = 3;
#[doc = " The Router Page returns."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ON_BACK_PRESS: ArkUI_RouterPageState = 4;
#[doc = " @brief Define the state of Router Page.\n\n @since 12"]
pub type ArkUI_RouterPageState = u32;
#[doc = " The default security zone includes the status bar and navigation bar."]
pub const ArkUI_SafeAreaType_ARKUI_SAFE_AREA_TYPE_SYSTEM: ArkUI_SafeAreaType = 1;
#[doc = " Non-secure areas of the device, such as bangs or hole holes."]
pub const ArkUI_SafeAreaType_ARKUI_SAFE_AREA_TYPE_CUTOUT: ArkUI_SafeAreaType = 2;
#[doc = " Soft keyboard area."]
pub const ArkUI_SafeAreaType_ARKUI_SAFE_AREA_TYPE_KEYBOARD: ArkUI_SafeAreaType = 4;
#[doc = " @brief defines the enumerated value of the extended security zone.\n\n @since 12"]
pub type ArkUI_SafeAreaType = u32;
#[doc = " Outside the area of the <b>ListItemGroup</b> component."]
#[cfg(feature = "api-15")]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_GROUP_AREA_OUTSIDE: ArkUI_ListItemGroupArea = 0;
#[doc = " Area when the <b>ListItemGroup</b> component does not have the header, footer, or list item."]
#[cfg(feature = "api-15")]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_SWIPE_AREA_NONE: ArkUI_ListItemGroupArea = 1;
#[doc = " List item area of the <b>ListItemGroup</b> component."]
#[cfg(feature = "api-15")]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_SWIPE_AREA_ITEM: ArkUI_ListItemGroupArea = 2;
#[doc = " Header area of the <b>ListItemGroup</b> component."]
#[cfg(feature = "api-15")]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_SWIPE_AREA_HEADER: ArkUI_ListItemGroupArea = 3;
#[doc = " Footer area of the <b>ListItemGroup</b> component."]
#[cfg(feature = "api-15")]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_SWIPE_AREA_FOOTER: ArkUI_ListItemGroupArea = 4;
#[doc = " @brief Define an enum for the areas of the <b>ListItemGroup</b> component.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_ListItemGroupArea = u32;
#[doc = " Upper area."]
pub const ArkUI_SafeAreaEdge_ARKUI_SAFE_AREA_EDGE_TOP: ArkUI_SafeAreaEdge = 1;
#[doc = " Lower area."]
pub const ArkUI_SafeAreaEdge_ARKUI_SAFE_AREA_EDGE_BOTTOM: ArkUI_SafeAreaEdge = 2;
#[doc = " Front area."]
pub const ArkUI_SafeAreaEdge_ARKUI_SAFE_AREA_EDGE_START: ArkUI_SafeAreaEdge = 4;
#[doc = " Tail area."]
pub const ArkUI_SafeAreaEdge_ARKUI_SAFE_AREA_EDGE_END: ArkUI_SafeAreaEdge = 8;
#[doc = " @brief defines the enumerated value of the direction of the extended security zone.\n\n @since 12"]
pub type ArkUI_SafeAreaEdge = u32;
#[doc = " Move focus forward."]
#[cfg(feature = "api-18")]
pub const ArkUI_FocusMove_ARKUI_FOCUS_MOVE_FORWARD: ArkUI_FocusMove = 0;
#[doc = " Move focus backward."]
#[cfg(feature = "api-18")]
pub const ArkUI_FocusMove_ARKUI_FOCUS_MOVE_BACKWARD: ArkUI_FocusMove = 1;
#[doc = " Move focus up."]
#[cfg(feature = "api-18")]
pub const ArkUI_FocusMove_ARKUI_FOCUS_MOVE_UP: ArkUI_FocusMove = 2;
#[doc = " Move focus down."]
#[cfg(feature = "api-18")]
pub const ArkUI_FocusMove_ARKUI_FOCUS_MOVE_DOWN: ArkUI_FocusMove = 3;
#[doc = " Move focus left."]
#[cfg(feature = "api-18")]
pub const ArkUI_FocusMove_ARKUI_FOCUS_MOVE_LEFT: ArkUI_FocusMove = 4;
#[doc = " Move focus right."]
#[cfg(feature = "api-18")]
pub const ArkUI_FocusMove_ARKUI_FOCUS_MOVE_RIGHT: ArkUI_FocusMove = 5;
#[doc = " @brief Define an enum for the focus movement directions.\n\n @since 18"]
#[cfg(feature = "api-18")]
pub type ArkUI_FocusMove = u32;
#[doc = " Defines avoid keyboard when keyboard shows."]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyboardAvoidMode_ARKUI_KEYBOARD_AVOID_MODE_DEFAULT: ArkUI_KeyboardAvoidMode = 0;
#[doc = " Defines not avoid keyboard when keyboard shows."]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyboardAvoidMode_ARKUI_KEYBOARD_AVOID_MODE_NONE: ArkUI_KeyboardAvoidMode = 1;
#[doc = " @brief defines the enumerated value of the customDialog's keyboard avoid mode.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_KeyboardAvoidMode = u32;
#[doc = " Layout top half screen when the phone in hover mode."]
#[cfg(feature = "api-15")]
pub const ArkUI_HoverModeAreaType_ARKUI_HOVER_MODE_AREA_TYPE_TOP: ArkUI_HoverModeAreaType = 0;
#[doc = " Layout bottom half screen when the phone in hover mode."]
#[cfg(feature = "api-15")]
pub const ArkUI_HoverModeAreaType_ARKUI_HOVER_MODE_AREA_TYPE_BOTTOM: ArkUI_HoverModeAreaType = 1;
#[doc = " @brief defines the enumerated value of area in hover mode.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_HoverModeAreaType = u32;
#[doc = " Not expand."]
#[cfg(feature = "api-15")]
pub const ArkUI_ExpandMode_ARKUI_NOT_EXPAND: ArkUI_ExpandMode = 0;
#[doc = " Expand."]
#[cfg(feature = "api-15")]
pub const ArkUI_ExpandMode_ARKUI_EXPAND: ArkUI_ExpandMode = 1;
#[doc = " Lazy expand. Expand the children of node if needed."]
#[cfg(feature = "api-15")]
pub const ArkUI_ExpandMode_ARKUI_LAZY_EXPAND: ArkUI_ExpandMode = 2;
#[doc = " @brief Enumerates the expand modes.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_ExpandMode = u32;
#[doc = " Normal state."]
#[cfg(feature = "api-20")]
pub const ArkUI_UIState_UI_STATE_NORMAL: ArkUI_UIState = 0;
#[doc = " Pressed state."]
#[cfg(feature = "api-20")]
pub const ArkUI_UIState_UI_STATE_PRESSED: ArkUI_UIState = 1;
#[doc = " Focused state."]
#[cfg(feature = "api-20")]
pub const ArkUI_UIState_UI_STATE_FOCUSED: ArkUI_UIState = 2;
#[doc = " Disabled state."]
#[cfg(feature = "api-20")]
pub const ArkUI_UIState_UI_STATE_DISABLED: ArkUI_UIState = 4;
#[doc = " Selected state. This state is supported only by specific component types:\n <b>Checkbox</b>, <b>Radio</b>, <b>Toggle</b>, <b>List</b>, <b>Grid</b>, and <b>MenuItem</b>."]
#[cfg(feature = "api-20")]
pub const ArkUI_UIState_UI_STATE_SELECTED: ArkUI_UIState = 8;
#[doc = " @brief Defines the navigation point indicator style of the <b><Swiper></b> component.\n @brief Enumerates the UI states of a component, used for handling state-specific styles.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type ArkUI_UIState = u32;
#[doc = " Set all edge derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_EdgeDirection_ARKUI_EDGE_DIRECTION_ALL: ArkUI_EdgeDirection = 0;
#[doc = " Set left edge derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_EdgeDirection_ARKUI_EDGE_DIRECTION_LEFT: ArkUI_EdgeDirection = 1;
#[doc = " Set right edge derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_EdgeDirection_ARKUI_EDGE_DIRECTION_RIGHT: ArkUI_EdgeDirection = 2;
#[doc = " Set top edge derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_EdgeDirection_ARKUI_EDGE_DIRECTION_TOP: ArkUI_EdgeDirection = 3;
#[doc = " Set bottom edge derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_EdgeDirection_ARKUI_EDGE_DIRECTION_BOTTOM: ArkUI_EdgeDirection = 4;
#[doc = " @brief Enumerates the edge derection.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type ArkUI_EdgeDirection = u32;
#[doc = " Set all corner derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_CornerDirection_ARKUI_CORNER_DIRECTION_ALL: ArkUI_CornerDirection = 0;
#[doc = " Set top left corner derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_CornerDirection_ARKUI_CORNER_DIRECTION_TOP_LEFT: ArkUI_CornerDirection = 1;
#[doc = " Set top right corner derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_CornerDirection_ARKUI_CORNER_DIRECTION_TOP_RIGHT: ArkUI_CornerDirection = 2;
#[doc = " Set bottom left corner derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_CornerDirection_ARKUI_CORNER_DIRECTION_BOTTOM_LEFT: ArkUI_CornerDirection = 3;
#[doc = " Set bottom right corner derection."]
#[cfg(feature = "api-20")]
pub const ArkUI_CornerDirection_ARKUI_CORNER_DIRECTION_BOTTOM_RIGHT: ArkUI_CornerDirection = 4;
#[doc = " @brief Enumerates the corner derection.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type ArkUI_CornerDirection = u32;
#[doc = " When the List direction is vertical, it indicates the left in LTR mode and right in RTL mode.\n When the List direction is horizontal, it indicates the top."]
#[cfg(feature = "api-21")]
pub const ArkUI_ListItemSwipeActionDirection_ARKUI_LIST_ITEM_SWIPE_ACTION_DIRECTION_START:
    ArkUI_ListItemSwipeActionDirection = 0;
#[doc = " When the List direction is vertical, it indicates the right in LTR mode and left in RTL mode.\n When the List direction is horizontal, it indicates the bottom."]
#[cfg(feature = "api-21")]
pub const ArkUI_ListItemSwipeActionDirection_ARKUI_LIST_ITEM_SWIPE_ACTION_DIRECTION_END:
    ArkUI_ListItemSwipeActionDirection = 1;
#[doc = " @brief Define the direction to expand the swipe action.\n\n @since 21"]
#[cfg(feature = "api-21")]
pub type ArkUI_ListItemSwipeActionDirection = u32;
#[doc = " The component fills its parent, which means its size is as large as its parent"]
#[cfg(feature = "api-21")]
pub const ArkUI_LayoutPolicy_ARKUI_LAYOUTPOLICY_MATCHPARENT: ArkUI_LayoutPolicy = 0;
#[doc = " The component fills its content, which means its size is as large as its children but it is constrained\n by its parent."]
#[cfg(feature = "api-21")]
pub const ArkUI_LayoutPolicy_ARKUI_LAYOUTPOLICY_WRAPCONTENT: ArkUI_LayoutPolicy = 1;
#[doc = " The component fills its content which means its size is as large as its children."]
#[cfg(feature = "api-21")]
pub const ArkUI_LayoutPolicy_ARKUI_LAYOUTPOLICY_FIXATIDEALSIZE: ArkUI_LayoutPolicy = 2;
#[doc = " @brief Enumerates the LayoutPolicy.\n\n @since 21"]
#[cfg(feature = "api-21")]
pub type ArkUI_LayoutPolicy = u32;
#[doc = " No Force round the component boundary coordinates to integer pixel."]
#[cfg(feature = "api-21")]
pub const ArkUI_PixelRoundCalcPolicy_ARKUI_PIXELROUNDCALCPOLICY_NOFORCEROUND:
    ArkUI_PixelRoundCalcPolicy = 0;
#[doc = " Force ceil the component boundary coordinates to integer pixel."]
#[cfg(feature = "api-21")]
pub const ArkUI_PixelRoundCalcPolicy_ARKUI_PIXELROUNDCALCPOLICY_FORCECEIL:
    ArkUI_PixelRoundCalcPolicy = 1;
#[doc = " Force floor the component boundary coordinates to integer pixel."]
#[cfg(feature = "api-21")]
pub const ArkUI_PixelRoundCalcPolicy_ARKUI_PIXELROUNDCALCPOLICY_FORCEFLOOR:
    ArkUI_PixelRoundCalcPolicy = 2;
#[doc = " @brief Enumerates the PixelRoundPolicy.\n\n @since 21"]
#[cfg(feature = "api-21")]
pub type ArkUI_PixelRoundCalcPolicy = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_SystemFontStyleEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_SnapshotOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TextPickerRangeContentArray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TextCascadePickerRangeContentArray {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates a size constraint.\n\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_Create() -> *mut ArkUI_LayoutConstraint;
}
extern "C" {
    #[doc = " @brief Creates a deep copy of a size constraint.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the pointer to the new size constraint.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_Copy(
        Constraint: *const ArkUI_LayoutConstraint,
    ) -> *mut ArkUI_LayoutConstraint;
}
extern "C" {
    #[doc = " @brief Destroys the pointer to a size constraint.\n\n @param Constraint Indicates the pointer to the size constraint.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_Dispose(
        Constraint: *mut ArkUI_LayoutConstraint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the maximum width for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the maximum width.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetMaxWidth(Constraint: *const ArkUI_LayoutConstraint) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the minimum width for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the minimum width.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetMinWidth(Constraint: *const ArkUI_LayoutConstraint) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the maximum height for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the maximum height.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetMaxHeight(Constraint: *const ArkUI_LayoutConstraint)
        -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the minimum height for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the minimum height.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetMinHeight(Constraint: *const ArkUI_LayoutConstraint)
        -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the width percentage reference for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the width percentage reference.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetPercentReferenceWidth(
        Constraint: *const ArkUI_LayoutConstraint,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the height percentage reference for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the height percentage reference.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetPercentReferenceHeight(
        Constraint: *const ArkUI_LayoutConstraint,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the maximum width.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the maximum width, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetMaxWidth(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the minimum width.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the minimum width, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetMinWidth(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the maximum height.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the maximum height, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetMaxHeight(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the minimum height.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the minimum height, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetMinHeight(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the width percentage reference.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the width percentage reference, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetPercentReferenceWidth(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the height percentage reference.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the height percentage reference, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetPercentReferenceHeight(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the pointer to a canvas for drawing, which can be converted into the <b>OH_Drawing_Canvas</b> pointer\n in the <b>Drawing</b> module.\n\n @param context Indicates the pointer to the drawing context.\n @return Returns the pointer to the canvas for drawing.\n @since 12"]
    pub fn OH_ArkUI_DrawContext_GetCanvas(
        context: *mut ArkUI_DrawContext,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the size of a drawing area.\n\n @param context Indicates the pointer to the drawing context.\n @return Returns the size of the drawing area.\n @since 12"]
    pub fn OH_ArkUI_DrawContext_GetSize(context: *mut ArkUI_DrawContext) -> ArkUI_IntSize;
}
extern "C" {
    #[doc = " @brief Creates <b>Grid</b> layout options.\n\n @return <b>Grid</b> layout options created.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_GridLayoutOptions_Create() -> *mut ArkUI_GridLayoutOptions;
}
extern "C" {
    #[doc = " @brief Disposes of <b>Grid</b> layout options.\n\n @param option <b>Grid</b> layout options.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_GridLayoutOptions_Dispose(option: *mut ArkUI_GridLayoutOptions);
}
extern "C" {
    #[doc = " @brief Sets the irregular grid item index array for the grid layout.\n\n @param option <b>Grid</b> layout options.\n @param irregularIndexes Array of irregular grid item indexes.\n @param size Size of the index array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         If an error code is returned, it may be due to a failure in parameter validation;\n         the parameter must not be null.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_GridLayoutOptions_SetIrregularIndexes(
        option: *mut ArkUI_GridLayoutOptions,
        irregularIndexes: *mut u32,
        size: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the irregular grid item index array for the grid layout.\n When <b>OH_ArkUI_GridLayoutOptions_RegisterGetIrregularSizeByIndexCallback</b> is not set,\n the grid item specified in <b>irregularIndexes</b> occupies an entire row of the grid that scrolls vertically or\n an entire column of the grid that scrolls horizontally.\n\n @param option <b>Grid</b> layout options.\n @param irregularIndexes Array of irregular grid item indexes.\n @param size Size of the index array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} if the provided buffer size is insufficient.\n         If an error code is returned, it may be due to a failure in parameter validation;\n         the parameter must not be null.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_GridLayoutOptions_GetIrregularIndexes(
        option: *mut ArkUI_GridLayoutOptions,
        irregularIndexes: *mut u32,
        size: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a callback to obtain the row and column span for the grid item at the specified index.\n\n @param option <b>Grid</b> layout options.\n @param userData Indicates the custom data.\n @param callback Callback that returns the row and column span for the grid item at the specified index.\n        itemIndex: grid item index, which must be within the range set by\n        {@link OH_ArkUI_GridLayoutOptions_SetIrregularIndexes}.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_GridLayoutOptions_RegisterGetIrregularSizeByIndexCallback(
        option: *mut ArkUI_GridLayoutOptions,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                itemIndex: i32,
                userData: *mut ::std::os::raw::c_void,
            ) -> ArkUI_GridItemSize,
        >,
    );
}
extern "C" {
    #[doc = " @brief Registers a callback to obtain the starting row, starting column, row span,\n and column span for the grid item at the specified index.\n\n @param option <b>Grid</b> layout options.\n @param userData Indicates the custom data.\n @param callback Callback that returns the starting row, starting column, row span,\n        and column span for the grid item at the specified index.\n        itemIndex: grid item index.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_GridLayoutOptions_RegisterGetRectByIndexCallback(
        option: *mut ArkUI_GridLayoutOptions,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                itemIndex: i32,
                userData: *mut ::std::os::raw::c_void,
            ) -> ArkUI_GridItemRect,
        >,
    );
}
extern "C" {
    #[doc = " @brief Creates water flow section configuration.\n\n @return Returns the water flow section configuration.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_Create() -> *mut ArkUI_WaterFlowSectionOption;
}
extern "C" {
    #[doc = " @brief Destroys the pointer to a water flow section configuration.\n\n @param option Indicates the pointer to a water flow section configuration.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_Dispose(option: *mut ArkUI_WaterFlowSectionOption);
}
extern "C" {
    #[doc = " @brief Sets the FlowItem block configuration information array length.\n\n @param option FlowItem Indicates the packet configuration.\n @param size Array Length.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetSize(
        option: *mut ArkUI_WaterFlowSectionOption,
        size: i32,
    );
}
extern "C" {
    #[doc = " @brief Gets the FlowItem grouping configuration information array length.\n\n @param option FlowItem Indicates the packet configuration.\n @return Array size. If -1 is returned, the return fails.\n         The possible cause of the failure is that the option parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetSize(
        option: *mut ArkUI_WaterFlowSectionOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the number of items in a water flow section.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param itemCount Indicates the number of items in the water flow section.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetItemCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        itemCount: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the number of items in the water flow section that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the number of items in the water flow section.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetItemCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief The FlowItem grouping configuration information getsthe spindle size of\n the specified Item based on flowItemIndex.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param callback Gets the spindle size of the specified Item based on index.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_RegisterGetItemMainSizeCallbackByIndex(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        callback: ::std::option::Option<unsafe extern "C" fn(itemIndex: i32) -> f32>,
    );
}
extern "C" {
    #[doc = " @brief The FlowItem grouping configuration information getsthe spindle size of\n the specified Item based on flowItemIndex.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param userData FlowItem Custom data.\n @param callback Gets the spindle size of the specified Item based on index.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_RegisterGetItemMainSizeCallbackByIndexWithUserData(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(itemIndex: i32, userData: *mut ::std::os::raw::c_void) -> f32,
        >,
    );
}
extern "C" {
    #[doc = " @brief Sets the number of columns (in a vertical layout) or rows (in a horizontal layout) of a water flow.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param crossCount Indicates the number of columns or rows, depending on the layout direction.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetCrossCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        crossCount: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the number of columns (in a vertical layout) or rows (in a horizontal layout) in the water flow section\n that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the number of columns or rows.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetCrossCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the gap between columns in the specified water flow section.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param columnGap Indicates the gap between columns to set.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetColumnGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        columnGap: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the gap between columns in the water flow section that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the gap between columns.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetColumnGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the gap between rows in the specified water flow section.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param rowGap Indicates the gap between rows to set.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetRowGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        rowGap: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the gap between rows in the water flow section that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the gap between rows.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetRowGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the margins for the specified water flow section.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param marginTop Indicates the top margin of the water flow section.\n @param marginRight Indicates the right margin of the water flow section.\n @param marginBottom Indicates the bottom margin of the water flow section.\n @param marginLeft Indicates the left margin of the water flow section.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetMargin(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        marginTop: f32,
        marginRight: f32,
        marginBottom: f32,
        marginLeft: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the margins of the water flow section that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the margins.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetMargin(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> ArkUI_Margin;
}
extern "C" {
    #[doc = " @brief Creates a navigation indicator.\n\n @param type Indicates the type of the indicator.\n @return Returns the pointer to the new indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_Create(
        type_: ArkUI_SwiperIndicatorType,
    ) -> *mut ArkUI_SwiperIndicator;
}
extern "C" {
    #[doc = " @brief Destroys the pointer to the indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_Dispose(indicator: *mut ArkUI_SwiperIndicator);
}
extern "C" {
    #[doc = " @brief Sets the distance between the navigation point and the start of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the distance between the navigation point and the start of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetStartPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the distance between the navigation point and the start of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the distance between the navigation point and the start of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetStartPosition(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the distance between the navigation point and the top of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the distance between the navigation point and the top of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetTopPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the distance between the navigation point and the top of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the distance between the navigation point and the top of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetTopPosition(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the distance between the navigation point and the right of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the distance between the navigation point and the right of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetEndPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the distance between the navigation point and the end of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the distance between the navigation point and the end of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetEndPosition(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the distance between the navigation point and the bottom of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the distance between the navigation point and the bottom of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetBottomPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the distance between the navigation point and the bottom of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the distance between the navigation point and the bottom of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetBottomPosition(indicator: *mut ArkUI_SwiperIndicator)
        -> f32;
}
extern "C" {
    #[doc = " @brief Sets the width of the dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the width of the dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetItemWidth(indicator: *mut ArkUI_SwiperIndicator, value: f32);
}
extern "C" {
    #[doc = " @brief Obtains the width of the dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the width of the dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetItemWidth(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the height of the dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the height of the dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetItemHeight(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief  Obtains the height of the dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the height of the dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetItemHeight(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the width of the selected dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the width of the selected dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetSelectedItemWidth(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief  Obtains the width of the selected dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the width of the selected dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetSelectedItemWidth(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the height of the selected dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the height of the selected dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetSelectedItemHeight(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief  Obtains the height of the selected dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the height of the selected dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetSelectedItemHeight(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets whether to display the mask style of the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param mask Whether to display the mask style. True means to display.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetMask(indicator: *mut ArkUI_SwiperIndicator, mask: i32);
}
extern "C" {
    #[doc = " @brief Obtains whether to display the mask style of the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns whether to display the mask style. True means to display.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetMask(indicator: *mut ArkUI_SwiperIndicator) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the color of the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param color the color of the dot navigation indicator, in 0xARGB format.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetColor(indicator: *mut ArkUI_SwiperIndicator, color: u32);
}
extern "C" {
    #[doc = " @brief Obtains the color of the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the color of the dot navigation indicator, in 0xARGB format.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetColor(indicator: *mut ArkUI_SwiperIndicator) -> u32;
}
extern "C" {
    #[doc = " @brief Sets the color of the selected dot for the navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param selectedColor the color of the selected dot, in 0xARGB format.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetSelectedColor(
        indicator: *mut ArkUI_SwiperIndicator,
        selectedColor: u32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the color of the selected dot for the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the color of the selected dot, in 0xARGB format.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetSelectedColor(indicator: *mut ArkUI_SwiperIndicator) -> u32;
}
extern "C" {
    #[doc = " @brief Sets the number of maxDisplayCount for the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param maxDisplayCount the maxDisplayCount of the navigation dot, span is 6-9.\n @return {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} indicator is null or maxDisplayCount less then 6 or\n         maxDisplayCount more then 9\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetMaxDisplayCount(
        indicator: *mut ArkUI_SwiperIndicator,
        maxDisplayCount: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of maxDisplayCount for the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the number of the maxDisplayCount, span is 6-9.\n         0 - indicator is null\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetMaxDisplayCount(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to ignore the size of the indicator for {@link OH_ArkUI_SwiperIndicator_SetBottomPosition}.\n\n @param indicator Indicates the pointer to the indicator.\n @param ignoreSize Whether to ignore the size of the indicator. The value 1 means to ignore, and 0 means the opposite.\n The default value is 0.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperIndicator_SetIgnoreSizeOfBottom(
        indicator: *mut ArkUI_SwiperIndicator,
        ignoreSize: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains whether to ignore the size of the indicator for {@link OH_ArkUI_SwiperIndicator_SetBottomPosition}.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns whether to ignore the size of the indicator.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperIndicator_GetIgnoreSizeOfBottom(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the space between the dots of the navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param space the space between the dots of the navigation indicator, the default value is 8vp.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperIndicator_SetSpace(indicator: *mut ArkUI_SwiperIndicator, space: f32);
}
extern "C" {
    #[doc = " @brief Obtains the space between the dots of the navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return the space between the dots of the navigation indicator\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperIndicator_GetSpace(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Creates a digital indicator.\n\n @return Returns the pointer to the new indicator.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_Create() -> *mut ArkUI_SwiperDigitIndicator;
}
extern "C" {
    #[doc = " @brief Sets the distance between the digital indicator and the start of the swiper.\n\n @param indicator The pointer to the digital indicator.\n @param value Indicates the distance between the digital indicator and the start of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetStartPosition(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Gets the distance between the digital indicator and the start of the swiper.\n\n @param indicator The pointer to the digital indicator.\n @return Returns the distance between the digital indicator and the start of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetStartPosition(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the distance between the digital indicator and the top of the swiper.\n\n @param indicator The pointer to the digital indicator.\n @param value Indicates the distance between the digital indicator and the top of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetTopPosition(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Gets the distance between the digital indicator and the top of the swiper.\n\n @param indicator The pointer to the digital indicator.\n @return Returns the distance between the digital indicator and the top of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetTopPosition(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the distance between the digital indicator and the end of the swiper.\n\n @param indicator The pointer to the digital indicator.\n @param value Indicates the distance between the digital indicator and the end of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetEndPosition(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Gets the distance between the digital indicator and the end of the swiper.\n\n @param indicator The pointer to the digital indicator.\n @return Returns the distance between the digital indicator and the end of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetEndPosition(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the distance between the digital indicator and the bottom of the swiper.\n\n @param indicator The pointer to the digital indicator.\n @param value Returns the distance between the digital indicator and the bottom of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetBottomPosition(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Gets the distance between the digital indicator and the bottom of the swiper.\n\n @param indicator The pointer to the digital indicator.\n @return Returns the distance between the digital indicator and the bottom of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetBottomPosition(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the font color of total count in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @param color font color, in 0xARGB format. Default value: 0xFF182431.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetFontColor(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        color: u32,
    );
}
extern "C" {
    #[doc = " @brief Gets the font color of total count in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @return font color, in 0xARGB format.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetFontColor(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Sets the font color of selected index in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @param selectedColor font color, in 0xARGB format. Default value: 0xFF182431.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetSelectedFontColor(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        selectedColor: u32,
    );
}
extern "C" {
    #[doc = " @brief Gets the font color of selected index in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @return font color, in 0xARGB format.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetSelectedFontColor(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Sets the font size of total count in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @param size font size, in fp.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetFontSize(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        size: f32,
    );
}
extern "C" {
    #[doc = " @brief Gets the font size of total count in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @return font size, in fp.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetFontSize(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the font size of selected index in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @param size font size, in fp.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetSelectedFontSize(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        size: f32,
    );
}
extern "C" {
    #[doc = " @brief Gets the font size of selected index in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @return font size, in fp.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetSelectedFontSize(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the font weight of total count in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @param fontWeight font weight {@link ArkUI_FontWeight}. The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetFontWeight(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        fontWeight: ArkUI_FontWeight,
    );
}
extern "C" {
    #[doc = " @brief Gets the font weight of total count in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @return font weight {@link ArkUI_FontWeight}.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetFontWeight(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> ArkUI_FontWeight;
}
extern "C" {
    #[doc = " @brief Sets the font weight of selected index in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @param selectedFontWeight font weight {@link ArkUI_FontWeight}. The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetSelectedFontWeight(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        selectedFontWeight: ArkUI_FontWeight,
    );
}
extern "C" {
    #[doc = " @brief Gets the font weight of selected index in the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @return font weight {@link ArkUI_FontWeight}.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetSelectedFontWeight(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> ArkUI_FontWeight;
}
extern "C" {
    #[doc = " @brief Destroys the digital indicator.\n\n @param indicator The pointer to the digital indicator.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_Destroy(indicator: *mut ArkUI_SwiperDigitIndicator);
}
extern "C" {
    #[doc = " @brief Sets whether to ignore the size of the indicator for {@link OH_ArkUI_SwiperDigitIndicator_SetBottomPosition}.\n\n @param indicator The pointer to the digital indicator.\n @param ignoreSize Whether to ignore the size of the indicator. The value 1 means to ignore, and 0 means the opposite.\n The default value is 0.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_SetIgnoreSizeOfBottom(
        indicator: *mut ArkUI_SwiperDigitIndicator,
        ignoreSize: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains whether to ignore the size of the indicator for {@link OH_ArkUI_SwiperDigitIndicator_SetBottomPosition}.\n\n @param indicator The pointer to the digital indicator.\n @return Returns whether to ignore the size of the indicator.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperDigitIndicator_GetIgnoreSizeOfBottom(
        indicator: *mut ArkUI_SwiperDigitIndicator,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Creates a arrow style for swiper.\n\n @return Returns the pointer to the new arrow style.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_Create() -> *mut ArkUI_SwiperArrowStyle;
}
extern "C" {
    #[doc = " @brief Sets whether to show the background for the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @param showBackground whether to show the background for the arrow.\n        The value <b>1</b> means to show the background, and <b>0</b> means the opposite.\n        The default value is <b>0</b>.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_SetShowBackground(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
        showBackground: i32,
    );
}
extern "C" {
    #[doc = " @brief Gets whether to show the background for the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @return whether to show the background for the arrow.\n         The value <b>1</b> means to show the background, and <b>0</b> means the opposite.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_GetShowBackground(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the display position of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @param showSidebarMiddle the display position of the arrow.\n        The value <b>1</b> means to display on boths sides of the swiper,\n        and <b>0</b> means display on boths sides of the swiper indicator.\n        The default value is <b>0</b>.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_SetShowSidebarMiddle(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
        showSidebarMiddle: i32,
    );
}
extern "C" {
    #[doc = " @brief Gets the display position of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @return the display position of the arrow. The value <b>1</b> means to display on boths sides of the swiper,\n         and <b>0</b> means display on boths sides of the swiper indicator.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_GetShowSidebarMiddle(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the background size of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @param backgroundSize the background size of the arrow. The unit is vp.\n        The default value is <b>24</b> when the arrow displays on both sides of the swiper indicator.\n        The default value is <b>32</b> when the arrow displays on both sides of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_SetBackgroundSize(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
        backgroundSize: f32,
    );
}
extern "C" {
    #[doc = " @brief Gets the background size of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @return Returns the background size of the arrow. The unit is vp.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_GetBackgroundSize(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Destroys the arrow style.\n\n @param arrowStyle The pointer to the arrow style.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_Destroy(arrowStyle: *mut ArkUI_SwiperArrowStyle);
}
extern "C" {
    #[doc = " @brief Sets the background color of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @param backgroundColor the background color of the arrow, in 0xARGB format.\n        The default value is <b>0x00000000</b> when the arrow displays on both sides of the swiper indicator.\n        The default value is <b>0x19182431</b> when the arrow displays on both sides of the swiper.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_SetBackgroundColor(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
        backgroundColor: u32,
    );
}
extern "C" {
    #[doc = " @brief Gets the background color of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @return Returns the background color of the arrow, in 0xARGB format.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_GetBackgroundColor(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Sets the size of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @param arrowSize the size of the arrow. The unit is vp.\n        The default value is <b>18</b> when the arrow displays on both sides of the swiper indicator.\n        The default value is <b>24</b> when the arrow displays on both sides of the swiper.\n        The arrow size is fixed to 3/4 of the background size when the background is shown.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_SetArrowSize(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
        arrowSize: f32,
    );
}
extern "C" {
    #[doc = " @brief Gets the size of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @return the size of the arrow. The unit is vp.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_GetArrowSize(arrowStyle: *mut ArkUI_SwiperArrowStyle) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the color of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @param arrowColor the color of the arrow, in 0xARGB format. The default value is <b>0x00182431</b>.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_SetArrowColor(
        arrowStyle: *mut ArkUI_SwiperArrowStyle,
        arrowColor: u32,
    );
}
extern "C" {
    #[doc = " @brief Gets the color of the arrow.\n\n @param arrowStyle The pointer to the arrow style.\n @return Returns the color of the arrow, in 0xARGB format.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_SwiperArrowStyle_GetArrowColor(arrowStyle: *mut ArkUI_SwiperArrowStyle) -> u32;
}
extern "C" {
    #[doc = " @brief Create auxiliary line information in the RelativeContaine container.\n\n @param size The number of auxiliary lines.\n @return auxiliary line information.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_Create(size: i32) -> *mut ArkUI_GuidelineOption;
}
extern "C" {
    #[doc = " @brief Destroy auxiliary line information.\n\n @param guideline auxiliary line information.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_Dispose(guideline: *mut ArkUI_GuidelineOption);
}
extern "C" {
    #[doc = " @brief Set the Id of the auxiliary line.\n\n @param guideline auxiliary line information.\n @param value id, must be unique and cannot have the same name as the component in the container.\n @param index auxiliary line index value.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_SetId(
        guideline: *mut ArkUI_GuidelineOption,
        value: *const ::std::os::raw::c_char,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Set the direction of the auxiliary line.\n\n @param guideline auxiliary line information.\n @param value direction.\n @param index auxiliary line index value.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_SetDirection(
        guideline: *mut ArkUI_GuidelineOption,
        value: ArkUI_Axis,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Set the distance from the left or top of the container.\n\n @param guideline auxiliary line information.\n @param value The distance from the left or top of the container.\n @param index auxiliary line index value.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_SetPositionStart(
        guideline: *mut ArkUI_GuidelineOption,
        value: f32,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Set the distance from the right or bottom of the container.\n\n @param guideline auxiliary line information.\n @param value The distance from the right side or bottom of the container.\n @param index auxiliary line index value.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_SetPositionEnd(
        guideline: *mut ArkUI_GuidelineOption,
        value: f32,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the Id of the auxiliary line.\n\n @param guideline auxiliary line information.\n @param index auxiliary line index value.\n @return Id.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_GetId(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the direction of the auxiliary line.\n\n @param guideline auxiliary line information.\n @param index auxiliary line index value.\n @return direction.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_GetDirection(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> ArkUI_Axis;
}
extern "C" {
    #[doc = " @brief Get the distance from the left or top of the container.\n\n @param guideline auxiliary line information.\n @param index auxiliary line index value.\n @return The distance from the left or top of the container.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_GetPositionStart(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Get the distance from the right side or bottom of the container.\n\n @param guideline auxiliary line information.\n @param index auxiliary line index value.\n @return The distance from the right side or bottom of the container.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_GetPositionEnd(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief creates barrier information within the RelativeContaine container.\n\n @param size Number of barriers.\n @return barrier information.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_Create(size: i32) -> *mut ArkUI_BarrierOption;
}
extern "C" {
    #[doc = " @brief Destroy barrier information.\n\n @param barrierStyle barrier information.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_Dispose(barrierStyle: *mut ArkUI_BarrierOption);
}
extern "C" {
    #[doc = " @brief Set the Id of the barrier.\n\n @param barrierStyle barrier information.\n @param value id, must be unique and cannot have the same name as the component in the container.\n @param index Barrier index value.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_SetId(
        barrierStyle: *mut ArkUI_BarrierOption,
        value: *const ::std::os::raw::c_char,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Set the direction of the barrier.\n\n @param barrierStyle barrier information.\n @param value direction.\n @param index Barrier index value.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_SetDirection(
        barrierStyle: *mut ArkUI_BarrierOption,
        value: ArkUI_BarrierDirection,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the dependent component of the barrier.\n\n @param barrierStyle barrier information.\n @param value The ID of the dependent component.\n @param index Barrier index value.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_SetReferencedId(
        barrierStyle: *mut ArkUI_BarrierOption,
        value: *const ::std::os::raw::c_char,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the Id of the barrier.\n\n @param barrierStyle auxiliary line information.\n @param index auxiliary line index value.\n @return The Id of the barrier.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_GetId(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the direction of the barrier.\n\n @param barrierStyle auxiliary line information.\n @param index auxiliary line index value.\n @return The direction of the barrier.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_GetDirection(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
    ) -> ArkUI_BarrierDirection;
}
extern "C" {
    #[doc = " @brief Get the dependent components of the barrier.\n\n @param barrierStyle auxiliary line information.\n @param index auxiliary line index value.\n @param referencedIndex dependent component Id index value.\n @return The barrier's dependent components.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_GetReferencedId(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
        referencedIndex: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the number of dependent components of the barrier.\n\n @param barrierStyle auxiliary line information.\n @param index auxiliary line index value.\n @return The number of dependent components of the barrier.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_GetReferencedIdSize(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ContentTransitionEffect {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief creates content switching animation effects.\n\n @param type content transition type: 0-identity, 1-opacity.\n @return content transition effect.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_ContentTransitionEffect_Create(
        type_: i32,
    ) -> *mut ArkUI_ContentTransitionEffect;
}
extern "C" {
    #[doc = " @brief creates alignment rule information for subcomponents in relative containers.\n\n @return Alignment rule information.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_Create() -> *mut ArkUI_AlignmentRuleOption;
}
extern "C" {
    #[doc = " @brief Destroys the alignment rule information of subcomponents in relative containers.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_Dispose(option: *mut ArkUI_AlignmentRuleOption);
}
extern "C" {
    #[doc = " @brief Set the start alignment parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param alignment Alignment relative to the anchor component.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetStart(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_HorizontalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the end alignment parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param alignment Alignment relative to the anchor component.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetEnd(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_HorizontalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the parameters for horizontal center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param alignment Alignment relative to anchor component\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetCenterHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_HorizontalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the parameters for top alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param alignment Alignment relative to anchor component\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetTop(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_VerticalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the bottom alignment parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param alignment Alignment relative to anchor component\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetBottom(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_VerticalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the parameters for vertical center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param alignment Alignment relative to the anchor component.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetCenterVertical(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_VerticalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Sets the horizontal offset parameter of the component under the anchor point constraint.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param horizontal bias value in the horizontal direction.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetBiasHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
        horizontal: f32,
    );
}
extern "C" {
    #[doc = " @brief Set the vertical offset parameter of the component under the anchor point constraint.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param vertical bias value in the vertical direction.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetBiasVertical(
        option: *mut ArkUI_AlignmentRuleOption,
        vertical: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the Id of the start-aligned parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The id value of the anchor component.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetStartId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the alignment of the start-aligned parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the parameters.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetStartAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_HorizontalAlignment;
}
extern "C" {
    #[doc = " @brief Get the end alignment parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return End-aligned parameter id.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetEndId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the end alignment parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the end-aligned parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetEndAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_HorizontalAlignment;
}
extern "C" {
    #[doc = " @brief Gets the parameters of horizontal center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The id of the parameter of horizontal center alignment.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterIdHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the parameters of horizontal center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the horizontally centered alignment parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterAlignmentHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_HorizontalAlignment;
}
extern "C" {
    #[doc = " @brief Get the top-aligned parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return Top aligned parameter id.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetTopId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the top-aligned parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the top-aligned parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetTopAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_VerticalAlignment;
}
extern "C" {
    #[doc = " @brief Get the bottom alignment parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The id of the bottom-aligned parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetBottomId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the bottom alignment parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the bottom-aligned parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetBottomAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_VerticalAlignment;
}
extern "C" {
    #[doc = " @brief Gets the parameters of vertical center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The id of the vertical center alignment parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterIdVertical(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the parameters of vertical center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the vertical center alignment parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterAlignmentVertical(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_VerticalAlignment;
}
extern "C" {
    #[doc = " @brief Get the bias value in the horizontal direction.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The bias value in the horizontal direction.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetBiasHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Get the bias value in the vertical direction.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return bias value in vertical direction.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetBiasVertical(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Create a configuration item for the ListitemSwipeActionItem interface settings.\n\n @return List Item SwipeActionItem configuration item instance. If the object returns a null pointer,\n         it indicates creation failure, and the reason for the failure may be that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_Create() -> *mut ArkUI_ListItemSwipeActionItem;
}
extern "C" {
    #[doc = " @brief Destroy the ListitemSwipeActionItem instance.\n\n @param item List Item SwipeActionItem instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_Dispose(item: *mut ArkUI_ListItemSwipeActionItem);
}
extern "C" {
    #[doc = " @brief Set the layout content of ListItem SwipeActionItem.\n\n @param item List Item SwipeActionItem instance.\n @param node Layout information.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetContent(
        item: *mut ArkUI_ListItemSwipeActionItem,
        node: ArkUI_NodeHandle,
    );
}
extern "C" {
    #[doc = " @brief Set the threshold for long-distance sliding deletion distance of components.\n\n @param item List Item SwipeActionItem instance.\n @param distance Component long-distance sliding deletion distance threshold.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetActionAreaDistance(
        item: *mut ArkUI_ListItemSwipeActionItem,
        distance: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtain the threshold for long-distance sliding deletion distance of components.\n\n @param item List Item SwipeActionItem instance.\n @return Component long-distance sliding deletion distance threshold. If -1.0f is returned, the return fails.\n         The possible cause of the failure is that the item parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_GetActionAreaDistance(
        item: *mut ArkUI_ListItemSwipeActionItem,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the event to be called when a sliding entry enters the deletion area.\n\n @param item List Item SwipeActionItem instance.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnEnterActionArea(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when a sliding entry enters the deletion area.\n\n @param item List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnEnterActionAreaWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set the event to be called when a component enters the long-range deletion area and deletes a ListItem.\n\n @param item List Item SwipeActionItem instance.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnAction(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when a component enters the long-range deletion area and deletes a ListItem.\n\n @param item List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnActionWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set the event to be called when a sliding entry exits the deletion area.\n\n @param item List Item SwipeActionItem instance.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnExitActionArea(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when a sliding entry exits the deletion area.\n\n @param item List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnExitActionAreaWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when the sliding state of a list item changes.\n\n @param item List Item SwipeActionItem instance.\n @param callback Callback Events.\n        swipeActionState The changed state.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnStateChange(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::std::option::Option<
            unsafe extern "C" fn(swipeActionState: ArkUI_ListItemSwipeActionState),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when the sliding state of a list item changes.\n\n @param item List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n        swipeActionState The changed state.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnStateChangeWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                swipeActionState: ArkUI_ListItemSwipeActionState,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    #[doc = " @brief Create a configuration item for the ListitemSwipeActionOption interface settings.\n\n @return List Item SwipeActionOption configuration item instance.If the object returns a null pointer,\n         it indicates a creation failure, and the reason for the failure may be that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_Create() -> *mut ArkUI_ListItemSwipeActionOption;
}
extern "C" {
    #[doc = " @brief Destroy the ListitemSwipeActionOption instance.\n\n @param option List Item SwipeActionOption instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_Dispose(option: *mut ArkUI_ListItemSwipeActionOption);
}
extern "C" {
    #[doc = " @brief Set the layout content on the left (vertical layout) or top (horizontal layout)\n of the ListItem SwipeActionItem.\n\n @param option List Item SwipeActionItem instance.\n @param item Layout information.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetStart(
        option: *mut ArkUI_ListItemSwipeActionOption,
        item: *mut ArkUI_ListItemSwipeActionItem,
    );
}
extern "C" {
    #[doc = " @brief Set the layout content on the right (vertical layout) or bottom (horizontal layout)\n of the ListItem SwipeActionItem.\n\n @param option List Item SwipeActionItem instance.\n @param item Layout information.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetEnd(
        option: *mut ArkUI_ListItemSwipeActionOption,
        item: *mut ArkUI_ListItemSwipeActionItem,
    );
}
extern "C" {
    #[doc = " @brief Set the sliding effect.\n\n @param option List Item SwipeActionItem instance.\n @param edgeEffect Sliding effect.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetEdgeEffect(
        option: *mut ArkUI_ListItemSwipeActionOption,
        edgeEffect: ArkUI_ListItemSwipeEdgeEffect,
    );
}
extern "C" {
    #[doc = " @brief Get the sliding effect.\n\n @param option List Item SwipeActionItem instance.\n @return Sliding effect. The default return value is 0. If -1 is returned, the return fails.\n         The possible cause of the failure is that the option parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_GetEdgeEffect(
        option: *mut ArkUI_ListItemSwipeActionOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief The event called when the sliding operation offset changes.\n\n @param option List Item SwipeActionItem instance.\n @param callback Callback Events.\n        offset Slide offset.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetOnOffsetChange(
        option: *mut ArkUI_ListItemSwipeActionOption,
        callback: ::std::option::Option<unsafe extern "C" fn(offset: f32)>,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when the sliding operation offset changes.\n\n @param option List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n        offset Slide offset.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetOnOffsetChangeWithUserData(
        option: *mut ArkUI_ListItemSwipeActionOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(offset: f32, userData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Create configuration items for the ListChildrenMainSize interface settings.\n\n @return ListChildrenMainSize configuration item instance.If the object returns a null pointer,\n         it indicates a creation failure, and the reason for the failure may be that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Create() -> *mut ArkUI_ListChildrenMainSize;
}
extern "C" {
    #[doc = " @brief Destroy the ListChildrenMainSize instance.\n\n @param option The ListChildrenMainSize instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Dispose(option: *mut ArkUI_ListChildrenMainSize);
}
extern "C" {
    #[doc = " @brief Set the default size of ChildrenMainSizeOption for the List component.\n\n @param option ListChildrenMainSize instance.\n @param defaultMainSize The default size of the ListItem under the List, measured in vp.\n @return 0 represents success. If defaultMainSize is less than 0 or option is a null pointer, return 401.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_SetDefaultMainSize(
        option: *mut ArkUI_ListChildrenMainSize,
        defaultMainSize: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the default size of ChildrenMainSizeOption for the List component.\n\n @param option ListChildrenMainSize instance.\n @return The default size of the ListItem under the List is 0, measured in vp.\n         When the option is a null pointer, it returns -1.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_GetDefaultMainSize(
        option: *mut ArkUI_ListChildrenMainSize,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Reset the array size of ChildrenMainSizeOption for the List component.\n\n @param option ListChildrenMainSize instance.\n @param totalSize Array size.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Resize(
        option: *mut ArkUI_ListChildrenMainSize,
        totalSize: i32,
    );
}
extern "C" {
    #[doc = " @brief Resize the ChildrenMainSizeOption array operation on the List component.\n\n @param option ListChildrenMainSize instance.\n @param index To modify the starting position of the MainSize array.\n @param deleteCount The number of MainSize arrays to be deleted starting from index.\n @param addCount The number of MainSize arrays to be added starting from index.\n @return 0 represents success. If the function parameter is abnormal, return 401.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Splice(
        option: *mut ArkUI_ListChildrenMainSize,
        index: i32,
        deleteCount: i32,
        addCount: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Update the value of the ChildrenMainSizeOption array in the List component.\n\n @param option ListChildrenMainSize instance.\n @param index To modify the starting position of the MainSize array.\n @param mainSize The actual modified value.\n @return 0 represents success. If the function parameter is abnormal, return 401.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_UpdateSize(
        option: *mut ArkUI_ListChildrenMainSize,
        index: i32,
        mainSize: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the value of the ChildrenMainSizeOption array for the List component.\n\n @param option ListChildrenMainSize instance.\n @param index The index position of the value to be obtained.\n @return The value of the specific position of the array. If the function parameter is abnormal, return -1.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_GetMainSize(
        option: *mut ArkUI_ListChildrenMainSize,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Creates measurement information for this custom span.\n\n @return Returns a <b>CustomSpanMeasureInfo</b> instance.\n <br> If the result returns nullptr, there may be out of memory.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMeasureInfo_Create() -> *mut ArkUI_CustomSpanMeasureInfo;
}
extern "C" {
    #[doc = " @brief Disposes of measurement information of this custom span.\n\n @param info The CustomSpanMeasureInfo instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMeasureInfo_Dispose(info: *mut ArkUI_CustomSpanMeasureInfo);
}
extern "C" {
    #[doc = " @brief Obtains the font size of a custom span.\n\n @param info Indicates the pointer to the measurement information of a custom span.\n @return Returns the font size. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMeasureInfo_GetFontSize(
        info: *mut ArkUI_CustomSpanMeasureInfo,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Creates measurement metrics for this custom span.\n\n @return Returns a <b>CustomSpanMetrics</b> instance.\n <br> If the result returns nullptr, there may be out of memory.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMetrics_Create() -> *mut ArkUI_CustomSpanMetrics;
}
extern "C" {
    #[doc = " @brief Disposes of measurement metrics of this custom span.\n\n @param metrics The CustomSpanMetrics instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMetrics_Dispose(metrics: *mut ArkUI_CustomSpanMetrics);
}
extern "C" {
    #[doc = " @brief Sets the width for a custom span.\n\n @param metrics Indicates the pointer to a <b>CustomSpanMetrics</b> instance.\n @param width Indicates the width, in px. The width should be greater than 0.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMetrics_SetWidth(
        metrics: *mut ArkUI_CustomSpanMetrics,
        width: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the height for a custom span.\n\n @param metrics Indicates the pointer to a <b>CustomSpanMetrics</b> instance.\n @param width Indicates the height, in px. The width should be greater than 0.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMetrics_SetHeight(
        metrics: *mut ArkUI_CustomSpanMetrics,
        height: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Creates drawing information for this custom span.\n\n @return Returns a <b>CustomSpanDrawInfo</b> instance.\n <br> If the result returns nullptr, there may be out of memory.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_Create() -> *mut ArkUI_CustomSpanDrawInfo;
}
extern "C" {
    #[doc = " @brief Disposes of drawing information for this custom span.\n\n @param info The CustomSpanDrawInfo instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_Dispose(info: *mut ArkUI_CustomSpanDrawInfo);
}
extern "C" {
    #[doc = " @brief Obtains the x-axis offset of the custom span relative to the mounted component.\n\n @param info Indicates the pointer to the drawing information of a custom span.\n @return Returns the x-axis offset. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetXOffset(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the top margin of the custom span relative to the mounted component.\n\n @param info Indicates the pointer to the drawing information of a custom span.\n @return Returns the top margin. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetLineTop(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the bottom margin of the custom span relative to the mounted component.\n\n @param info Indicates the pointer to the drawing information of a custom span.\n @return Returns the bottom margin. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetLineBottom(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the baseline offset of the custom span relative to the mounted component.\n\n @param info Indicates the pointer to the drawing information of a custom span.\n @return Returns the baseline offset. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetBaseline(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
}
extern "C" {
    #[doc = " @brief Create a image frame from the image path.\n @param src Indicates the image path.\n @return Returns the pointer to the image frame object.\n If a null pointer is returned, the object fails to be created. The possible cause is that\n the src parameter is abnormal, for example, the pointer is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_CreateFromString(
        src: *mut ::std::os::raw::c_char,
    ) -> *mut ArkUI_ImageAnimatorFrameInfo;
}
extern "C" {
    #[doc = " @brief Create a image frame from the drawable descriptor.\n\n @param drawable Indicates the pointer to the drawable descriptor.\n @return Returns the pointer to the image frame object.\n If a null pointer is returned, the object fails to be created. The possible cause is that\n the drawable parameter is abnormal, for example, the pointer is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_CreateFromDrawableDescriptor(
        drawable: *mut ArkUI_DrawableDescriptor,
    ) -> *mut ArkUI_ImageAnimatorFrameInfo;
}
extern "C" {
    #[doc = " @brief Destroy the pointer to the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_Dispose(imageInfo: *mut ArkUI_ImageAnimatorFrameInfo);
}
extern "C" {
    #[doc = " @brief Set the width of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param width Indicates the width of the image frame, and the unit is PX.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetWidth(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        width: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the width of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Return the width of the image frame, and the unit is PX. Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetWidth(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the height of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param height Indicates the height of the image frame, and the unit is PX.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetHeight(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        height: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the height of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Return the height of the image frame, and the unit is PX. Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetHeight(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the vertical coordinate of the image relative to the upper left corner of the widget.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param top Indicates the vertical coordinate of the image relative to the upper left corner of the widget,\n and the unit is PX.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetTop(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        top: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the vertical coordinate of the image relative to the upper left corner of the widget.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Returns the vertical coordinate of the image relative to the upper left corner of the widget,\n and the unit is PX. Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetTop(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the horizontal coordinate of the image relative to the upper left corner of the widget.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param left Indicates the horizontal coordinate of the image relative to the upper left corner of the widget,\n and the unit is PX.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetLeft(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        left: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the horizontal coordinate of the image relative to the upper left corner of the widget.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Returns the horizontal coordinate of the image relative to the upper left corner of the widget,\n and the unit is PX. Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetLeft(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the playback duration of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param duration Indicates the playback duration of each image frame, and the unit is milliseconds.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetDuration(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        duration: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the playback duration of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Returns the playback duration of the image frame, and the unit is milliseconds.\n Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetDuration(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Create accessibility state.\n\n @return Returns the pointer to the accessibility state object.\n If a null pointer is returned, the object fails to be created. The possible cause is that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_Create() -> *mut ArkUI_AccessibilityState;
}
extern "C" {
    #[doc = " @brief Dispose accessibility state.\n\n @param state accessibility state object.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_Dispose(state: *mut ArkUI_AccessibilityState);
}
extern "C" {
    #[doc = " @brief Set accessibility state disabled.\n\n @param state accessibility state object.\n @param isDisabled accessibility state disabled, Value 1 indicates disabled and 0 indicates enbled.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_SetDisabled(
        state: *mut ArkUI_AccessibilityState,
        isDisabled: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility state disabled.\n\n @param state accessibility state object.\n @return accessibility state disabled, Value 1 indicates disabled and 0 indicates enbled. The default value is 0.\n         If the function parameter is abnormal, return the default value.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_IsDisabled(state: *mut ArkUI_AccessibilityState) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility state selected.\n\n @param state accessibility state object.\n @param isSelected accessibility state selected, Value 1 indicates selected, and 0 indicates not selected.\n        The default value is 0.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_SetSelected(
        state: *mut ArkUI_AccessibilityState,
        isSelected: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility state selected.\n\n @param state accessibility state object.\n @return accessibility state selected, Value 1 indicates selected, and 0 indicates not selected.\n         The default value is 0.\n         If the function parameter is abnormal, return the default value.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_IsSelected(state: *mut ArkUI_AccessibilityState) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility checked state.\n\n @param state accessibility state object.\n @param checkedState checked state, and uses the {@link ArkUI_AccessibilityCheckedState} enumeration value,\n        The default value is ARKUI_ACCESSIBILITY_UNCHECKED.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_SetCheckedState(
        state: *mut ArkUI_AccessibilityState,
        checkedState: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility checked state.\n\n @param state accessibility state object.\n @return checked state, and uses the {@link ArkUI_AccessibilityCheckedState} enumeration value,\n         The default value is ARKUI_ACCESSIBILITY_UNCHECKED.\n         If the function parameter is abnormal, return the default value.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_GetCheckedState(state: *mut ArkUI_AccessibilityState)
        -> i32;
}
extern "C" {
    #[doc = " @brief Create accessibility value.\n\n @return Returns the pointer to the accessibility state object.\n If a null pointer is returned, the object fails to be created. The possible cause is that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_Create() -> *mut ArkUI_AccessibilityValue;
}
extern "C" {
    #[doc = " @brief Dispose accessibility value.\n\n @param value accessibility value object.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_Dispose(value: *mut ArkUI_AccessibilityValue);
}
extern "C" {
    #[doc = " @brief Set accessibility minimum value.\n\n @param value accessibility value object.\n @param min minimum value based on range components, The default value is -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_SetMin(value: *mut ArkUI_AccessibilityValue, min: i32);
}
extern "C" {
    #[doc = " @brief Get accessibility minimum value.\n\n @param value accessibility value object.\n @return minimum value based on range components, The default value is -1.\n         If the function parameter is abnormal, return -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_GetMin(value: *mut ArkUI_AccessibilityValue) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility minimum value.\n\n @param value accessibility value object.\n @param max maximum value based on range components, The default value is -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_SetMax(value: *mut ArkUI_AccessibilityValue, max: i32);
}
extern "C" {
    #[doc = " @brief Get accessibility minimum value.\n\n @param value accessibility value object.\n @return maximum value based on range components, The default value is -1.\n         If the function parameter is abnormal, return -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_GetMax(value: *mut ArkUI_AccessibilityValue) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility current value.\n\n @param value accessibility value object.\n @param current value based on range components, The default value is -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_SetCurrent(
        value: *mut ArkUI_AccessibilityValue,
        current: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility current value.\n\n @param value accessibility value object.\n @return current value based on range components, The default value is -1.\n         If the function parameter is abnormal, return -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_GetCurrent(value: *mut ArkUI_AccessibilityValue) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility minimum value.\n\n @param value accessibility value object.\n @param rangeMin minimum value based on range components, The default value is -1.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_AccessibilityValue_SetRangeMin(
        value: *mut ArkUI_AccessibilityValue,
        rangeMin: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility minimum value.\n\n @param value accessibility value object.\n @return minimum value based on range components, The default value is -1.\n         If the function parameter is abnormal, return -1.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_AccessibilityValue_GetRangeMin(value: *mut ArkUI_AccessibilityValue) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility maximum value.\n\n @param value accessibility value object.\n @param rangeMax maximum value based on range components, The default value is -1.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_AccessibilityValue_SetRangeMax(
        value: *mut ArkUI_AccessibilityValue,
        rangeMax: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility maximum value.\n\n @param value accessibility value object.\n @return maximum value based on range components, The default value is -1.\n         If the function parameter is abnormal, return -1.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_AccessibilityValue_GetRangeMax(value: *mut ArkUI_AccessibilityValue) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility current value.\n\n @param value accessibility value object.\n @param rangeCurrent value based on range components, The default value is -1.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_AccessibilityValue_SetRangeCurrent(
        value: *mut ArkUI_AccessibilityValue,
        rangeCurrent: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility current value.\n\n @param value accessibility value object.\n @return current value based on range components, The default value is -1.\n         If the function parameter is abnormal, return -1.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_AccessibilityValue_GetRangeCurrent(value: *mut ArkUI_AccessibilityValue)
        -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility text value.\n\n @param value accessibility value object.\n @param text The textual description information of the component, which defaults to an empty string.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_SetText(
        value: *mut ArkUI_AccessibilityValue,
        text: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility text value.\n\n @param value accessibility value object.\n @return The textual description information of the component, which defaults to an empty string;\n         If the function parameter is abnormal, return null.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_GetText(
        value: *mut ArkUI_AccessibilityValue,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Destroy the instance of Customs Property.\n\n @param handle The instance of Customs Property to be destroyed.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_CustomProperty_Destroy(handle: *mut ArkUI_CustomProperty);
}
extern "C" {
    #[doc = " @brief Get custom attribute value information.\n\n @param handle Custom attribute object pointer.\n @return Customize the value information within the attribute structure.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_CustomProperty_GetStringValue(
        handle: *mut ArkUI_CustomProperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get window name from HostWindowInfo.\n\n @param info HostWindowInfo object pointer.\n @return Window name in HostWindowInfo.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_HostWindowInfo_GetName(
        info: *mut ArkUI_HostWindowInfo,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Destroy the instance of HostWindowInfo.\n\n @param info Instance of HostWindowInfo to be destroyed.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_HostWindowInfo_Destroy(info: *mut ArkUI_HostWindowInfo);
}
extern "C" {
    #[doc = " @brief Destroy ActiveChildenInfo instance.\n\n @param handle ActiveChild instance to be destroyed.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_ActiveChildrenInfo_Destroy(handle: *mut ArkUI_ActiveChildrenInfo);
}
extern "C" {
    #[doc = " @brief Retrieve the child nodes of ActiveChildenInfo with the structure index.\n\n @param handle The ActiveChildenInfo instance for obtaining information.\n @param index The index of child nodes.\n @return The child node pointer corresponding to the index. Return nullptr in case of exception.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_ActiveChildrenInfo_GetNodeByIndex(
        handle: *mut ArkUI_ActiveChildrenInfo,
        index: i32,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Retrieve the number of nodes within the structure of ActiveChildenInfo.\n\n @param handle The ActiveChildenInfo instance for obtaining information.\n @return Number of child nodes. Default value: 0.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_ActiveChildrenInfo_GetCount(handle: *mut ArkUI_ActiveChildrenInfo) -> i32;
}
extern "C" {
    #[doc = " @brief Create linear progress indicator style information.\n\n @return Returns a <b>ProgressLinearStyleOption</b> instance.\n <br> If the result returns nullptr, there may be out of memory.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_Create() -> *mut ArkUI_ProgressLinearStyleOption;
}
extern "C" {
    #[doc = " @brief Destroy linear progress indicator style information.\n\n @param option Linear progress indicator style information.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_Destroy(option: *mut ArkUI_ProgressLinearStyleOption);
}
extern "C" {
    #[doc = " @brief Set whether the scan effect is enabled.\n\n @param option Linear progress indicator style information.\n @param enabled Whether to enable the scan effect. Default value: false.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_SetScanEffectEnabled(
        option: *mut ArkUI_ProgressLinearStyleOption,
        enabled: bool,
    );
}
extern "C" {
    #[doc = " @brief Set whether smoothing effect is enabled.\n\n @param option Linear progress indicator style information.\n @param enabled Whether to enable the smooth effect. When this effect is enabled, the progress change to\n the set value takes place gradually. Otherwise, it takes place immediately. Default value: true.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_SetSmoothEffectEnabled(
        option: *mut ArkUI_ProgressLinearStyleOption,
        enabled: bool,
    );
}
extern "C" {
    #[doc = " @brief Set linear progress indicator stroke width.\n\n @param option Linear progress indicator style information.\n @param strokeWidth Stroke width of the progress indicator. It cannot be set in percentage.\n Default value: 4.0vp.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_SetStrokeWidth(
        option: *mut ArkUI_ProgressLinearStyleOption,
        strokeWidth: f32,
    );
}
extern "C" {
    #[doc = " @brief Set linear progress indicator stroke radius.\n\n @param option Linear progress indicator style information.\n @param strokeRadius Rounded corner radius of the progress indicator. Value range: [0, strokeWidth/2].\n Default value: strokeWidth/2.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_SetStrokeRadius(
        option: *mut ArkUI_ProgressLinearStyleOption,
        strokeRadius: f32,
    );
}
extern "C" {
    #[doc = " @brief Get whether scan effect is enable.\n\n @param option Linear progress indicator style information.\n @return Whether to enable the scan effect.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_GetScanEffectEnabled(
        option: *mut ArkUI_ProgressLinearStyleOption,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get whether smoothing effect is enabled.\n\n @param option Linear progress indicator style information.\n @return Whether to enable the smooth effect.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_GetSmoothEffectEnabled(
        option: *mut ArkUI_ProgressLinearStyleOption,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get linear progress indicator stroke width.\n\n @param option Linear progress indicator style information.\n @return Stroke width of the progress indicator.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_GetStrokeWidth(
        option: *mut ArkUI_ProgressLinearStyleOption,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Get linear progress indicator stroke radius.\n\n @param option Linear progress indicator style information.\n @return Rounded corner radius of the progress indicator.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_ProgressLinearStyleOption_GetStrokeRadius(
        option: *mut ArkUI_ProgressLinearStyleOption,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Create a cross-language option instance.\n\n @return Returns a cross-language option instance. If the result is a null pointer, it may be out of memory.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_CrossLanguageOption_Create() -> *mut ArkUI_CrossLanguageOption;
}
extern "C" {
    #[doc = " @brief Destroy the cross-language option instance.\n\n @param option The cross-language option instance.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_CrossLanguageOption_Destroy(option: *mut ArkUI_CrossLanguageOption);
}
extern "C" {
    #[doc = " @brief Enable the attribute setting in the cross-language option.\n\n @param option The cross-language option.\n @param enabled The attribute setting in the cross-language option.\n Default value: false.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_CrossLanguageOption_SetAttributeSettingStatus(
        option: *mut ArkUI_CrossLanguageOption,
        enabled: bool,
    );
}
extern "C" {
    #[doc = " @brief Get the attribute setting enable of the cross-language option.\n\n @param option The cross-language option.\n @return The attribute setting enable of the cross-language option.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_CrossLanguageOption_GetAttributeSettingStatus(
        option: *mut ArkUI_CrossLanguageOption,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Creates an option for taking snapshot, the returned value must be released through\n        {@link OH_ArkUI_DestroySnapshotOptions} when it's not used anymore.\n\n @return Returns the pointer to the created snapshot options object.If the object returns a null pointer,\n         it indicates a creation failure, and the reason for the failure may be that the address space is full.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_CreateSnapshotOptions() -> *mut ArkUI_SnapshotOptions;
}
extern "C" {
    #[doc = " @brief Dispose a snapshot option object.\n\n @param snapshotOptions Indicates the pointer to the snapshot option.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_DestroySnapshotOptions(snapshotOptions: *mut ArkUI_SnapshotOptions);
}
extern "C" {
    #[doc = " @brief Config the snapshot option with scale.\n\n @param snapshotOptions Indicates the pointer to the snapshot option.\n @param scale Indicates the scale property to take the snapshot.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_SnapshotOptions_SetScale(
        snapshotOptions: *mut ArkUI_SnapshotOptions,
        scale: f32,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_VisibleAreaEventOptions {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates an instance of visible area change event parameters\n\n @return Returns the created instance of visible area change event parameters.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_VisibleAreaEventOptions_Create() -> *mut ArkUI_VisibleAreaEventOptions;
}
extern "C" {
    #[doc = " @brief Disposes of an instance of visible area change event parameters.\n\n @param option Instance to be destroyed.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_VisibleAreaEventOptions_Dispose(option: *mut ArkUI_VisibleAreaEventOptions);
}
extern "C" {
    #[doc = " @brief Sets the threshold ratios for visible area changes.\n\n @param option Instance of visible area change event parameters.\n @param value Array of threshold ratios. Each element represents the ratio of the visible area of a component to\n its total area. The visible area is calculated within the parent component's bounds; any area outside the parent\n component is not considered. Each value must be within the [0.0, 1.0] range.\n Values outside this range will be handled as 0.0 or 1.0.\n @param size Size of the threshold array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         If an error code is returned, it may be due to a failure in parameter validation;\n         the parameter must not be null.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_VisibleAreaEventOptions_SetRatios(
        option: *mut ArkUI_VisibleAreaEventOptions,
        value: *mut f32,
        size: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the expected update interval for visible area changes.\n\n @param option Instance of visible area change event parameters.\n @param value Expected update interval, in ms.  Default value: <b>1000</b>.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         If an error code is returned, it may be due to a failure in parameter validation;\n         the parameter must not be null.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_VisibleAreaEventOptions_SetExpectedUpdateInterval(
        option: *mut ArkUI_VisibleAreaEventOptions,
        value: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the flag for controlling if the child components can exceed the parent's bounds.\n if set to false, the part that exceeds the parent's bounds will be considered as invisible area,\n set to true to allow the exceeding, the part that exceeds will be considered as visible area.\n\n Please note that if the parent component set clip(true), the measureFromViewport configuration\n will be ignored.\n\n @param option Instance of visible area change event parameters.\n @param measureFromViewport When this parameter is set to true, the parts of the component\n    that exceed the parent component's area will also be included in the visible area calculation. However, this\n    only applies if the parent component does not explicitly set the clip property to true. If the parent component\n    sets clip to true, regardless of the value of this parameter, the parts that exceed the parent component's area\n    will still be treated as invisible in the visible area calculation.\n Default measureFromViewport: <b>false</b>.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         If an error code is returned, it may be due to a failure in parameter validation;\n         the parameter must not be null.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_VisibleAreaEventOptions_SetMeasureFromViewport(
        option: *mut ArkUI_VisibleAreaEventOptions,
        measureFromViewport: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the threshold ratios for visible area changes.\n\n @param option Instance of visible area change event parameters.\n @param value Array of threshold ratios.\n @param size Size of the threshold array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} if the provided buffer size is insufficient.\n         If an error code is returned, it may be due to a failure in parameter validation;\n         the parameter must not be null.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_VisibleAreaEventOptions_GetRatios(
        option: *mut ArkUI_VisibleAreaEventOptions,
        value: *mut f32,
        size: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the expected update interval for visible area changes.\n\n @param option Instance of visible area change event parameters.\n @return Returns the expected update interval, in ms.  Default value: <b>1000</b>.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_VisibleAreaEventOptions_GetExpectedUpdateInterval(
        option: *mut ArkUI_VisibleAreaEventOptions,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the value set through {@link OH_ArkUI_VisibleAreaEventOptions_SetMeasureFromViewport} .\n\n @param option Instance of visible area change event parameters.\n @return Returns the flag for controlling of the visible area calculation. Default value: <b>false</b>.\n\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_VisibleAreaEventOptions_GetMeasureFromViewport(
        option: *mut ArkUI_VisibleAreaEventOptions,
    ) -> bool;
}
extern "C" {
    #[doc = "@brief Creates a TextPickerRangeContent instance.\n\n@param length The length of the picker array.\n@return Returns a <b>TextPickerRangeContent</b> instance.\n@since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_TextPickerRangeContentArray_Create(
        length: i32,
    ) -> *mut ArkUI_TextPickerRangeContentArray;
}
extern "C" {
    #[doc = "@brief Sets the icon of items in a text picker ranges.\n\n@param handle The TextPickerRangeContent instance for obtaining information.\n@param icon Icon addreass.\n@param index The index position of the value to be obtained.\n@since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_TextPickerRangeContentArray_SetIconAtIndex(
        handle: *mut ArkUI_TextPickerRangeContentArray,
        icon: *mut ::std::os::raw::c_char,
        index: i32,
    );
}
extern "C" {
    #[doc = "@brief Sets the text of items in a text picker ranges\n\n@param handle The TextPickerRangeContent instance for obtaining information.\n@param text Text content\n@param index The index position of the value to be obtained.\n@since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_TextPickerRangeContentArray_SetTextAtIndex(
        handle: *mut ArkUI_TextPickerRangeContentArray,
        text: *mut ::std::os::raw::c_char,
        index: i32,
    );
}
extern "C" {
    #[doc = "@brief Destroy the TextPickerRangeContent instance.\n\n@param handle The TextPickerRangeContent instance for obtaining information.\n@since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_TextPickerRangeContentArray_Destroy(
        handle: *mut ArkUI_TextPickerRangeContentArray,
    );
}
extern "C" {
    #[doc = "@brief Creates a TextCascadePickerRangeContent instance.\n\n@param length The length of the picker array.\n@return Returns a <b>TextCascadePickerRangeContent</b> instance.\n@since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_TextCascadePickerRangeContentArray_Create(
        length: i32,
    ) -> *mut ArkUI_TextCascadePickerRangeContentArray;
}
extern "C" {
    #[doc = "@brief Sets the text of items in a multi text picker ranges.\n\n@param handle The TextCascadePickerRangeContent instance for obtaining information.\n@param text text content\n@param index The index position of the value to be obtained.\n@since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_TextCascadePickerRangeContentArray_SetTextAtIndex(
        handle: *mut ArkUI_TextCascadePickerRangeContentArray,
        text: *mut ::std::os::raw::c_char,
        index: i32,
    );
}
extern "C" {
    #[doc = "@brief Sets the childs info of items in a multi text picker ranges.\n\n@param handle The TextCascadePickerRangeContent instance for obtaining information.\n@param child The child instance.\n@param index The index position of the value to be obtained.\n@since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_TextCascadePickerRangeContentArray_SetChildAtIndex(
        handle: *mut ArkUI_TextCascadePickerRangeContentArray,
        child: *mut ArkUI_TextCascadePickerRangeContentArray,
        index: i32,
    );
}
extern "C" {
    #[doc = "@brief Destroy the TextCascadePickerRangeContent instance.\n\n@param handle The TextCascadePickerRangeContent instance for obtaining information.\n@since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_TextCascadePickerRangeContentArray_Destroy(
        handle: *mut ArkUI_TextCascadePickerRangeContentArray,
    );
}
extern "C" {
    #[doc = " @brief Create an object for the EmbeddedComponent option.\n\n @return A pointer to the object of the EmbeddedComponent option.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_EmbeddedComponentOption_Create() -> *mut ArkUI_EmbeddedComponentOption;
}
extern "C" {
    #[doc = " @brief Destroy the object by EmbeddedComponent option.\n\n @param option Pointer to the object by the EmbeddeComponent to be destroyed.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_EmbeddedComponentOption_Dispose(option: *mut ArkUI_EmbeddedComponentOption);
}
extern "C" {
    #[doc = " @brief Set the onError of EmbeddedComponent.\n\n @param option Pointer to the object option by the EmbeddedComponent.\n @param code Common error information about the API invoking failure.\n @param name Common error name information about the API invoking failure.\n @param message Common error message information about the API invoking failure.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_EmbeddedComponentOption_SetOnError(
        option: *mut ArkUI_EmbeddedComponentOption,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                code: i32,
                name: *const ::std::os::raw::c_char,
                message: *const ::std::os::raw::c_char,
            ),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set the onTerminated of EmbeddedComponent.\n\n @param option Pointer to the object option by the EmbeddedComponent.\n @param code Result code returned when the EmbeddedUIExtensionAbility exits.\n @param want Data returned when the EmbeddedUIExtensionAbility exits.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_EmbeddedComponentOption_SetOnTerminated(
        option: *mut ArkUI_EmbeddedComponentOption,
        callback: ::std::option::Option<
            unsafe extern "C" fn(code: i32, want: *mut AbilityBase_Want),
        >,
    );
}
extern "C" {
    #[doc = " @brief Expand the swipe action.\n\n @param node List Item node.\n @param direction expand direction of swipeAction.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_ERROR} The component type of the node is incorrect.\n         {@link ARKUI_ERROR_CODE_NODE_NOT_ON_MAIN_TREE} The node not mounted to component tree.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_ListItemSwipeAction_Expand(
        node: ArkUI_NodeHandle,
        direction: ArkUI_ListItemSwipeActionDirection,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Collapse the swipe action.\n\n @param node List Item node.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_ERROR} The component type of the node is incorrect.\n         {@link ARKUI_ERROR_CODE_NODE_NOT_ON_MAIN_TREE} The node not mounted to component tree.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_ListItemSwipeAction_Collapse(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Create an edge object for position attribute.\n\n @return A pointer to the edge object.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_Create() -> *mut ArkUI_PositionEdges;
}
extern "C" {
    #[doc = " @brief Creates a deep copy of an edge object for position attribute.\n\n @param edges A pointer to an edge object.\n @return A pointer to the new edge object.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_Copy(
        edges: *const ArkUI_PositionEdges,
    ) -> *mut ArkUI_PositionEdges;
}
extern "C" {
    #[doc = " @brief Dispose an edge object for position attribute.\n\n @param edges Pointer to the edge object to be disposed.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_Dispose(edges: *mut ArkUI_PositionEdges);
}
extern "C" {
    #[doc = " @brief Sets the top edge of an edge object for position attribute.\n\n @param edges Pointer to the edge object.\n @param value The distance of top edge to the corresponding edge of parent container, in vp.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_SetTop(edges: *mut ArkUI_PositionEdges, value: f32);
}
extern "C" {
    #[doc = " @brief Gets the top edge of an edge object for position attribute.\n\n @param edges Pointer to the edge object.\n @param value The distance of top edge to the corresponding edge of parent container, in vp.\n @return Returns the result code.\n      Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n      Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the parameter is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_GetTop(edges: *mut ArkUI_PositionEdges, value: *mut f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the left edge of an edge object for position attribute.\n\n @param edges Pointer to the edge object.\n @param value The distance of left edge to the corresponding edge of parent container, in vp.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_SetLeft(edges: *mut ArkUI_PositionEdges, value: f32);
}
extern "C" {
    #[doc = " @brief Gets the left edge of an edge object for position attribute.\n\n @param edges Pointer to the edge object.\n @param value The distance of left edge to the corresponding edge of parent container, in vp.\n @return Returns the result code.\n      Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n      Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the parameter is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_GetLeft(edges: *mut ArkUI_PositionEdges, value: *mut f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the bottom edge of an edge object for position attribute.\n\n @param edges Pointer to the edge object.\n @param value The distance of bottom edge to the corresponding edge of parent container, in vp.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_SetBottom(edges: *mut ArkUI_PositionEdges, value: f32);
}
extern "C" {
    #[doc = " @brief Gets the bottom edge of an edge object for position attribute.\n\n @param edges Pointer to the edge object.\n @param value The distance of bottom edge to the corresponding edge of parent container, in vp.\n @return Returns the result code.\n      Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n      Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the parameter is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_GetBottom(
        edges: *mut ArkUI_PositionEdges,
        value: *mut f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the right edge of an edge object for position attribute.\n\n @param edges Pointer to the edge object.\n @param value The distance of right edge to the corresponding edge of parent container, in vp.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_SetRight(edges: *mut ArkUI_PositionEdges, value: f32);
}
extern "C" {
    #[doc = " @brief Gets the right edge of an edge object for position attribute.\n\n @param edges Pointer to the edge object.\n @param value The distance of right edge to the corresponding edge of parent container, in vp.\n @return Returns the result code.\n      Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n      Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the parameter is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PositionEdges_GetRight(edges: *mut ArkUI_PositionEdges, value: *mut f32)
        -> i32;
}
extern "C" {
    #[doc = " @brief Create a policy object for PixelRound attribute.\n\n @return A pointer to the policy object.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_Create() -> *mut ArkUI_PixelRoundPolicy;
}
extern "C" {
    #[doc = " @brief Dispose a policy object for PixelRound attribute.\n\n @param policy Pointer to the policy object to be disposed.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_Dispose(policy: *mut ArkUI_PixelRoundPolicy);
}
extern "C" {
    #[doc = " @brief Sets the top edge of a policy object for PixelRound attribute.\n\n @param policy Pointer to the policy object.\n @param value The CalcPolicy of top edge.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_SetTop(
        policy: *mut ArkUI_PixelRoundPolicy,
        value: ArkUI_PixelRoundCalcPolicy,
    );
}
extern "C" {
    #[doc = " @brief Gets the top edge of a policy object for PixelRound attribute.\n\n @param policy Pointer to the policy object.\n @param value The CalcPolicy of top edge.\n @return Returns the result code.\n      Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n      Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the parameter is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_GetTop(
        policy: *mut ArkUI_PixelRoundPolicy,
        value: *mut ArkUI_PixelRoundCalcPolicy,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the start edge of a policy object for PixelRound attribute.\n\n @param policy Pointer to the policy object.\n @param value The CalcPolicy of start edge.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_SetStart(
        policy: *mut ArkUI_PixelRoundPolicy,
        value: ArkUI_PixelRoundCalcPolicy,
    );
}
extern "C" {
    #[doc = " @brief Gets the start edge of a policy object for PixelRound attribute.\n\n @param policy Pointer to the policy object.\n @param value The CalcPolicy of start edge.\n @return Returns the result code.\n      Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n      Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the parameter is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_GetStart(
        policy: *mut ArkUI_PixelRoundPolicy,
        value: *mut ArkUI_PixelRoundCalcPolicy,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the bottom edge of a policy object for PixelRound attribute.\n\n @param policy Pointer to the policy object.\n @param value The CalcPolicy of bottom edge.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_SetBottom(
        policy: *mut ArkUI_PixelRoundPolicy,
        value: ArkUI_PixelRoundCalcPolicy,
    );
}
extern "C" {
    #[doc = " @brief Gets the bottom edge of a policy object for PixelRound attribute.\n\n @param policy Pointer to the policy object.\n @param value The CalcPolicy of bottom edge.\n @return Returns the result code.\n      Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n      Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the parameter is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_GetBottom(
        policy: *mut ArkUI_PixelRoundPolicy,
        value: *mut ArkUI_PixelRoundCalcPolicy,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the end edge of a policy object for PixelRound attribute.\n\n @param policy Pointer to the policy object.\n @param value The CalcPolicy of end edge.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_SetEnd(
        policy: *mut ArkUI_PixelRoundPolicy,
        value: ArkUI_PixelRoundCalcPolicy,
    );
}
extern "C" {
    #[doc = " @brief Gets the end edge of a policy object for PixelRound attribute.\n\n @param policy Pointer to the policy object.\n @param value The CalcPolicy of end edge.\n @return Returns the result code.\n      Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n      Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the parameter is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_PixelRoundPolicy_GetEnd(
        policy: *mut ArkUI_PixelRoundPolicy,
        value: *mut ArkUI_PixelRoundCalcPolicy,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TextMenuItem {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create an object of the text edit menu item.\n\n @return A pointer to the ArkUI_TextMenuItem.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_Create() -> *mut ArkUI_TextMenuItem;
}
extern "C" {
    #[doc = " @brief Dispose an object of the text edit menu options.\n\n @param textMenuItem Pointer to the ArkUI_TextMenuItem object to be disposed.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_Dispose(textMenuItem: *mut ArkUI_TextMenuItem);
}
extern "C" {
    #[doc = " @brief Set text menu item title.\n\n @param item The text menu item.\n @param content The name of the text menu item, which defaults to an empty string. The string will copy to framework.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_SetContent(
        item: *mut ArkUI_TextMenuItem,
        content: *const ::std::os::raw::c_char,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get text menu item title.\n\n @param item The text menu item object.\n @param buffer The buffer of the text menu content, memory space needs to be allocated by the developer.\n @param bufferSize The name of the text menu item, which defaults to an empty string;\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_GetContent(
        item: *const ArkUI_TextMenuItem,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set text menu item icon.\n\n @param item The text menu item.\n @param icon The text menu item icon resource, which defaults to an empty string. The string will copy to framework.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_SetIcon(
        item: *mut ArkUI_TextMenuItem,
        icon: *const ::std::os::raw::c_char,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get text menu item icon.\n\n @param item The text menu item object\n @param buffer The buffer of the text menu content, memory space needs to be allocated by the developer.\n @param bufferSize The icon of the text menu item, which defaults to an empty string;\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_GetIcon(
        item: *const ArkUI_TextMenuItem,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set text menu item label info for keyboard shortcut.\n\n @param item The text menu item.\n @param labelInfo The text menu item shortcut displays, which defaults to an empty string.\n      The string will copy to framework.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_SetLabelInfo(
        item: *mut ArkUI_TextMenuItem,
        labelInfo: *const ::std::os::raw::c_char,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get text menu item label info for keyboard shortcut..\n\n @param item The text menu item object\n @param buffer The buffer of the text menu content, memory space needs to be allocated by the developer.\n @param bufferSize The shortcuts of the text menu item, which defaults to an empty string;\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_GetLabelInfo(
        item: *const ArkUI_TextMenuItem,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set text menu item id.\n\n @param item The text menu item.\n @param id The text menu id.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_SetId(item: *mut ArkUI_TextMenuItem, id: i32) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get text menu item id.\n\n @param item The text menu item object\n @param id The text menu item id;\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItem_GetId(
        item: *const ArkUI_TextMenuItem,
        id: *mut i32,
    ) -> ArkUI_ErrorCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TextMenuItemArray {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Get the size of text menu items.\n\n @param items The text menu items.\n @param size The size of text menu items.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItemArray_GetSize(
        items: *mut ArkUI_TextMenuItemArray,
        size: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get text menu item at index.\n\n @param items The text menu items.\n @param index The index of text menu items.\n @param item The text menu item at index of array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItemArray_GetItem(
        items: *mut ArkUI_TextMenuItemArray,
        index: i32,
        item: *mut *mut ArkUI_TextMenuItem,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Insert text menu item at index.\n\n @param items The text menu items.\n @param item The text menu item at index of array. The item will copy by framework.\n @param index The index of text menu items.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItemArray_Insert(
        items: *mut ArkUI_TextMenuItemArray,
        item: *mut ArkUI_TextMenuItem,
        index: i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Erase text menu item at index.\n\n @param items The text menu items.\n @param index The index of text menu items.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItemArray_Erase(
        items: *mut ArkUI_TextMenuItemArray,
        index: i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Clear all the items.\n\n @param items The text menu items.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextMenuItemArray_Clear(items: *mut ArkUI_TextMenuItemArray)
        -> ArkUI_ErrorCode;
}
#[doc = " Indicates the TextMenuItemId to copy and delete the currently selected text."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_CUT: ArkUI_TextMenuItemId = 0;
#[doc = " Indicates the TextMenuItemId to copy the currently selected text to the clipboard."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_COPY: ArkUI_TextMenuItemId = 1;
#[doc = " Indicates the TextMenuItemId to copy the current contents of the clipboard into the text view."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_PASTE: ArkUI_TextMenuItemId = 2;
#[doc = " Indicates the TextMenuItemId to select all text in a text view."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_SELECT_ALL: ArkUI_TextMenuItemId = 3;
#[doc = " Indicates the TextMenuItemId for collaboration service menu items."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_COLLABORATION_SERVICE: ArkUI_TextMenuItemId =
    4;
#[doc = " Indicates the TextMenuItemId to recognize the text in the picture and input it into the text view."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_CAMERA_INPUT: ArkUI_TextMenuItemId = 5;
#[doc = " Indicates the TextMenuItemId to help with text creation by invoking large models."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_AI_WRITER: ArkUI_TextMenuItemId = 6;
#[doc = " Indicates the TextMenuItemId to translate the selected content."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_TRANSLATE: ArkUI_TextMenuItemId = 7;
#[doc = " Indicates the TextMenuItemId to search the selected content."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_SEARCH: ArkUI_TextMenuItemId = 8;
#[doc = " Indicates the TextMenuItemId to share the selected content."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_SHARE: ArkUI_TextMenuItemId = 9;
#[doc = " Indicates the TextMenuItemId to open url."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_URL: ArkUI_TextMenuItemId = 10;
#[doc = " Indicates the TextMenuItemId to open email."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_EMAIL: ArkUI_TextMenuItemId = 11;
#[doc = " Indicates the TextMenuItemId to call the phone number."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_PHONE_NUMBER: ArkUI_TextMenuItemId = 12;
#[doc = " Indicates the TextMenuItemId to open map."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_ADDRESS: ArkUI_TextMenuItemId = 13;
#[doc = " Indicates the TextMenuItemId to open calendar."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_DATA_TIME: ArkUI_TextMenuItemId = 14;
#[doc = " Indicates the TextMenuItemId for asking AI."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_ASK_AI: ArkUI_TextMenuItemId = 15;
#[doc = " Inclusive begin of app-reserved ID range."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_APP_RESERVED_BEGIN: ArkUI_TextMenuItemId =
    10000;
#[doc = " Inclusive end of app-reserved ID range."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextMenuItemId_ARKUI_TEXT_MENU_ITEM_ID_APP_RESERVED_END: ArkUI_TextMenuItemId =
    20000;
#[doc = " @brief Enumerates the text menu item id.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_TextMenuItemId = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TextEditMenuOptions {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create an object of the text edit menu options.\n\n @return A pointer to the ArkUI_TextEditMenuOptions.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextEditMenuOptions_Create() -> *mut ArkUI_TextEditMenuOptions;
}
extern "C" {
    #[doc = " @brief Dispose an object of the text edit menu options.\n\n @param editMenuOptions Pointer to the ArkUI_TextEditMenuOptions object to be disposed.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextEditMenuOptions_Dispose(editMenuOptions: *mut ArkUI_TextEditMenuOptions);
}
#[doc = " The text menu create callback function.\n\n @param items The framework creates and owns the array.\n     In callback: the developer can modify the array by calling {@link OH_ArkUI_TextMenuItemArray_Insert},\n     {@link OH_ArkUI_TextMenuItemArray_Erase}, or similar APIs.\n     The developer must not free the array instance.\n @param userData User defined data.\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_TextCreateMenuCallback = ::std::option::Option<
    unsafe extern "C" fn(
        items: *mut ArkUI_TextMenuItemArray,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " The text menu prepare callback function.\n\n @param items The framework creates and owns the array.\n     In callback: the developer can modify the array by calling {@link OH_ArkUI_TextMenuItemArray_Insert},\n     {@link OH_ArkUI_TextMenuItemArray_Erase}, or similar APIs.\n     The developer must not free the array instance.\n @param userData User defined data.\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_TextPrepareMenuCallback = ::std::option::Option<
    unsafe extern "C" fn(
        items: *mut ArkUI_TextMenuItemArray,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " The text menu item click callback function.\n\n @param item The menu item click.\n @param start The start offset of the selected content.\n @param end The end offset of the selected content.\n @param userData The user data.\n @return bool Return True, the event is consumed, false otherwise.\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_TextMenuItemClickCallback = ::std::option::Option<
    unsafe extern "C" fn(
        item: *const ArkUI_TextMenuItem,
        start: i32,
        end: i32,
        userData: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " @brief Set the event to be called when text menu create.\n\n @param editMenuOptions Pointer to the ArkUI_TextEditMenuOptions object.\n @param userData The user data.\n @param cb The create callback function.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextEditMenuOptions_RegisterOnCreateMenuCallback(
        editMenuOptions: *mut ArkUI_TextEditMenuOptions,
        userData: *mut ::std::os::raw::c_void,
        cb: ArkUI_TextCreateMenuCallback,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set the event to be called when menu prepare.\n\n @param editMenuOptions Pointer to the ArkUI_TextEditMenuOptions object.\n @param userData The user data.\n @param cb The prepare callback function.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextEditMenuOptions_RegisterOnPrepareMenuCallback(
        editMenuOptions: *mut ArkUI_TextEditMenuOptions,
        userData: *mut ::std::os::raw::c_void,
        cb: ArkUI_TextPrepareMenuCallback,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set the event to be called when menu item click.\n\n @param editMenuOptions Pointer to the ArkUI_TextEditMenuOptions object.\n @param userData The user data.\n @param cb The menu item click callback function.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextEditMenuOptions_RegisterOnMenuItemClickCallback(
        editMenuOptions: *mut ArkUI_TextEditMenuOptions,
        userData: *mut ::std::os::raw::c_void,
        cb: ArkUI_TextMenuItemClickCallback,
    ) -> ArkUI_ErrorCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TextSelectionMenuOptions {
    _unused: [u8; 0],
}
#[doc = " The span type only contains text."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextSpanType_ARKUI_TEXT_SPAN_TYPE_TEXT: ArkUI_TextSpanType = 0;
#[doc = " The span type only contains image."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextSpanType_ARKUI_TEXT_SPAN_TYPE_IMAGE: ArkUI_TextSpanType = 1;
#[doc = " The span type contains both text and image."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextSpanType_ARKUI_TEXT_SPAN_TYPE_MIXED: ArkUI_TextSpanType = 2;
#[doc = " When no other types are explicitly specified, this type will be matched.\n When this type is registered but TEXT, IMAGE, or MIXED types are not registered,\n this type will be triggered and displayed for those registered types."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextSpanType_ARKUI_TEXT_SPAN_TYPE_DEFAULT: ArkUI_TextSpanType = 3;
#[doc = " @brief Enumerates the text span type.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_TextSpanType = u32;
#[doc = " The response type of right click."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextResponseType_ARKUI_TEXT_RESPONSE_TYPE_RIGHT_CLICK: ArkUI_TextResponseType = 0;
#[doc = " The response type of long press."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextResponseType_ARKUI_TEXT_RESPONSE_TYPE_LONG_PRESS: ArkUI_TextResponseType = 1;
#[doc = " The response type of select by mouse."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextResponseType_ARKUI_TEXT_RESPONSE_TYPE_SELECT: ArkUI_TextResponseType = 2;
#[doc = " When no other types are explicitly specified, this type will be matched.\n When this type is registered but RIGHT_CLICK, LONG_PRESS, or SELECT types are not registered,\n this type will be triggered and displayed for right-click, long press, and mouse selection actions."]
#[cfg(feature = "api-22")]
pub const ArkUI_TextResponseType_ARKUI_TEXT_RESPONSE_TYPE_DEFAULT: ArkUI_TextResponseType = 3;
#[doc = " @brief Enumerates the text response type.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_TextResponseType = u32;
extern "C" {
    #[doc = " @brief Create an object of the text selection menu options.\n\n @return A pointer to the ArkUI_TextSelectionMenuOptions.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_Create() -> *mut ArkUI_TextSelectionMenuOptions;
}
extern "C" {
    #[doc = " @brief Dispose an object of the text selection menu options.\n\n @param selectionMenuOptions Pointer to the ArkUI_TextSelectionMenuOptions object to be disposed.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_Dispose(
        selectionMenuOptions: *mut ArkUI_TextSelectionMenuOptions,
    );
}
extern "C" {
    #[doc = " @brief Sets the recognition types of a configuration object for selected text recognition.\n\n @param selectionMenuOptions Pointer to the ArkUI_TextSelectionMenuOptions object.\n @param textSpanType The span type of {@link ArkUI_TextSpanType}.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_SetSpanType(
        selectionMenuOptions: *mut ArkUI_TextSelectionMenuOptions,
        textSpanType: ArkUI_TextSpanType,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Gets the span type select menu options.\n\n @param selectionMenuOptions Pointer to the ArkUI_TextSelectionMenuOptions object.\n @param spanType the text span type {@link ArkUI_TextSpanType}.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_GetSpanType(
        selectionMenuOptions: *mut ArkUI_TextSelectionMenuOptions,
        spanType: *mut ArkUI_TextSpanType,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set custom text menu node of text.\n\n @param selectionMenuOptions Pointer to the ArkUI_TextSelectionMenuOptions object.\n @param node The custom menu node.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_SetContentNode(
        selectionMenuOptions: *mut ArkUI_TextSelectionMenuOptions,
        node: ArkUI_NodeHandle,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get custom text menu node of text.\n\n @param selectionMenuOptions Pointer to the ArkUI_TextSelectionMenuOptions object.\n @param node The custom menu node.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_GetContentNode(
        selectionMenuOptions: *mut ArkUI_TextSelectionMenuOptions,
        node: *mut ArkUI_NodeHandle,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets the recognition types of a configuration object for selected text recognition.\n\n @param selectionMenuOptions Pointer to the ArkUI_TextSelectionMenuOptions object.\n @param responseType The response type of {@link ArkUI_TextResponseType}.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_SetResponseType(
        selectionMenuOptions: *mut ArkUI_TextSelectionMenuOptions,
        responseType: ArkUI_TextResponseType,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Gets the response type select menu options.\n\n @param selectionMenuOptions Pointer to the ArkUI_TextSelectionMenuOptions object.\n @param responseType The text response type {@link ArkUI_TextResponseType}.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_GetResponseType(
        selectionMenuOptions: *mut ArkUI_TextSelectionMenuOptions,
        responseType: *mut ArkUI_TextResponseType,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set the event to be called when selection menu show.\n\n @param selectionMenuOptions Pointer to the ArkUI_TextSelectionMenuOptions object.\n @param userData The user data.\n @param callback The callback function of menu show.\n     start The start offset of the selected content.\n     end The end offset of the selected content.\n     userData The user data.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_RegisterOnMenuShowCallback(
        selectionMenuOptions: *mut ArkUI_TextSelectionMenuOptions,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(start: i32, end: i32, userData: *mut ::std::os::raw::c_void),
        >,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set the event to be called when selection menu hide.\n\n @param selectionMenuOptions Pointer to the ArkUI_TextSelectionMenuOptions object.\n @param userData The user data.\n @param callback The callback function of menu hide.\n     start The start offset of the selected content.\n     end The end offset of the selected content.\n     userData The user data.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextSelectionMenuOptions_RegisterOnMenuHideCallback(
        selectionMenuOptions: *mut ArkUI_TextSelectionMenuOptions,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(start: i32, end: i32, userData: *mut ::std::os::raw::c_void),
        >,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a configuration object for textField's counter.\n\n @return A pointer to the configuration object.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_ShowCounterConfig_Create() -> *mut ArkUI_ShowCounterConfig;
}
extern "C" {
    #[doc = " @brief Disposes a configuration object for textField's counter.\n\n @param config Pointer to the configuration object to be disposed.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_ShowCounterConfig_Dispose(config: *mut ArkUI_ShowCounterConfig);
}
extern "C" {
    #[doc = " @brief Sets the color of counter when textField hasn't wanted to exceed the maximum character count.\n\n @param config Pointer to the configuration object to be modified.\n @param color The color of the counter when textField hasn't wanted to exceed the maximum character count, in 0xARGB format.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_ShowCounterConfig_SetCounterTextColor(
        config: *mut ArkUI_ShowCounterConfig,
        color: u32,
    );
}
extern "C" {
    #[doc = " @brief Sets the color of counter when textField wants to exceed the maximum character count.\n\n @param config Pointer to the configuration object to be modified.\n @param color The color of the counter when textField wants to exceed the maximum character count, in 0xARGB format.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_ShowCounterConfig_SetCounterTextOverflowColor(
        config: *mut ArkUI_ShowCounterConfig,
        color: u32,
    );
}
extern "C" {
    #[doc = " @brief Gets the color of counter when textField hasn't wanted to exceed the maximum character count.\n\n @param config Pointer to the configuration object.\n @return Returns the color of the counter when textField hasn't wanted to exceed the maximum character count, in 0xARGB format.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_ShowCounterConfig_GetCounterTextColor(
        config: *mut ArkUI_ShowCounterConfig,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Gets the color of counter when textField wants to exceed the maximum character count.\n\n @param config Pointer to the configuration object.\n @return Returns the color of the counter when textField wants to exceed the maximum character count, in 0xARGB format.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_ShowCounterConfig_GetCounterTextOverflowColor(
        config: *mut ArkUI_ShowCounterConfig,
    ) -> u32;
}
#[doc = " @brief Defines the region of the image source to decode.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_Region {
    #[doc = " X coordinate of the start point, in pixels."]
    pub x: u32,
    #[doc = " Y coordinate of the start point, in pixels."]
    pub y: u32,
    #[doc = " Width of the region, in pixels."]
    pub width: u32,
    #[doc = " Height of the region, in pixels."]
    pub height: u32,
}
#[doc = " @brief Defines the area of the image pixels to read or write.\n\n @since 22"]
#[cfg(feature = "api-22")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_PositionArea {
    #[doc = " Image pixels data that will be read or written."]
    pub pixels: *mut u8,
    #[doc = " Length of the image pixels data."]
    pub pixelsSize: usize,
    #[doc = " Offset for data reading or writing."]
    pub offset: u32,
    #[doc = " Number of bytes per row of the region."]
    pub stride: u32,
    #[doc = " Region to read or write."]
    pub region: Image_Region,
}
#[doc = " @brief Defines the image scale ratio.\n\n @since 22"]
#[cfg(feature = "api-22")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_Scale {
    #[doc = " Scale ratio on the x-axis."]
    pub x: f32,
    #[doc = " Scale ratio on the y-axis."]
    pub y: f32,
}
#[doc = " @brief Defines the region of the image source to decode.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_String {
    #[doc = " data for string type"]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = " data lenth for string type"]
    pub size: usize,
}
#[doc = " @brief Define a PictureMetadata struct type, used for picture metadata.\n\n @since 13"]
#[cfg(feature = "api-13")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PictureMetadata {
    _unused: [u8; 0],
}
#[doc = " operation success"]
pub const Image_ErrorCode_IMAGE_SUCCESS: Image_ErrorCode = 0;
#[doc = " invalid parameter"]
pub const Image_ErrorCode_IMAGE_BAD_PARAMETER: Image_ErrorCode = 401;
#[doc = " unsupported mime type"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_MIME_TYPE: Image_ErrorCode = 7600101;
#[doc = " unknown mime type"]
pub const Image_ErrorCode_IMAGE_UNKNOWN_MIME_TYPE: Image_ErrorCode = 7600102;
#[doc = " too large data or image"]
pub const Image_ErrorCode_IMAGE_TOO_LARGE: Image_ErrorCode = 7600103;
#[doc = " @error DMA memory does not exist"]
pub const Image_ErrorCode_IMAGE_DMA_NOT_EXIST: Image_ErrorCode = 7600173;
#[doc = " @error DMA operation failed"]
pub const Image_ErrorCode_IMAGE_DMA_OPERATION_FAILED: Image_ErrorCode = 7600174;
#[doc = " unsupported operations"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_OPERATION: Image_ErrorCode = 7600201;
#[doc = " unsupported metadata"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_METADATA: Image_ErrorCode = 7600202;
#[doc = " unsupported conversion"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_CONVERSION: Image_ErrorCode = 7600203;
#[doc = " invalid region"]
pub const Image_ErrorCode_IMAGE_INVALID_REGION: Image_ErrorCode = 7600204;
#[doc = "  @error unsupported memory format\n  @since 13"]
#[cfg(feature = "api-13")]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_MEMORY_FORMAT: Image_ErrorCode = 7600205;
#[doc = " @error Invalid parameter.\n @since 19"]
#[cfg(feature = "api-19")]
pub const Image_ErrorCode_IMAGE_INVALID_PARAMETER: Image_ErrorCode = 7600206;
#[doc = " @error Unsupported data format\n @since 22"]
#[cfg(feature = "api-22")]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_DATA_FORMAT: Image_ErrorCode = 7600207;
#[doc = " failed to allocate memory"]
pub const Image_ErrorCode_IMAGE_ALLOC_FAILED: Image_ErrorCode = 7600301;
#[doc = " memory copy failed"]
pub const Image_ErrorCode_IMAGE_COPY_FAILED: Image_ErrorCode = 7600302;
#[doc = " @error memory lock or unlock failed\n @since 15"]
#[cfg(feature = "api-15")]
pub const Image_ErrorCode_IMAGE_LOCK_UNLOCK_FAILED: Image_ErrorCode = 7600303;
#[doc = " @error Initialization failed\n @since 22"]
#[cfg(feature = "api-22")]
pub const Image_ErrorCode_IMAGE_INIT_FAILED: Image_ErrorCode = 7600304;
#[doc = " @error Create PixelMap failed\n @since 22"]
#[cfg(feature = "api-22")]
pub const Image_ErrorCode_IMAGE_CREATE_PIXELMAP_FAILED: Image_ErrorCode = 7600305;
#[doc = " @error unsupported allocator mode, e.g., use share memory to create a HDR image as only\n DMA supported hdr metadata.\n @since 20"]
#[cfg(feature = "api-20")]
pub const Image_ErrorCode_IMAGE_ALLOCATOR_MODE_UNSUPPORTED: Image_ErrorCode = 7600501;
#[doc = " unknown error"]
pub const Image_ErrorCode_IMAGE_UNKNOWN_ERROR: Image_ErrorCode = 7600901;
#[doc = " decode data source exception"]
pub const Image_ErrorCode_IMAGE_BAD_SOURCE: Image_ErrorCode = 7700101;
#[doc = " @error unsupported mime type\n @since 15"]
#[cfg(feature = "api-15")]
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_MIME_TYPE: Image_ErrorCode = 7700102;
#[doc = " @error image to large\n @since 15"]
#[cfg(feature = "api-15")]
pub const Image_ErrorCode_IMAGE_SOURCE_TOO_LARGE: Image_ErrorCode = 7700103;
#[doc = " @error unsupported allocator type, e.g., use share memory to decode a HDR image as only\n DMA supported hdr metadata.\n @since 15"]
#[cfg(feature = "api-15")]
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_ALLOCATOR_TYPE: Image_ErrorCode = 7700201;
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_OPTIONS: Image_ErrorCode = 7700203;
#[doc = " @error Invalid parameter.\n @since 19"]
#[cfg(feature = "api-19")]
pub const Image_ErrorCode_IMAGE_SOURCE_INVALID_PARAMETER: Image_ErrorCode = 7700204;
#[doc = " decode failed"]
pub const Image_ErrorCode_IMAGE_DECODE_FAILED: Image_ErrorCode = 7700301;
#[doc = " @error memory allocation failed\n @since 15"]
#[cfg(feature = "api-15")]
pub const Image_ErrorCode_IMAGE_SOURCE_ALLOC_FAILED: Image_ErrorCode = 7700302;
#[doc = " @error Invalid parameter for ImagePacker.\n @since 19"]
#[cfg(feature = "api-19")]
pub const Image_ErrorCode_IMAGE_PACKER_INVALID_PARAMETER: Image_ErrorCode = 7800202;
#[doc = " encode failed"]
pub const Image_ErrorCode_IMAGE_ENCODE_FAILED: Image_ErrorCode = 7800301;
#[doc = " @error Invalid parameter for ImageReceiver.\n @since 20"]
#[cfg(feature = "api-20")]
pub const Image_ErrorCode_IMAGE_RECEIVER_INVALID_PARAMETER: Image_ErrorCode = 7900201;
#[doc = " @brief Enumerates the return values that may be used by the interface.\n\n @since 12"]
pub type Image_ErrorCode = u32;
#[doc = " EXIF metadata."]
#[cfg(feature = "api-13")]
pub const Image_MetadataType_EXIF_METADATA: Image_MetadataType = 1;
#[doc = " Fragment metadata."]
#[cfg(feature = "api-13")]
pub const Image_MetadataType_FRAGMENT_METADATA: Image_MetadataType = 2;
#[doc = " Metadata of a GIF image.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const Image_MetadataType_GIF_METADATA: Image_MetadataType = 5;
#[doc = " @brief Define the metadata type.\n\n @since 13"]
#[cfg(feature = "api-13")]
pub type Image_MetadataType = u32;
#[doc = " The system determines which memory to use to create the PixelMap.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const IMAGE_ALLOCATOR_MODE_IMAGE_ALLOCATOR_MODE_AUTO: IMAGE_ALLOCATOR_MODE = 0;
#[doc = " Use DMA buffer to create the PixelMap.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const IMAGE_ALLOCATOR_MODE_IMAGE_ALLOCATOR_MODE_DMA: IMAGE_ALLOCATOR_MODE = 1;
#[doc = " Use share memory to create the PixelMap.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const IMAGE_ALLOCATOR_MODE_IMAGE_ALLOCATOR_MODE_SHARED_MEMORY: IMAGE_ALLOCATOR_MODE = 2;
#[doc = " @brief Type of allocator used to allocate memory of a PixelMap.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type IMAGE_ALLOCATOR_MODE = u32;
extern "C" {
    #[doc = " @brief Creates a <b>PictureMetadata</b> object.\n\n @param metadataType The type of metadata.\n @param metadata The PictureMetadata pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_PictureMetadata_Create(
        metadataType: Image_MetadataType,
        metadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the property of picture metadata.\n\n @param metadata The PictureMetadata pointer will be operated.\n @param key The property's key.\n @param value The property's value.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_PictureMetadata_GetProperty(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set picture metadata property.\n\n @param metadata The PictureMetadata pointer will be operated.\n @param key The property's key.\n @param value The property's value.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_PictureMetadata_SetProperty(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the property of picture metadata. The output value.data is null-terminated.\n\n @param metadata Pointer to OH_PictureMetadata.\n @param key Pointer to property's key.\n @param value Pointer to property's value. Output parameter.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_INVALID_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_PictureMetadata_GetPropertyWithNull(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases this PictureMetadata object.\n\n @param metadata The PictureMetadata pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_PictureMetadata_Release(metadata: *mut OH_PictureMetadata) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains a clone of metadata.\n\n @param oldMetadata The PictureMetadata pointer will be operated.\n @param newMetadata The PictureMetadata pointer will be cloned.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n         {@link IMAGE_ALLOC_FAILED} memory alloc failed.\n         {@link IMAGE_COPY_FAILED} memory copy failed.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_PictureMetadata_Clone(
        oldMetadata: *mut OH_PictureMetadata,
        newMetadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
#[doc = " @brief Define a native buffer type, used for retrieving a native buffer.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_NativeBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_NativeColorSpaceManager {
    _unused: [u8; 0],
}
#[doc = " Nearest-neighbor interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_NONE:
    OH_PixelmapNative_AntiAliasingLevel = 0;
#[doc = " Bilinear interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_LOW:
    OH_PixelmapNative_AntiAliasingLevel = 1;
#[doc = " Bilinear interpolation algorithm with mipmap linear filtering"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_MEDIUM:
    OH_PixelmapNative_AntiAliasingLevel = 2;
#[doc = " Cubic interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_HIGH:
    OH_PixelmapNative_AntiAliasingLevel = 3;
#[doc = " @brief Defines the anti-aliasing level.\n\n @since 12"]
pub type OH_PixelmapNative_AntiAliasingLevel = u32;
#[doc = " Indicate the types of metadata that image needs to use."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_METADATA_TYPE: OH_Pixelmap_HdrMetadataKey = 0;
#[doc = " Static metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_STATIC_METADATA: OH_Pixelmap_HdrMetadataKey = 1;
#[doc = " Dynamic metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_DYNAMIC_METADATA: OH_Pixelmap_HdrMetadataKey = 2;
#[doc = " Gainmap metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_GAINMAP_METADATA: OH_Pixelmap_HdrMetadataKey = 3;
#[doc = " @brief Enumerates the HDR metadata types that need to be stored in Pixelmap.\n\n @since 12"]
pub type OH_Pixelmap_HdrMetadataKey = u32;
#[doc = " No metadata."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_NONE: OH_Pixelmap_HdrMetadataType = 0;
#[doc = " Indicates that metadata will be used for the base image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_BASE: OH_Pixelmap_HdrMetadataType = 1;
#[doc = " Indicates that metadata will be used for the gainmap image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_GAINMAP: OH_Pixelmap_HdrMetadataType = 2;
#[doc = " Indicates that metadata will be used for the alternate image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_ALTERNATE: OH_Pixelmap_HdrMetadataType = 3;
#[doc = " @brief Value for HDR_METADATA_TYPE.\n\n @since 12"]
pub type OH_Pixelmap_HdrMetadataType = u32;
#[doc = " @brief Value for HDR_STATIC_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrStaticMetadata {
    #[doc = " The X-coordinate of the primary colors. The length of the array is three. Store in the order of r, g, b."]
    pub displayPrimariesX: [f32; 3usize],
    #[doc = " The Y-coordinate of the primary colors. The length of the array is three. Store in the order of r, g, b."]
    pub displayPrimariesY: [f32; 3usize],
    #[doc = " The X-coordinate of the white point value."]
    pub whitePointX: f32,
    #[doc = " The Y-coordinate of the white point value."]
    pub whitePointY: f32,
    #[doc = " Max luminance."]
    pub maxLuminance: f32,
    #[doc = " Min luminance."]
    pub minLuminance: f32,
    #[doc = " Maximum brightness of displayed content."]
    pub maxContentLightLevel: f32,
    #[doc = " Maximum average brightness of displayed content."]
    pub maxFrameAverageLightLevel: f32,
}
#[doc = " @brief Value for HDR_DYNAMIC_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrDynamicMetadata {
    #[doc = " The value of dynamic metadata."]
    pub data: *mut u8,
    #[doc = " The length of dynamic metadata."]
    pub length: u32,
}
#[doc = " @brief Value for HDR_GAINMAP_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrGainmapMetadata {
    #[doc = " The version used by the writer."]
    pub writerVersion: u16,
    #[doc = " The minimum version a parser needs to understand."]
    pub miniVersion: u16,
    #[doc = " The number of gain map channels, with a value of 1 or 3."]
    pub gainmapChannelNum: u8,
    #[doc = " Indicate whether to use the color space of the base image."]
    pub useBaseColorFlag: bool,
    #[doc = " The baseline hdr headroom."]
    pub baseHeadroom: f32,
    #[doc = " The alternate hdr headroom."]
    pub alternateHeadroom: f32,
    #[doc = " The per-component max gain map values."]
    pub gainmapMax: [f32; 3usize],
    #[doc = " The per-component min gain map values."]
    pub gainmapMin: [f32; 3usize],
    #[doc = " The per-component gamma values."]
    pub gamma: [f32; 3usize],
    #[doc = " The per-component baseline offset."]
    pub baselineOffset: [f32; 3usize],
    #[doc = " The per-component alternate offset."]
    pub alternateOffset: [f32; 3usize],
}
#[doc = " @brief Value for HDR_METADATA_KEY. Corresponding relationship with HDR_METADATA_KEY.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrMetadataValue {
    #[doc = " The value corresponding to the HDR_METADATA_TYPE key"]
    pub type_: OH_Pixelmap_HdrMetadataType,
    #[doc = " The value corresponding to the HDR_STATIC_METADATA key"]
    pub staticMetadata: OH_Pixelmap_HdrStaticMetadata,
    #[doc = " The value corresponding to the HDR_DYNAMIC_METADATA key"]
    pub dynamicMetadata: OH_Pixelmap_HdrDynamicMetadata,
    #[doc = " The value corresponding to the HDR_GAINMAP_METADATA key"]
    pub gainmapMetadata: OH_Pixelmap_HdrGainmapMetadata,
}
#[doc = " @brief Defines the options used for creating a pixel map.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_InitializationOptions {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create a for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_Create(
        options: *mut *mut OH_Pixelmap_InitializationOptions,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get width number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param width the number of image width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetWidth(
        options: *mut OH_Pixelmap_InitializationOptions,
        width: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set width number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param width the number of image width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetWidth(
        options: *mut OH_Pixelmap_InitializationOptions,
        width: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get height number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param height the number of image height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetHeight(
        options: *mut OH_Pixelmap_InitializationOptions,
        height: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set height number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param height the number of image height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetHeight(
        options: *mut OH_Pixelmap_InitializationOptions,
        height: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelFormat: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param srcpixelFormat the number of image srcpixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetSrcPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        srcpixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param srcpixelFormat the number of image srcpixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetSrcPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        srcpixelFormat: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get rowStride for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param rowStride the rowStride of image buffer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if rowStride is null.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe options is released.\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetRowStride(
        options: *mut OH_Pixelmap_InitializationOptions,
        rowStride: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set rowStride number for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param rowStride the rowStride of image buffer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if rowStride does not match width.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe options is released.\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetRowStride(
        options: *mut OH_Pixelmap_InitializationOptions,
        rowStride: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get alphaType number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param alphaType the number of image alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetAlphaType(
        options: *mut OH_Pixelmap_InitializationOptions,
        alphaType: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set alphaType number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param alphaType the number of image alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetAlphaType(
        options: *mut OH_Pixelmap_InitializationOptions,
        alphaType: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get editable for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param editable The boolean value representing the editable status.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if options or editable is invalid.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_PixelmapInitializationOptions_GetEditable(
        options: *mut OH_Pixelmap_InitializationOptions,
        editable: *mut bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set editable for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param editable The boolean value representing the editable status.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if options is invalid.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_PixelmapInitializationOptions_SetEditable(
        options: *mut OH_Pixelmap_InitializationOptions,
        editable: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief delete InitializationOtions pointer.\n\n @param options The InitializationOtions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_Release(
        options: *mut OH_Pixelmap_InitializationOptions,
    ) -> Image_ErrorCode;
}
#[doc = " @brief Defines the pixel map information.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_ImageInfo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create imageinfo struct  .\n\n @param info The imageinfo pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_Create(info: *mut *mut OH_Pixelmap_ImageInfo) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get width number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param width The number of imageinfo width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetWidth(
        info: *mut OH_Pixelmap_ImageInfo,
        width: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get height number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param height The number of imageinfo height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetHeight(
        info: *mut OH_Pixelmap_ImageInfo,
        height: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get alphaMode number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param alphaMode The number of imageinfo alphaMode.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} info is nullptr, or alphaMode is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_PixelmapImageInfo_GetAlphaMode(
        info: *mut OH_Pixelmap_ImageInfo,
        alphaMode: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get rowStride number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param rowStride The number of imageinfo rowStride.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetRowStride(
        info: *mut OH_Pixelmap_ImageInfo,
        rowStride: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param pixelFormat The number of imageinfo pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetPixelFormat(
        info: *mut OH_Pixelmap_ImageInfo,
        pixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get alphaType number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param alphaType The number of imageinfo alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetAlphaType(
        info: *mut OH_Pixelmap_ImageInfo,
        alphaType: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get isHdr boolean for imageinfo struct.\n\n @param info The imageinfo pointer will be operated. Pointer connot be null.\n @param isHdr Whether the image has a high dynamic range.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetDynamicRange(
        info: *mut OH_Pixelmap_ImageInfo,
        isHdr: *mut bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Delete imageinfo struct pointer.\n\n @param info The imageinfo pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_Release(info: *mut OH_Pixelmap_ImageInfo) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a <b>PixelMap</b> object.\n\n @param data Color buffer in BGRA_8888 format.\n @param dataLength Color buffer size in BGRA_8888 format.\n @param options IPixel properties, including the alpha type, size, pixel format, and editable.\n @param pixelmap Pixelmap pointer for created.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_CreatePixelmap(
        data: *mut u8,
        dataLength: usize,
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a pixelmap based on options {@link OH_Pixelmap_InitializationOptions}, the memory type used by the\n pixelmap can be specified by allocatorType {@link IMAGE_ALLOCATOR_MODE}. By default, the system selects the memory\n type based on the image type, image size, platform capability, etc. When processing the pixelmap returned by this\n interface, please always consider the impact of stride.\n\n @param data Input color buffer in BGRA_8888 format by default.\n @param dataLength Length of input buffer in bytes.\n @param options Pixelmap initialization properties including size, pixel format, alpha type, and editable flags.\n @param allocator Indicate which memory type will be used by the returned pixelmap.\n @param pixelmap Output parameter receiving the created pixelmap object pointer.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If the param is nullptr or invalid.\n         {@link IMAGE_TOO_LARGE} too large data or image.\n         {@link IMAGE_UNSUPPORTED_OPERATION} unsupported operations.\n         {@link IMAGE_DMA_OPERATION_FAILED} DMA operation failed.\n         {@link IMAGE_ALLOCATOR_MODE_UNSUPPORTED} unsupported allocator mode, e.g.,\n         use share memory to create a HDR image as only DMA supported hdr metadata.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_PixelmapNative_CreatePixelmapUsingAllocator(
        data: *mut u8,
        dataLength: usize,
        options: *mut OH_Pixelmap_InitializationOptions,
        allocator: IMAGE_ALLOCATOR_MODE,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert a native <b>PixelMap</b> object to <b>PixelMap</b> napi object.\n\n @param env Indicates the NAPI environment pointer.\n @param pixelmapNative Indicates a pointer to the <b>PixelMap</b> object created at the native layer.\n @param pixelmapNapi the <b>PixelMap</b> pointer will be converted.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} pixelmapNative is nullptr\n @since 12"]
    pub fn OH_PixelmapNative_ConvertPixelmapNativeToNapi(
        env: napi_env,
        pixelmapNative: *mut OH_PixelmapNative,
        pixelmapNapi: *mut napi_value,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert a <b>PixelMap</b> napi object to native <b>PixelMap</b> object.\n\n @param env Indicates the NAPI environment pointer.\n @param pixelmapNapi Indicates napi <b>PixelMap</b> object.\n @param pixelmapNative Indicates native <b>PixelMap</b> pointer to created.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} pixelmapNative is nullptr, or pixelmapNapi is not a PixelMap\n @since 12"]
    pub fn OH_PixelmapNative_ConvertPixelmapNativeFromNapi(
        env: napi_env,
        pixelmapNapi: napi_value,
        pixelmapNative: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Reads data of this pixel map to an Buffer. If this pixel map is created in the BGRA_8888 format,\n the data read is the same as the original data.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param destination Buffer to which the image pixel map data will be written.\n @param bufferSize Buffer size to which the image pixel map data will be written.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_ReadPixels(
        pixelmap: *mut OH_PixelmapNative,
        destination: *mut u8,
        bufferSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Reads image data in an Buffer and writes the data to a Pixelmap object.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param source Buffer from which the image data will be read.\n @param bufferSize Buffer size from which the image data will be read.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_WritePixels(
        pixelmap: *mut OH_PixelmapNative,
        source: *mut u8,
        bufferSize: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Reads data from a certain area of the PixelMap to a buffer. The resulting data will be in BGRA_8888 format.\n\n @param pixelmap The PixelMap to be read.\n @param area Area of the PixelMap to read the data. Data will be read and copied into area->pixels.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If any parameter is invalid, e.g. pixelmap or area is incorrect.\n         {@link IMAGE_UNKNOWN_ERROR} Internal unknown error, e.g. unsupported pixel format.\n @see OH_PixelmapNative\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_PixelmapNative_ReadPixelsFromArea(
        pixelmap: *mut OH_PixelmapNative,
        area: *mut Image_PositionArea,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Writes data from a buffer to a certain area of the PixelMap. The source data should be in BGRA_8888 format.\n\n @param pixelmap The PixelMap to be written.\n @param area Area of the PixelMap to write the data.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If any parameter is invalid, e.g. pixelmap or area is incorrect.\n         {@link IMAGE_UNSUPPORTED_OPERATION} If the PixelMap is not editable.\n         {@link IMAGE_UNKNOWN_ERROR} Internal unknown error, e.g. unsupported pixel format.\n @see OH_PixelmapNative\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_PixelmapNative_WritePixelsToArea(
        pixelmap: *mut OH_PixelmapNative,
        area: *mut Image_PositionArea,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get argb pixel buffer from pixelmap.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param destination Buffer to which the image pixel map data will be written.\n @param bufferSize Buffer size to which the image pixel map data will be written.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, destination and bufferSize are incorrect.\n         {@link IMAGE_UNSUPPORTED_CONVERSION} If format does not support conversion to argb or conversion failed.\n         {@link IMAGE_ALLOC_FAILED} If device has no memory.\n         {@link IMAGE_COPY_FAILED} If memory copy failed.\n @see OH_PixelmapNative\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_PixelmapNative_GetArgbPixels(
        pixelmap: *mut OH_PixelmapNative,
        destination: *mut u8,
        bufferSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert {@link OH_PixelmapNative} to standard dynamic range.\n\n @param pixelmap The Pixelmap pointer will be operated. Pointer connot be null.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n returns {@link Image_ErrorCode} IMAGE_UNSUPPORTED_OPERATION - Unsupported operation.Pixelmap can't be converted.\n @since 12"]
    pub fn OH_PixelmapNative_ToSdr(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains pixel map information of this image.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param imageInfo Indicates the pointer to the image information.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_GetImageInfo(
        pixelmap: *mut OH_PixelmapNative,
        imageInfo: *mut OH_Pixelmap_ImageInfo,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets an opacity rate for this image pixel map.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param rate Opacity rate to set. The value ranges from 0 to 1.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Opacity(
        pixelmap: *mut OH_PixelmapNative,
        rate: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Scales this image based on the input width and height.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Scale(
        pixelmap: *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Scales this image based on the input width and height with anti-aliasing.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @param level The anti-aliasing algorithm to be used.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, x and y are incorrect.\n returns {@link Image_ErrorCode} IMAGE_TOO_LARGE - if image is too large.\n returns {@link Image_ErrorCode} IMAGE_ALLOC_FAILED - if device has no memory.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe source pixelmap is released.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_ScaleWithAntiAliasing(
        pixelmap: *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
        level: OH_PixelmapNative_AntiAliasingLevel,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Create a scaled pixelmap based on the source pixelmap and the input width and height.\n\n @param srcPixelmap The source native pixelmap.\n @param dstPixelmap The destination native pixelmap for create.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} If the param is nullptr or invalid.\n @see OH_PixelmapNative\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_PixelmapNative_CreateScaledPixelMap(
        srcPixelmap: *mut OH_PixelmapNative,
        dstPixelmap: *mut *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Create a scaled pixelmap based on the source pixelmap and the input width and height with anti-aliasing.\n\n @param srcPixelmap The source native pixelmap.\n @param dstPixelmap The destination native pixelmap for create.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @param level The anti-aliasing algorithm to be used.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} If the param is nullptr or invalid.\n         {@link IMAGE_TOO_LARGE} If image is too large.\n         {@link IMAGE_ALLOC_FAILED} If device has no memory.\n @see OH_PixelmapNative\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_PixelmapNative_CreateScaledPixelMapWithAntiAliasing(
        srcPixelmap: *mut OH_PixelmapNative,
        dstPixelmap: *mut *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
        level: OH_PixelmapNative_AntiAliasingLevel,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Translates this image based on the input coordinates.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param x The distance to be translate in the X direction.\n @param y The distance to be translate in the Y direction.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Translate(
        pixelmap: *mut OH_PixelmapNative,
        x: f32,
        y: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a PixelMap with only alpha channel from the source PixelMap.\n\n @param srcPixelmap The source PixelMap.\n @param dstPixelmap The target PixelMap to be created.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If any parameter is invalid, e.g. srcPixelmap or dstPixelmap is incorrect.\n @see OH_PixelmapNative\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_PixelmapNative_CreateAlphaPixelmap(
        srcPixelmap: *mut OH_PixelmapNative,
        dstPixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Clones a PixelMap from the source PixelMap.\n\n @param srcPixelmap The source PixelMap to be cloned.\n @param dstPixelmap The target PixelMap to be created.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If any parameter is invalid, e.g. srcPixelmap or dstPixelmap is incorrect.\n         {@link IMAGE_UNSUPPORTED_DATA_FORMAT} If the pixel format is unsupported.\n         {@link IMAGE_TOO_LARGE} If the PixelMap size is too large.\n         {@link IMAGE_INIT_FAILED} If the PixelMap initialization failed.\n         {@link IMAGE_ALLOC_FAILED} If the copying of PixelMap data failed.\n @see OH_PixelmapNative\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_PixelmapNative_Clone(
        srcPixelmap: *mut OH_PixelmapNative,
        dstPixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a cropped and then scaled PixelMap based on the source PixelMap.\n\n @param srcPixelmap The source PixelMap.\n @param region The crop region.\n @param scale The scale ratio of width and height.\n @param level The anti-aliasing algorithm to be used.\n @param dstPixelmap The target PixelMap to be created.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If any parameter is invalid, e.g. srcPixelmap, region, scale, or dstPixelmap is\n                                     incorrect.\n         {@link IMAGE_UNSUPPORTED_DATA_FORMAT} If the pixel format is unsupported.\n         {@link IMAGE_TOO_LARGE} If the PixelMap size is too large.\n         {@link IMAGE_INIT_FAILED} If the PixelMap initialization failed.\n         {@link IMAGE_ALLOC_FAILED} If the copying of PixelMap data failed.\n @see OH_PixelmapNative\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_PixelmapNative_CreateCroppedAndScaledPixelMap(
        srcPixelmap: *mut OH_PixelmapNative,
        region: *mut Image_Region,
        scale: *mut Image_Scale,
        level: OH_PixelmapNative_AntiAliasingLevel,
        dstPixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Rotates this image based on the input angle.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param angle Angle to rotate.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Rotate(
        pixelmap: *mut OH_PixelmapNative,
        angle: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Flips this image horizontally or vertically, or both.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param shouldFilpHorizontally Whether to flip the image horizontally.\n @param shouldFilpVertically Whether to flip the image vertically.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Flip(
        pixelmap: *mut OH_PixelmapNative,
        shouldFilpHorizontally: bool,
        shouldFilpVertically: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Crops this image based on the input size.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param region Area size, read according to area.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Crop(
        pixelmap: *mut OH_PixelmapNative,
        region: *mut Image_Region,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases an <b>OH_Pixelmap</b> object.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Release(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Destroys an <b>OH_PixelmapNative</b> object and deallocates its resources.\n\n @param pixelmap A pointer to the OH_PixelmapNative pointer to destroy.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if pixelmap is null or *pixelmap is null.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_PixelmapNative_Destroy(pixelmap: *mut *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Converting images to alpha format\n\n @param srcpixelmap The source pixel map pointer will be operated.\n @param dstpixelmap The destination pixel map pointer will be operated.\n @param isPremul Whether it is pre-multiplied, true for prediction, false for non-pre-multiplied.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_ConvertAlphaFormat(
        srcpixelmap: *mut OH_PixelmapNative,
        dstpixelmap: *mut OH_PixelmapNative,
        isPremul: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Create a empty <b>PixelMap</b> object.\n\n @param options IPixel properties, including the alpha type, size, pixel format, and editable.\n @param pixelmap Pixelmap pointer for created.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_CreateEmptyPixelmap(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a empty pixelmap based on options {@link OH_Pixelmap_InitializationOptions}, the memory type used\n by the pixelmap can be specified by allocatorType {@link IMAGE_ALLOCATOR_MODE}. By default,\n the system selects the memory type based on the image type, image size, platform capability, etc. When processing\n the pixelmap returned by this interface, please always consider the impact of stride.\n\n @param options Pixelmap initialization properties including size, pixel format, alpha type, and editable flags.\n @param allocator Indicate which memory type will be used by the returned pixelmap.\n @param pixelmap Output parameter receiving the created pixelmap object pointer.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If the param is nullptr or invalid.\n         {@link IMAGE_TOO_LARGE} too large data or image.\n         {@link IMAGE_UNSUPPORTED_OPERATION} unsupported operations.\n         {@link IMAGE_ALLOCATOR_MODE_UNSUPPORTED} unsupported allocator mode, e.g., use\n         share memory to create a HDR image as only DMA supported hdr metadata.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_PixelmapNative_CreateEmptyPixelmapUsingAllocator(
        options: *mut OH_Pixelmap_InitializationOptions,
        allocator: IMAGE_ALLOCATOR_MODE,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a PixelMap from a Surface with the Surface ID.\n\n @param surfaceId The Surface ID.\n @param length Length of the Surface ID.\n @param pixelmap The PixelMap to be created.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If any parameter is invalid, e.g. surfaceId or pixelmap is incorrect.\n         {@link IMAGE_CREATE_PIXELMAP_FAILED} If the PixelMap creation failed.\n @see OH_PixelmapNative\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_PixelmapNative_CreatePixelmapFromSurface(
        surfaceId: *const ::std::os::raw::c_char,
        length: usize,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a PixelMap from a native buffer.\n\n @param nativeBuffer The native buffer.\n @param pixelmap The PixelMap to be created.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If any parameter is invalid, e.g. nativeBuffer or pixelmap is incorrect.\n         {@link IMAGE_CREATE_PIXELMAP_FAILED} If the PixelMap creation failed.\n @see OH_PixelmapNative\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_PixelmapNative_CreatePixelmapFromNativeBuffer(
        nativeBuffer: *mut OH_NativeBuffer,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get metadata.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param key Type of metadata.\n @param value Value of metadata.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, key and value are incorrect.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory does not exist.\n returns {@link Image_ErrorCode} IMAGE_COPY_FAILED - if memory copy failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_GetMetadata(
        pixelmap: *mut OH_PixelmapNative,
        key: OH_Pixelmap_HdrMetadataKey,
        value: *mut *mut OH_Pixelmap_HdrMetadataValue,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set metadata.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param key Type of metadata.\n @param value Value of metadata.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, key and value are incorrect.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory does not exist.\n returns {@link Image_ErrorCode} IMAGE_COPY_FAILED - if memory copy failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_SetMetadata(
        pixelmap: *mut OH_PixelmapNative,
        key: OH_Pixelmap_HdrMetadataKey,
        value: *mut OH_Pixelmap_HdrMetadataValue,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the native buffer from the PixelMap.\n\n @param pixelmap The PixelMap to get the native buffer from.\n @param nativeBuffer The native buffer to retrieve.\n @return Returns {@link Image_ErrorCode} IMAGE_RESULT_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, pixelmap or nativeBuffer is null.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory dose not exist.\n returns {@link Image_ErrorCode} IMAGE_DMA_OPERATION_FAILED - if operations related to DMA memory has failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_GetNativeBuffer(
        pixelmap: *mut OH_PixelmapNative,
        nativeBuffer: *mut *mut OH_NativeBuffer,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the native colorspace from the PixelMap.\n\n @param pixelmap The native pixelmap to get the native colorspace from.\n @param colorSpaceNative The native colorspace to retrieve.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} The param of pixelmap or colorSpaceNative is nullptr or invalid.\n @see OH_PixelmapNative\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_PixelmapNative_GetColorSpaceNative(
        pixelmap: *mut OH_PixelmapNative,
        colorSpaceNative: *mut *mut OH_NativeColorSpaceManager,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set the native colorspace for the PixelMap.\n\n @param pixelmap The native pixelmap to set the native colorspace for.\n @param colorSpaceNative The native colorspace to set.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} The param of pixelmap or colorSpaceNative is nullptr or invalid.\n @see OH_PixelmapNative\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_PixelmapNative_SetColorSpaceNative(
        pixelmap: *mut OH_PixelmapNative,
        colorSpaceNative: *mut OH_NativeColorSpaceManager,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelmap memory name.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param name The pointer of name that needs to be set.\n @param size The size of name size that needs to be set.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, name and size are incorrect.\n         {@link IMAGE_UNSUPPORTED_MEMORY_FORMAT} If memory format is unsupported.\n @see OH_PixelmapNative\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_PixelmapNative_SetMemoryName(
        pixelmap: *mut OH_PixelmapNative,
        name: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the total number of bytes occupied by all pixels in the Pixelmap, without any padding.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param byteCount The total number of bytes to be retrieved.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap or byteCount are invalid.\n @see OH_PixelmapNative\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_PixelmapNative_GetByteCount(
        pixelmap: *mut OH_PixelmapNative,
        byteCount: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the size of the allocated memory used to store this pixelmap's pixels.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param allocationByteCount The size of the allocated memory.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap or allocationByteCount are invalid.\n @see OH_PixelmapNative\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_PixelmapNative_GetAllocationByteCount(
        pixelmap: *mut OH_PixelmapNative,
        allocationByteCount: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the memory address of a PixelMap and locks the memory.\n        When the memory is locked, any operation that modifies or releases the PixelMap will fail and return\n        {@link IMAGE_BAD_PARAMETER}.\n\n @param pixelmap The PixelMap pointer to be operated.\n @param addr The double pointer to the memory address of the PixelMap.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap or addr are invalid.\n         {@link IMAGE_LOCK_UNLOCK_FAILED} If memory failed to be locked.\n @see OH_PixelmapNative\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_PixelmapNative_AccessPixels(
        pixelmap: *mut OH_PixelmapNative,
        addr: *mut *mut ::std::os::raw::c_void,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Unlocks the memory of the PixelMap data.\n        This function is used with {@link OH_PixelmapNative_AccessPixels} in pairs.\n\n @param pixelmap The PixelMap pointer to be operated.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap is invalid.\n         {@link IMAGE_LOCK_UNLOCK_FAILED} If memory failed to be unlocked.\n @see OH_PixelmapNative\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_PixelmapNative_UnaccessPixels(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Gets the unique ID of a PixelMap.\n\n @param pixelmap The PixelMap to retrieve the unique ID.\n @param uniqueId The resulting unique ID.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If any parameter is invalid, e.g. pixelmap or uniqueId is incorrect.\n @see OH_PixelmapNative\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_PixelmapNative_GetUniqueId(
        pixelmap: *mut OH_PixelmapNative,
        uniqueId: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Checks whether the PixelMap has been released.\n\n @param pixelmap The PixelMap to check.\n @param released The resulting release status.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If any parameter is invalid, e.g. pixelmap or released is incorrect.\n @see OH_PixelmapNative\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_PixelmapNative_IsReleased(
        pixelmap: *mut OH_PixelmapNative,
        released: *mut bool,
    ) -> Image_ErrorCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsPlainText {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsHyperlink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsHtml {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsAppItem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsFileUri {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsPixelMap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsContentForm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsArrayBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsDetails {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsPlainText}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsPlainText}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_Create() -> *mut OH_UdsPlainText;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsPlainText} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_Destroy(pThis: *mut OH_UdsPlainText);
}
extern "C" {
    #[doc = " @brief Get type id from the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_GetType(pThis: *mut OH_UdsPlainText) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get content from the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_GetContent(pThis: *mut OH_UdsPlainText)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get abstract from the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_GetAbstract(
        pThis: *mut OH_UdsPlainText,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get details from the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsPlainText OH_UdsDetails Udmf_ErrCode\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsPlainText_GetDetails(
        pThis: *mut OH_UdsPlainText,
        details: *mut OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set content to the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @param content Represents a new content string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsPlainText Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsPlainText_SetContent(
        pThis: *mut OH_UdsPlainText,
        content: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set abstract to the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @param abstract Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsPlainText Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsPlainText_SetAbstract(
        pThis: *mut OH_UdsPlainText,
        abstract_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set details to the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsPlainText OH_UdsDetails Udmf_ErrCode\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsPlainText_SetDetails(
        pThis: *mut OH_UdsPlainText,
        details: *const OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsHyperlink}.\n\n @return If the operation is successful, a pointer to the instance of {@link OH_UdsHyperlink}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_Create() -> *mut OH_UdsHyperlink;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsHyperlink} instance.\n\n @param pThis Represents a pointer to an  instance of {@link OH_UdsHyperlink}.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_Destroy(pThis: *mut OH_UdsHyperlink);
}
extern "C" {
    #[doc = " @brief Get type from the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_GetType(pThis: *mut OH_UdsHyperlink) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get url from the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_GetUrl(pThis: *mut OH_UdsHyperlink) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get description from the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_GetDescription(
        pThis: *mut OH_UdsHyperlink,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get details from the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsHyperlink OH_UdsDetails Udmf_ErrCode\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsHyperlink_GetDetails(
        pThis: *mut OH_UdsHyperlink,
        details: *mut OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set url to the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @param url Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsHyperlink Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsHyperlink_SetUrl(
        pThis: *mut OH_UdsHyperlink,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set description to the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @param description Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsHyperlink Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsHyperlink_SetDescription(
        pThis: *mut OH_UdsHyperlink,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set details to the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsHyperlink OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsHyperlink_SetDetails(
        pThis: *mut OH_UdsHyperlink,
        details: *const OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsHtml}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsHtml}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_Create() -> *mut OH_UdsHtml;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsHtml} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_Destroy(pThis: *mut OH_UdsHtml);
}
extern "C" {
    #[doc = " @brief Get html from the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_GetType(pThis: *mut OH_UdsHtml) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get content from the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_GetContent(pThis: *mut OH_UdsHtml) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get plain content from the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_GetPlainContent(pThis: *mut OH_UdsHtml) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get details from the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsHtml OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsHtml_GetDetails(
        pThis: *mut OH_UdsHtml,
        details: *mut OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set content to the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @param content Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsHtml Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsHtml_SetContent(
        pThis: *mut OH_UdsHtml,
        content: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set plain content to the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @param plainContent Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsHtml Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsHtml_SetPlainContent(
        pThis: *mut OH_UdsHtml,
        plainContent: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set details to the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsHtml OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsHtml_SetDetails(
        pThis: *mut OH_UdsHtml,
        details: *const OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsAppItem}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsAppItem}\n structure is returned. sIf the operation is failed, nullptr is returned.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_Create() -> *mut OH_UdsAppItem;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsAppItem} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_Destroy(pThis: *mut OH_UdsAppItem);
}
extern "C" {
    #[doc = " @brief Get type from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetType(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get app id from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetId(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get app name from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetName(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get app icon id from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetIconId(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get app label id from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetLabelId(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get bundle name from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetBundleName(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get ability name from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetAbilityName(pThis: *mut OH_UdsAppItem)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get details from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsAppItem OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsAppItem_GetDetails(
        pThis: *mut OH_UdsAppItem,
        details: *mut OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set application id to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param appId Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetId(
        pThis: *mut OH_UdsAppItem,
        appId: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set application name to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param appName Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetName(
        pThis: *mut OH_UdsAppItem,
        appName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set application icon id to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param appIconId Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetIconId(
        pThis: *mut OH_UdsAppItem,
        appIconId: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set application label id to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param appLabelId Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetLabelId(
        pThis: *mut OH_UdsAppItem,
        appLabelId: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set bundle name to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param bundleName Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetBundleName(
        pThis: *mut OH_UdsAppItem,
        bundleName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set ability name to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param abilityName Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetAbilityName(
        pThis: *mut OH_UdsAppItem,
        abilityName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set details to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem OH_UdsDetails Udmf_ErrCode\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsAppItem_SetDetails(
        pThis: *mut OH_UdsAppItem,
        details: *const OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsFileUri}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsFileUri}\n structure is returned. If the memory is not enough, nullptr is returned.\n @see OH_UdsFileUri\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsFileUri_Create() -> *mut OH_UdsFileUri;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsFileUri} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @see OH_UdsFileUri\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsFileUri_Destroy(pThis: *mut OH_UdsFileUri);
}
extern "C" {
    #[doc = " @brief Get type id from the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsFileUri\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsFileUri_GetType(pThis: *mut OH_UdsFileUri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get file uri from the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsFileUri\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsFileUri_GetFileUri(pThis: *mut OH_UdsFileUri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get file type from the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsFileUri\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsFileUri_GetFileType(pThis: *mut OH_UdsFileUri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get details from the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsFileUri OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsFileUri_GetDetails(
        pThis: *mut OH_UdsFileUri,
        details: *mut OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set file uri to the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @param fileUri Represents a new file uri string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsFileUri Udmf_ErrCode\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsFileUri_SetFileUri(
        pThis: *mut OH_UdsFileUri,
        fileUri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set file type to the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @param fileType Represents a new file type string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsFileUri Udmf_ErrCode\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsFileUri_SetFileType(
        pThis: *mut OH_UdsFileUri,
        fileType: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set details to the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsFileUri OH_UdsDetails Udmf_ErrCode\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsFileUri_SetDetails(
        pThis: *mut OH_UdsFileUri,
        details: *const OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsPixelMap}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsPixelMap}\n structure is returned. If the memory is not enough, nullptr is returned.\n @see OH_UdsPixelMap\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsPixelMap_Create() -> *mut OH_UdsPixelMap;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsPixelMap} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @see OH_UdsPixelMap\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsPixelMap_Destroy(pThis: *mut OH_UdsPixelMap);
}
extern "C" {
    #[doc = " @brief Get type id from the {@link OH_UdsPixelMap}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsPixelMap\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsPixelMap_GetType(pThis: *mut OH_UdsPixelMap) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get pixel map from the {@link OH_UdsPixelMap}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @param pixelmapNative Represents output params of {@link OH_PixelmapNative}.\n @see OH_UdsPixelMap\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsPixelMap_GetPixelMap(
        pThis: *mut OH_UdsPixelMap,
        pixelmapNative: *mut OH_PixelmapNative,
    );
}
extern "C" {
    #[doc = " @brief Get details from the {@link OH_UdsPixelMap}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsPixelMap OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsPixelMap_GetDetails(
        pThis: *mut OH_UdsPixelMap,
        details: *mut OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set pixel map to the {@link OH_UdsPixelMap}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @param pixelmapNative Represents a new {@link OH_PixelmapNative}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsPixelMap Udmf_ErrCode\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsPixelMap_SetPixelMap(
        pThis: *mut OH_UdsPixelMap,
        pixelmapNative: *mut OH_PixelmapNative,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set details to the {@link OH_UdsPixelMap}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @param details Represents a pointer to an instance of {@link OH_UdsDetails}. The pointer cannot be null.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsPixelMap OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsPixelMap_SetDetails(
        pThis: *mut OH_UdsPixelMap,
        details: *const OH_UdsDetails,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsArrayBuffer}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsArrayBuffer}\n structure is returned. If the memory is not enough, nullptr is returned.\n @see OH_UdsArrayBuffer\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsArrayBuffer_Create() -> *mut OH_UdsArrayBuffer;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsArrayBuffer} instance.\n\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsArrayBuffer Udmf_ErrCode\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsArrayBuffer_Destroy(buffer: *mut OH_UdsArrayBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set array buffer data to the {@link OH_UdsArrayBuffer}.\n\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @param data Represents the array buffer data.\n @param len Represents the length of data param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsArrayBuffer Udmf_ErrCode\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsArrayBuffer_SetData(
        buffer: *mut OH_UdsArrayBuffer,
        data: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get array buffer data from the {@link OH_UdsArrayBuffer}.\n\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @param data Represents a pointer to array buffer data that is a output param.\n @param len Represents the array buffer data length that is a output param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsArrayBuffer Udmf_ErrCode\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdsArrayBuffer_GetData(
        buffer: *mut OH_UdsArrayBuffer,
        data: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsContentForm}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsContentForm}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdsContentForm\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_Create() -> *mut OH_UdsContentForm;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsContentForm} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @see OH_UdsContentForm\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_Destroy(pThis: *mut OH_UdsContentForm);
}
extern "C" {
    #[doc = " @brief Get type id from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_GetType(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get thumb data from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param thumbData Represents a pointer to thumb data that is a output param.\n @param len Represents the thumb data length that is a output param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_GetThumbData(
        pThis: *mut OH_UdsContentForm,
        thumbData: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get description from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_GetDescription(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get title from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_GetTitle(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get thumb data from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param appIcon Represents a pointer to app icon that is a output param.\n @param len Represents the app icon length that is a output param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_GetAppIcon(
        pThis: *mut OH_UdsContentForm,
        appIcon: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get app name from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_GetAppName(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get link url from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_GetLinkUri(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set thumb data to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param thumbData Represents the thumb data.\n @param len Represents the length of thumb data param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_SetThumbData(
        pThis: *mut OH_UdsContentForm,
        thumbData: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set description to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param description Represents a description string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_SetDescription(
        pThis: *mut OH_UdsContentForm,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set title to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param title Represents a title string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_SetTitle(
        pThis: *mut OH_UdsContentForm,
        title: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set thumb data to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param appIcon Represents the app icon.\n @param len Represents the length of app icon param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_SetAppIcon(
        pThis: *mut OH_UdsContentForm,
        appIcon: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set app name to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param appName Represents a app name string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_SetAppName(
        pThis: *mut OH_UdsContentForm,
        appName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set link uri to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param linkUri Represents a link uri string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdsContentForm_SetLinkUri(
        pThis: *mut OH_UdsContentForm,
        linkUri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsDetails}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsDetails}\n structure is returned. If the operation is failed, nullptr is returned.\n @since 22\n @see OH_UdsDetails"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsDetails_Create() -> *mut OH_UdsDetails;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsDetails} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsDetails}.\n @since 22\n @see OH_UdsDetails"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsDetails_Destroy(pThis: *mut OH_UdsDetails);
}
extern "C" {
    #[doc = " @brief Determine whether the {@link OH_UdsDetails} contain the specified key.\n\n @param pThis Represents a pointer to an instance of the {@link OH_UdsDetails}.\n @param key Represents key in the details.\n @return Returns the status code of the execution.\n         {@code false} Represents The details do not contain the key.\n         {@code true} Represents The details contain the key.\n @see OH_UdsDetails\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsDetails_HasKey(
        pThis: *const OH_UdsDetails,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Remove the value corresponding to this key from the {@link OH_UdsDetails}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsDetails}.\n @param key Represents key in the details.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsDetails_Remove(
        pThis: *mut OH_UdsDetails,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Clear all data in the {@link OH_UdsDetails}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsDetails}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsDetails_Clear(pThis: *mut OH_UdsDetails) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set key-value data to the {@link OH_UdsDetails}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsDetails}.\n @param key Represents the key data to be written.\n @param value Represents the value data to be written.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @since 22\n @see OH_UdsDetails Udmf_ErrCode"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsDetails_SetValue(
        pThis: *mut OH_UdsDetails,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the value from the {@link OH_UdsDetails} using the key.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsDetails}.\n @param key Represents key in the details.\n @return Returns a string pointer when input args normally, otherwise return nullptr.\n @since 22\n @see OH_UdsDetails"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsDetails_GetValue(
        pThis: *const OH_UdsDetails,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the all keys from the {@link OH_UdsDetails}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsDetails}.\n @param count Represents the keys count.\n @return Returns string list of keys. Memory will be released after calling the OH_UdsDetails_Destroy function.\n @since 22\n @see OH_UdsDetails"]
    #[cfg(feature = "api-22")]
    pub fn OH_UdsDetails_GetAllKeys(
        pThis: *mut OH_UdsDetails,
        count: *mut ::std::os::raw::c_uint,
    ) -> *mut *mut ::std::os::raw::c_char;
}
#[doc = " @brief The intention is drag."]
pub const Udmf_Intention_UDMF_INTENTION_DRAG: Udmf_Intention = 0;
#[doc = " @brief The intention is pasteboard."]
pub const Udmf_Intention_UDMF_INTENTION_PASTEBOARD: Udmf_Intention = 1;
#[doc = " @brief The intention is data hub.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const Udmf_Intention_UDMF_INTENTION_DATA_HUB: Udmf_Intention = 2;
#[doc = " @brief The intention is system share.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const Udmf_Intention_UDMF_INTENTION_SYSTEM_SHARE: Udmf_Intention = 3;
#[doc = " @brief The intention is picker.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const Udmf_Intention_UDMF_INTENTION_PICKER: Udmf_Intention = 4;
#[doc = " @brief The intention is menu.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const Udmf_Intention_UDMF_INTENTION_MENU: Udmf_Intention = 5;
#[doc = " @brief Describe the intention type of the udmf.\n\n @since 12"]
pub type Udmf_Intention = u32;
#[doc = " @brief Invalid share option."]
pub const Udmf_ShareOption_SHARE_OPTIONS_INVALID: Udmf_ShareOption = 0;
#[doc = " @brief Allowed to be used in the same application on this device."]
pub const Udmf_ShareOption_SHARE_OPTIONS_IN_APP: Udmf_ShareOption = 1;
#[doc = " @brief Allowed to be used in the cross application on this device."]
pub const Udmf_ShareOption_SHARE_OPTIONS_CROSS_APP: Udmf_ShareOption = 2;
#[doc = " @brief Describe intra-device usage range type enumeration.\n\n @since 12"]
pub type Udmf_ShareOption = u32;
#[doc = " @brief Overwrite when dest uri has file with same name."]
#[cfg(feature = "api-15")]
pub const Udmf_FileConflictOptions_UDMF_OVERWRITE: Udmf_FileConflictOptions = 0;
#[doc = " @brief Skip when dest uri has file with same name."]
#[cfg(feature = "api-15")]
pub const Udmf_FileConflictOptions_UDMF_SKIP: Udmf_FileConflictOptions = 1;
#[doc = " @brief Describe the types of file conflict options when getting data from the udmf.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type Udmf_FileConflictOptions = u32;
#[doc = " @brief Getting data without system default progress indicator."]
#[cfg(feature = "api-15")]
pub const Udmf_ProgressIndicator_UDMF_NONE: Udmf_ProgressIndicator = 0;
#[doc = " @brief Getting data with system default progress indicator."]
#[cfg(feature = "api-15")]
pub const Udmf_ProgressIndicator_UDMF_DEFAULT: Udmf_ProgressIndicator = 1;
#[doc = " @brief Describe the types of progress indicator when getting data from the udmf.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type Udmf_ProgressIndicator = u32;
#[doc = " @brief The visibility level that specifies that any hap or native can be obtained."]
#[cfg(feature = "api-20")]
pub const Udmf_Visibility_UDMF_ALL: Udmf_Visibility = 0;
#[doc = " @brief The visibility level that specifies that only data providers can be obtained."]
#[cfg(feature = "api-20")]
pub const Udmf_Visibility_UDMF_OWN_PROCESS: Udmf_Visibility = 1;
#[doc = " @brief Describe the visibility range of data\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type Udmf_Visibility = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfRecord {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfRecordProvider {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfProperty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Udmf_ProgressInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfGetDataParams {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the callback function used to return the progress information and data.\n\n @param progressInfo The progress information notified to Application.\n @param data Represents the unified data.\n @since 15"]
#[cfg(feature = "api-15")]
pub type OH_Udmf_DataProgressListener = ::std::option::Option<
    unsafe extern "C" fn(progressInfo: *mut OH_Udmf_ProgressInfo, data: *mut OH_UdmfData),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfDataLoadParams {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfDataLoadInfo {
    _unused: [u8; 0],
}
#[doc = " @brief Indicates the callback function for loading data.\n\n @param acceptableInfo Indicates the type and number of data that can be accepted by the receiver.\n @return Returns the data to be loaded.\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_Udmf_DataLoadHandler = ::std::option::Option<
    unsafe extern "C" fn(acceptableInfo: *mut OH_UdmfDataLoadInfo) -> *mut OH_UdmfData,
>;
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfData}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfData}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfData.\n @since 12"]
    pub fn OH_UdmfData_Create() -> *mut OH_UdmfData;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdmfData} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @see OH_UdmfData.\n @since 12"]
    pub fn OH_UdmfData_Destroy(pThis: *mut OH_UdmfData);
}
extern "C" {
    #[doc = " @brief Add one {OH_UdmfRecord} record to the {@link OH_UdmfData} data.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @param record Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfData Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfData_AddRecord(
        pThis: *mut OH_UdmfData,
        record: *mut OH_UdmfRecord,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check whether the type exists in the {@link OH_UdmfData} data.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @param type Represents a string pointer of the type.\n @return Returns the status of finding type.\n         {@code false} is not existed.\n         {@code true} is existed.\n @see OH_UdmfData.\n @since 12"]
    pub fn OH_UdmfData_HasType(
        pThis: *mut OH_UdmfData,
        type_: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get all types in the {@link OH_UdmfData} data.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @param count Represents the types count that is a output param.\n @return Returns string array that in {@link OH_UdmfData} when input parameters valid,\n otherwise return nullptr.\n @see OH_UdmfData.\n @since 12"]
    pub fn OH_UdmfData_GetTypes(
        pThis: *mut OH_UdmfData,
        count: *mut ::std::os::raw::c_uint,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get all records in the {@link OH_UdmfData} data.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @param count Represents the records count that is a output param.\n @return Returns {@link OH_UdmfRecord} pointer array when input parameters valid, otherwise return nullptr.\n @see OH_UdmfData OH_UdmfRecord.\n @since 12"]
    pub fn OH_UdmfData_GetRecords(
        pThis: *mut OH_UdmfData,
        count: *mut ::std::os::raw::c_uint,
    ) -> *mut *mut OH_UdmfRecord;
}
#[doc = " @brief Defines the callback function used free the context.\n @param context Pointer to the context which is to be free.\n @since 13"]
#[cfg(feature = "api-13")]
pub type UdmfData_Finalize =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " @brief Creates an {@link OH_UdmfRecordProvider} instance.\n\n @return Returns the pointer to the {@link OH_UdmfRecordProvider} instance created if the operation is successful.\n Returns nullptr if the memory is not enough.\n @see OH_UdmfRecordProvider.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecordProvider_Create() -> *mut OH_UdmfRecordProvider;
}
extern "C" {
    #[doc = " @brief Destroy an {@link OH_UdmfRecordProvider} instance.\n\n @param provider Pointer to the {@link OH_UdmfRecordProvider} instance to destroy.\n @return Returns the status code of the execution. For details, see {@link Udmf_ErrCode}.\n         Returns {@link UDMF_E_OK} if the operation is successful.\n         Returns {@link UDMF_E_INVALID_PARAM} if invalid args are detected.\n @see OH_UdmfRecordProvider Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecordProvider_Destroy(
        provider: *mut OH_UdmfRecordProvider,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief Defines a callback function used to obtain data by type.\n\n @param context Pointer to the context set by {@link OH_UdmfRecordProvider_SetData}.\n @param type Pointer to the type of data to obtain. For details, see {@link udmf_meta.h}.\n @return Returns the data content.\n @since 13"]
#[cfg(feature = "api-13")]
pub type OH_UdmfRecordProvider_GetData = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        type_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[doc = " @brief Sets a callback function to obtain data.\n\n @param provider Pointer to the {@link OH_UdmfRecordProvider} instance.\n @param context Pointer to the context set, which is the first parameter in OH_UdmfRecordProvider_GetData.\n @param callback Callback to set. For details, see {@link OH_UdmfRecordProvider_GetData}.\n @param finalize Optional callback that can free context when destroy provider.\n         For details, see {@link UdmfData_Finalize}.\n @return Returns the status code of the execution. For details, see {@link Udmf_ErrCode}.\n         Returns {@link UDMF_E_OK} if the operation is successful.\n         Returns {@link UDMF_E_INVALID_PARAM} if invalid args are detected.\n @see OH_UdmfRecordProvider OH_UdmfRecordProvider_GetData UdmfData_Finalize Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecordProvider_SetData(
        provider: *mut OH_UdmfRecordProvider,
        context: *mut ::std::os::raw::c_void,
        callback: OH_UdmfRecordProvider_GetData,
        finalize: UdmfData_Finalize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfRecord}, it's relate with UDS data.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfRecord}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfRecord.\n @since 12"]
    pub fn OH_UdmfRecord_Create() -> *mut OH_UdmfRecord;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to an instance of {@link OH_UdmfRecord}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @see OH_UdmfRecord.\n @since 12"]
    pub fn OH_UdmfRecord_Destroy(pThis: *mut OH_UdmfRecord);
}
extern "C" {
    #[doc = " @brief Add one custom data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param typeId Represents record type, reference udmf_meta.h.\n @param entry Represents custom data.\n @param count Represents the size of data param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddGeneralEntry(
        pThis: *mut OH_UdmfRecord,
        typeId: *const ::std::os::raw::c_char,
        entry: *mut ::std::os::raw::c_uchar,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsPlainText} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param plainText Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsPlainText Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddPlainText(
        pThis: *mut OH_UdmfRecord,
        plainText: *mut OH_UdsPlainText,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsHyperlink} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param hyperlink Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsHyperlink Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddHyperlink(
        pThis: *mut OH_UdmfRecord,
        hyperlink: *mut OH_UdsHyperlink,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsHtml} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param html Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsHtml Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddHtml(
        pThis: *mut OH_UdmfRecord,
        html: *mut OH_UdsHtml,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsAppItem} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param appItem Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsAppItem Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddAppItem(
        pThis: *mut OH_UdmfRecord,
        appItem: *mut OH_UdsAppItem,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsFileUri} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param fileUri Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsFileUri Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecord_AddFileUri(
        pThis: *mut OH_UdmfRecord,
        fileUri: *mut OH_UdsFileUri,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsPixelMap} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param pixelMap Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsPixelMap Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecord_AddPixelMap(
        pThis: *mut OH_UdmfRecord,
        pixelMap: *mut OH_UdsPixelMap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {@link OH_UdsArrayBuffer} data to the {@link OH_UdmfRecord} record.\n\n @param record Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param type Represents record type, reference udmf_meta.h.\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsArrayBuffer Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecord_AddArrayBuffer(
        record: *mut OH_UdmfRecord,
        type_: *const ::std::os::raw::c_char,
        buffer: *mut OH_UdsArrayBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {@link OH_UdsContentForm} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param contentForm Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsContentForm Udmf_ErrCode.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdmfRecord_AddContentForm(
        pThis: *mut OH_UdmfRecord,
        contentForm: *mut OH_UdsContentForm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get all types in the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param count Represents the types count that is a output param.\n @return Returns string array that in {@link OH_UdmfRecord} when input parameters valid,\n otherwise return nullptr.\n @see OH_UdmfRecord.\n @since 12"]
    pub fn OH_UdmfRecord_GetTypes(
        pThis: *mut OH_UdmfRecord,
        count: *mut ::std::os::raw::c_uint,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get one entry data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param typeId Represents record type, reference udmf_meta.h.\n @param entry Represents a pointer to entry data that is a output param.\n @param count Represents the entry data length that is a output param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetGeneralEntry(
        pThis: *mut OH_UdmfRecord,
        typeId: *const ::std::os::raw::c_char,
        entry: *mut *mut ::std::os::raw::c_uchar,
        count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsPlainText} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param plainText Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord OH_UdsPlainText Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetPlainText(
        pThis: *mut OH_UdmfRecord,
        plainText: *mut OH_UdsPlainText,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsHyperlink} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param hyperlink Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord OH_UdsHyperlink Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetHyperlink(
        pThis: *mut OH_UdmfRecord,
        hyperlink: *mut OH_UdsHyperlink,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsHtml} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param html Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord OH_UdsHtml Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetHtml(
        pThis: *mut OH_UdmfRecord,
        html: *mut OH_UdsHtml,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsAppItem} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param appItem Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord OH_UdsAppItem Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetAppItem(
        pThis: *mut OH_UdmfRecord,
        appItem: *mut OH_UdsAppItem,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsFileUri} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param fileUri Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsFileUri Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecord_GetFileUri(
        pThis: *mut OH_UdmfRecord,
        fileUri: *mut OH_UdsFileUri,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsPixelMap} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param pixelMap Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsPixelMap Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecord_GetPixelMap(
        pThis: *mut OH_UdmfRecord,
        pixelMap: *mut OH_UdsPixelMap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the data provider of the types.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param types Represents a pointer to a group of data types;\n @param count Represents the number of data types;\n @param provider Represents a pointer an instance of {@link OH_UdmfRecordProvider}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdmfRecordProvider Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecord_SetProvider(
        pThis: *mut OH_UdmfRecord,
        types: *const *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        provider: *mut OH_UdmfRecordProvider,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {@link OH_UdsArrayBuffer} data from the {@link OH_UdmfRecord} record.\n\n @param record Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param type Represents record type, reference udmf_meta.h.\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsArrayBuffer Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfRecord_GetArrayBuffer(
        record: *mut OH_UdmfRecord,
        type_: *const ::std::os::raw::c_char,
        buffer: *mut OH_UdsArrayBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {@link OH_UdsContentForm} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param contentForm Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsContentForm Udmf_ErrCode.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_UdmfRecord_GetContentForm(
        pThis: *mut OH_UdmfRecord,
        contentForm: *mut OH_UdsContentForm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get primary {@link OH_UdsPlainText} data from the {@link OH_UdmfData}.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @param plainText Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfData OH_UdsPlainText Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfData_GetPrimaryPlainText(
        data: *mut OH_UdmfData,
        plainText: *mut OH_UdsPlainText,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {@link OH_UdsHtml} data from the {@link OH_UdmfData}.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @param html Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfData OH_UdsHtml Udmf_ErrCode.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfData_GetPrimaryHtml(
        data: *mut OH_UdmfData,
        html: *mut OH_UdsHtml,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the count of {@link OH_UdmfRecord} in the {@link OH_UdmfData}.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @return Returns the count of {@link OH_UdmfRecord}\n @see OH_UdmfData.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfData_GetRecordCount(data: *mut OH_UdmfData) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the record of the specified index from the {@link OH_UdmfData}.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @param index Represents the index of {@link OH_UdmfRecord} in the {@link OH_UdmfData}.\n @return Returns {@link OH_UdmfRecord} pointer when input parameters valid, otherwise return nullptr.\n @see OH_UdmfData.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfData_GetRecord(
        data: *mut OH_UdmfData,
        index: ::std::os::raw::c_uint,
    ) -> *mut OH_UdmfRecord;
}
extern "C" {
    #[doc = " @brief Checks whether the UDMF data is from a local device.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @return Returns a boolean value, which indicates whether the UDMF data is from a local device.\n         The value {@code true} means the data is from a local device.\n         The value {@code false} means the opposite.\n @see OH_UdmfData.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_UdmfData_IsLocal(data: *mut OH_UdmfData) -> bool;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfProperty}\n from a {@link OH_UdmfData} data.\n\n @param unifiedData Represents a pointer to an instance of {@link OH_UdmfData}.\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfProperty}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfData OH_UdmfProperty.\n @since 12"]
    pub fn OH_UdmfProperty_Create(unifiedData: *mut OH_UdmfData) -> *mut OH_UdmfProperty;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdmfProperty} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @see OH_UdmfProperty.\n @since 12"]
    pub fn OH_UdmfProperty_Destroy(pThis: *mut OH_UdmfProperty);
}
extern "C" {
    #[doc = " @brief Get tag value from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @return Returns a pointer of the tag value string when input parameters valid, otherwise return nullptr.\n @see OH_UdmfProperty.\n @since 12"]
    pub fn OH_UdmfProperty_GetTag(pThis: *mut OH_UdmfProperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get timestamp value from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @return Returns timestamp value.\n @see OH_UdmfProperty\n @since 12"]
    pub fn OH_UdmfProperty_GetTimestamp(pThis: *mut OH_UdmfProperty) -> i64;
}
extern "C" {
    #[doc = " @brief Get share option value from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @return Returns {@link Udmf_ShareOption} value.\n @see OH_UdmfProperty Udmf_ShareOption\n @since 12"]
    pub fn OH_UdmfProperty_GetShareOption(pThis: *mut OH_UdmfProperty) -> Udmf_ShareOption;
}
extern "C" {
    #[doc = " @brief Get integer value by key from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param key Represents key-value pair's key\n @param defaultValue Represents when get value failure.\n @return Returns value associated with the key in successfully, otherwise return defaultValue.\n @see OH_UdmfProperty.\n @since 12"]
    pub fn OH_UdmfProperty_GetExtrasIntParam(
        pThis: *mut OH_UdmfProperty,
        key: *const ::std::os::raw::c_char,
        defaultValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get tag value from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param key Represents key-value pair's key.\n @return Returns a pointer of the key value string when input parameters valid, otherwise return nullptr.\n @see OH_UdmfProperty\n @since 12"]
    pub fn OH_UdmfProperty_GetExtrasStringParam(
        pThis: *mut OH_UdmfProperty,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set tag value to {@link OH_UdmfProperty} .\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param tag Represents new tag param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfProperty Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfProperty_SetTag(
        pThis: *mut OH_UdmfProperty,
        tag: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set Udmf_ShareOption value to {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param option Represents new {@link Udmf_ShareOption} param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfProperty Udmf_ShareOption Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfProperty_SetShareOption(
        pThis: *mut OH_UdmfProperty,
        option: Udmf_ShareOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set extras param to {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param key Represents extras param's key value.\n @param param Represents value of k-v pairs.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfProperty Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfProperty_SetExtrasIntParam(
        pThis: *mut OH_UdmfProperty,
        key: *const ::std::os::raw::c_char,
        param: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set extras param to {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param key Represents extras param's key value.\n @param param Represents value of k-v pairs.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfProperty Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfProperty_SetExtrasStringParam(
        pThis: *mut OH_UdmfProperty,
        key: *const ::std::os::raw::c_char,
        param: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfOptions}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfOptions}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfOptions.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfOptions_Create() -> *mut OH_UdmfOptions;
}
extern "C" {
    #[doc = " @brief Destroy the heap memory pointed to by the pointer of {@link OH_UdmfOptions}.\n Note that this function cannot be called repeatedly for the same pointer.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @see OH_UdmfOptions.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfOptions_Destroy(pThis: *mut OH_UdmfOptions);
}
extern "C" {
    #[doc = " @brief Get key from the {@link OH_UdmfOptions}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdmfOptions\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfOptions_GetKey(pThis: *mut OH_UdmfOptions) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set the key to the {@link OH_UdmfOptions}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @param key Represents a new string value of the key.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfOptions Udmf_ErrCode\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfOptions_SetKey(
        pThis: *mut OH_UdmfOptions,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get intention from the {@link OH_UdmfOptions}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @return Returns {@link Udmf_Intention} value.\n @see OH_UdmfOptions Udmf_Intention\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfOptions_GetIntention(pThis: *mut OH_UdmfOptions) -> Udmf_Intention;
}
extern "C" {
    #[doc = " @brief Set intention value to {@link OH_UdmfOptions}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @param intention Represents new {@link Udmf_Intention} param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfOptions Udmf_Intention Udmf_ErrCode.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfOptions_SetIntention(
        pThis: *mut OH_UdmfOptions,
        intention: Udmf_Intention,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Reset {@link OH_UdmfOptions} to default.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfOptions Udmf_ErrCode.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfOptions_Reset(pThis: *mut OH_UdmfOptions) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get visibility from the {@link OH_UdmfOptions}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @return Returns {@link Udmf_Visibility} value.\n @see OH_UdmfOptions Udmf_Visibility\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfOptions_GetVisibility(pThis: *mut OH_UdmfOptions) -> Udmf_Visibility;
}
extern "C" {
    #[doc = " @brief Set visibility value to {@link OH_UdmfOptions}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @param visibility Represents new {@link Udmf_Visibility} param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfOptions Udmf_Visibility Udmf_ErrCode.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfOptions_SetVisibility(
        pThis: *mut OH_UdmfOptions,
        visibility: Udmf_Visibility,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get {@link OH_UdmfData} data from udmf database.\n\n @param key Represents database store's key value.\n @param intention Represents data type {@link Udmf_Intention}\n @param unifiedData Represents output params of {@link OH_UdmfData};\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error. The potential reason is server malfunction or insufficient memory.\n @see OH_UdmfProperty Udmf_Intention Udmf_ErrCode.\n @since 12"]
    pub fn OH_Udmf_GetUnifiedData(
        key: *const ::std::os::raw::c_char,
        intention: Udmf_Intention,
        unifiedData: *mut OH_UdmfData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get {@link OH_UdmfData} data array from udmf database by intention.\n\n @param options Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @param dataArray Represents output params of {@link OH_UdmfData}.\n     It should be accessed using {@link OH_UDMF_GetDataElementAt} to retrieve elements by index.\n     This pointer needs to be released using the {@link OH_Udmf_DestroyDataArray} function.\n @param dataSize Represents the data count of output params.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error. The potential reason is server malfunction or insufficient memory.\n @see OH_UdmfData Udmf_Intention Udmf_ErrCode.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_Udmf_GetUnifiedDataByOptions(
        options: *mut OH_UdmfOptions,
        dataArray: *mut *mut OH_UdmfData,
        dataSize: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set {@link OH_UdmfData} data to database.\n\n @param intention Represents data type {@link Udmf_Intention}.\n @param unifiedData Represents a pointer to an instance of {@link OH_UdmfData}.\n @param key Represents return value after set data to database successfully,\n it's memory size not less than {@link UDMF_KEY_BUFFER_LEN}.\n @param keyLen Represents size of key param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error. The potential reason is server malfunction or insufficient memory.\n @see OH_UdmfProperty Udmf_Intention Udmf_ErrCode.\n @since 12"]
    pub fn OH_Udmf_SetUnifiedData(
        intention: Udmf_Intention,
        unifiedData: *mut OH_UdmfData,
        key: *mut ::std::os::raw::c_char,
        keyLen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set {@link OH_UdmfData} data to database with options.\n\n @param options Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @param unifiedData Represents a pointer to an instance of {@link OH_UdmfData}.\n @param key Represents return value after set data to database successfully,\n it's memory size not less than {@link UDMF_KEY_BUFFER_LEN}.\n @param keyLen Represents size of key param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error. The potential reason is server malfunction or insufficient memory.\n @see OH_UdmfOptions OH_UdmfData Udmf_ErrCode.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_Udmf_SetUnifiedDataByOptions(
        options: *mut OH_UdmfOptions,
        unifiedData: *mut OH_UdmfData,
        key: *mut ::std::os::raw::c_char,
        keyLen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Update {@link OH_UdmfData} data to database with options.\n\n @param options Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @param unifiedData Represents a pointer to an instance of {@link OH_UdmfData}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error. The potential reason is server malfunction or insufficient memory.\n @see OH_UdmfOptions OH_UdmfData Udmf_ErrCode.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_Udmf_UpdateUnifiedData(
        options: *mut OH_UdmfOptions,
        unifiedData: *mut OH_UdmfData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Delete {@link OH_UdmfData} data of database with options.\n\n @param options Represents a pointer to an instance of {@link OH_UdmfOptions}.\n @param dataArray Represents output params of {@link OH_UdmfData}.\n     It should be accessed using {@link OH_UDMF_GetDataElementAt} to retrieve elements by index.\n     This pointer needs to be released using the {@link OH_Udmf_DestroyDataArray} function.\n @param dataSize Represents the data count of output params.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error. The potential reason is server malfunction or insufficient memory.\n @see OH_UdmfData Udmf_Intention Udmf_ErrCode.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_Udmf_DeleteUnifiedData(
        options: *mut OH_UdmfOptions,
        dataArray: *mut *mut OH_UdmfData,
        dataSize: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets the pointer to the element at the specified index from the input array.\n\n @param dataArray A pointer to an array of {@link OH_UdmfData} pointers.\n @param index The index of the desired element. Note that the input index should not exceed the array range.\n @return A pointer to the {@link OH_UdmfData} element at the specified index; returns NULL if the array is NULL.\n @see OH_UdmfData\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_UDMF_GetDataElementAt(
        dataArray: *mut *mut OH_UdmfData,
        index: ::std::os::raw::c_uint,
    ) -> *mut OH_UdmfData;
}
extern "C" {
    #[doc = " @brief Destroy data array memory.\n\n @param dataArray Represents a point to {@link OH_UdmfData}.\n @param dataSize Represents data size in list.\n @see OH_UdmfData\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_Udmf_DestroyDataArray(
        dataArray: *mut *mut OH_UdmfData,
        dataSize: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Gets the progress from the {@OH_Udmf_ProgressInfo}.\n\n @param progressInfo Represents a pointer to an instance of {@link OH_Udmf_ProgressInfo}.\n @return Returns the progress.\n @see OH_Udmf_ProgressInfo\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_UdmfProgressInfo_GetProgress(
        progressInfo: *mut OH_Udmf_ProgressInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets the status from the {@OH_Udmf_ProgressInfo}.\n\n @param progressInfo Represents a pointer to an instance of {@link OH_Udmf_ProgressInfo}.\n @return Returns the status code. See {@link Udmf_ListenerStatus}.\n @see OH_Udmf_ProgressInfo Udmf_ListenerStatus\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_UdmfProgressInfo_GetStatus(
        progressInfo: *mut OH_Udmf_ProgressInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfGetDataParams}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfGetDataParams}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfGetDataParams\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_UdmfGetDataParams_Create() -> *mut OH_UdmfGetDataParams;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to an instance of {@link OH_UdmfGetDataParams}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @see OH_UdmfGetDataParams\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_UdmfGetDataParams_Destroy(pThis: *mut OH_UdmfGetDataParams);
}
extern "C" {
    #[doc = " @brief Sets the destination uri to the {@OH_UdmfGetDataParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @param destUri Pointer to a destination uri.\n @see OH_UdmfGetDataParams\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_UdmfGetDataParams_SetDestUri(
        params: *mut OH_UdmfGetDataParams,
        destUri: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets the file conflict options to the {@OH_UdmfGetDataParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @param options Represents to the file conflict options.\n @see OH_UdmfGetDataParams Udmf_FileConflictOptions\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_UdmfGetDataParams_SetFileConflictOptions(
        params: *mut OH_UdmfGetDataParams,
        options: Udmf_FileConflictOptions,
    );
}
extern "C" {
    #[doc = " @brief Sets the progress indicator to the {@OH_UdmfGetDataParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @param progressIndicator Represents to the progress indicator.\n @see OH_UdmfGetDataParams Udmf_ProgressIndicator\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_UdmfGetDataParams_SetProgressIndicator(
        params: *mut OH_UdmfGetDataParams,
        progressIndicator: Udmf_ProgressIndicator,
    );
}
extern "C" {
    #[doc = " @brief Sets the progress indicator to the {@OH_UdmfGetDataParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @param dataProgressListener Represents to the data progress listener.\n @see OH_UdmfGetDataParams OH_Udmf_DataProgressListener\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_UdmfGetDataParams_SetDataProgressListener(
        params: *mut OH_UdmfGetDataParams,
        dataProgressListener: OH_Udmf_DataProgressListener,
    );
}
extern "C" {
    #[doc = " @brief Sets the acceptable info to the {@OH_UdmfGetDataParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @param acceptableInfo Represents a pointer to an instance of {@link OH_UdmfDataLoadInfo}.\n @see OH_UdmfGetDataParams OH_UdmfDataLoadInfo\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfGetDataParams_SetAcceptableInfo(
        params: *mut OH_UdmfGetDataParams,
        acceptableInfo: *mut OH_UdmfDataLoadInfo,
    );
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfDataLoadParams}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfDataLoadParams}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfDataLoadParams\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadParams_Create() -> *mut OH_UdmfDataLoadParams;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to an instance of {@link OH_UdmfDataLoadParams}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfDataLoadParams}.\n @see OH_UdmfDataLoadParams\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadParams_Destroy(pThis: *mut OH_UdmfDataLoadParams);
}
extern "C" {
    #[doc = " @brief Sets the data load handler to the {@OH_UdmfDataLoadParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfDataLoadParams}.\n @param dataLoadHandler Represents to the data load handler.\n @see OH_UdmfDataLoadParams OH_Udmf_DataLoadHandler\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadParams_SetLoadHandler(
        params: *mut OH_UdmfDataLoadParams,
        dataLoadHandler: OH_Udmf_DataLoadHandler,
    );
}
extern "C" {
    #[doc = " @brief Sets the data load info to the {@OH_UdmfDataLoadParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfDataLoadParams}.\n @param dataLoadInfo Represents a pointer to an instance of {@link OH_UdmfDataLoadInfo}.\n @see OH_UdmfDataLoadParams OH_UdmfDataLoadInfo\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadParams_SetDataLoadInfo(
        params: *mut OH_UdmfDataLoadParams,
        dataLoadInfo: *mut OH_UdmfDataLoadInfo,
    );
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfDataLoadInfo}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfDataLoadInfo}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfDataLoadInfo\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadInfo_Create() -> *mut OH_UdmfDataLoadInfo;
}
extern "C" {
    #[doc = " @brief Destroy the heap memory pointed to by the pointer of {@link OH_UdmfDataLoadInfo}.\n Note that this function cannot be called repeatedly for the same pointer.\n\n @param dataLoadInfo Represents a pointer to an instance of {@link OH_UdmfDataLoadInfo}.\n @see OH_UdmfDataLoadInfo\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadInfo_Destroy(dataLoadInfo: *mut OH_UdmfDataLoadInfo);
}
extern "C" {
    #[doc = " @brief Gets the types from the {@OH_UdmfDataLoadInfo}.\n\n @param dataLoadInfo Represents a pointer to an instance of {@link OH_UdmfDataLoadInfo}.\n @param count the types count of data.\n @return Returns the types of data.\n @see OH_UdmfDataLoadInfo\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadInfo_GetTypes(
        dataLoadInfo: *mut OH_UdmfDataLoadInfo,
        count: *mut ::std::os::raw::c_uint,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Sets the data load info to the {@OH_UdmfDataLoadInfo}.\n\n @param dataLoadInfo Represents a pointer to an instance of {@link OH_UdmfDataLoadInfo}.\n @param type Represents the type of data.\n @see OH_UdmfDataLoadInfo\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadInfo_SetType(
        dataLoadInfo: *mut OH_UdmfDataLoadInfo,
        type_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Gets the record count from the {@OH_UdmfDataLoadInfo}.\n\n @param dataLoadInfo Represents a pointer to an instance of {@link OH_UdmfDataLoadInfo}.\n @return Returns the record count.\n @see OH_UdmfDataLoadInfo\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadInfo_GetRecordCount(
        dataLoadInfo: *mut OH_UdmfDataLoadInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets the record count to the {@OH_UdmfDataLoadInfo}.\n\n @param dataLoadInfo Represents a pointer to an instance of {@link OH_UdmfDataLoadInfo}.\n @param recordCount Represents the types of data.\n @see OH_UdmfDataLoadInfo\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_UdmfDataLoadInfo_SetRecordCount(
        dataLoadInfo: *mut OH_UdmfDataLoadInfo,
        recordCount: ::std::os::raw::c_uint,
    );
}
#[doc = " The drag and drop operation succeeded."]
pub const ArkUI_DragResult_ARKUI_DRAG_RESULT_SUCCESSFUL: ArkUI_DragResult = 0;
#[doc = " The drag and drop operation failed."]
pub const ArkUI_DragResult_ARKUI_DRAG_RESULT_FAILED: ArkUI_DragResult = 1;
#[doc = " The drag and drop operation was canceled."]
pub const ArkUI_DragResult_ARKUI_DRAG_RESULT_CANCELED: ArkUI_DragResult = 2;
#[doc = " @brief Defines an enum for drag results, which are set by the data receiver and transferred by the system to the\n        drag source so that the drag source is aware of the data processing result of the receiver.\n\n @since 12"]
pub type ArkUI_DragResult = u32;
#[doc = " Copy."]
pub const ArkUI_DropOperation_ARKUI_DROP_OPERATION_COPY: ArkUI_DropOperation = 0;
#[doc = " Cut."]
pub const ArkUI_DropOperation_ARKUI_DROP_OPERATION_MOVE: ArkUI_DropOperation = 1;
#[doc = " @brief Defines an enum for data processing modes used when data is dropped, which affects the display of the badge.\n\n @since 12"]
pub type ArkUI_DropOperation = u32;
#[doc = " Unknown."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_UNKNOWN: ArkUI_PreDragStatus = -1;
#[doc = " A drag gesture is being detected."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_ACTION_DETECTING: ArkUI_PreDragStatus = 0;
#[doc = " The component is ready to be dragged."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_READY_TO_TRIGGER_DRAG: ArkUI_PreDragStatus = 1;
#[doc = " A lift animation is started."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_PREVIEW_LIFT_STARTED: ArkUI_PreDragStatus = 2;
#[doc = " A lift animation is finished."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_PREVIEW_LIFT_FINISHED: ArkUI_PreDragStatus = 3;
#[doc = " A drop animation is started."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_PREVIEW_LANDING_STARTED: ArkUI_PreDragStatus =
    4;
#[doc = " A drop animation is finished."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_PREVIEW_LANDING_FINISHED: ArkUI_PreDragStatus =
    5;
#[doc = " A drop animation is terminated."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_CANCELED_BEFORE_DRAG: ArkUI_PreDragStatus = 6;
#[doc = " @brief Defines an enum for interaction states prior to a drop and drop operation.\n\n @since 12"]
pub type ArkUI_PreDragStatus = i32;
#[doc = " The system automatically changes the position of the dragged point based on the scenario and\n scales the drag preview based on set rules."]
pub const ArkUI_DragPreviewScaleMode_ARKUI_DRAG_PREVIEW_SCALE_AUTO: ArkUI_DragPreviewScaleMode = 0;
#[doc = " The system does not scale the drag preview."]
pub const ArkUI_DragPreviewScaleMode_ARKUI_DRAG_PREVIEW_SCALE_DISABLED: ArkUI_DragPreviewScaleMode =
    1;
#[doc = " @brief Defines an enum for drag preview scale modes.\n\n @since 12"]
pub type ArkUI_DragPreviewScaleMode = u32;
#[doc = " Unknown."]
pub const ArkUI_DragStatus_ARKUI_DRAG_STATUS_UNKNOWN: ArkUI_DragStatus = -1;
#[doc = " Started."]
pub const ArkUI_DragStatus_ARKUI_DRAG_STATUS_STARTED: ArkUI_DragStatus = 0;
#[doc = " Ended."]
pub const ArkUI_DragStatus_ARKUI_DRAG_STATUS_ENDED: ArkUI_DragStatus = 1;
#[doc = " @brief Defines an enum for drag states.\n\n @since 12"]
pub type ArkUI_DragStatus = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DragEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DragPreviewOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DragAction {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DragAndDropInfo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Obtains a <b>ArkUI_DragEvent</b> object from the specified <b>ArkUI_NodeEvent</b> object.\n\n @param nodeEvent Indicates the pointer to an <b>ArkUI_NodeEvent</b> object.\n @return Returns the pointer to an <b>ArkUI_DragEvent</b> object.\n         Returns <b>null</b> if the parameter passed in is invalid or is not a drag-related event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetDragEvent(nodeEvent: *mut ArkUI_NodeEvent)
        -> *mut ArkUI_DragEvent;
}
extern "C" {
    #[doc = " @brief Obtains the interaction state prior to a drop and drop operation.\n\n @param nodeEvent Indicates the pointer to an <b>ArkUI_NodeEvent</b> object.\n @return Returns the interaction state prior to the drop and drop operation.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetPreDragStatus(
        nodeEvent: *mut ArkUI_NodeEvent,
    ) -> ArkUI_PreDragStatus;
}
extern "C" {
    #[doc = " @brief Sets whether to disable the default drop animation.\n The default drop animation is enabled by default and can be disabled to apply a custom drop animation.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param disable Indicates whether to disable the default drop animation.\n The value <b>true</b> means to disable the default drop animation, and <b>false</b> means the opposite.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_DisableDefaultDropAnimation(
        event: *mut ArkUI_DragEvent,
        disable: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the data processing mode.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param dropOperation Indicates the data processing mode.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_SetSuggestedDropOperation(
        event: *mut ArkUI_DragEvent,
        dropOperation: ArkUI_DropOperation,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the result for a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param result Indicates the drag result.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_SetDragResult(
        event: *mut ArkUI_DragEvent,
        result: ArkUI_DragResult,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set drag data for a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param data Indicates the drag data.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_SetData(event: *mut ArkUI_DragEvent, data: *mut OH_UdmfData) -> i32;
}
extern "C" {
    #[doc = " @brief Use this method to provide a data loading parameter to the system instead of providing\n a complete data object directly. When the user drags and drops to the target application,\n the system will use this parameter to request data from you. This can greatly improve the efficiency\n of the dragging operation for large amounts of data and the effectiveness of the drop data handling\n in the target application.\n\n This method should be always prioritized over using {@link OH_ArkUI_DragEvent_SetData}.\n See {@link OH_UdmfDataLoadParams_Create} in <b>udmf.h</b> for how to create and prepare the data loading parameter.\n\n [Note]: Please be awared this method is conflict with {@link OH_ArkUI_DragEvent_SetData}, and the system always use\n the last called method as the final result.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param dataLoadParams Indicates the data loading parameters which will be used when dropping.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_DragEvent_SetDataLoadParams(
        event: *mut ArkUI_DragEvent,
        dataLoadParams: *mut OH_UdmfDataLoadParams,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the default drag data from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param data Indicates the pointer to an <b>OH_UdmfData</b> object. The application needs to create a pointer\n             for receiving data by using the {@link OH_UdmfData_Create} method.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetUdmfData(
        event: *mut ArkUI_DragEvent,
        data: *mut OH_UdmfData,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of drag data types from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param count Indicates the number of drag data types returned.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetDataTypeCount(event: *mut ArkUI_DragEvent, count: *mut i32)
        -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the list of drag data types from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param eventTypeArray Indicates the list of the drag data types. You need to create a string array first.\n @param length Indicates the total length of the list array. It must be greater than or equal to the number obtained\n        by using {@link OH_ArkUI_DragEvent_GetDataTypeCount}.\n @param maxStrLen Indicates the max string length of drag data types.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} if the giving buffer is not enough for string copy.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetDataTypes(
        event: *mut ArkUI_DragEvent,
        eventTypeArray: *mut *mut ::std::os::raw::c_char,
        length: i32,
        maxStrLen: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the drag result from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param result Indicates the drag result returned.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetDragResult(
        event: *mut ArkUI_DragEvent,
        result: *mut ArkUI_DragResult,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the drop operation from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param operation Indicates the drop operation which the data receiver set.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n                 Possible causes: 1. The given parameters are null or the given event is not a valid DragEvent.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetDropOperation(
        event: *mut ArkUI_DragEvent,
        operation: *mut ArkUI_DropOperation,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of the touch point for a drag preview from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the X coordinate of the touch point, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetPreviewTouchPointX(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of the touch point for a drag preview from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the Y coordinate of the touch point, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetPreviewTouchPointY(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the width of a drag preview from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the width of the drag preview, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetPreviewRectWidth(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the height of a drag preview from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the height of the drag preview, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetPreviewRectHeight(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of the touch point relative to the window from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the X coordinate of the touch point relative to the window, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetTouchPointXToWindow(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of the touch point relative to the window from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the Y coordinate of the touch point relative to the window, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetTouchPointYToWindow(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of the touch point relative to the current display from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the X coordinate of the touch point relative to the current display, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetTouchPointXToDisplay(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of the touch point relative to the current display from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the Y coordinate of the touch point relative to the current display, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetTouchPointYToDisplay(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the global display X coordinate of the touch point from an <b>ArkUI_DragEvent</b> object.\n\n @param event Pointer to an <b>ArkUI_DragEvent</b> object.\n @return float Global display X coordinate of the touch point, in px.\n         If the input parameter is invalid, the default value <b>0</b> is returned.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_DragEvent_GetTouchPointXToGlobalDisplay(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the global display Y coordinate of the touch point from an <b>ArkUI_DragEvent</b> object.\n\n @param event Pointer to an <b>ArkUI_DragEvent</b> object.\n @return float Global display Y coordinate of the touch point, in px.\n         If the input parameter is invalid, the default value <b>0</b> is returned.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_DragEvent_GetTouchPointYToGlobalDisplay(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the dragging velocity along the x-axis.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the dragging velocity along the x-axis, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetVelocityX(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the dragging velocity along the y-axis.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the dragging velocity along the y-axis, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetVelocityY(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the dragging velocity along the main axis.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the dragging velocity along the main axis, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetVelocity(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the pressed status of modifier keys from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param keys {@link ArkUI_ModifierKeyName} Indicates the returned combination of modifier keys that are\n             currently pressed. The application can determine the pressed modifier keys through bitwise operations.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetModifierKeyStates(
        event: *mut ArkUI_DragEvent,
        keys: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the display ID of the screen for the specified drag event.\n\n @param event Pointer to an <b>ArkUI_DragEvent</b> object.\n @param displayId Display ID of the event occurs in.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_DragEvent_GetDisplayId(
        event: *mut ArkUI_DragEvent,
        displayId: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Request to start the data sync process with the sync option.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param options Indicates the pointer to an <b>OH_UdmfGetDataParams</b> object.\n @param key Represents return value after set data to database successfully, it should be not\n            less than {@link UDMF_KEY_BUFFER_LEN}.\n @param keyLen Represents the length of key string.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_DragEvent_StartDataLoading(
        event: *mut ArkUI_DragEvent,
        options: *mut OH_UdmfGetDataParams,
        key: *mut ::std::os::raw::c_char,
        keyLen: ::std::os::raw::c_uint,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Cancel the data sync process.\n\n @param uiContext Indicates the pointer to a UI instance.\n @param key Represents the data key returned by {@link OH_ArkUI_DragEvent_StartDataLoading}.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_CancelDataLoading(
        uiContext: ArkUI_ContextHandle,
        key: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to disable data prefetch process before the onDrop callback executing.\n        The system will retry to getting data until the max time limit (2.4s for now) reaches,\n        this's useful for the cross device draging operation, as the system helps to eliminate\n        the communication instability, but it's redundant for {@link OH_ArkUI_DragEvent_StartDataLoading}\n        method, as it will take care the data fetching with asynchronous mechanism, so must set this\n        field to true if using {@link OH_ArkUI_DragEvent_StartDataLoading} in onDrop to avoid the data is\n        fetched before onDrop executing unexpectedly.\n\n @param node Indicates the pointer to a component node.\n @param disabled Indicates whether to disable the data pre-fetch process, true for disable, false for not.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_DisableDropDataPrefetchOnNode(node: ArkUI_NodeHandle, disabled: bool) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable strict reporting on drag events.\n        This feature is disabled by default, and you are advised to enable it.\n        If this feature is disabled, the parent component is not notified when an item in it is dragged over its child\n        component. If this feature is enabled, the component is notified of the dragged item's leaving, and the chil\n        component to which the dragged item is dropped is notified of the item's entering. This configuration is\n        related to a specific UI instance. You can pass in a specific component node on the current UI instance\n        for association.\n\n @param node Indicates the pointer to a component node.\n @param enabled Indicates whether to enable strict reporting on drag events.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetDragEventStrictReportWithNode(node: ArkUI_NodeHandle, enabled: bool) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable strict reporting on drag events.\n        This feature is disabled by default, and you are advised to enable it.\n        If this feature is disabled, the parent component is not notified when an item in it is dragged over its child\n        component. If this feature is enabled, the component is notified of the dragged item's leaving, and the child\n        component to which the dragged item is dropped is notified of the item's entering. This configuration is\n        related to a specific UI instance. You can pass in a specific UI instance for association.\n\n @param uiContext Indicates the pointer to a UI instance.\n @param enabled Indicates whether to enable strict reporting on drag events.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetDragEventStrictReportWithContext(
        uiContext: ArkUI_ContextHandle,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the types of data that can be dropped to the specified component. This API resets the settings configured\n        through {@link OH_ArkUI_DisallowNodeAnyDropDataTypes} and {@link OH_ArkUI_AllowNodeAllDropDataTypes}.\n\n @param node Indicates the pointer to a component node.\n @param typesArray Indicates the array of types of data that can be dropped.\n @param count Indicates length of an array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetNodeAllowedDropDataTypes(
        node: ArkUI_NodeHandle,
        typesArray: *mut *const ::std::os::raw::c_char,
        count: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Configures the specified component to disallow any data types. This API resets the settings configured through\n        {@link OH_ArkUI_SetNodeAllowedDropDataTypes}.\n\n @param node Indicates the pointer to a component node.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DisallowNodeAnyDropDataTypes(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Configures the specified component to allow any data types. This API resets the settings configured through\n        {@link OH_ArkUI_SetNodeAllowedDropDataTypes}.\n\n @param node Indicates the pointer to a component node.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AllowNodeAllDropDataTypes(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether the specified component is draggable.\n\n @param node Indicates the pointer to a component node.\n @param enabled Indicates whether the component is draggable.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetNodeDraggable(node: ArkUI_NodeHandle, enabled: bool) -> i32;
}
extern "C" {
    #[doc = " @brief Sets a custom drag preview for the specified component.\n\n @param node Indicates the pointer to a component node.\n @param preview Indicates the custom drag preview, which is a pixel map.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetNodeDragPreview(
        node: ArkUI_NodeHandle,
        preview: *mut OH_PixelmapNative,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Creates an <b>ArkUI_DragPreviewOption</b> object.\n\n @return Returns the created <b>ArkUI_DragPreviewOption</b> object.\n @since 12"]
    pub fn OH_ArkUI_CreateDragPreviewOption() -> *mut ArkUI_DragPreviewOption;
}
extern "C" {
    #[doc = " @brief Disposes of a <b>ArkUI_DragPreviewOption</b> object.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_Dispose(option: *mut ArkUI_DragPreviewOption);
}
extern "C" {
    #[doc = " @brief Sets the scale mode for an <b>ArkUI_DragPreviewOption</b> object.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param scaleMode Indicates the scale mode.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetScaleMode(
        option: *mut ArkUI_DragPreviewOption,
        scaleMode: ArkUI_DragPreviewScaleMode,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the shadow effect for an <b>ArkUI_DragPreviewOption</b> object.\n        The shadow effect is enabled by default.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param enabled Indicates whether to enable the shadow effect.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetDefaultShadowEnabled(
        option: *mut ArkUI_DragPreviewOption,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the rounded corner effect for an <b>ArkUI_DragPreviewOption</b> object.\n        The rounded corner effect is enabled by default.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param enabled Indicates whether to enable the rounded corner effect.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetDefaultRadiusEnabled(
        option: *mut ArkUI_DragPreviewOption,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the badge for an <b>ArkUI_DragPreviewOption</b> object.\n        If this feature is enabled, a badge that contains the number of dragged items is displayed.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param enabled Indicates whether to enable badge.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetNumberBadgeEnabled(
        option: *mut ArkUI_DragPreviewOption,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the count on the badge.\n        The settings will overwrite the value in the <b>SetDragPreviewNumberBadgeEnabled</b> API.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param forcedNumber Indicates the count on the badge.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetBadgeNumber(
        option: *mut ArkUI_DragPreviewOption,
        forcedNumber: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the default animation on a click or touch, it's not used in drag action.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param enabled Indicates whether to enable the default animation on a click or touch.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetDefaultAnimationBeforeLiftingEnabled(
        option: *mut ArkUI_DragPreviewOption,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets an <b>ArkUI_DragPreviewOption</b> object for the specified component.\n\n @param node Indicates the pointer to a component node.\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetNodeDragPreviewOption(
        node: ArkUI_NodeHandle,
        option: *mut ArkUI_DragPreviewOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Creates a drag action object for a UI instance based on the specified component node of the current\n        UI instance.\n\n @param node Indicates the pointer to a component node.\n @return Returns the pointer to the created drag action object; returns null if the operation fails.\n @since 12"]
    pub fn OH_ArkUI_CreateDragActionWithNode(node: ArkUI_NodeHandle) -> *mut ArkUI_DragAction;
}
extern "C" {
    #[doc = " @brief Creates a drag action object for the specified UI instance.\n\n @param uiContext Indicates the pointer to a UI instance.\n @return Returns the pointer to the created drag action object; returns null if the operation fails.\n @since 12"]
    pub fn OH_ArkUI_CreateDragActionWithContext(
        uiContext: ArkUI_ContextHandle,
    ) -> *mut ArkUI_DragAction;
}
extern "C" {
    #[doc = " @brief Disposes of a drag action object.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @since 12"]
    pub fn OH_ArkUI_DragAction_Dispose(dragAction: *mut ArkUI_DragAction);
}
extern "C" {
    #[doc = " @brief Sets the pointer ID. If only one finger is operating on the screen, the pointer ID is 0.\n        In general cases, you can set the pointer ID to 0.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param pointer Indicates the pointer ID. The value ranges from 0 to 9.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetPointerId(dragAction: *mut ArkUI_DragAction, pointer: i32)
        -> i32;
}
extern "C" {
    #[doc = " @brief Sets the drag previews for a drag action.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param pixelmapArray Indicates the array of the drag previews to set, which must be pixel maps.\n @param size Indicates the size of the drag preview array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetPixelMaps(
        dragAction: *mut ArkUI_DragAction,
        pixelmapArray: *mut *mut OH_PixelmapNative,
        size: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the touch point relative to the upper left corner of the first drag preview (pixel map).\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param x Indicates the X coordinate of the touch point.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetTouchPointX(dragAction: *mut ArkUI_DragAction, x: f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the touch point relative to the upper left corner of the first drag preview (pixel map).\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param y Indicates the Y coordinate of the touch point.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetTouchPointY(dragAction: *mut ArkUI_DragAction, y: f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the drag data.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param data Indicates the drag data.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetData(
        dragAction: *mut ArkUI_DragAction,
        data: *mut OH_UdmfData,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Use this method to provide a data loading parameter to the system instead of providing\n a complete data object directly. When the user drags and drops to the target application,\n the system will use this parameter to request data from you. This can greatly improve the efficiency\n of the dragging operation for large amounts of data and the effectiveness of the drop data handling\n in the target application.\n\n It's recommanded to use this method instead of using {@link OH_ArkUI_DragAction_SetData}.\n See {@link OH_UdmfDataLoadParams_Create} in <b>udmf.h</b> for how to create and prepare the data loading parameter.\n\n [Note]: Please be awared this method is conflict with {@link OH_ArkUI_DragAction_SetData}, and the system always use\n the last called method as the final result.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param dataLoadParams Indicates the data loading parameters which will be used when dropping.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_DragAction_SetDataLoadParams(
        dragAction: *mut ArkUI_DragAction,
        dataLoadParams: *mut OH_UdmfDataLoadParams,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets an <b>ArkUI_DragPreviewOption</b> object for the specified drag action object.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetDragPreviewOption(
        dragAction: *mut ArkUI_DragAction,
        option: *mut ArkUI_DragPreviewOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a drag status listener.\n        This listener can be used to check whether the data is successfully  received and processed.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param userData Indicates the custom user data.\n @param listener\n Indicates the listener to register. When the callback is invoked, the system returns a pointer to the drag status\n object. The pointer is destroyed after the callback is complete and the application should not hold it anymore.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_RegisterStatusListener(
        dragAction: *mut ArkUI_DragAction,
        userData: *mut ::std::os::raw::c_void,
        listener: ::std::option::Option<
            unsafe extern "C" fn(
                dragAndDropInfo: *mut ArkUI_DragAndDropInfo,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregisters a drag status listener.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @since 12"]
    pub fn OH_ArkUI_DragAction_UnregisterStatusListener(dragAction: *mut ArkUI_DragAction);
}
extern "C" {
    #[doc = " @brief Obtains the drag status of a drag action.\n\n @param dragAndDropInfo Indicates the drag and drop information returned by the drag status listener.\n @return Returns an <b>ArkUI_DragStatus</b> object; returns <b>ArkUI_DRAG_STATUS_UNKNOWN</b> if an error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAndDropInfo_GetDragStatus(
        dragAndDropInfo: *mut ArkUI_DragAndDropInfo,
    ) -> ArkUI_DragStatus;
}
extern "C" {
    #[doc = " @brief Obtains a drag event based on the specified drag and drop information.\n        The drag event can then be used to obtain the drag result and the drag behavior, please note\n        other info is not included in such a drag event.\n\n @param dragAndDropInfo Indicates the drag and drop information returned by the drag status listener.\n @return Returns an <b>ArkUI_DragEvent</b> object; returns null if an error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAndDropInfo_GetDragEvent(
        dragAndDropInfo: *mut ArkUI_DragAndDropInfo,
    ) -> *mut ArkUI_DragEvent;
}
extern "C" {
    #[doc = " @brief Initiates a drag action through the specified drag action object.\n\n @param dragAction Indicates a drag action object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_StartDrag(dragAction: *mut ArkUI_DragAction) -> i32;
}
extern "C" {
    #[doc = " @brief Request to delay the drop end handling for a while to wait until the process result\n        is really conformed by application, the result need to be notified back to system through\n        {@link OH_ArkUI_NotifyDragResult} interface. And when all the handling done, the\n        {@link OH_ArkUI_NotifyDragEndPendingDone} should be called.\n        Please be aware, the maximum pending time is 2 seconds;\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param requestIdentify Indicates the Identify for the request initiated by this method, it's a number generated\nby system automatically, and it's an out parameter too, so one valid address needed.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_DRAG_DROP_OPERATION_NOT_ALLOWED} if current is not during the drop handing.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_DragEvent_RequestDragEndPending(
        event: *mut ArkUI_DragEvent,
        requestIdentify: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Notify the system final drag result, the request identify will be checked, it should be the same\n        as the one returned by {@link OH_ArkUI_DragEvent_RequestDragEndPending} interface, if it's not,\n        the calling will be ignored.\n\n @param requestIdentify The identify returned by {@link OH_ArkUI_DragEvent_RequestDragEndPending} interface.\n @param result Indicates the drag result.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_DRAG_DROP_OPERATION_NOT_ALLOWED} if current is not during the drop handing.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_NotifyDragResult(requestIdentify: i32, result: ArkUI_DragResult) -> i32;
}
extern "C" {
    #[doc = " @brief Notify the system all handling done, the drag end pending can be finished.\n\n @param requestIdentify The identify returned by {@link OH_ArkUI_DragEvent_RequestDragEndPending} interface.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_DRAG_DROP_OPERATION_NOT_ALLOWED} if current is not during the drop handing.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_NotifyDragEndPendingDone(requestIdentify: i32) -> i32;
}
extern "C" {
    #[doc = " @brief Use this method to obtain the application bundle name of the drag-and-drop initiator, you need\n  to pass a character array for receiving the string and explicitly specify the array length. It is\n  recommended that the array length be no less than 128 characters. If the length cannot accommodate\n  the actual bundle name length, the ERROR result will be returned.\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param bundleName A string array used to receive the source application's bundle name.\n @param length Use this to explicitly specify the length of the incoming string array.\n  It is recommended to be bigger than 128.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_DragEvent_GetDragSource(
        event: *mut ArkUI_DragEvent,
        bundleName: *mut ::std::os::raw::c_char,
        length: i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Call this method to determine whether the current drag and drop operation is cross-device.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param isRemote Boolean pointer to receive the result.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_DragEvent_IsRemote(
        event: *mut ArkUI_DragEvent,
        isRemote: *mut bool,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the display of a disallow status icon.\n\n Typically, when a component can receive or process data dragged by the user, or when it declares to the\n system that data should be processed in COPY way by setting ARKUI_DROP_OPERATION_COPY through\n {@link OH_ArkUI_DragEvent_SetSuggestedDropOperation}, the system will display\n a plus sign together with the data number on the upper-left corner of the dragged object; if setting\n ARKUI_DROP_OPERATION_MOVE to the system to declare that data should be processed in CUT way, the system will only\n display the data number on the upper-left corner of the dragged object.\n\n In some cases, when the system determines or the component explicitly declares that it cannot handle the\n data that the user is dragging, the system displays a badge icon in the same way as it does for DragBehavior.MOVE.\n So if you want to show the more clearly status, you can call this method on the UI instance in advance to force\n the system to display a clear prohibition icon on the upper left corner in such cases, and the user can clearly\n know that data cannot be dropped here.\n\n @param uiContext Pointer to a UI instance.\n @param enabled Whether to enable the display of the disallow badge icon.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_EnableDropDisallowedBadge(
        uiContext: ArkUI_ContextHandle,
        enabled: bool,
    ) -> ArkUI_ErrorCode;
}
#[doc = " @brief Defines the expected frame rate range of the animation.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ExpectedFrameRateRange {
    #[doc = " Expected minimum frame rate."]
    pub min: u32,
    #[doc = " Expected maximum frame rate."]
    pub max: u32,
    #[doc = " Expected optimal frame rate."]
    pub expected: u32,
}
#[doc = " @brief Defines the callback type for when the animation playback is complete.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimateCompleteCallback {
    #[doc = " Type of the <b>onFinish</b> callback."]
    pub type_: ArkUI_FinishCallbackType,
    #[doc = " Callback invoked when the animation playback is complete."]
    pub callback:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
    #[doc = " Custom type."]
    pub userData: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimateOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Curve {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to an interpolation curve.\n\n @since 12"]
pub type ArkUI_CurveHandle = *mut ArkUI_Curve;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_KeyframeAnimateOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimatorOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Animator {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to an animator object.\n\n @since 12"]
pub type ArkUI_AnimatorHandle = *mut ArkUI_Animator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimatorEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimatorOnFrameEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TransitionEffect {
    _unused: [u8; 0],
}
#[doc = " @brief Implements the native animation APIs provided by ArkUI.\n\n @version 1\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeAnimateAPI_1 {
    #[doc = " @brief Defines an explicit animation.\n\n @note Make sure the component attributes to be set in the event closure have been set before.\n\n @param context Indicates a <b>UIContext</b> instance.\n @param option Indicates the pointer to an animation configuration.\n @param update Indicates the animation closure. The system automatically inserts a transition animation for the\n state change caused by the closure.\n @param complete Indicates the callback to be invoked when the animation playback is complete.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub animateTo: ::std::option::Option<
        unsafe extern "C" fn(
            context: ArkUI_ContextHandle,
            option: *mut ArkUI_AnimateOption,
            update: *mut ArkUI_ContextCallback,
            complete: *mut ArkUI_AnimateCompleteCallback,
        ) -> i32,
    >,
    #[doc = " @brief Sets the keyframe animation.\n\n\n @param context Indicates a <b>UIContext</b> instance.\n @param option Indicates the keyframe animation parameters.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub keyframeAnimateTo: ::std::option::Option<
        unsafe extern "C" fn(
            context: ArkUI_ContextHandle,
            option: *mut ArkUI_KeyframeAnimateOption,
        ) -> i32,
    >,
    #[doc = " @brief Creates an animator object.\n\n @param context Indicates a <b>UIContext</b> instance.\n @param option Indicates the animator parameters.\n @return Returns the pointer to the animator object; returns <b>NULL</b> if a function parameter error occurs."]
    pub createAnimator: ::std::option::Option<
        unsafe extern "C" fn(
            context: ArkUI_ContextHandle,
            option: *mut ArkUI_AnimatorOption,
        ) -> ArkUI_AnimatorHandle,
    >,
    #[doc = " @brief Disposes of an animator object.\n\n @param animatorHandle Indicates the target animator object."]
    pub disposeAnimator:
        ::std::option::Option<unsafe extern "C" fn(animatorHandle: ArkUI_AnimatorHandle)>,
}
extern "C" {
    #[doc = " @brief Creates an animation configuration.\n\n @return Returns the pointer to the created animation configuration.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_Create() -> *mut ArkUI_AnimateOption;
}
extern "C" {
    #[doc = " @brief Disposes of an animation configuration.\n\n @param option Indicates the pointer to an animation configuration.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_Dispose(option: *mut ArkUI_AnimateOption);
}
extern "C" {
    #[doc = " @brief Obtains the animation duration, in milliseconds.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the duration.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetDuration(option: *mut ArkUI_AnimateOption) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the animation playback speed.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the animation playback speed.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetTempo(option: *mut ArkUI_AnimateOption) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the animation curve.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the animated curve.If Null is returned, it means option is an invalid value.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetCurve(
        option: *mut ArkUI_AnimateOption,
    ) -> ArkUI_AnimationCurve;
}
extern "C" {
    #[doc = " @brief Obtains the animation delay, in milliseconds.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the animation delay.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetDelay(option: *mut ArkUI_AnimateOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of times that an animation is played.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the number of times that the animation is played.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetIterations(option: *mut ArkUI_AnimateOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the animation playback mode.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the animation playback mode.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetPlayMode(
        option: *mut ArkUI_AnimateOption,
    ) -> ArkUI_AnimationPlayMode;
}
extern "C" {
    #[doc = " @brief Obtains the expected frame rate range of an animation.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the expected frame rate range.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetExpectedFrameRateRange(
        option: *mut ArkUI_AnimateOption,
    ) -> *mut ArkUI_ExpectedFrameRateRange;
}
extern "C" {
    #[doc = " @brief Sets the animation duration.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the duration, in milliseconds.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetDuration(option: *mut ArkUI_AnimateOption, value: i32);
}
extern "C" {
    #[doc = " @brief Sets the animation playback speed.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the animation playback speed.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetTempo(option: *mut ArkUI_AnimateOption, value: f32);
}
extern "C" {
    #[doc = " @brief Sets the animation curve.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the animated curve. Default valueARKUI_CURVE_LINEAR.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetCurve(
        option: *mut ArkUI_AnimateOption,
        value: ArkUI_AnimationCurve,
    );
}
extern "C" {
    #[doc = " @brief Sets the animation delay.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the animation delay.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetDelay(option: *mut ArkUI_AnimateOption, value: i32);
}
extern "C" {
    #[doc = " @brief Sets the number of times that an animation is played.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the number of times that the animation is played.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetIterations(option: *mut ArkUI_AnimateOption, value: i32);
}
extern "C" {
    #[doc = " @brief Sets the animation playback mode.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the animation playback mode.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetPlayMode(
        option: *mut ArkUI_AnimateOption,
        value: ArkUI_AnimationPlayMode,
    );
}
extern "C" {
    #[doc = " @brief Sets the expected frame rate range of an animation.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the expected frame rate range.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetExpectedFrameRateRange(
        option: *mut ArkUI_AnimateOption,
        value: *mut ArkUI_ExpectedFrameRateRange,
    );
}
extern "C" {
    #[doc = " @brief Sets the animation curve for the animation of an animator.\n\n @note This method is better than the value set by OH_ArkUI_AnimateOption_SetCurve.\n @param option Indicates the animator parameters.\n @param value Indicates the animation curve settings.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetICurve(
        option: *mut ArkUI_AnimateOption,
        value: ArkUI_CurveHandle,
    );
}
extern "C" {
    #[doc = " @brief Obtains the animation curve of the animation of an animator.\n\n @param option Indicates the animator parameters.\n @return Returns the animation curve of the specified animation.\n If Null is returned, it means option is an invalid value.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetICurve(option: *mut ArkUI_AnimateOption) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Obtains the keyframe animation parameters.\n\n @param size Indicates the number of keyframe animation states.\n @return Returns the keyframe animation parameter object; returns <b>NULL</b> if the value of <b>size</b> is less than\n 0.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_Create(size: i32) -> *mut ArkUI_KeyframeAnimateOption;
}
extern "C" {
    #[doc = " @brief Disposes of the keyframe animation parameter object.\n\n @param option Indicates the keyframe animation parameter object.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_Dispose(option: *mut ArkUI_KeyframeAnimateOption);
}
extern "C" {
    #[doc = " @brief Sets the overall delay of a keyframe animation, in milliseconds. By default, the keyframe animation is played\n without delay.\n\n @param option Indicates the keyframe animation parameters.\n @param value Indicates the delay, in milliseconds.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_SetDelay(
        option: *mut ArkUI_KeyframeAnimateOption,
        value: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the number of times that the keyframe animation is played. By default, the animation is played once.\n The value <b>-1</b> indicates that the animation is played for an unlimited number of times. The value <b>0</b>\n indicates that there is no animation.\n\n @param option Indicates the keyframe animation parameters.\n @param value Indicates the number of times that the animation is played.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_SetIterations(
        option: *mut ArkUI_KeyframeAnimateOption,
        value: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the keyframe animation playback is complete. This API is called after the\n keyframe animation has played for the specified number of times.\n\n @param option Indicates the keyframe animation parameters.\n @param userData Indicates the pointer to a custom object.\n @param onFinish Indicates the callback.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_RegisterOnFinishCallback(
        option: *mut ArkUI_KeyframeAnimateOption,
        userData: *mut ::std::os::raw::c_void,
        onFinish: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the expected frame rate range of a keyframe animation.\n\n @param option Indicates the pointer to a keyframe animation configuration.\n @param frameRate Indicates the expected frame rate range.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_KeyframeAnimateOption_SetExpectedFrameRate(
        option: *mut ArkUI_KeyframeAnimateOption,
        frameRate: *mut ArkUI_ExpectedFrameRateRange,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the duration of a keyframe animation, in milliseconds.\n\n @param option Indicates the keyframe animation parameters.\n @param value Indicates the duration to set, in milliseconds.\n @param index Indicates a state index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_SetDuration(
        option: *mut ArkUI_KeyframeAnimateOption,
        value: i32,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the animation curve for a specific keyframe in a keyframe animation.\n\n @note Because the <b>springMotion</b>, <b>responsiveSpringMotion</b>, and <b>interpolatingSpring</b> curves do not\n have effective duration settings, they are not supported.\n @param option Indicates the keyframe animation parameters.\n @param value Indicates the animation curve to set. Default valueEASE_IN_OUT.\n @param index Indicates a state index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_SetCurve(
        option: *mut ArkUI_KeyframeAnimateOption,
        value: ArkUI_CurveHandle,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the closure function of the state at the time of the keyframe, that is, the state to be reached at the\n time of the keyframe.\n\n @param option Indicates the keyframe animation parameters.\n @param event Indicates a closure function.\n @param userData Indicates the pointer to a custom object.\n @param index Indicates a state index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_RegisterOnEventCallback(
        option: *mut ArkUI_KeyframeAnimateOption,
        userData: *mut ::std::os::raw::c_void,
        event: ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the overall delay of a keyframe animation\n\n @param option Indicates the keyframe animation parameters.\n @return Returns the overall delay.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_GetDelay(option: *mut ArkUI_KeyframeAnimateOption)
        -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of times that a keyframe animation is played.\n\n @param option Indicates the keyframe animation parameters.\n @return Returns the number of times that the animation is played.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_GetIterations(
        option: *mut ArkUI_KeyframeAnimateOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the expected frame rate range of a keyframe animation configuration.\n\n @param option Indicates the pointer to a keyframe animation configuration.\n @return Returns the expected frame rate range of the keyframe animation.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_KeyframeAnimateOption_GetExpectedFrameRate(
        option: *mut ArkUI_KeyframeAnimateOption,
    ) -> *mut ArkUI_ExpectedFrameRateRange;
}
extern "C" {
    #[doc = " @brief Obtains the duration of a specific state in a keyframe animation.\n\n @param option Indicates the keyframe animation parameters.\n @param index Indicates a state index.\n @return Returns the duration. The unit is millisecond.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_GetDuration(
        option: *mut ArkUI_KeyframeAnimateOption,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the animation curve of a specific state in a keyframe animation.\n\n @param option Indicates the keyframe animation parameters.\n @param index Indicates a state index.\n @return Returns the animated curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_GetCurve(
        option: *mut ArkUI_KeyframeAnimateOption,
        index: i32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates an animator parameter object.\n\n @note When <b>keyframeSize</b> is greater than 0, the animation interpolation start point is 0, and the animation\n interpolation end point is 1; no setting is allowed.\n @param keyframeSize Indicates the number of keyframes.\n @return Returns the pointer to the animator parameter object.\n returns <b>NULL</b> if the value of <b>size</b> is less than 0.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_Create(keyframeSize: i32) -> *mut ArkUI_AnimatorOption;
}
extern "C" {
    #[doc = " @brief Disposes of an animator parameter object.\n\n @param option Indicates the target animator parameter object.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_Dispose(option: *mut ArkUI_AnimatorOption);
}
extern "C" {
    #[doc = " @brief Sets the duration for thea nimation of an animator, in milliseconds.\n\n @param option Indicates the target animator parameter object.\n @param value Indicates the playback duration, in milliseconds.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetDuration(
        option: *mut ArkUI_AnimatorOption,
        value: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the delay for playing the animation of an animator, in milliseconds.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the delay to set, in milliseconds.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetDelay(option: *mut ArkUI_AnimatorOption, value: i32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the number of times that the animation of an animator is played. The value <b>0</b> means not to play the\n animation, and <b>-1</b> means to play the animation for an unlimited number of times.\n\n @note If this parameter is set to a negative value other than <b>-1</b>, the value is invalid. In this case, the\n animation is played once.\n @param option Indicates an animator parameter object.\n @param value Indicates the number of times that the animation is played.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetIterations(
        option: *mut ArkUI_AnimatorOption,
        value: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether the animation of an animator is restored to the initial state after being executed.\n\n @param option Indicates an animator parameter object.\n @param value Indicates whether to restore the animation to the initial state after the animation is executed.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetFill(
        option: *mut ArkUI_AnimatorOption,
        value: ArkUI_AnimationFillMode,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the playback direction for the animation of an animator.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the animation playback direction.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetDirection(
        option: *mut ArkUI_AnimatorOption,
        value: ArkUI_AnimationDirection,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the interpolation curve for the animation of an animator.\n\n @note <b>springCurve</b>, <b>springMotion</b>, <b>responsiveSpringMotion</b>, <b>interpolatingSpring</b>,\n and <b>customCurve</b> curves are not supported.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the target interpolation curve. Default valueARKUI_CURVE_LINEAR.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetCurve(
        option: *mut ArkUI_AnimatorOption,
        value: ArkUI_CurveHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the interpolation start point for the animation of an animator.\n @note This API does not take effect when the animation is a keyframe animation.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the interpolation start point to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetBegin(option: *mut ArkUI_AnimatorOption, value: f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the interpolation end point for the animation of an animator.\n @note This API does not take effect when the animation is a keyframe animation.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the interpolation end point to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetEnd(option: *mut ArkUI_AnimatorOption, value: f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the expected frame rate range for the animation of an animator.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the expected frame rate range to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetExpectedFrameRateRange(
        option: *mut ArkUI_AnimatorOption,
        value: *mut ArkUI_ExpectedFrameRateRange,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the keyframe parameters for the animation of an animator.\n\n @param option Indicates an animator parameter object.\n @param time Indicates the keyframe time. Value range: [0,1].\n @param value Indicates the keyframe value.\n @param index Indicates the keyframe index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetKeyframe(
        option: *mut ArkUI_AnimatorOption,
        time: f32,
        value: f32,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the keyframe curve type for the animation of an animator.\n\n @note <b>springCurve</b>, <b>springMotion</b>, <b>responsiveSpringMotion</b>, <b>interpolatingSpring</b>,\n and <b>customCurve</b> curves are not supported.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the target interpolation curve.\n @param index Indicates the keyframe index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetKeyframeCurve(
        option: *mut ArkUI_AnimatorOption,
        value: ArkUI_CurveHandle,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the duration for playing an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the duration for playing the animation, in milliseconds.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetDuration(option: *mut ArkUI_AnimatorOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the delay for playing the animation of an animator.\n\n @param option Indicates the animator parameters.\n @return Returns the delay for playing the animation, in milliseconds.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetDelay(option: *mut ArkUI_AnimatorOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of times that an animation is played.\n\n @param option Animator animation parameter.\n @return Returns the number of times that the animation is played.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetIterations(option: *mut ArkUI_AnimatorOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether the animator animation is restored to the initial state after being executed.\n\n @param option Indicates the animator parameters.\n @return Returns whether the animator animation is restored to the initial state after being executed.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetFill(
        option: *mut ArkUI_AnimatorOption,
    ) -> ArkUI_AnimationFillMode;
}
extern "C" {
    #[doc = " @brief Obtains the playback direction of an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the animation playback direction.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetDirection(
        option: *mut ArkUI_AnimatorOption,
    ) -> ArkUI_AnimationDirection;
}
extern "C" {
    #[doc = " @brief Obtains the interpolation curve of the animation of an animator.\n\n @param option Indicates the animator parameters.\n @return Returns the interpolation curve of the animation.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetCurve(option: *mut ArkUI_AnimatorOption)
        -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Obtains the interpolation start point of an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the interpolation start point of the animation.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetBegin(option: *mut ArkUI_AnimatorOption) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the interpolation end point of an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the interpolation end point of the animation.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetEnd(option: *mut ArkUI_AnimatorOption) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the expected frame rate range of an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the pointer to the expected frame rate range object.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetExpectedFrameRateRange(
        option: *mut ArkUI_AnimatorOption,
    ) -> *mut ArkUI_ExpectedFrameRateRange;
}
extern "C" {
    #[doc = " @brief Obtains the keyframe time of an animation.\n\n @param option Indicates an animator parameter object.\n @param index Indicates the keyframe index.\n @return Returns the keyframe time.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetKeyframeTime(
        option: *mut ArkUI_AnimatorOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the keyframe value of an animation.\n\n @param option Indicates an animator parameter object.\n @param index Indicates the keyframe index.\n @return Returns the keyframe value.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetKeyframeValue(
        option: *mut ArkUI_AnimatorOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the interpolation curve for a keyframe in the animation of an animator.\n\n @param option Indicates an animator parameter object.\n @param index Indicates the keyframe index.\n @return Returns the interpolation curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetKeyframeCurve(
        option: *mut ArkUI_AnimatorOption,
        index: i32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Obtains the custom object in an animation event object.\n\n @param event Indicates an animation event object.\n @return Returns the custom object.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorEvent_GetUserData(
        event: *mut ArkUI_AnimatorEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the custom object in an animation event object.\n\n @param event Indicates an animation event object.\n @return Returns the custom object.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOnFrameEvent_GetUserData(
        event: *mut ArkUI_AnimatorOnFrameEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the current progress in an animation event object.\n\n @param event Indicates an animation event object.\n @return Returns the animation progress.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOnFrameEvent_GetValue(event: *mut ArkUI_AnimatorOnFrameEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the animator receives a frame.\n\n @param option Indicates an animator parameter object.\n @param userData Indicates the custom parameter.\n @param callback Indicates the callback to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_RegisterOnFrameCallback(
        option: *mut ArkUI_AnimatorOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(event: *mut ArkUI_AnimatorOnFrameEvent),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the animation playback is complete.\n\n @param option Indicates an animator parameter object.\n @param userData Indicates the custom parameter.\n @param callback Indicates the callback to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_RegisterOnFinishCallback(
        option: *mut ArkUI_AnimatorOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_AnimatorEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the animation playback is canceled.\n\n @param option Indicates an animator parameter object.\n @param userData Indicates the custom parameter.\n @param callback Indicates the callback to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_RegisterOnCancelCallback(
        option: *mut ArkUI_AnimatorOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_AnimatorEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the animation playback is repeated.\n\n @param option Indicates an animator parameter object.\n @param userData Indicates the custom parameter.\n @param callback Indicates the callback to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_RegisterOnRepeatCallback(
        option: *mut ArkUI_AnimatorOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_AnimatorEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Resets the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @param option Indicates the animator parameters.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_ResetAnimatorOption(
        animatorHandle: ArkUI_AnimatorHandle,
        option: *mut ArkUI_AnimatorOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Starts the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Play(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Ends the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Finish(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Pauses the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Pause(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Cancels the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Cancel(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Plays the animation of an animator in reverse order.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Reverse(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Implements initialization for the interpolation curve, which is used to create an interpolation curve based on\n the input parameter.\n\n @param curve Indicates the curve type.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Curve_CreateCurveByType(curve: ArkUI_AnimationCurve) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a step curve.\n\n @param count Indicates the number of steps. The value must be a positive integer. Value range: [1, +).\n @param end Indicates whether jumping occurs when the interpolation ends.\n <b>true</b>: Jumping occurs when the interpolation ends. <b>false</b>: Jumping occurs when the interpolation starts.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Curve_CreateStepsCurve(count: i32, end: bool) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a cubic Bezier curve.\n\n\n @param x1 Indicates the X coordinate of the first point on the Bezier curve. Value range: [0, 1].\n A value less than 0 is handed as <b>0</b>. A value greater than 1 is handed as <b>1</b>.\n @param y1 Indicates the Y coordinate of the first point on the Bezier curve.\n @param x2 Indicates the X coordinate of the second point on the Bezier curve. Value range: [0, 1].\n A value less than 0 is handed as <b>0</b>. A value greater than 1 is handed as <b>1</b>.\n @param y2 Indicates the Y coordinate of the second point on the Bezier curve.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Curve_CreateCubicBezierCurve(
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a spring curve. The curve shape is subject to the spring parameters, and the animation duration is\n subject to the <b>duration</b> parameter in <b>animation</b> and <b>animateTo</b>.\n\n @param velocity Indicates the initial velocity of the spring. It is applied by external factors to the spring\n animation, designed to help ensure the smooth transition from the previous motion state. The velocity is the\n normalized velocity, and its value is equal to the actual velocity at the beginning of the animation divided by the\n  animation attribute change value.\n @param mass Indicates the mass, which influences the inertia in the spring system. The greater the mass, the greater\n the amplitude of the oscillation, and the slower the speed of restoring to the equilibrium position.\n @param stiffness Indicates the stiffness. It is the degree to which an object deforms by resisting the force applied.\n In an elastic system, the greater the stiffness, the stronger the ability to resist deformation, and the faster the\n speed of restoring to the equilibrium position.\n @param damping Indicates the damping. It is used to describe the oscillation and attenuation of the system after\n being disturbed. The larger the damping, the smaller the number of oscillations of elastic motion, and the smaller\n the oscillation amplitude.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Curve_CreateSpringCurve(
        velocity: f32,
        mass: f32,
        stiffness: f32,
        damping: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a spring animation curve. If multiple spring animations are applied to the same attribute of an\n  object, each animation replaces their predecessor and inherits the velocity.\n @note The animation duration is subject to the curve parameters, rather than the <b>duration</b> parameter in\n <b>animation</b> or <b>animateTo</b>.\n\n @param response Indicates the duration of one complete oscillation.\n @param dampingFraction Indicates the damping coefficient.\n > 0 and < 1: underdamped. In this case, the spring overshoots the equilibrium position.\n <b>1</b>: critically damped.\n > 1: overdamped. In this case, the spring approaches equilibrium gradually.\n @param overlapDuration Indicates the duration for animations to overlap. When animations overlap, the <b>response</b>\n values of these animations will\n transit smoothly over this duration if they are different.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Curve_CreateSpringMotion(
        response: f32,
        dampingFraction: f32,
        overlapDuration: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a responsive spring animation curve. It is a special case of <b>springMotion</b>, with the only\n difference in the default values. It can be used together with <b>springMotion</b>.\n @note The animation duration is subject to the curve parameters, rather than the <b>duration</b> parameter in\n <b>animation</b> or <b>animateTo</b>.\n\n @param response Indicates the duration of one complete oscillation.\n @param dampingFraction Indicates the damping coefficient.\n > 0 and < 1: underdamped. In this case, the spring overshoots the equilibrium position.\n <b>1</b>: critically damped.\n > 1: overdamped. In this case, the spring approaches equilibrium gradually.\n @param overlapDuration Indicates the duration for animations to overlap. When animations overlap, the\n <b>response</b> values of these animations will\n transit smoothly over this duration if they are different.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Curve_CreateResponsiveSpringMotion(
        response: f32,
        dampingFraction: f32,
        overlapDuration: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates an interpolating spring curve animated from 0 to 1. The actual animation value is calculated based on\n the curve.\n @note The animation duration is subject to the curve parameters, rather than the <b>duration</b> parameter in\n <b>animation</b> or <b>animateTo</b>.\n\n\n @param velocity Indicates the initial velocity of the spring. It is applied by external factors to the spring\n animation, esigned to help ensure the smooth transition from the previous motion state. The velocity is the\n normalized velocity, and its value is equal to the actual velocity\n at the beginning of the animation divided by the animation attribute change value.\n @param mass Indicates the mass, which influences the inertia in the spring system.\n The greater the mass, the greater the amplitude of the oscillation, and the slower the speed of restoring to the\n equilibrium position.\n @param stiffness Indicates the stiffness. It is the degree to which an object deforms by resisting the force applied.\n In an elastic system, the greater the stiffness, the stronger the ability to resist deformation, and the faster the\n speed of restoring to the equilibrium position.\n @param damping Indicates the damping. It is used to describe the oscillation and attenuation of the system after\n being disturbed. The larger the damping, the smaller the number of oscillations of elastic motion, and the smaller\n the oscillation amplitude.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Curve_CreateInterpolatingSpring(
        velocity: f32,
        mass: f32,
        stiffness: f32,
        damping: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a custom curve.\n\n @param userData Indicates the custom data.\n @param interpolate Indicates the custom interpolation callback. <b>fraction</b> indicates the input x value for\n interpolation when the animation starts; value range: [0,1].\n The return value is the y value of the curve; value range: [0,1].\n If <b>fraction</b> is <b>0</b>, the return value <b>0</b> corresponds to the animation start point; any other return\n value means that the animation jumps at the start point.\n If <b>fraction</b> is <b>1</b>, the return value <b>1</b> corresponds to the animation end point; any other return\n value means that the end value of the animation is not the value of the state variable,\n which will result in an effect of transition from that end value to the value of the state variable.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Curve_CreateCustomCurve(
        userData: *mut ::std::os::raw::c_void,
        interpolate: ::std::option::Option<
            unsafe extern "C" fn(fraction: f32, userdata: *mut ::std::os::raw::c_void) -> f32,
        >,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Disposes of a custom curve.\n\n @param curveHandle Indicates the pointer to the interpolation object of the curve.\n @since 12"]
    pub fn OH_ArkUI_Curve_DisposeCurve(curveHandle: ArkUI_CurveHandle);
}
extern "C" {
    #[doc = " @brief Creates an opacity object for component transition.\n\n @note If the value specified is less than 0, the value <b>0</b> is used. If the value specified is greater than 1,\n the value <b>1</b> is used.\n @param opacity Indicates the opacity. Value range: [0, 1].\n @return Returns the created opacity object for component transition.\n @since 12"]
    pub fn OH_ArkUI_CreateOpacityTransitionEffect(opacity: f32) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates a translation object for component transition.\n\n @param translate Indicates the translation settings for component transition.\n @return Returns the translation object created for component transition.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateTranslationTransitionEffect(
        translate: *mut ArkUI_TranslationOptions,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates a scaling object for component transition.\n\n @param scale Indicates the scaling settings for component transition.\n @return Returns the scaling object created for component transition.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateScaleTransitionEffect(
        scale: *mut ArkUI_ScaleOptions,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates a rotation object for component transition.\n\n @param rotate Indicates the rotation settings for component transition.\n @return Returns the rotation object created for component transition.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateRotationTransitionEffect(
        rotate: *mut ArkUI_RotationOptions,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates a movement object for component transition.\n\n @param edge Indicates the movement type.\n @return Returns the movement object created for component transition.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateMovementTransitionEffect(
        edge: ArkUI_TransitionEdge,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates an asymmetric transition effect.\n\n @note If the <b>asymmetric</b> function is not used for <b>TransitionEffect</b>, the transition effect takes effect\n for both appearance and disappearance of the component.\n @param appear Indicates the transition effect for appearance.\n @param disappear Indicates the transition effect for disappearance.\n @return Returns the asymmetric transition effect.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateAsymmetricTransitionEffect(
        appear: *mut ArkUI_TransitionEffect,
        disappear: *mut ArkUI_TransitionEffect,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Disposes of a transition effect.\n\n @param effect Indicates the transition effect to dispose of.\n @since 12"]
    pub fn OH_ArkUI_TransitionEffect_Dispose(effect: *mut ArkUI_TransitionEffect);
}
extern "C" {
    #[doc = " @brief Sets a combination of transition effects.\n\n @param firstEffect Indicates the transition effect options.\n @param secondEffect Indicates the combination of transition effects.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_TransitionEffect_Combine(
        firstEffect: *mut ArkUI_TransitionEffect,
        secondEffect: *mut ArkUI_TransitionEffect,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets transition effect animation settings.\n\n @note If <b>combine</b> is used for combining transition effects, the animation settings of a transition effect are\n applicable to the one following it.\n @param effect Indicates the transition effect options.\n @param animation Indicates the animation settings.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_TransitionEffect_SetAnimation(
        effect: *mut ArkUI_TransitionEffect,
        animation: *mut ArkUI_AnimateOption,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_UIInputEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CoastingAxisEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TouchTestInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TouchTestInfoItem {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the touch test info item handle.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_TouchTestInfoItemHandle = *mut ArkUI_TouchTestInfoItem;
#[doc = " @brief Defines the gesture recognizer handle array.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_TouchTestInfoItemArray = *mut ArkUI_TouchTestInfoItemHandle;
pub const ArkUI_UIInputEvent_Type_ARKUI_UIINPUTEVENT_TYPE_UNKNOWN: ArkUI_UIInputEvent_Type = 0;
pub const ArkUI_UIInputEvent_Type_ARKUI_UIINPUTEVENT_TYPE_TOUCH: ArkUI_UIInputEvent_Type = 1;
pub const ArkUI_UIInputEvent_Type_ARKUI_UIINPUTEVENT_TYPE_AXIS: ArkUI_UIInputEvent_Type = 2;
#[doc = " Mouse event."]
pub const ArkUI_UIInputEvent_Type_ARKUI_UIINPUTEVENT_TYPE_MOUSE: ArkUI_UIInputEvent_Type = 3;
#[doc = " @brief key event.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_UIInputEvent_Type_ARKUI_UIINPUTEVENT_TYPE_KEY: ArkUI_UIInputEvent_Type = 4;
#[doc = " @brief Enumerates the UI input event types.\n\n @since 12"]
pub type ArkUI_UIInputEvent_Type = u32;
#[doc = " Idle phase, indicating no-coasting phase."]
#[cfg(feature = "api-22")]
pub const ArkUI_CoastingAxisEventPhase_ARKUI_COASTING_AXIS_EVENT_PHASE_NONE:
    ArkUI_CoastingAxisEventPhase = 0;
#[doc = " Coasting begin, this is the first coasting event."]
#[cfg(feature = "api-22")]
pub const ArkUI_CoastingAxisEventPhase_ARKUI_COASTING_AXIS_EVENT_PHASE_BEGIN:
    ArkUI_CoastingAxisEventPhase = 1;
#[doc = " Coasting ongoing."]
#[cfg(feature = "api-22")]
pub const ArkUI_CoastingAxisEventPhase_ARKUI_COASTING_AXIS_EVENT_PHASE_UPDATE:
    ArkUI_CoastingAxisEventPhase = 2;
#[doc = " Coasting end, this is the last coasting event."]
#[cfg(feature = "api-22")]
pub const ArkUI_CoastingAxisEventPhase_ARKUI_COASTING_AXIS_EVENT_PHASE_END:
    ArkUI_CoastingAxisEventPhase = 3;
#[doc = " @brief Enumerates the coasting axis event phases.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_CoastingAxisEventPhase = u32;
#[doc = " Both the node and its child node respond to the hit test of a touch event, but its sibling node is blocked from\n  the hit test."]
pub const HitTestMode_HTM_DEFAULT: HitTestMode = 0;
#[doc = " The node responds to the hit test of a touch event, but its child node and sibling node are blocked from the hit\n  test."]
pub const HitTestMode_HTM_BLOCK: HitTestMode = 1;
#[doc = " Both the node and its child node respond to the hit test of a touch event, and its sibling node is also\n  considered during the hit test."]
pub const HitTestMode_HTM_TRANSPARENT: HitTestMode = 2;
#[doc = " The node does not respond to the hit test of a touch event, but its child node and sibling node are considered\n  during the hit test."]
pub const HitTestMode_HTM_NONE: HitTestMode = 3;
#[doc = " The node and its child nodes participate in hit tests, while blocking hit tests for all sibling nodes and parent\n nodes with lower priority.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const HitTestMode_HTM_BLOCK_HIERARCHY: HitTestMode = 4;
#[doc = " The node does not respond to hit tests, and none of its descendants (including children and grandchildren)\n participate in hit tests either.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const HitTestMode_HTM_BLOCK_DESCENDANTS: HitTestMode = 5;
#[doc = " @brief Enumerates the hit test modes.\n\n @since 12"]
pub type HitTestMode = u32;
#[doc = " Ctrl."]
pub const ArkUI_ModifierKeyName_ARKUI_MODIFIER_KEY_CTRL: ArkUI_ModifierKeyName = 1;
#[doc = " Shift."]
pub const ArkUI_ModifierKeyName_ARKUI_MODIFIER_KEY_SHIFT: ArkUI_ModifierKeyName = 2;
#[doc = " Alt."]
pub const ArkUI_ModifierKeyName_ARKUI_MODIFIER_KEY_ALT: ArkUI_ModifierKeyName = 4;
#[doc = " Fn."]
pub const ArkUI_ModifierKeyName_ARKUI_MODIFIER_KEY_FN: ArkUI_ModifierKeyName = 8;
#[doc = " @brief Defines an enum for modifier keys.\n\n @since 12"]
pub type ArkUI_ModifierKeyName = u32;
#[doc = " Unknown."]
#[cfg(feature = "api-15")]
pub const ArkUI_InteractionHand_ARKUI_EVENT_HAND_NONE: ArkUI_InteractionHand = 0;
#[doc = " Left hand."]
#[cfg(feature = "api-15")]
pub const ArkUI_InteractionHand_ARKUI_EVENT_HAND_LEFT: ArkUI_InteractionHand = 1;
#[doc = " Right hand."]
#[cfg(feature = "api-15")]
pub const ArkUI_InteractionHand_ARKUI_EVENT_HAND_RIGHT: ArkUI_InteractionHand = 2;
#[doc = " @brief Defines whether the touch event is from the left or right hand.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_InteractionHand = u32;
#[doc = " Custom dispatch has no effect; the system distributes events based on the hit status of the current node."]
#[cfg(feature = "api-22")]
pub const ArkUI_TouchTestStrategy_ARKUI_TOUCH_TEST_STRATEGY_DEFAULT: ArkUI_TouchTestStrategy = 0;
#[doc = " The specified event is forwarded to a particular child node, and the system determines whether to\n  distribute the event to other sibling nodes."]
#[cfg(feature = "api-22")]
pub const ArkUI_TouchTestStrategy_ARKUI_TOUCH_TEST_STRATEGY_FORWARD_COMPETITION:
    ArkUI_TouchTestStrategy = 1;
#[doc = " The specified event is forwarded to a particular child node, and the system no longer distributes\n  the event to other sibling nodes."]
#[cfg(feature = "api-22")]
pub const ArkUI_TouchTestStrategy_ARKUI_TOUCH_TEST_STRATEGY_FORWARD: ArkUI_TouchTestStrategy = 2;
#[doc = " @brief Define the touch test strategy.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub type ArkUI_TouchTestStrategy = u32;
extern "C" {
    #[doc = " @brief Obtains the type of a UI input event.\n\n Before accessing an <b>ArkUI_UIInputEvent</b> pointer, use this API to determine the type of the input event.\n This API returns a value from the {@link ArkUI_UIInputEvent_Type} enum. It helps ensure compatibility with subsequent\n accessors. For example, if the event is a touch event,\n which is directional, you can use OH_ArkUI_UIInputEvent_GetXXX or OH_ArkUI_PointerEvent_GetXXX for access.\n Using OH_ArkUI_KeyEvent_GetXXX to access the event may produce undefined behavior.\n\n For unsupported event types, this API returns the default value <b>0</b>.\n\n @param event Pointer to the current UI input event.\n @return Returns the type of the current UI input event; returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetType(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the action type of this UI input event.\n\n The action type defines the phase of a basic event (for example, start or end) and characterizes its behavior,\n such as touch down or touch up Action types are specific to the event category:\n UI_TOUCH_EVENT_ACTION_XXX for touch events and UI_MOUSE_EVENT_ACTION_XXX for mouse events.\n\n @note\n 1. For axis events, use {@link OH_ArkUI_AxisEvent_GetAxisAction} to obtain the action type,\n    which returns UI_AXIS_EVENT_ACTION_XXX.\n 2. For key events, use {@link OH_ArkUI_KeyEvent_GetType} instead.\n\n @param event Pointer to the current UI input event.\n @return Returns the action type of the current UI input event; returns <b>-1</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetAction(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the source type of a UI input event.\n\n The source represents the physical device, such as a touchscreen or mouse device, that generates the event.\n It is defined by the UI_INPUT_EVENT_SOURCE_TYPE_XXX enum.\n This is different from the input tool, which is the device used to interact with the source, for example,\n a finger or stylus. However, in certain cases, the input source and the input tool can be the same.\n For example, a mouse device acts as both the source and tool for click events.\n\n @note For key events, obtaining the source type is not supported, and in such cases,\n       the API will return an <b>unknown</b> value.\n\n @param event Pointer to the current UI input event.\n @return Returns the source type of the current UI input event.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetSourceType(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the tool type of a UI input event.\n\n The input tool is the device used to interact with the input source, such as a finger or stylus.\n It is defined by the UI_INPUT_EVENT_TOOL_TYPE_XXX enum.\n These tools do not produce events directly but drive the input source to generate them.\n\n @note For key events, obtaining the tool type is not supported, and in such cases,\n       the API will return an <b>unknown</b> value.\n\n @param event Pointer to the current UI input event.\n @return Returns the tool type of the current UI input event.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetToolType(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the time when this UI input event occurs.\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the time when the UI input event occurs; returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetEventTime(event: *const ArkUI_UIInputEvent) -> i64;
}
extern "C" {
    #[doc = " @brief Obtains the number of contact points from a pointer event (such as a touch, mouse, or axis event).\n\n Pointer events are typically events that carry position information, such as touch events,\n where the location of the event can be determined.\n Non-pointer events, such as key events, do not have position information and do not involve contact points,\n so this API is not applicable to key events.\n\n For touch events, this API returns the number of active touch points, for example, fingers on the screen.\n For mouse and axis events, this API always returns <b>1</b>, as they are single-pointer interactions.\n\n @param event Pointer to the current UI input event.\n @return Number of contact points for the current pointer event.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetPointerCount(event: *const ArkUI_UIInputEvent) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the unique ID of a contact point from a pointer event (such as a touch, mouse, or axis event).\n\n The ID distinguishes between multiple contact points from the same input device. The return value itself does not\n have any other meaning beyond identifying the contact point.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Unique ID of the specified contact point.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetPointerId(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of the touch pointer that triggers the current touch event.\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_GetChangedPointerId(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the upper left corner of the current component from a directional\n input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the directional input event.\n @return Returns the X coordinate relative to the upper left corner of the current component;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific contact point relative to the upper left corner of the current\n component from a pointer event (such as a touch, mouse, or axis event).\n For mouse and axis events, this API returns the default value of <b>0.0f</b> if the given index is greater than 0.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Returns the X coordinate relative to the upper left corner of the current component;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetXByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the upper left corner of the current component from a directional\n input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the Y coordinate relative to the upper left corner of the current component;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific contact point relative to the upper left corner of the current\n component from a pointer event (such as a touch, mouse, or axis event).\n For mouse and axis events, this API returns the default value of <b>0.0f</b> if the given index is greater than 0.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Y coordinate relative to the upper left corner of the current component;\n         <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetYByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the upper left corner of the current application window from a\n directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the X coordinate relative to the upper left corner of the current application window;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetWindowX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific contact point relative to the upper left corner of the current\n application window from a pointer event (such as a touch, mouse, or axis event).\n For mouse and axis events, this API returns the default value of <b>0.0f</b> if the given index is greater than 0.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return X coordinate relative to the upper left corner of the current application window;\n         <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetWindowXByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the upper left corner of the current application window from a\n directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the Y coordinate relative to the upper left corner of the current application window;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetWindowY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific contact point relative to the upper left corner of the current\n application window from a pointer event (such as a touch, mouse, or axis event).\n For mouse and axis events, this API returns the default value of <b>0.0f</b> if the given index is greater than 0.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Returns the Y coordinate relative to the upper left corner of the current application window;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetWindowYByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the upper left corner of the current screen from a directional input\n event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the X coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetDisplayX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific contact point relative to the upper left corner of the current screen\n from a pointer event (such as a touch, mouse, or axis event).\n For mouse and axis events, this API returns the default value of <b>0.0f</b> if the given index is greater than 0.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Returns the X coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetDisplayXByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the upper left corner of the current screen from a directional input\n event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the Y coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetDisplayY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point relative to the upper left corner of the current screen\n from a pointer event (such as a touch event, mouse event, or axis event).\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Returns the Y coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetDisplayYByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to global display from a pointer event (such as a touch, mouse,\n or axis event).\n Position information can only be obtained from UI input events.\n\n @param event Pointer to the current UI input event.\n @return float X coordinate relative to the global display. <b>0</b> is returned if any parameter error occurs\n (for example, if the event does not contain position information).\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_PointerEvent_GetGlobalDisplayX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific contact point relative to global display from a pointer event\n (such as a touch, mouse, or axis event).\n Position information can only be obtained from UI input events. For mouse and axis events, if the provided\n <b>pointerIndex</b> is greater than 0, this API always returns the default value <b>0.0f</b>.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\nValue range: [0, @link OH_ArkUI_PointerEvent_GetPointerCount() - 1]\n @return float X coordinate relative to the global display; <b>0.0f</b> if any parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_PointerEvent_GetGlobalDisplayXByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to global display from a pointer event (such as a touch, mouse,\n or axis event).\n Position information can only be obtained from pointer-like events.\n\n @param event Pointer to the current UI input event.\n @return float Y coordinate relative to the global display; <b>0</b> if any parameter error occurs\n (for example, if the event does not contain position information).\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_PointerEvent_GetGlobalDisplayY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific contact point relative to global display from a pointer event\n (such as a touch, mouse, or axis event).\n Position information can only be obtained from UI input events. For mouse and axis events, if the provided\n <b>pointerIndex</b> is greater than 0, this API always returns the default value <b>0.0f</b>.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\nValue range: [0, @link OH_ArkUI_PointerEvent_GetPointerCount() - 1]\n @return float Y coordinate relative to the global display; <b>0.0f</b> if any parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_PointerEvent_GetGlobalDisplayYByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the pressure applied to the touchscreen from a directional input event (for example, a touch event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the pressure applied to the touchscreen; returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetPressure(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the tilt angle relative to the YZ plane from a pointer event.\n The value range is [-90, 90], where positive values indicate a rightward tilt.\n This API is applicable only to stylus-based touch events from devices that support tilt angle reporting.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Returns the angle relative to the YZ plane.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetTiltX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the tilt angle relative to the XZ plane from a pointer event.\n The value range is [-90, 90], where positive values indicate a rightward tilt.\n This API is applicable only to stylus-based touch events from devices that support tilt angle reporting.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Returns the angle relative to the XZ plane.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetTiltY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the rotation angle of the stylus around the z-axis from a UI input event.\n\n @param event Pointer to the UI input event.\n @param rollAngle Rotation angle of the stylus around the z-axis.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_PointerEvent_GetRollAngle(
        event: *const ArkUI_UIInputEvent,
        rollAngle: *mut f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the width of the contact area for a pointer event. This API is applicable only to finger-based touch\n events, and the return value typically represents the radius of a circular touch area.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Returns the width of the touch area.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetTouchAreaWidth(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the height of the contact area for a pointer event. This API is applicable only to finger-based touch\n events, and the return value typically represents the radius of a circular touch area.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @return Returns the height of the touch area.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetTouchAreaHeight(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Checks whether an event is triggered by the user's left or right hand.\n This API is only effective on some touch devices.\n\n @note This value cannot be obtained in real time when pressed. Before the\n system completes result inference, it will return <b>NONE</b> by default. Therefore,\n please do not over-rely on the results returned by this interface.\n\n @param event Pointer to the current UI input event.\n @param hand Whether the touch point is from the left or right hand.\n @return Result code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_GetInteractionHand(
        event: *const ArkUI_UIInputEvent,
        hand: *mut ArkUI_InteractionHand,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Checks whether an event is triggered by the user's left or right hand.\n This API is only effective on some touch devices.\n\n @note This value cannot be obtained in real time when pressed. Before the\n system completes result inference, it will return <b>NONE</b> by default. Therefore,\n please do not over-rely on the results returned by this interface.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\n @param hand Whether the touch point is from the left or right hand.\n @return Result code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_GetInteractionHandByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: i32,
        hand: *mut ArkUI_InteractionHand,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of historical events from a pointer event (such as a touch event).\n Historical events are the raw events that occur between the current event and the previous event.\n This API is applicable only to move events.\n\n @param event Pointer to the current UI input event.\n @return Returns the number of historical events.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistorySize(event: *const ArkUI_UIInputEvent) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the occurrence time of a historical event from a directional input event (such as a touch event,\n mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the time when the UI input event occurs; returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryEventTime(
        event: *const ArkUI_UIInputEvent,
        historyIndex: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Obtains the number of touch points in a specific historical event from a directional input event (such as\n a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the number of touch points in the specified historical event\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryPointerCount(
        event: *const ArkUI_UIInputEvent,
        historyIndex: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the unique ID of a contact point from a historical event of a pointer event (such as a touch event).\n\n The ID distinguishes between multiple contact points from the same input device.\n The return value itself does not have any other meaning beyond identifying the contact point.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target contact point in the contact point list.\n @param historyIndex Index of the target historical event.\n @return Returns the ID of the corresponding touch point in the specified historical event.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryPointerId(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current component from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the X coordinate relative to the upper left corner of the current component;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current component from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the Y coordinate relative to the upper left corner of the current component;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current application window from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the X coordinate relative to the upper left corner of the current application window;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryWindowX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current application window from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the Y coordinate relative to the upper left corner of the current application window;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryWindowY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current screen from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the X coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryDisplayX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current screen from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the Y coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryDisplayY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the global display for a specific touch point from historical events,\n based on the given pointer index and history index of an input event (such as a touch, mouse, or axis event).\n Position information can only be obtained from UI input events. For mouse and axis events, if the provided\n <b>pointerIndex</b> is greater than 0, this API always returns the default value <b>0.0f</b>.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\nValue range: [0, @link OH_ArkUI_PointerEvent_GetPointerCount() - 1]\n @param historyIndex Index of the historical value to return. It must be less than\n {@link #OH_ArkUI_PointerEvent_GetHistorySize}.\n @return float X coordinate relative to the global display; <b>0.0f</b> if any parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_PointerEvent_GetHistoryGlobalDisplayX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the global display for a specific touch point from historical events,\n based on the given pointer index and history index of an input event (such as a touch, mouse, or axis event).\n Position information can only be obtained from UI input events. For mouse and axis events, if the provided\n <b>pointerIndex</b> is greater than 0, this API always returns the default value <b>0.0f</b>.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\nValue range: [0, @link OH_ArkUI_PointerEvent_GetPointerCount() - 1]\n @param historyIndex Index of the historical value to return. It must be less than\n {@link #OH_ArkUI_PointerEvent_GetHistorySize}.\n @return float Y coordinate relative to the global display; <b>0.0f</b> if any parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_PointerEvent_GetHistoryGlobalDisplayY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the pressure applied to the touchscreen in a specific historical event from a directional input event\n (for example, a touch event)..\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the pressure applied to the touchscreen; returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryPressure(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle relative to the YZ plane in a specific historical event from a directional input event\n (for example, a touch event). The value range is [-90, 90]. A positive value indicates a rightward tilt.\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the angle relative to the YZ plane.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryTiltX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle relative to the XZ plane in a specific historical event from a directional input event\n (for example, a touch event). The value range is [-90, 90]. A positive value indicates a downward tilt.\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the angle relative to the XZ plane.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryTiltY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the width of the touch area in a specific historical event from a directional input event\n (for example, a touch event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the width of the touch area.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryTouchAreaWidth(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the height of the touch area in a specific historical event from a directional input event\n (for example, a touch event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the height of the touch area.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryTouchAreaHeight(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the value of the vertical scroll axis for this axis event.\n This value is typically generated by mouse wheel scrolling or two-finger vertical swiping on a touchpad.\n\n If the value is generated by mouse wheel scrolling:\n 1. The reported value is in degrees and represents the incremental angle of a single scroll,\n    not the total scroll amount.\n 2. The reported value includes the user's scroll step configuration (see {@link OH_ArkUI_AxisEvent_GetScrollStep}).\n 3. The sign of the value indicates the direction: positive for forward scrolling and negative for backward scrolling.\n\n If the value is generated by two-finger vertical swiping on a touchpad:\n 1. The reported value is in px and represents the incremental scroll amount, not the total scroll amount.\n 2. The reported value does not include the user's scroll step configuration.\n 3. The sign of the value indicates the direction: positive for swiping down and negative for swiping up.\n 4. The direction is affected by the system settings for natural scrolling.\n\n Under normal circumstances, vertical scroll axis events only drive vertical swipe gestures. However,\n if the mouse pointer is over a scrollable area where the scrollable directions are consistent,\n the vertical scroll axis event can drive the swipe gestures in this scrollable area, even if they are defined\n as horizontal.\n\n @param event Pointer to the current UI input event.\n @return Value of the vertical scroll axis of the current axis event; <b>0.0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AxisEvent_GetVerticalAxisValue(event: *const ArkUI_UIInputEvent) -> f64;
}
extern "C" {
    #[doc = " @brief Obtains the value of the horizontal scroll axis for this axis event.\n This value is generated by two-finger horizontal swiping on a touchpad.\n\n @note\n 1. The reported value is in px and represents the incremental scroll amount, not the total scroll amount.\n 2. The reported value does not include the user's scroll step configuration.\n 3. The sign of the value indicates the direction: positive for swiping right and negative for swiping left.\n 4. The direction is affected by the system settings for natural scrolling.\n\n @param event Pointer to the current UI input event.\n @return Returns the value of the horizontal scroll axis of the current axis event;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AxisEvent_GetHorizontalAxisValue(event: *const ArkUI_UIInputEvent) -> f64;
}
extern "C" {
    #[doc = " This value is generated by a two-finger pinch gesture on a touchpad.\n The reported scale value is relative to the initial state\n\n when the system first detects the pinch gesture, with an initial scale value of 1.0.\n During the pinch operation, the scale value decreases from 1.0 towards 0.0 when the user pinches inward\n and increases from 1.0 when the user spreads fingers outward.\n\n @param event Pointer to the current UI input event.\n @return Scale value of the pinch axis of the current axis event; <b>0.0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AxisEvent_GetPinchAxisScaleValue(event: *const ArkUI_UIInputEvent) -> f64;
}
extern "C" {
    #[doc = " @brief Obtains the action type of the current axis event.\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the action type of the current axis event.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_AxisEvent_GetAxisAction(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Checks whether this axis event contains the specified axis type.\n\n @param event Indicates the pointer to the current UI input event.\n @param axis Axis type of the axis event.\n @return Whether the current axis event contains the specified axis type.\n Returns <b>true</b> if the axis event contains the specified axis type, and <b>false</b> otherwise.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_AxisEvent_HasAxis(event: *const ArkUI_UIInputEvent, axis: i32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the hit testing mode, that is, how the component behaves during hit testing.\n This API only applies to scenarios raw input events are received, such as when {@link NODE_ON_TOUCH} is used for\n touch event handling.\n It cannot be used with <b>ArkUI_UIInputEvent</b> objects obtained from gesture events through\n {@link OH_ArkUI_GestureEvent_GetRawInputEvent}.\n\n @param event Pointer to the current UI input event.\n @param mode Hit testing mode, of type {@link HitTestMode}.\n @return Result code.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_SetInterceptHitTestMode(
        event: *const ArkUI_UIInputEvent,
        mode: HitTestMode,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the value of the button type for mouse events.\n\n @param event Represents a pointer to the current UI input event.\n @return Return to the mouse button type, where <b>1</b> is the left button, <b>2</b> is the right button,\n <b>3</b> is the middle button, <b>4</b> is the back button, and <b>5</b> is the forward button.\n @since 12"]
    pub fn OH_ArkUI_MouseEvent_GetMouseButton(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Get the value of the mouse action type for mouse events.\n\n @param event Represents a pointer to the current UI input event.\n @return Returns the type of mouse action, where <b>1</b> represents button pressed,\n <b>2</b> represents button released, and <b>3</b> represents mouse movement.\n @since 12"]
    pub fn OH_ArkUI_MouseEvent_GetMouseAction(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to stop event propagation. This API only applies to scenarios raw input events are received,\n such as when {@link NODE_ON_TOUCH} is used for touch event handling.\n It cannot be used with <b>ArkUI_UIInputEvent</b> objects obtained from gesture events\n through {@link OH_ArkUI_GestureEvent_GetRawInputEvent}.\n\n @param event Pointer to the current UI input event.\n @param stopPropagation Whether to stop event propagation.\n @return Returns the status code of the execution. If 0 is returned, the setting is successful.\n         If 401 is returned, the execution fails.\n         The possible cause of the failure is that the event parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_SetStopPropagation(
        event: *const ArkUI_UIInputEvent,
        stopPropagation: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of device that triggers UI input event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the device ID.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_UIInputEvent_GetDeviceId(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains all keys that are pressed from UI input event. Only supports key events currently.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param pressedKeyCodes Array of all keys that are pressed. You need to allocate the memory space.\n @param length Length of the passed pressedKeyCodes array (when used as an input parameter);\n               number of the keys pressed (when used as an output parameter).\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_NOT_ENOUGH} if the giving buffer is not enough.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_UIInputEvent_GetPressedKeys(
        event: *const ArkUI_UIInputEvent,
        pressedKeyCodes: *mut i32,
        length: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the axis value of a focus axis event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param axis Axis type of the focus axis event.\n @return Returns the axis value of the focus axis event; returns <b>0.0</b> if any parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_FocusAxisEvent_GetAxisValue(event: *const ArkUI_UIInputEvent, axis: i32)
        -> f64;
}
extern "C" {
    #[doc = " @brief Sets whether to prevent a focus axis event from bubbling up.\n\n @param event Indicates the pointer to the current UI input event.\n @param stopPropagation Indicates whether to stop event propagation.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_FocusAxisEvent_SetStopPropagation(
        event: *const ArkUI_UIInputEvent,
        stopPropagation: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the width of the component hit by an event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the width of the component hit by the event; returns <b>0.0f</b> if any parameter error occurs.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_UIInputEvent_GetEventTargetWidth(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the height of the component hit by an event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the height of the component hit by the event; returns <b>0.0f</b> if any parameter error occurs.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_UIInputEvent_GetEventTargetHeight(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of the component hit by an event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the X coordinate of the component hit by the event; returns <b>0.0f</b> if any parameter error occurs.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_UIInputEvent_GetEventTargetPositionX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of the component hit by an event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the Y coordinate of the component hit by the event;\n         returns <b>0.0f</b> if any parameter error occurs.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_UIInputEvent_GetEventTargetPositionY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the global X coordinate of the component hit by an event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the global X coordinate of the component hit by the event;\n         returns <b>0.0f</b> if any parameter error occurs.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_UIInputEvent_GetEventTargetGlobalPositionX(
        event: *const ArkUI_UIInputEvent,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the global Y coordinate of the component hit by an event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the global Y coordinate of the component hit by the event;\n         returns <b>0.0f</b> if any parameter error occurs.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_UIInputEvent_GetEventTargetGlobalPositionY(
        event: *const ArkUI_UIInputEvent,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Checks whether the cursor is hovering over this component.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns <b>true</b> if the cursor is hovering over the current component.\n         Returns <b>false</b> if the cursor is not hovering over the current component.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_HoverEvent_IsHovered(event: *const ArkUI_UIInputEvent) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains the modifier key states for a UI input event.\n This API outputs the state of all modifier keys at the time of the event through the <b>keys</b> parameter.\n You can determine which keys are pressed by performing bitwise operations with the modifier key types defined\n in {@link ArkUI_ModifierKeyName}.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param keys Pointer to a variable where the current combination of pressed modifier keys will be returned.\n        The application can use bitwise operations to determine the state of each modifier key.\n @return Result code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_UIInputEvent_GetModifierKeyStates(
        event: *const ArkUI_UIInputEvent,
        keys: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the press time of a specified touch point. This API is effective only for touch events.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\n @return Returns the press time of the specific touch point; returns <b>0</b> if any parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_GetPressedTimeByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Obtains the movement increment of the mouse device along the X-axis in a two-dimensional plane.\n Its value represents the raw movement data from the mouse device, expressed in units of physical\n distance in the real world. The reported value is determined by the hardware itself and does not\n correspond to the physical or logical pixels on the screen.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the x-axis offset of the mouse position relative to the position in the previously reported\n mouse event; returns <b>0.0f</b> if any parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_MouseEvent_GetRawDeltaX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the movement increment of the mouse device along the Y-axis in a two-dimensional plane.\n Its value represents the raw movement data from the mouse device, expressed in units of physical\n distance in the real world. The reported value is determined by the hardware itself and does not\n correspond to the physical or logical pixels on the screen.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the y-axis offset of the mouse position relative to the position in the previously reported\n mouse event; returns <b>0.0f</b> if any parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_MouseEvent_GetRawDeltaY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the pressed buttons from a mouse event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param pressedButtons Array of the pressed buttons. An int array must be created beforehand to store the pressed\n                       buttons.\n @param length Length of the passed pressedButtons array (when used as an input parameter);\n               number of the buttons pressed (when used as an output parameter).\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} if the given buffer size is insufficient.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_MouseEvent_GetPressedButtons(
        event: *const ArkUI_UIInputEvent,
        pressedButtons: *mut i32,
        length: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of the screen where the UI input event occurs.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the screen ID; returns <b>0</b> if any parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_UIInputEvent_GetTargetDisplayId(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable axis event propagation (bubbling). By default, axis events do not bubble and are\n only sent to the first component that can respond to axis events. You can enable axis event bubbling\n to allow the current event to be passed to the next ancestor component in the response chain\n that can handle axis events.\n This API cannot be used on axis events obtained from gesture events.\n\n @param event Pointer to the UI input event.\n @param propagation Whether to enable event propagation.\n @return Result code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_AxisEvent_SetPropagation(
        event: *const ArkUI_UIInputEvent,
        propagation: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the scroll step coefficient for a wheel-based axis event.\n This API returns the user-configured scroll scale factor factor.\n\n @param event Pointer to the UI input event.\n @return Scroll step configuration of the mouse wheel axis event.\n @since 17"]
    #[cfg(feature = "api-17")]
    pub fn OH_ArkUI_AxisEvent_GetScrollStep(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Creates a cloned event pointer based on an event pointer. This API is effective only for touch events.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param clonedEvent Pointer to the cloned <b>ArkUI_UIInputEvent</b> object.\n @return Result code.\n          {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_CreateClonedEvent(
        event: *const ArkUI_UIInputEvent,
        clonedEvent: *mut *mut ArkUI_UIInputEvent,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Destroys a cloned event pointer.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NOT_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_DestroyClonedEvent(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the X and Y coordinates of a cloned event relative to the upper left corner of the current component.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param x X coordinate of the event relative to the upper left corner of the current component.\n @param y Y coordinate of the event relative to the upper left corner of the current component.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NOT_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventLocalPosition(
        event: *const ArkUI_UIInputEvent,
        x: f32,
        y: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the X and Y coordinates of a specific contact point of a cloned event relative to the upper left corner\n of the current component.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param x X coordinate of the event relative to the upper left corner of the current component.\n @param y Y coordinate of the event relative to the upper left corner of the current component.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NOT_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventLocalPositionByIndex(
        event: *const ArkUI_UIInputEvent,
        x: f32,
        y: f32,
        pointerIndex: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the action type of a cloned event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param actionType Action type of the cloned event.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NOT_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventActionType(
        event: *const ArkUI_UIInputEvent,
        actionType: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the touch point ID of a cloned pointer event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param fingerId ID of the touch point that triggers the event.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NOT_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventChangedFingerId(
        event: *const ArkUI_UIInputEvent,
        fingerId: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the touch point ID of a specific contact point of a cloned event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param fingerId Touch point ID of the specific contact point.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NOT_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventFingerIdByIndex(
        event: *const ArkUI_UIInputEvent,
        fingerId: i32,
        pointerIndex: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Posts a cloned event to a specific node.\n\n @param node Target node.\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_CLONED_POINTER_EVENT} if the input event pointer is not a\n         cloned event pointer.\n         Returns {@link ARKUI_ERROR_CODE_POST_CLONED_COMPONENT_STATUS_ABNORMAL}\n         if the component status abnormal.\n         Returns {@link ARKUI_ERROR_CODE_POST_CLONED_NO_COMPONENT_HIT_TO_RESPOND_TO_THE_EVENT}\n         if no component hit to response to the event.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_PointerEvent_PostClonedEvent(
        node: ArkUI_NodeHandle,
        event: *const ArkUI_UIInputEvent,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Use this method to obtain the execution status of the latest UI input related method.\n\n In most cases, this method is unnecessary unless you need to determine if the return value indicates an error.\n Here's an example of usage: For return values like float (where 0.0 doesn't indicate an error), use GetLatestStatus\n to confirm if an error occurred.\n    float x = OH_ArkUI_PointerEvent_GetX(event);\n    if (ARKUI_ERROR_CODE_NO_ERROR != OH_ArkUI_UIInputEvent_GetLatestStatus()) {\n        // error\n        return;\n     }\n Note: The system clears the status of the previous function call each time a UIInput-related function is executed,\n ensuring you always get the latest status.\n\n @return Returns the ArkUI_ErrorCode.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_UIInputEvent_GetLatestStatus() -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the coasting axis event from a component event, valid event only can be\n fetched only when user flings on the touchpad with two fingers and any components register\n NODE_ON_COASTING_AXIS_EVENT exist under the pointer location.\n Call this method after the {@link ArkUI_UIInputEvent} object is obtained from the {@link ArkUI_NodeEvent} object.\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the pointer to the coasting axis event, return null if no any coasting axis event occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_UIInputEvent_GetCoastingAxisEvent(
        event: *mut ArkUI_UIInputEvent,
    ) -> *mut ArkUI_CoastingAxisEvent;
}
extern "C" {
    #[doc = " @brief Obtains the time when this coasting event occurs.\n\n @param event Indicates the pointer to the coasting axis event.\n @return Returns the time when the UI input event occurs; returns <b>0</b> if any parameter error occurs.\n\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_CoastingAxisEvent_GetEventTime(event: *mut ArkUI_CoastingAxisEvent) -> i64;
}
extern "C" {
    #[doc = " @brief Obtains the coasting phase when this coasting event occurs.\n\n @param event Indicates the pointer to the coasting axis event.\n @return Returns the event phase, see {@link ArkUI_CoastingAxisEventPhase};\n     returns <b>ARKUI_COASTING_AXIS_EVENT_PHASE_NONE</b> if any parameter error occurs.\n\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_CoastingAxisEvent_GetPhase(
        event: *mut ArkUI_CoastingAxisEvent,
    ) -> ArkUI_CoastingAxisEventPhase;
}
extern "C" {
    #[doc = " @brief Obtains the horizontal delta value.\n\n @param event Indicates the pointer to the coasting axis event.\n @return Returns delta X value, count in PX; returns <b>0</b> if any parameter error occurs.\n\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_CoastingAxisEvent_GetDeltaX(event: *mut ArkUI_CoastingAxisEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the vertical delta value.\n\n @param event Indicates the pointer to the coasting axis event.\n @return Returns delta Y value, count in PX; returns <b>0</b> if any parameter error occurs.\n\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_CoastingAxisEvent_GetDeltaY(event: *mut ArkUI_CoastingAxisEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable coasting axis event propagation.\n\n @param event Pointer to the coasting axis event.\n @param propagation Whether to enable event propagation.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_CoastingAxisEvent_SetPropagation(
        event: *mut ArkUI_CoastingAxisEvent,
        propagation: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains touch test info item list in the touch test info.\n\n @param info Indicates the pointer to a touch test info.\n @param array Indicates the pointer to the array of touch test info list.\n @param size Indicates the size of the array of touch test info list.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfo_GetTouchTestInfoList(
        info: *mut ArkUI_TouchTestInfo,
        array: *mut ArkUI_TouchTestInfoItemArray,
        size: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the upper left corner of the child component from the touch test\n info item.\n\n @param info Indicates the pointer to the touch test info item.\n @return Returns the X coordinate relative to the upper left corner of the parent component.\n returns <b>0</b> if any parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfoItem_GetX(info: *const ArkUI_TouchTestInfoItem) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the upper left corner of the child component from the touch test\n info item.\n\n @param info Indicates the pointer to the touch test info item.\n @return Returns the Y coordinate relative to the upper left corner of the parent component.\n returns <b>0</b> if any parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfoItem_GetY(info: *const ArkUI_TouchTestInfoItem) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the upper left corner of the current application window from the touch\n test info item.\n\n @param info Indicates the pointer to the touch test info item.\n @return Returns the X coordinate relative to the upper left corner of the current application window.\n returns <b>0.0f</b> if any parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfoItem_GetWindowX(info: *const ArkUI_TouchTestInfoItem) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the upper left corner of the current application window from the touch\n test info item.\n\n @param info Indicates the pointer to the touch test info item.\n @return Returns the Y coordinate relative to the upper left corner of the current application window.\n returns <b>0.0f</b> if any parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfoItem_GetWindowY(info: *const ArkUI_TouchTestInfoItem) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the upper left corner of the parent component from the touch test\n info item.\n\n @param info Indicates the pointer to the touch test info item.\n @return Returns the X coordinate relative to the upper left corner of the parent component.\n returns <b>0</b> if any parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfoItem_GetXRelativeToParent(
        info: *const ArkUI_TouchTestInfoItem,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the upper left corner of the parent component from the touch test\n info item.\n\n @param info Indicates the pointer to the touch test info item.\n @return Returns the Y coordinate relative to the upper left corner of the parent component.\n returns <b>0</b> if any parameter error occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfoItem_GetYRelativeToParent(
        info: *const ArkUI_TouchTestInfoItem,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the sub component's frame rect info from the touch test info item.\n\n @param info Indicates the pointer to the touch test info item.\n @param childRect Indicates the pointer to the child frame rect.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfoItem_GetChildRect(
        info: *const ArkUI_TouchTestInfoItem,
        childRect: *mut ArkUI_Rect,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the sub component's name from the touch test info item.\n\n @param info Indicates the pointer to the touch test info item.\n @param buffer Indicates the buffer.\n @param bufferSize Indicates the buffer size.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_NOT_ENOUGH} if the buffer is not large enough.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfoItem_GetChildId(
        info: *const ArkUI_TouchTestInfoItem,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets the touch test strategy, that is, how the component and the sub components behave during hit testing.\n\n @param {pointer} info Indicates the pointer to a touch test info.\n @param {ArkUI_TouchTestStrategy} strategy The touch test strategy.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfo_SetTouchResultStrategy(
        info: *mut ArkUI_TouchTestInfo,
        strategy: ArkUI_TouchTestStrategy,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets the sub component's name, that is, which sub components need to be effected during hit testing.\n\n @param {pointer} info Indicates the pointer to a touch test info.\n @param {pointer} id The sub component's name.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TouchTestInfo_SetTouchResultId(
        info: *mut ArkUI_TouchTestInfo,
        id: *const ::std::os::raw::c_char,
    ) -> ArkUI_ErrorCode;
}
#[doc = " Custom node."]
pub const ArkUI_NodeType_ARKUI_NODE_CUSTOM: ArkUI_NodeType = 0;
#[doc = " Text."]
pub const ArkUI_NodeType_ARKUI_NODE_TEXT: ArkUI_NodeType = 1;
#[doc = " Text span."]
pub const ArkUI_NodeType_ARKUI_NODE_SPAN: ArkUI_NodeType = 2;
#[doc = " Image span."]
pub const ArkUI_NodeType_ARKUI_NODE_IMAGE_SPAN: ArkUI_NodeType = 3;
#[doc = " Image."]
pub const ArkUI_NodeType_ARKUI_NODE_IMAGE: ArkUI_NodeType = 4;
#[doc = " Toggle."]
pub const ArkUI_NodeType_ARKUI_NODE_TOGGLE: ArkUI_NodeType = 5;
#[doc = " Loading icon."]
pub const ArkUI_NodeType_ARKUI_NODE_LOADING_PROGRESS: ArkUI_NodeType = 6;
#[doc = " Single-line text input."]
pub const ArkUI_NodeType_ARKUI_NODE_TEXT_INPUT: ArkUI_NodeType = 7;
#[doc = " Multi-line text input."]
pub const ArkUI_NodeType_ARKUI_NODE_TEXT_AREA: ArkUI_NodeType = 8;
#[doc = " Button."]
pub const ArkUI_NodeType_ARKUI_NODE_BUTTON: ArkUI_NodeType = 9;
#[doc = " Progress indicator."]
pub const ArkUI_NodeType_ARKUI_NODE_PROGRESS: ArkUI_NodeType = 10;
#[doc = " Check box."]
pub const ArkUI_NodeType_ARKUI_NODE_CHECKBOX: ArkUI_NodeType = 11;
#[doc = " XComponent."]
pub const ArkUI_NodeType_ARKUI_NODE_XCOMPONENT: ArkUI_NodeType = 12;
#[doc = " Date picker."]
pub const ArkUI_NodeType_ARKUI_NODE_DATE_PICKER: ArkUI_NodeType = 13;
#[doc = " Time picker."]
pub const ArkUI_NodeType_ARKUI_NODE_TIME_PICKER: ArkUI_NodeType = 14;
#[doc = " Text picker."]
pub const ArkUI_NodeType_ARKUI_NODE_TEXT_PICKER: ArkUI_NodeType = 15;
#[doc = " Calendar picker."]
pub const ArkUI_NodeType_ARKUI_NODE_CALENDAR_PICKER: ArkUI_NodeType = 16;
#[doc = " Slider."]
pub const ArkUI_NodeType_ARKUI_NODE_SLIDER: ArkUI_NodeType = 17;
#[doc = " Radio"]
pub const ArkUI_NodeType_ARKUI_NODE_RADIO: ArkUI_NodeType = 18;
#[doc = " Image animator."]
pub const ArkUI_NodeType_ARKUI_NODE_IMAGE_ANIMATOR: ArkUI_NodeType = 19;
#[doc = " XComponent of type TEXTURE.\n  @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeType_ARKUI_NODE_XCOMPONENT_TEXTURE: ArkUI_NodeType = 20;
#[doc = " Check box group.\n  @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeType_ARKUI_NODE_CHECKBOX_GROUP: ArkUI_NodeType = 21;
#[doc = " Stack container."]
pub const ArkUI_NodeType_ARKUI_NODE_STACK: ArkUI_NodeType = 1000;
#[doc = " Swiper."]
pub const ArkUI_NodeType_ARKUI_NODE_SWIPER: ArkUI_NodeType = 1001;
#[doc = " Scrolling container."]
pub const ArkUI_NodeType_ARKUI_NODE_SCROLL: ArkUI_NodeType = 1002;
#[doc = " List."]
pub const ArkUI_NodeType_ARKUI_NODE_LIST: ArkUI_NodeType = 1003;
#[doc = " List item."]
pub const ArkUI_NodeType_ARKUI_NODE_LIST_ITEM: ArkUI_NodeType = 1004;
#[doc = " List item group."]
pub const ArkUI_NodeType_ARKUI_NODE_LIST_ITEM_GROUP: ArkUI_NodeType = 1005;
#[doc = " Column container."]
pub const ArkUI_NodeType_ARKUI_NODE_COLUMN: ArkUI_NodeType = 1006;
#[doc = " Row container."]
pub const ArkUI_NodeType_ARKUI_NODE_ROW: ArkUI_NodeType = 1007;
#[doc = " Flex container."]
pub const ArkUI_NodeType_ARKUI_NODE_FLEX: ArkUI_NodeType = 1008;
#[doc = " Refresh component."]
pub const ArkUI_NodeType_ARKUI_NODE_REFRESH: ArkUI_NodeType = 1009;
#[doc = " Water flow container."]
pub const ArkUI_NodeType_ARKUI_NODE_WATER_FLOW: ArkUI_NodeType = 1010;
#[doc = " Water flow item."]
pub const ArkUI_NodeType_ARKUI_NODE_FLOW_ITEM: ArkUI_NodeType = 1011;
#[doc = " Relative layout component."]
pub const ArkUI_NodeType_ARKUI_NODE_RELATIVE_CONTAINER: ArkUI_NodeType = 1012;
#[doc = " Grid."]
pub const ArkUI_NodeType_ARKUI_NODE_GRID: ArkUI_NodeType = 1013;
#[doc = " Grid item."]
pub const ArkUI_NodeType_ARKUI_NODE_GRID_ITEM: ArkUI_NodeType = 1014;
#[doc = " Custom span."]
pub const ArkUI_NodeType_ARKUI_NODE_CUSTOM_SPAN: ArkUI_NodeType = 1015;
#[doc = " EmbeddedComponent.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeType_ARKUI_NODE_EMBEDDED_COMPONENT: ArkUI_NodeType = 1016;
#[doc = " Undefined.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeType_ARKUI_NODE_UNDEFINED: ArkUI_NodeType = 1017;
#[doc = " @brief Enumerates ArkUI component types that can be created on the native side.\n\n @since 12"]
pub type ArkUI_NodeType = u32;
#[doc = " @brief Defines the general input parameter structure of the {@link setAttribute} function.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AttributeItem {
    #[doc = " Numeric array."]
    pub value: *const ArkUI_NumberValue,
    #[doc = " Size of the numeric array."]
    pub size: i32,
    #[doc = " String type."]
    pub string: *const ::std::os::raw::c_char,
    #[doc = " Object type."]
    pub object: *mut ::std::os::raw::c_void,
}
#[doc = " @brief Defines the width attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WIDTH: ArkUI_NodeAttributeType = 0;
#[doc = " @brief Defines the height attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: height, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: height, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_HEIGHT: ArkUI_NodeAttributeType = 1;
#[doc = " @brief Defines the background color attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: background color. The value is in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color. The value is in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_COLOR: ArkUI_NodeAttributeType = 2;
#[doc = " @brief Defines the background image attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: image address;\\n\n .value[0]?.i32: whether to repeat the image. Optional. The parameter type is {@link ArkUI_ImageRepeat}.\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n The default value is <b>ARKUI_IMAGE_REPEAT_NONE</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: image address;\\n\n .value[0].i32: whether to repeat the image. The parameter type is {@link ArkUI_ImageRepeat}.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_IMAGE: ArkUI_NodeAttributeType = 3;
#[doc = " @brief Defines the padding attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: Specify the same padding for the four directions. \\n\n .value[0].f32: padding, in vp.\\n\n 2: Specify different paddings for different directions. \\n\n .value[0].f32: top padding, in vp.\\n\n .value[1].f32: right padding, in vp.\\n\n .value[2].f32: bottom padding, in vp.\\n\n .value[3].f32: left padding, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: top padding, in vp.\\n\n .value[1].f32: right padding, in vp.\\n\n .value[2].f32: bottom padding, in vp.\\n\n .value[3].f32: left padding, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PADDING: ArkUI_NodeAttributeType = 4;
#[doc = " @brief Defines the component ID attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component ID.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component ID.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ID: ArkUI_NodeAttributeType = 5;
#[doc = " @brief Defines the interactivity attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The value <b>true</b> means that the component can interact with users, and <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means that the component can interact with users, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ENABLED: ArkUI_NodeAttributeType = 6;
#[doc = " @brief Defines the margin attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: Specify the same margin for the four directions. \\n\n .value[0].f32: margin, in vp.\\n\n 2: Specify different margins for different directions. \\n\n .value[0].f32: top margin, in vp.\\n\n .value[1].f32: right margin, in vp.\\n\n .value[2].f32: bottom margin, in vp.\\n\n .value[3].f32: left margin, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: top margin, in vp.\\n\n .value[1].f32: right margin, in vp.\\n\n .value[2].f32: bottom margin, in vp.\\n\n .value[3].f32: left margin, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MARGIN: ArkUI_NodeAttributeType = 7;
#[doc = " @brief Defines the translate attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: distance to translate along the x-axis, in vp. The default value is <b>0</b>.\\n\n .value[1].f32: distance to translate along the y-axis, in vp. The default value is <b>0</b>.\\n\n .value[2].f32: distance to translate along the z-axis, in vp. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: distance to translate along the x-axis, in vp.\\n\n .value[1].f32: distance to translate along the y-axis, in vp.\\n\n .value[2].f32: distance to translate along the z-axis, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSLATE: ArkUI_NodeAttributeType = 8;
#[doc = " @brief Defines the scale attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: scale factor along the x-axis. The default value is <b>1</b>.\\n\n .value[1].f32: scale factor along the y-axis. The default value is <b>1</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: scale factor along the x-axis.\\n\n .value[1].f32: scale factor along the y-axis. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCALE: ArkUI_NodeAttributeType = 9;
#[doc = " @brief Defines the rotate attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: X coordinate of the rotation axis vector. The default value is <b>0</b>.\\n\n .value[1].f32: Y coordinate of the rotation axis vector. The default value is <b>0</b>.\\n\n .value[2].f32: Z coordinate of the rotation axis vector. The default value is <b>0</b>.\\n\n .value[3].f32: rotation angle. The default value is <b>0</b>.\\n\n .value[4].f32: line of sight, that is, the distance from the viewpoint to the z=0 plane, in vp.\n The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the rotation axis vector.\\n\n .value[1].f32: Y coordinate of the rotation axis vector.\\n\n .value[2].f32: Z coordinate of the rotation axis vector.\\n\n .value[3].f32: rotation angle.\\n\n .value[4].f32: line of sight, that is, the distance from the viewpoint to the z=0 plane, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ROTATE: ArkUI_NodeAttributeType = 10;
#[doc = " @brief Sets the brightness attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: brightness value. The default value is <b>1.0</b>, and the recommended value range is [0, 2]. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: brightness value. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BRIGHTNESS: ArkUI_NodeAttributeType = 11;
#[doc = " @brief Sets the saturation attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].f32: saturation value. The default value is <b>1.0</b>, and the recommended value range is [0, 50). \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].f32: saturation value. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SATURATION: ArkUI_NodeAttributeType = 12;
#[doc = " @brief Sets the blur attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].f32: blur radius. A larger value indicates a higher blur degree. If the value is <b>0</b>,\n the component is not blurred. The unit is vp. The default value is <b>0.0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: blur radius. The larger the fuzzy radius, the more blurred the image. If the value is <b>0</b>,\n the image is not blurred. The unit is vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BLUR: ArkUI_NodeAttributeType = 13;
#[doc = " @brief Sets the gradient attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: start angle of the linear gradient. This attribute takes effect only when\n {@link ArkUI_LinearGradientDirection} is set to <b>ARKUI_LINEAR_GRADIENT_DIRECTION_CUSTOM</b>.\n A positive value indicates a clockwise rotation from the origin, (0, 0). The default value is <b>180</b>. \\n\n .value[1].i32: direction of the linear gradient. When it is set, the <b>angle</b> attribute does not take effect.\n The parameter type is {@link ArkUI_LinearGradientDirection}: \\n\n .value[2].i32: whether the colors are repeated. The default value is <b>false</b>. \\n\n .object: array of color stops, each of which consists of a color and its stop position.\n Invalid colors are automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].f32: start angle of the linear gradient. \\n\n .value[1].i32: direction of the linear gradient. It does not take effect when <b>angle</b> is set. \\n\n .value[2].i32: whether the colors are repeated. \\n\n .object: array of color stops, each of which consists of a color and its stop position.\n Invalid colors are automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LINEAR_GRADIENT: ArkUI_NodeAttributeType = 14;
#[doc = " @brief Sets the alignment attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode. The data type is {@link ArkUI_Alignment}.\n The default value is <b>ARKUI_ALIGNMENT_CENTER</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode. The data type is {@link ArkUI_Alignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ALIGNMENT: ArkUI_NodeAttributeType = 15;
#[doc = " @brief Defines the opacity attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: opacity value. The value ranges from 0 to 1. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: opacity value. The value ranges from 0 to 1. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OPACITY: ArkUI_NodeAttributeType = 16;
#[doc = " @brief Defines the border width attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].f32: width of the four borders. \\n\n 2: .value[0].f32: width of the top border. \\n\n .value[1].f32: width of the right border. \\n\n .value[2].f32: width of the bottom border. \\n\n .value[3].f32: width of the left border. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the top border. \\n\n .value[1].f32: width of the right border. \\n\n .value[2].f32: width of the bottom border. \\n\n .value[3].f32: width of the left border. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_WIDTH: ArkUI_NodeAttributeType = 17;
#[doc = " @brief Defines the border corner radius attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].f32: radius of the four corners. \\n\n 2: .value[0].f32: radius of the upper left corner. \\n\n .value[1].f32: radius of the upper right corner. \\n\n .value[2].f32: radius of the lower left corner. \\n\n .value[3].f32: radius of the lower right corner. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: radius of the upper left corner. \\n\n .value[1].f32: radius of the upper right corner. \\n\n .value[2].f32: radius of the lower left corner. \\n\n .value[3].f32: radius of the lower right corner. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_RADIUS: ArkUI_NodeAttributeType = 18;
#[doc = " @brief Defines the border color attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].u32: color of the four borders, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n 2: .value[0].u32: color of the top border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[1].u32: color of the right border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[2].u32: color of the lower border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[3].u32: color of the left border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the top border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[1].u32: color of the right border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[2].u32: color of the lower border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[3].u32: color of the left border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_COLOR: ArkUI_NodeAttributeType = 19;
#[doc = " @brief Defines the border line style attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].i32: line style of the four borders. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n 2: .value[0].i32: line style of the top border. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n .value[1].i32: line style of the right border. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n .value[2].i32: line style of the bottom border. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n .value[3].i32: line style of the left border. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: line style of the top border. \\n\n .value[1].i32: line style of the right border. \\n\n .value[2].i32: line style of the bottom border. \\n\n .value[3].i32: line style of the left border. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_STYLE: ArkUI_NodeAttributeType = 20;
#[doc = " @brief Defines the z-index attribute for the stack sequence.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: z-index value. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: z-index value. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_Z_INDEX: ArkUI_NodeAttributeType = 21;
#[doc = " @brief Defines the visibility attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show or hide the component. The parameter type is {@link ArkUI_Visibility}.\n The default value is <b>ARKUI_VISIBILITY_VISIBLE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to show or hide the component. The parameter type is {@link ArkUI_Visibility}.\n The default value is <b>ARKUI_VISIBILITY_VISIBLE</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_VISIBILITY: ArkUI_NodeAttributeType = 22;
#[doc = " @brief Defines the clipping and masking attribute, which can be set, reset, and obtained as required through\n APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to clip the component based on the parent container bounds.\n The value <b>1</b> means to clip the component, and <b>0</b> means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to clip the component based on the parent container bounds.\n The value <b>1</b> means to clip the component, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CLIP: ArkUI_NodeAttributeType = 23;
#[doc = " @brief Defines the clipping region on the component.\n This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute,\n which supports four types of shapes:\\n\n 1. Rectangle:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_RECTANGLE</b> for the rectangle shape. \\n\n .value[1].f32: width of the rectangle.\\n\n .value[2].f32: height of rectangle.\\n\n .value[3].f32: width of the rounded corner of the rectangle.\\n\n .value[4].f32: height of the rounded corner of the rectangle.\\n\n .value[5]?.f32: radius of the top left corner of the rectangular shape.\\n\n .value[6]?.f32: radius of the bottom left corner of the rectangular shape.\\n\n .value[7]?.f32: radius of the top right corner of the rectangular shape.\\n\n .value[8]?.f32: radius of the bottom right corner of the rectangular shape.\\n\n ?.object: clipOption of the rectangle. The parameter type is {@link ArkUI_RenderNodeClipOption} type.\n It takes effect when only the .object parameter is passed, ArkUI_RenderNodeClipOption type is rectangle, and .size must be equal to 1.\n 2. Circle:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[1].f32: width of the circle.\\n\n .value[2].f32: height of the circle.\\n\n ?.object: clipOption of the circle. The parameter type is {@link ArkUI_RenderNodeClipOption} type.\n It takes effect when only the .object parameter is passed, ArkUI_RenderNodeClipOption type is circle, and .size must be equal to 1.\n 3.Ellipse:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[1].f32: width of the ellipse.\\n\n .value[2].f32: height of the ellipse.\\n\n ?.object: clipOption of the ellipse. The parameter type is {@link ArkUI_RenderNodeClipOption} type.\n It takes effect when only the .object parameter is passed, ArkUI_RenderNodeClipOption type is ellipse, and .size must be equal to 1.\n 4. Path:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_PATH</b> for the path shape.\\n\n .value[1].f32: width of the path.\\n\n .value[2].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n ?.object: clipOption of the path. The parameter type is {@link ArkUI_RenderNodeClipOption} type.\n It takes effect when only the .object parameter is passed, ArkUI_RenderNodeClipOption type is path, and .size must be equal to 1.\\n\n Format of the return value {@link ArkUI_AttributeItem}, which supports four types of shapes: \\n\n 1. Rectangle:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_RECTANGLE</b> for the rectangle shape.\\n\n .value[1].f32: width of the rectangle.\\n\n .value[2].f32: height of rectangle.\\n\n .value[3].f32: width of the rounded corner of the rectangle.\\n\n .value[4].f32: height of the rounded corner of the rectangle.\\n\n .value[5].f32: radius of the top left corner of the rectangular shape; \\n\n .value[6].f32: radius of the bottom left corner of the rectangular shape; \\n\n .value[7].f32: radius of the top right corner of the rectangular shape; \\n\n .value[8].f32: radius of the bottom right corner of the rectangular shape; \\n\n .value[9]?.f32: horizontal coordinate offset of the rectangle. \\n\n .value[10]?.f32: vertical coordinate offset of the rectangle. \\n\n 2. Circle:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[1].f32: width of the circle.\\n\n .value[2].f32: height of the circle.\\n\n .value[3]?.f32: horizontal coordinate offset of the circle.\\n\n .value[4]?.f32: vertical coordinate offset of the circle.\\n\n 3.Ellipse:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[1].f32: width of the ellipse.\\n\n .value[2].f32: height of the ellipse.\\n\n .value[3]?.f32: horizontal coordinate offset of the ellipse.\\n\n .value[4]?.f32: vertical coordinate offset of the ellipse.\\n\n 4. Path:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_PATH</b> for the path shape.\\n\n .value[1].f32: width of the path.\\n\n .value[2].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CLIP_SHAPE: ArkUI_NodeAttributeType = 24;
#[doc = " @brief Defines the transform attribute, which can be used to translate, rotate, and scale images.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0...15].f32: 16 floating-point numbers. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0...15].f32: 16 floating-point numbers. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSFORM: ArkUI_NodeAttributeType = 25;
#[doc = " @brief Defines the hit test behavior attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: hit test mode. The parameter type is {@link ArkUI_HitTestMode}.\n The default value is <b>ARKUI_HIT_TEST_MODE_DEFAULT</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: hit test mode. The parameter type is {@link ArkUI_HitTestMode}.\n The default value is <b>ARKUI_HIT_TEST_MODE_DEFAULT</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_HIT_TEST_BEHAVIOR: ArkUI_NodeAttributeType = 26;
#[doc = " @brief Defines the offset attribute, which specifies the offset of the component's upper left corner relative\n to the parent container's. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: X coordinate. \\n\n .value[1].f32: Y coordinate. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate. \\n\n .value[1].f32: Y coordinate. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_POSITION: ArkUI_NodeAttributeType = 27;
#[doc = " @brief Defines the shadow attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: shadow effect. The parameter type is {@link ArkUI_ShadowStyle}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: shadow effect. The parameter type is {@link ArkUI_ShadowStyle}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SHADOW: ArkUI_NodeAttributeType = 28;
#[doc = " @brief Defines the custom shadow effect. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: blur radius of the shadow, in vp.\\n\n .value[1]?.i32: whether to enable the coloring strategy. The value <b>1</b> means to enable the coloring\n strategy, and <b>0</b> (default value) means the opposite.\\n\n .value[2]?.f32: offset of the shadow along the x-axis, in px.\\n\n .value[3]?.f32: offset of the shadow along the y-axis, in px.\\n\n .value[4]?.i32: shadow type {@link ArkUI_ShadowType}. The default value is <b>ARKUI_SHADOW_TYPE_COLOR</b>.\\n\n .value[5]?.u32: shadow color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n .value[6]?.u32: whether to fill the shadow. The value <b>1</b> means to fill the shadow, and <b>0</b>\n means the opposite.\\n\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: blur radius of the shadow, in vp.\\n\n .value[1].i32: whether to enable the coloring strategy. \\n\n .value[2].f32: offset of the shadow along the x-axis, in px.\\n\n .value[3].f32: offset of the shadow along the y-axis, in px.\\n\n .value[4].i32: shadow type {@link ArkUI_ShadowType}. The default value is <b>ARKUI_SHADOW_TYPE_COLOR</b>.\\n\n .value[5].u32: shadow color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n .value[6].u32: whether to fill the shadow. The value <b>1</b> means to fill the shadow, and <b>0</b>\n means the opposite.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CUSTOM_SHADOW: ArkUI_NodeAttributeType = 29;
#[doc = " @brief Defines the background image width and height.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width of the image. The value range is [0, +), and the unit is vp. \\n\n .value[1].f32: height of the image. The value range is [0, +), and the unit is vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the image, in vp. \\n\n .value[1].f32: height of the image, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_IMAGE_SIZE: ArkUI_NodeAttributeType = 30;
#[doc = " @brief Defines the background image size.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: size of the background image. The value is an enum of {@link ArkUI_ImageSize}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: size of the background image. The value is an enum of {@link ArkUI_ImageSize}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_IMAGE_SIZE_WITH_STYLE: ArkUI_NodeAttributeType =
    31;
#[doc = " @brief Defines the background blur attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: blue type. The value is an enum of {@link ArkUI_BlurStyle}. \\n\n .value[1]?.i32: color mode. The value is an enum of {@link ArkUI_ColorMode}. \\n\n .value[2]?.i32: adaptive color mode. The value is an enum of {@link ArkUI_AdaptiveColor}. \\n\n .value[3]?.f32: blur degree. The value range is [0.0, 1.0]. \\n\n .value[4]?.f32: start boundary of grayscale blur. \\n\n .value[5]?.f32: end boundary of grayscale blur. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: blue type. The value is an enum of {@link ArkUI_BlurStyle}. \\n\n .value[1].i32: color mode. The value is an enum of {@link ArkUI_ColorMode}. \\n\n .value[2].i32: adaptive color mode. The value is an enum of {@link ArkUI_AdaptiveColor}. \\n\n .value[3].f32: blur degree. The value range is [0.0, 1.0]. \\n\n .value[4].f32: start boundary of grayscale blur. \\n\n .value[5].f32: end boundary of grayscale blur. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_BLUR_STYLE: ArkUI_NodeAttributeType = 32;
#[doc = " @brief Defines the transform center attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: X coordinate of the center point, in vp.\\n\n .value[1]?.f32: Y coordinate of the center point, in vp.\\n\n .value[2]?.f32: Z coordinate of the center point, in vp.\\n\n .value[3]?.f32 : X coordinate of the center point, expressed in a number that represents a percentage.\n For example, 0.2 indicates 20%. This attribute overwrites value[0].f32. The default value is <b>0.5f</b>. \\n\n .value[4]?.f32 : Y coordinate of the center point, expressed in a number that represents a percentage.\n For example, 0.2 indicates 20%. This attribute overwrites value[1].f32. The default value is <b>0.5f</b>. \\n\n .value[5]?.f32 : Z coordinate of the center point, expressed in a number that represents a percentage.\n For example, 0.2 indicates 20%. This attribute overwrites value[2].f32. The default value is <b>0.0f</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the center point, in vp.\\n\n .value[1].f32: Y coordinate of the center point, in vp.\\n\n .value[2].f32: Z coordinate of the center point, in vp.\\n\n Note: If the coordinate is expressed in a number that represents a percentage, the attribute obtaining API\n returns the calculated value in vp.\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSFORM_CENTER: ArkUI_NodeAttributeType = 33;
#[doc = " @brief Defines the transition opacity attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: opacity values of the start and end points.\\n\n .value[1].i32: animation duration, in milliseconds.\\n\n .value[2].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n\n .value[3]?.i32: animation delay duration, in milliseconds.\\n\n .value[4]?.i32: number of times that the animation is played.\\n\n .value[5]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}.\\n\n .value[6]?.f32: animation playback speed.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: opacity values of the start and end points.\\n\n .value[1].i32: animation duration, in milliseconds.\\n\n .value[2].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n\n .value[3].i32: animation delay duration, in milliseconds. \\n\n .value[4].i32: number of times that the animation is played. \\n\n .value[5].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[6].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OPACITY_TRANSITION: ArkUI_NodeAttributeType = 34;
#[doc = " @brief Defines the transition rotation attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: X-component of the rotation vector. \\n\n .value[1].f32: Y-component of the rotation vector. \\n\n .value[2].f32: Z-component of the rotation vector \\n\n .value[3].f32: angle. \\n\n .value[4].f32: line of sight. The default value is <b>0.0f</b>. \\n\n .value[5].i32: animation duration, in milliseconds. \\n\n .value[6].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n .value[7]?.i32: animation delay duration, in milliseconds. \\n\n .value[8]?.i32: number of times that the animation is played. \\n\n .value[9]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[10]?.f32: animation playback speed. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X-component of the rotation vector. \\n\n .value[1].f32: Y-component of the rotation vector. \\n\n .value[2].f32: Z-component of the rotation vector \\n\n .value[3].f32: angle. \\n\n .value[4].f32: line of sight. \\n\n .value[5].i32: animation duration, in milliseconds. \\n\n .value[6].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n .value[7].i32: animation delay duration, in milliseconds. \\n\n .value[8].i32: number of times that the animation is played. \\n\n .value[9].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[10].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ROTATE_TRANSITION: ArkUI_NodeAttributeType = 35;
#[doc = " @brief Defines the transition scaling attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: scale factor along the x-axis. \\n\n .value[1].f32: scale factor along the y-axis. \\n\n .value[2].f32: scale factor along the z-axis. \\n\n .value[3].i32: animation duration, in milliseconds. \\n\n .value[4].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n .value[5]?.i32: animation delay duration, in milliseconds. \\n\n .value[6]?.i32: number of times that the animation is played. \\n\n .value[7]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[8]?.f32: animation playback speed. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: scale factor along the x-axis. \\n\n .value[1].f32: scale factor along the y-axis. \\n\n .value[2].f32: scale factor along the z-axis. \\n\n .value[3].i32: animation duration, in milliseconds. \\n\n .value[4].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n .value[5].i32: animation delay duration, in milliseconds. \\n\n .value[6].i32: number of times that the animation is played. \\n\n .value[7].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[8].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCALE_TRANSITION: ArkUI_NodeAttributeType = 36;
#[doc = " @brief Defines the transition translation attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n value[0].f32: translation distance along the x-axis, in vp.\\n\n value[1].f32: translation distance along the y-axis, in vp.\\n\n value[2].f32: translation distance along the z-axis, in vp.\\n\n value[3].i32: animation duration, in milliseconds. \\n\n value[4].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n value[5]?.i32: animation delay duration, in milliseconds. \\n\n value[6]?.i32: number of times that the animation is played. \\n\n value[7]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n value[8]?.f32: animation playback speed. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].f32: translation distance along the x-axis, in vp.\\n\n value[1].f32: translation distance along the y-axis, in vp.\\n\n value[2].f32: translation distance along the z-axis, in vp.\\n\n value[3].i32: animation duration, in milliseconds. \\n\n value[4].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n value[5].i32: animation delay duration, in milliseconds. \\n\n value[6].i32: number of times that the animation is played. \\n\n value[7].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n value[8].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSLATE_TRANSITION: ArkUI_NodeAttributeType = 37;
#[doc = " @brief Defines the slide-in and slide-out of the component from the screen edge during transition.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_TransitionEdge}. \\n\n .value[1].i32: animation duration, in milliseconds.\\n\n .value[2].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n\n .value[3]?.i32: animation delay duration, in milliseconds.\\n\n .value[4]?.i32: number of times that the animation is played.\\n\n .value[5]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}.\\n\n .value[6]?.f32: animation playback speed.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_TransitionEdge}. \\n\n .value[1].i32: animation duration, in milliseconds.\\n\n .value[2].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n\n .value[3].i32: animation delay duration, in milliseconds. \\n\n .value[4].i32: number of times that the animation is played. \\n\n .value[5].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[6].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MOVE_TRANSITION: ArkUI_NodeAttributeType = 38;
#[doc = " @brief Defines the focus attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_FOCUSABLE: ArkUI_NodeAttributeType = 39;
#[doc = " @brief Defines the default focus attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_DEFAULT_FOCUS: ArkUI_NodeAttributeType = 40;
#[doc = " @brief Defines the touch target attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .data[0].f32: X coordinate of the touch point relative to the upper left corner of the component, in vp. \\n\n .data[1].f32: Y coordinate of the touch point relative to the upper left corner of the component, in vp. \\n\n .data[2].f32: width of the touch target, in %. \\n\n .data[3].f32: height of the touch target, in %. \\n\n .data[4...].f32: Multiple touch targets can be set. The sequence of the parameters is the same as the preceding.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .data[0].f32: X coordinate of the touch point relative to the upper left corner of the component, in vp. \\n\n .data[1].f32: Y coordinate of the touch point relative to the upper left corner of the component, in vp. \\n\n .data[2].f32: width of the touch target, in %. \\n\n .data[3].f32: height of the touch target, in %. \\n\n .data[4...].f32: Multiple touch targets can be set. The sequence of the parameters is the same as the preceding.\n"]
pub const ArkUI_NodeAttributeType_NODE_RESPONSE_REGION: ArkUI_NodeAttributeType = 41;
#[doc = " @brief Defines the overlay attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n You can set the overlay content through .string or .object as follow, and .string has higher priority.\n .string: mask text.\\n\n .value[0]?.i32: position of the overlay relative to the component. Optional.\n The parameter type is {@link ArkUI_Alignment}.\n The default value is <b>ARKUI_ALIGNMENT_TOP_START.</b> \\n\n .value[1]?.f32: offset of the overlay relative to the upper left corner of itself on the x-axis, in vp. Optional. \\n\n .value[2]?.f32: offset of the overlay relative to the upper left corner of itself on the y-axis, in vp. Optional.\n \\n\n .value[3]?.i32: the layout direction.\n The parameter type is {@link ArkUI_Direction}, supported since API 21.\n The default value is <b>ARKUI_DIRECTION_LTR.</b> \\n\n In most cases, this parameter should be set to Auto, this allowing the system to handle\n the layout direction automatically. If you need to keep a specific direction in any situation, set it to\n either LTR (Left-to-Right) or RTL (Right-to-Left). Optional.\n \\n\n .object: the node tree used as the overlay.\n The parameter type is {@link ArkUI_NodeHandle}.\n The default value is <b>nullptr.</b> \\n\n this parameter is conflict with .string, and it has lower priority than .string.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: mask text.\\n\n .value[0].i32: position of the overlay relative to the component.\n The parameter type is {@link ArkUI_Alignment}.\n The default value is <b>ARKUI_ALIGNMENT_TOP_START.</b> \\n\n .value[1].f32: offset of the overlay relative to the upper left corner of itself on the x-axis, in vp. \\n\n .value[2].f32: offset of the overlay relative to the upper left corner of itself on the y-axis, in vp.\n .value[3].i32: the layout direction.\n The parameter type is {@link ArkUI_Direction}, supported since API 21.\n The default value is <b>ARKUI_DIRECTION_LTR.</b> \\n\n .object: the overlay node handle. \\n"]
pub const ArkUI_NodeAttributeType_NODE_OVERLAY: ArkUI_NodeAttributeType = 42;
#[doc = " @brief Defines the sweep gradient effect.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: X coordinate of the sweep gradient center relative to the upper left corner of the component.\\n\n .value[1]?.f32: Y coordinate of the sweep gradient center relative to the upper left corner of the component.\\n\n .value[2]?.f32: start point of the sweep gradient. The default value is <b>0</b>. \\n\n .value[3]?.f32: end point of the sweep gradient. The default value is <b>0</b>. \\n\n .value[4]?.f32: rotation angle of the sweep gradient. The default value is <b>0</b>. \\n\n .value[5]?.i32: whether the colors are repeated. The value <b>1</b> means that the colors are repeated,\n and <b>0</b> means the opposite.\\n\n .object: array of color stops, each of which consists of a color and its stop position. Invalid colors are\n automatically skipped.\\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the sweep gradient center relative to the upper left corner of the component. \\n\n .value[1].f32: Y coordinate of the sweep gradient center relative to the upper left corner of the component. \\n\n .value[2].f32: start point of the sweep gradient. The default value is <b>0</b>. \\n\n .value[3].f32: end point of the sweep gradient. The default value is <b>0</b>. \\n\n .value[4].f32: rotation angle of the sweep gradient. The default value is <b>0</b>. \\n\n .value[5].i32: whether the colors are repeated. The value <b>1</b> means that the colors are repeated,\n and <b>0</b> means the opposite.\\n\n .object: array of color stops, each of which consists of a color and its stop position. Invalid colors are\n automatically skipped.\\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWEEP_GRADIENT: ArkUI_NodeAttributeType = 43;
#[doc = " @brief Defines the radial gradient effect.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0]?.f32: X coordinate of the radial gradient center relative to the upper left corner of the component. \\n\n .value[1]?.f32: Y coordinate of the radial gradient center relative to the upper left corner of the component. \\n\n .value[2]?.f32: radius of the radial gradient. The default value is <b>0</b>. \\n\n .value[3]?.i32: whether the colors are repeated. The value <b>1</b> means that the colors are repeated,\n and <b>0</b> means the opposite. \\n\n .object: array of color stops, each of which consists of a color and its stop position. Invalid colors are\n automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the radial gradient center relative to the upper left corner of the component. \\n\n .value[1].f32: Y coordinate of the radial gradient center relative to the upper left corner of the component. \\n\n .value[2].f32: radius of the radial gradient. The default value is <b>0</b>. \\n\n .value[3].i32: whether the colors are repeated. The value <b>1</b> means that the colors are repeated,\n and <b>0</b> means the opposite.\\n\n .object: array of color stops, each of which consists of a color and its stop position. Invalid colors are\n automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RADIAL_GRADIENT: ArkUI_NodeAttributeType = 44;
#[doc = " @brief Adds a mask of the specified shape to the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute, which supports five types of\n shapes:\\n\n 1. Rectangle:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_RECTANGLE</b> for the rectangle shape.\\n\n .value[4].f32: width of the rectangle.\\n\n .value[5].f32: height of the rectangle.\\n\n .value[6].f32: width of the rounded corner of the rectangle.\\n\n .value[7].f32: height of the rounded corner of the rectangle.\\n\n .value[8]?.f32: radius of the top left corner of the rectangular shape.\\n\n .value[9]?.f32: radius of the bottom left corner of the rectangular shape.\\n\n .value[10]?.f32: radius of the top right corner of the rectangular shape.\\n\n .value[11]?.f32: radius of the bottom right corner of the rectangular shape.\\n\n 2. Circle:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[4].f32: width of the circle.\\n\n .value[5].f32: height of the circle.\\n\n 3. Ellipse:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[4].f32: width of the ellipse.\\n\n .value[5].f32: height of the ellipse.\\n\n 4. Path:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_PATH</b> for the path shape.\\n\n .value[4].f32: width of the path.\\n\n .value[5].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n 5. Progress:\\n\n .value[0].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_PROGRESS</b> for the progress shape.\\n\n .value[1].f32: current value of the progress indicator.\\n\n .value[2].f32: maximum value of the progress indicator.\\n\n .value[3].u32: color of the progress indicator, in 0xARGB format.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}, which supports five types of shapes:\\n\n 1. Rectangle:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type.\\n\n .value[4].f32: width of the rectangle.\\n\n .value[5].f32: height of the rectangle.\\n\n .value[6].f32: width of the rounded corner of the rectangle.\\n\n .value[7].f32: height of the rounded corner of the rectangle.\\n\n .value[8].f32: radius of the top left corner of the rectangular shape.\\n\n .value[9].f32: radius of the bottom left corner of the rectangular shape.\\n\n .value[10].f32: radius of the top right corner of the rectangular shape.\\n\n .value[11].f32: radius of the bottom right corner of the rectangular shape.\\n\n 2. Circle:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type.\\n\n .value[4].f32: width of the circle.\\n\n .value[5].f32: height of the circle.\\n\n 3. Ellipse:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type.\\n\n .value[4].f32: width of the ellipse.\\n\n .value[5].f32: height of the ellipse.\\n\n 4. Path:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type.\\n\n .value[4].f32: width of the path.\\n\n .value[5].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n 5. Progress:\\n\n .value[0].i32: mask type.\\n\n .value[1].f32: current value of the progress indicator.\\n\n .value[2].f32: maximum value of the progress indicator.\\n\n .value[3].u32: color of the progress indicator.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MASK: ArkUI_NodeAttributeType = 45;
#[doc = " @brief Blends the component's background with the content of the component's child node.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: blend mode. The parameter type is {@link ArkUI_BlendMode}. The default value is\n <b>ARKUI_BLEND_MODE_NONE</b>. \\n\n .value[1].?i32: how the specified blend mode is applied. The parameter type is {@link ArkUI_BlendApplyType}.\n The default value is <b>BLEND_APPLY_TYPE_FAST</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: blend mode. The parameter type is {@link ArkUI_BlendMode}. The default value is\n <b>ARKUI_BLEND_MODE_NONE</b>. \\n\n .value[1].i32: how the specified blend mode is applied. The parameter type is {@link ArkUI_BlendApplyType}.\n The default value is <b>BLEND_APPLY_TYPE_FAST</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BLEND_MODE: ArkUI_NodeAttributeType = 46;
#[doc = " @brief Sets the direction of the main axis.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: direction of the main axis.\\n\n The parameter type is {@link ArkUI_Direction}. The default value is <b>ARKUI_DIRECTION_AUTO</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: direction of the main axis.\\n\n The parameter type is {@link ArkUI_Direction}. The default value is <b>ARKUI_DIRECTION_AUTO</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DIRECTION: ArkUI_NodeAttributeType = 47;
#[doc = " @brief Defines the size constraints.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum width, in vp.\\n\n .value[1].f32: maximum width, in vp.\\n\n .value[2].f32: minimum height, in vp.\\n\n .value[3].f32: maximum height, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum width, in vp.\\n\n .value[1].f32: maximum width, in vp.\\n\n .value[2].f32: minimum height, in vp.\\n\n .value[3].f32: maximum height, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CONSTRAINT_SIZE: ArkUI_NodeAttributeType = 48;
#[doc = " @brief Defines the grayscale effect.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: grayscale conversion ratio. The value ranges from 0 to 1.\n For example, 0.5 indicates a 50% grayscale conversion ratio. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: grayscale conversion ratio. The value ranges from 0 to 1.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRAY_SCALE: ArkUI_NodeAttributeType = 49;
#[doc = " @brief Inverts the image.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: image inversion ratio. The value ranges from 0 to 1.\n For example, 0.5 indicates a 50% image inversion ratio.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: image inversion ratio. The value ranges from 0 to 1.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_INVERT: ArkUI_NodeAttributeType = 50;
#[doc = " @brief Defines the sepia conversion ratio.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: sepia conversion ratio. The value ranges from 0 to 1.\n For example, 0.5 indicates that a 50% sepia conversion ratio.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: sepia conversion ratio. The value ranges from 0 to 1.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SEPIA: ArkUI_NodeAttributeType = 51;
#[doc = " @brief Defines the contrast attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: contrast. If the value is <b>1</b>, the source image is displayed.\n A larger value indicates a higher contrast. Value range: [0, 10).\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: contrast. Value range: [0, 10).\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CONTRAST: ArkUI_NodeAttributeType = 52;
#[doc = " @brief Defines the foreground color attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n 2: .value[0].i32: color enum {@link ArkUI_ColoringStrategy}.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FOREGROUND_COLOR: ArkUI_NodeAttributeType = 53;
#[doc = " @brief Defines the offset of the component's child relative to the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32 : offset along the x-axis, in vp. \\n\n .value[1].f32 : offset along the y-axis, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32 : offset along the x-axis, in vp. \\n\n .value[1].f32 : offset along the y-axis, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OFFSET: ArkUI_NodeAttributeType = 54;
#[doc = " @brief Sets the anchor for locating the component's child.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: X coordinate of the anchor, in vp.\\n\n .value[1].f32: Y coordinate of the anchor, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the anchor, in vp.\\n\n .value[1].f32: Y coordinate of the anchor, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MARK_ANCHOR: ArkUI_NodeAttributeType = 55;
#[doc = " @brief Defines the position of the background image in the component, that is, the coordinates relative to\n the upper left corner of the component. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: position along the x-axis, in px. \\n\n .value[1].f32: position along the y-axis, in px. \\n\n .value[2].?i32: the alignment mode. The data type is {@link ArkUI_Alignment}, and supported since API 21.\n The default value is <b>ARKUI_ALIGNMENT_TOP_START</b>. \\n\n .value[3].?i32: the direction. The type is {@link ArkUI_Direction}, and supported since API 21.\n The default value is <b>ARKUI_DIRECTION_AUTO</b>. \\n\n In most cases, this parameter should be set to Auto, this allowing the system to handle\n the layout direction automatically. If you need to keep a specific direction in any situation, set it to\n either LTR (Left-to-Right) or RTL (Right-to-Left). Optional.\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: position along the x-axis, in px. \\n\n .value[1].f32: position along the y-axis, in px. \\n\n .value[2].i32: the alignment mode. The data type is {@link ArkUI_Alignment}, and supported since API 21.\n The default value is <b>ARKUI_ALIGNMENT_TOP_START</b>. \\n\n .value[3].i32: the direction. The type is {@link ArkUI_Direction}, and supported since API 21.\n The default value is <b>ARKUI_DIRECTION_AUTO</b>. \\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_IMAGE_POSITION: ArkUI_NodeAttributeType = 56;
#[doc = " @brief Sets the alignment rules in the relative container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: Use the {@link ArkUI_AlignmentRuleOption} object as the components alignment rule. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: Use the {@link ArkUI_AlignmentRuleOption} object as the components alignment rule. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ALIGN_RULES: ArkUI_NodeAttributeType = 57;
#[doc = " @brief Sets the alignment mode of the child components along the cross axis of the parent container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode of the child components along the cross axis of the parent container.\\n\n The parameter type is {@link ArkUI_ItemAlignment}. The default value is <b>ARKUI_ITEM_ALIGNMENT_AUTO</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode of the child components along the cross axis of the parent container.\\n\n The parameter type is {@link ArkUI_ItemAlignment}. The default value is <b>ARKUI_ITEM_ALIGNMENT_AUTO</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ALIGN_SELF: ArkUI_NodeAttributeType = 58;
#[doc = " @brief Sets the percentage of the parent container's remaining space that is allocated to the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: percentage of the parent container's remaining space that is allocated to the component. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: percentage of the parent container's remaining space that is allocated to the component. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FLEX_GROW: ArkUI_NodeAttributeType = 59;
#[doc = " @brief Sets the percentage of the parent container's shrink size that is allocated to the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: percentage of the parent container's shrink size that is allocated to the component. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: percentage of the parent container's shrink size that is allocated to the component. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FLEX_SHRINK: ArkUI_NodeAttributeType = 60;
#[doc = " @brief Sets the base size of the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: percentage of the parent container's remaining space that is allocated to the component. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: percentage of the parent container's remaining space that is allocated to the component. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FLEX_BASIS: ArkUI_NodeAttributeType = 61;
#[doc = " @brief Sets the accessibility group. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: Accessibility group. The value <b>1</b> means that the component and all its child components\n form an entire selectable component.\n In this case, the accessibility service will no longer be available for the content of its child components.\n The value is <b>1</b> or <b>0</b>.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: Accessibility group. The value <b>1</b> means that the component and all its child components\n form an entire selectable component.\n In this case, the accessibility service will no longer be available for the content of its child components.\n The value is <b>1</b> or <b>0</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_GROUP: ArkUI_NodeAttributeType = 62;
#[doc = " @brief Sets the accessibility text. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: accessibility text.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: accessibility text.\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_TEXT: ArkUI_NodeAttributeType = 63;
#[doc = " @brief Sets the accessibility service model. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: accessibility service model. The parameter type is {@link ArkUI_AccessibilityMode}.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: accessibility service model. The parameter type is {@link ArkUI_AccessibilityMode}.\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_MODE: ArkUI_NodeAttributeType = 64;
#[doc = " @brief Sets the accessibility description.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: accessibility description.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: accessibility description.\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_DESCRIPTION: ArkUI_NodeAttributeType = 65;
#[doc = " @brief Defines the focused state. This attribute can be set and obtained as required through APIs.\n @note Setting the parameter to <b>0</b> shifts focus from the currently focused component on the current level\n of the page to the root container.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_FOCUS_STATUS: ArkUI_NodeAttributeType = 66;
#[doc = " @brief Defines the aspect ratio attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: aspect ratio of the component, in width/height format. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: aspect ratio of the component, in width/height format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ASPECT_RATIO: ArkUI_NodeAttributeType = 67;
#[doc = " @brief Defines the weight of the component within its row, column, or flex container for proportional\n distribution of available space within the container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: weight of the component along the main axis. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: weight of the component along the main axis. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LAYOUT_WEIGHT: ArkUI_NodeAttributeType = 68;
#[doc = " @brief Sets the display priority for the component in the row, column, or flex  (single-line) container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: display priority of the component in the container. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: display priority of the component in the container. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DISPLAY_PRIORITY: ArkUI_NodeAttributeType = 69;
#[doc = " @brief Sets the thickness of an element's outline.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: thickness of the left outline. \\n\n .value[1].f32: thickness of the top outline. \\n\n .value[2].f32: thickness of the right outline. \\n\n .value[3].f32: thickness of the bottom outline. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: thickness of the left outline. \\n\n .value[1].f32: thickness of the top outline. \\n\n .value[2].f32: thickness of the right outline. \\n\n .value[3].f32: thickness of the bottom outline. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OUTLINE_WIDTH: ArkUI_NodeAttributeType = 70;
#[doc = " @brief Defines the width attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width, in percentage.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width, in percentage.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WIDTH_PERCENT: ArkUI_NodeAttributeType = 71;
#[doc = " @brief Defines the height attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: height, in percentage.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: height, in percentage.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_HEIGHT_PERCENT: ArkUI_NodeAttributeType = 72;
#[doc = " @brief Defines the padding attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: Specify the same padding for the four directions. \\n\n .value[0].f32: padding, in percentage.\\n\n 2: Specify different paddings for different directions. \\n\n .value[0].f32: top padding, in percentage.\\n\n .value[1].f32: right padding, in percentage.\\n\n .value[2].f32: bottom padding, in percentage.\\n\n .value[3].f32: left padding, in percentage.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: top padding, in percentage.\\n\n .value[1].f32: right padding, in percentage.\\n\n .value[2].f32: bottom padding, in percentage.\\n\n .value[3].f32: left padding, in percentage.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PADDING_PERCENT: ArkUI_NodeAttributeType = 73;
#[doc = " @brief Defines the margin attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: Specify the same margin for the four directions. \\n\n .value[0].f32: margin, in percentage.\\n\n 2: Specify different margins for different directions. \\n\n .value[0].f32: top margin, in percentage.\\n\n .value[1].f32: right margin, in percentage.\\n\n .value[2].f32: bottom margin, in percentage.\\n\n .value[3].f32: left margin, in percentage.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: top margin, in percentage.\\n\n .value[1].f32: right margin, in percentage.\\n\n .value[2].f32: bottom margin, in percentage.\\n\n .value[3].f32: left margin, in percentage.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MARGIN_PERCENT: ArkUI_NodeAttributeType = 74;
#[doc = " @brief The implicit shared element transition within the component supports attribute setting,\n attribute reset, and attribute acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .value[0]?.i32: The parameter type is 1 or 0. 2 components that share element bindings,\n Whether to continue to participate in the shared element animation when the appearance element is not deleted,\n the default is false, and the original position will remain unchanged if not involved. \\n\n .string is used to set the binding relationship. Set the id to \"\" to\n clear the binding relationship to avoid participating in sharing behavior. \\n\n The id can be changed and the binding relationship re-established.\n The same ID can only be bound to two components and they are in/out roles of different types.\n Multiple components cannot be bound to the same id. \\n\n\\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .value[0].i32: The parameter type is 1 or 0. 2 components that share element bindings,\n Whether to continue to participate in the shared element animation when the appearance element is not deleted,\n the default is not false, if not involved, the original position will remain unchanged. \\n\n .string is used to set the binding relationship. Set the id to \"\" to\n clear the binding relationship to avoid participating in sharing behavior. \\n\n The id can be changed and the binding relationship re-established.\n The same ID can only be bound to two components and they are in/out roles of different types.\n Multiple components cannot be bound to the same id. \\n"]
pub const ArkUI_NodeAttributeType_NODE_GEOMETRY_TRANSITION: ArkUI_NodeAttributeType = 75;
#[doc = " @brief specifies the parameters of the chain formed by this component as the chain head,\n and supports attribute setting, attribute reset and attribute acquisition interfaces.\n\n Only takes effect when the parent container is RelativeContainer\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .value[0].i32: The direction of the chain. Enum {@link ArkUI_Axis}. \\n\n .value[1].i32: Chain style. Enum {@link ArkUI_RelativeLayoutChainStyle}. \\n\n\\n\n .value[0].i32: The direction of the chain. Enum {@link ArkUI_Axis}. \\n\n .value[1].i32: Chain style. Enum {@link ArkUI_RelativeLayoutChainStyle}. \\n"]
pub const ArkUI_NodeAttributeType_NODE_RELATIVE_LAYOUT_CHAIN_MODE: ArkUI_NodeAttributeType = 76;
#[doc = " @brief Set the component content filling method in the process of width and height animation,\n support property setting, property reset, property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32 Content filling mode {@link ArkUI_RenderFit}.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32 Content filling mode {@link ArkUI_RenderFit}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RENDER_FIT: ArkUI_NodeAttributeType = 77;
#[doc = " @brief External stroke color properties, support property setting,\n property reset and property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].u32: Set the border color of the four sides uniformly, using 0xargb, such as 0xFFFF11FF. \\n\n 2: .value[0].u32: Set the top border color, represented by 0xargb, such as 0xFFFF11FF. \\n\n .value[1].u32: Set the right border color, represented by 0xargb, such as 0xFFFF11FF. \\n\n .value[2].u32: Set the lower side box color, denoted by 0xargb, such as 0xFFFF11FF. \\n\n .value[3].u32: Set the left border color, denoted by 0xargb, such as 0xFFFF11FF. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: Set the top border color, represented by 0xargb, such as 0xFFFF11FF. \\n\n .value[1].u32: Set the right border color, represented by 0xargb, such as 0xFFFF11FF. \\n\n .value[2].u32: Set the lower side box color, denoted by 0xargb, such as 0xFFFF11FF. \\n\n .value[3].u32: Set the left border color, denoted by 0xargb, such as 0xFFFF11FF. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OUTLINE_COLOR: ArkUI_NodeAttributeType = 78;
#[doc = " @brief Set the height and width dimensions, support property setting,\n property reset and property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: Width value, unit is vp;\\n\n .value[1].f32: Height value, unit is vp;\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: Width value, unit is vp;\\n\n .value[1].f32: Height value, unit is vp;\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SIZE: ArkUI_NodeAttributeType = 79;
#[doc = " @brief Set whether the current component and child component are\n rendered off the screen first and then fused with the parent control,\n supporting property setting, property reset and property acquisition.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_RENDER_GROUP: ArkUI_NodeAttributeType = 80;
#[doc = " @brief Add color overlay effect to components, support property setting,\n property reset and property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: The color of the overlay is represented by 0xargb, such as 0xFFFF11FF. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: The color of the overlay is represented by 0xargb, such as 0xFFFF11FF. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_COLOR_BLEND: ArkUI_NodeAttributeType = 81;
#[doc = " @brief Provide content ambiguity capability for the current component,\n support property setting, property reset, property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32 Represents the content blurring style, and uses the {@link ArkUI_BlurStyle} enumeration value.\\n\n .value[1]?.i32 Represents the dark and light mode used by the content blur effect,\\n\n with the {@link ArkUI_ThemeColorMode} enumeration value.\\n\n .value[2]?.i32 The color extraction mode used to represent the content blur effect takes\\n\n the {@link ArkUI_AdaptiveColor} enumeration value.\\n\n .value[3]?.f32: blur degree. The value range is [0.0, 1.0]. \\n\n .value[4]?.f32 It is a gray-level fuzzy parameter. The value range is [0,127].\\n\n .value[5]?.f32 It is a gray-level fuzzy parameter. The value range is [0,127].\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32 Represents the content blurring style, and uses the {@link ArkUI_BlurStyle} enumeration value.\\n\n .value[1].i32 Represents the dark and light mode used by the content blur effect,\\n\n with the {@link ArkUI_ThemeColorMode} enumeration value.\\n\n .value[2].i32 The color extraction mode used to represent the content blur effect takes\\n\n the {@link ArkUI_AdaptiveColor} enumeration value.\\n\n .value[3].f32: blur degree. The value range is [0.0, 1.0]. \\n\n .value[4].f32 It is a gray-level fuzzy parameter. The value range is [0,127].\\n\n .value[5].f32 It is a gray-level fuzzy parameter. The value range is [0,127].\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FOREGROUND_BLUR_STYLE: ArkUI_NodeAttributeType = 82;
#[doc = " @brief Defines the component size and position for layout.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: X coordinate of the component, in px. \\n\n .value[1].i32: Y coordinate of the component, in px. \\n\n .value[2].i32: width of the component, in px. \\n\n .value[3].i32: height of the component, in px. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: X coordinate of the component, in px. \\n\n .value[1].i32: Y coordinate of the component, in px. \\n\n .value[2].i32: width of the component, in px. \\n\n .value[3].i32: height of the component, in px. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LAYOUT_RECT: ArkUI_NodeAttributeType = 83;
#[doc = " @brief Whether the current component supports click-to-focus capability,\n which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_FOCUS_ON_TOUCH: ArkUI_NodeAttributeType = 84;
#[doc = " @brief Defines the border width attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].f32: width of the four borders, in percentage. \\n\n 2: .value[0].f32: width of the top border, in percentage. \\n\n .value[1].f32: width of the right border, in percentage. \\n\n .value[2].f32: width of the bottom border, in percentage. \\n\n .value[3].f32: width of the left border, in percentage. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the top border, in percentage. \\n\n .value[1].f32: width of the right border, in percentage. \\n\n .value[2].f32: width of the bottom border, in percentage. \\n\n .value[3].f32: width of the left border, in percentage. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_WIDTH_PERCENT: ArkUI_NodeAttributeType = 85;
#[doc = " @brief Defines the border corner radius attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].f32: radius of the four corners, in percentage. \\n\n 2: .value[0].f32: radius of the upper left corner, in percentage. \\n\n .value[1].f32: radius of the upper right corner, in percentage. \\n\n .value[2].f32: radius of the lower left corner, in percentage. \\n\n .value[3].f32: radius of the lower right corner, in percentage. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: radius of the upper left corner, in percentage. \\n\n .value[1].f32: radius of the upper right corner, in percentage. \\n\n .value[2].f32: radius of the lower left corner, in percentage. \\n\n .value[3].f32: radius of the lower right corner, in percentage. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_RADIUS_PERCENT: ArkUI_NodeAttributeType = 86;
#[doc = " @brief Accessible ID, which can be obtained as required through APIs.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32Accessible ID\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_ID: ArkUI_NodeAttributeType = 87;
#[doc = " @brief Define accessible actions, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32accessible action typesand uses the {@link ArkUI_AccessibilityActionType} enumeration value.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32accessible action typesand uses the {@link ArkUI_AccessibilityActionType} enumeration value.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_ACTIONS: ArkUI_NodeAttributeType = 88;
#[doc = " @brief Define accessible role, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32accessible role typeand uses the {@link ArkUI_NodeType} enumeration value.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32accessible role typeand uses the {@link ArkUI_NodeType} enumeration value.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_ROLE: ArkUI_NodeAttributeType = 89;
#[doc = " @brief Define accessible state, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .objectthe parameter type is {@link ArkUI_AccessibilityState}.\\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .objectthe parameter type is {@link ArkUI_AccessibilityState}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_STATE: ArkUI_NodeAttributeType = 90;
#[doc = " @brief Define accessible value, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .objectthe parameter type is {@link ArkUI_AccessibilityValue}.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .objectthe parameter type is {@link ArkUI_AccessibilityValue}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_VALUE: ArkUI_NodeAttributeType = 91;
#[doc = " @brief defines control components to extend their security zones,\n supporting property setting, property reset, and property fetching.\n\n Attribute setting method {@link ArkUI_AttributeItem} Parameter format: \\n\n .value[0]? .u32: Set of extended security zone enumerated values {@link ArkUI_SafeAreaType},\n For example, ARKUI_SAFE_AREA_TYPE_SYSTEM | ARKUI_SAFE_AREA_TYPE_CUTOUT; \\n\n .value[1]? .u32: set of directional enum values for extended security zones {@link ArkUI_SafeAreaEdge}; \\n\n For example: ARKUI_SAFE_AREA_EDGE_TOP | ARKUI_SAFE_AREA_EDGE_BOTTOM; \\n\n \\n\n Attribute fetch method return value {@link ArkUI_AttributeItem} format: \\n\n.value[0].u32: extends the security zone. \\n. \\n\n.value[1].u32: indicates the direction to extend the security zone. \\n. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_EXPAND_SAFE_AREA: ArkUI_NodeAttributeType = 92;
#[doc = " @brief Defines the visible area ratio (visible area/total area of the component) threshold for invoking the\n visible area change event of the component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[...].f32: threshold array. The value range is 0 to 1.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[...].f32: threshold array. \\n\n\n @since 12\n/\n/**\n @brief Defines the visible area ratio (visible area/total area of the component) threshold for invoking the\n visible area change event of the component, this enum extends the configuration capbility.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[...].f32: threshold array. The value range is 0 to 1.\n .?object: pass in one {@link ArkUI_VisibleAreaEventOptions} objcet for configging the ratio or other options.\n Please note, when use this param, the ratios set through .value[...].f32 will be ignored, and the update\n interval from it is always ignored too.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[...].f32: threshold array. \\n\n .object: the {@link ArkUI_VisibleAreaEventOptions} objcet.\n\n @since 22"]
pub const ArkUI_NodeAttributeType_NODE_VISIBLE_AREA_CHANGE_RATIO: ArkUI_NodeAttributeType = 93;
#[doc = " @brief Sets the transition effect when the component is inserted or deleted.\n This attribute can be set, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: transition effect. The parameter type is {@link ArkUI_TransitionEffect}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: transition effect. The parameter type is {@link ArkUI_TransitionEffect}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSITION: ArkUI_NodeAttributeType = 94;
#[doc = " @brief Defines the component ID.\n This attribute can be obtained through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for obtaining the attribute:\\n\n .value[0].i32: component ID. \\n\n\n @deprecated since 20\n @useinstead OH_ArkUI_NodeUtils_GetNodeUniqueId"]
pub const ArkUI_NodeAttributeType_NODE_UNIQUE_ID: ArkUI_NodeAttributeType = 95;
#[doc = " @brief Set the current component system focus box style.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].f32: The distance between the focus box and the edge of the component. \\n\n Positive numbers represent the outer side, negative numbers represent the inner side. \\n\n Percentage is not supported. \\n\n .value[1].f32: Focus box width. Negative numbers and percentages are not supported. \\n\n .value[2].u32: Focus box color. \\n\n \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FOCUS_BOX: ArkUI_NodeAttributeType = 96;
#[doc = " @brief Defines the moving distance limit for the component-bound tap gesture.\n This attribute can be set as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: allowed moving distance of a finger, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CLICK_DISTANCE: ArkUI_NodeAttributeType = 97;
#[doc = " @brief Sets whether the focus can be placed on this component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the focus can be placed on the current component. The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the focus can be placed on the current component. The parameter type is 1 or 0.\n\n @since 14"]
#[cfg(feature = "api-14")]
pub const ArkUI_NodeAttributeType_NODE_TAB_STOP: ArkUI_NodeAttributeType = 98;
#[doc = " @brief Defines the backdrop blur attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32backdrop blur radius, in px. The value range is [0, +).\\n\n .value[1]?.f32grayscale blur settings that control the brightness of the black color.\\n\n The value range is [0, 127].\\n\n .value[2]?.f32grayscale blur settings that control the darkness of the white color.\\n\n The value range is [0, 127].\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32backdrop blur radius, in px. The value range is [0, +).\\n\n .value[1].f32grayscale blur settings that control the brightness of the black color.\\n\n The value range is [0, 127].\\n\n .value[2].f32grayscale blur settings that control the darkness of the white color.\\n\n The value range is [0, 127].\\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_BACKDROP_BLUR: ArkUI_NodeAttributeType = 99;
#[doc = " @brief Defines the background image resizable attribute, which can be set, reset,\n and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width of the left edge. The unit is vp. \\n\n .value[1].f32: width of the top edge. The unit is vp. \\n\n .value[2].f32: width of the right edge. The unit is vp. \\n\n .value[3].f32: width of the bottom edge. The unit is vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the left edge. The unit is vp. \\n\n .value[1].f32: width of the top edge. The unit is vp. \\n\n .value[2].f32: width of the right edge. The unit is vp. \\n\n .value[3].f32: width of the bottom edge. The unit is vp. \\n\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_IMAGE_RESIZABLE_WITH_SLICE:
    ArkUI_NodeAttributeType = 100;
#[doc = " @brief Sets the next focus node.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: focus movement direction, as defined in {@link ArkUI_FocusMove}.\n .object: next focus node. The parameter type is {@link ArkUI_NodeHandle}.\\n\n \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_NEXT_FOCUS: ArkUI_NodeAttributeType = 101;
#[doc = " @brief Sets the parameters for visible area change events.\n\n @note The visible area change callback is not a real-time callback. The actual callback interval may differ from\n the expected interval due to system load and other factors.\n The interval between two visible area change callbacks will not be less than the expected update interval. If the\n provided expected interval is too short, the actual callback interval will be determined by the system load.\n By default, the interval threshold of the visible area change callback includes 0. This means that,\n if the provided threshold is [0.5], the effective threshold will be [0.0, 0.5].\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: parameters for visible area change events.\n The parameter type is {@link ArkUI_VisibleAreaEventOptions}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: parameters for visible area change events.\n The parameter type is {@link ArkUI_VisibleAreaEventOptions}. \\n\n\n @since 17"]
#[cfg(feature = "api-17")]
pub const ArkUI_NodeAttributeType_NODE_VISIBLE_AREA_APPROXIMATE_CHANGE_RATIO:
    ArkUI_NodeAttributeType = 102;
#[doc = " @brief Defines the translate attribute, which supports for percentile translation input, and can be set, reset,\n and obtained as required through APIs.\\n\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: distance to translate along the x-axis. The default unit is percentage.\n The unit is vp only if value[3] exists and value[3] is 0. The default value of value[0] is <b>0</b>.\\n\n .value[1].f32: distance to translate along the y-axis. The default unit is percentage.\n The unit is vp only if value[4] exists and value[4] is 0. The default value of value[1] is <b>0</b>.\\n\n .value[2].f32: distance to translate along the z-axis, in vp. The default value is <b>0</b>.\\n\n .value[3]?.i32: Whether the translation distance along the x-axis is specified as a percentage.\n  The value can be 0 or 1. When the value is 1, it is specified as a percentage.\n  For example, value[0].f32=0.1 and value[3].i32=1 indicates a 10% shift in the x direction.\n  The default value is <b>1</b>.\\n\n .value[4]?.i32: Whether the translation distance along the y-axis is specified as a percentage.\n  The value can be 0 or 1. When the value is 1, it is specified as a percentage.\n  For example, value[1].f32=0.1 and value[4].i32=1 indicates a 10% shift in the y direction.\n  The default value is <b>1</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: distance to translate along the x-axis. The unit depends on value[3].\\n\n .value[1].f32: distance to translate along the y-axis. The unit depends on value[4].\\n\n .value[2].f32: distance to translate along the z-axis. The unit is vp.\\n\n .value[3].i32: Whether the unit of the X-axis translation distance is in percentage. When value[3].i32 is 0,\n  the unit of the X-axis translation distance is vp; when value[3].i32 is 1, the unit of the X-axis translation\n  distance is percentage;\\n\n .value[4].i32: Whether the unit of the Y-axis translation distance is in percentage. When value[4].i32 is 0,\n  the unit of the Y-axis translation distance is vp; when value[4].i32 is 1, the unit of the Y-axis translation\n  distance is percentage;\\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TRANSLATE_WITH_PERCENT: ArkUI_NodeAttributeType = 103;
#[doc = " @brief Sets component rotation with multi-axis angle control. This attribute can be set, reset,\n and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: x-axis rotation angle. The default value is <b>0</b>. \\n\n .value[1].f32: y-axis rotation angle. The default value is <b>0</b>. \\n\n .value[2].f32: z-axis rotation angle. The default value is <b>0</b>. \\n\n .value[3].f32: perspective distance from the viewpoint to the z=0 plane, in px. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: x-axis rotation angle. The default value is <b>0</b>.\n .value[1].f32: y-axis rotation angle. The default value is <b>0</b>. \\n\n .value[2].f32: z-axis rotation angle. The default value is <b>0</b>. \\n\n .value[3].f32: perspective distance from the viewpoint to the z=0 plane, in px. The default value is <b>0</b>. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_ROTATE_ANGLE: ArkUI_NodeAttributeType = 104;
#[doc = " @brief Defines the width attribute with param type LayoutPolicy, which can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: the LayoutPolicy that the width of the component follows.\\n\n The parameter type is {@link ArkUI_LayoutPolicy}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: the LayoutPolicy that the width of the component follows.\\n\n The parameter type is {@link ArkUI_LayoutPolicy}. \\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_WIDTH_LAYOUTPOLICY: ArkUI_NodeAttributeType = 105;
#[doc = " @brief Defines the height attribute with param type LayoutPolicy, which can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: the LayoutPolicy that the height of the component follows.\\n\n The parameter type is {@link ArkUI_LayoutPolicy}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: the LayoutPolicy that the height of the component follows.\\n\n The parameter type is {@link ArkUI_LayoutPolicy}. \\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_HEIGHT_LAYOUTPOLICY: ArkUI_NodeAttributeType = 106;
#[doc = " @brief Defines the position attribute in param type Edges, which specifies the position of the component\n by the distance relative to the parent container's four edges. This attribute can be set, reset, and obtained as\n required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object indicates struct of edges for position. The parameter type is {@link ArkUI_PositionEdges}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object indicates struct of edges for position. The parameter type is {@link ArkUI_PositionEdges}. \\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_POSITION_EDGES: ArkUI_NodeAttributeType = 107;
#[doc = " @brief Set whether the component enables the ability to invert colors.\n This attribute can be set , and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_ALLOW_FORCE_DARK: ArkUI_NodeAttributeType = 108;
#[doc = " @brief Defines the pixelRound attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object indicates struct of policy for pixelRound. The parameter type is {@link ArkUI_PixelRoundPolicy}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object indicates struct of policy for pixelRound. The parameter type is {@link ArkUI_PixelRoundPolicy}. \\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_PIXEL_ROUND: ArkUI_NodeAttributeType = 109;
#[doc = " @brief Defines the text content attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: text content.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: text content.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_CONTENT: ArkUI_NodeAttributeType = 1000;
#[doc = " @brief Defines the font color attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: font color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: font color value, in 0xARGB format.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_COLOR: ArkUI_NodeAttributeType = 1001;
#[doc = " @brief Defines the font size attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: font size, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: font size, in fp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_SIZE: ArkUI_NodeAttributeType = 1002;
#[doc = " @brief Defines the font style attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: font style {@link ArkUI_FontStyle}. The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: font style {@link ArkUI_FontStyle}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_STYLE: ArkUI_NodeAttributeType = 1003;
#[doc = " @brief Defines the font weight attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: font weight {@link ArkUI_FontWeight}. The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: font weight {@link ArkUI_FontWeight}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_WEIGHT: ArkUI_NodeAttributeType = 1004;
#[doc = " @brief Defines the text line height attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: line height, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: line height, in fp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LINE_HEIGHT: ArkUI_NodeAttributeType = 1005;
#[doc = " @brief Defines the text decoration style and color.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text decoration type {@link ArkUI_TextDecorationType}.\n The default value is <b>ARKUI_TEXT_DECORATION_TYPE_NONE</b>.\\n\n .value[1]?.u32: text decoration color, in 0xARGB format. For example, 0xFFFF0000 indicates red. Optional.\\n\n .value[2]?.i32: text decoration style {@link ArkUI_TextDecorationStyle}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text decoration type {@link ArkUI_TextDecorationType}.\\n\n .value[1].u32: text decoration color, in 0xARGB format. \\n\n .value[2].i32: text decoration style {@link ArkUI_TextDecorationStyle}. \\n\n\n/\n/**\n @brief Defines the text decoration style and color.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text decoration type {@link ArkUI_TextDecorationType}.\n The default value is <b>ARKUI_TEXT_DECORATION_TYPE_NONE</b>.\\n\n .value[1]?.u32: text decoration color, in 0xARGB format. For example, 0xFFFF0000 indicates red. Optional.\\n\n .value[2]?.i32: text decoration style {@link ArkUI_TextDecorationStyle}. \\n\n .value[3]?.f32: text decoration thickness scale. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text decoration type {@link ArkUI_TextDecorationType}.\\n\n .value[1].u32: text decoration color, in 0xARGB format. \\n\n .value[2].i32: text decoration style {@link ArkUI_TextDecorationStyle}. \\n\n .value[3].f32: text decoration thickness scale. \\n\n\n  since 22"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_DECORATION: ArkUI_NodeAttributeType = 1006;
#[doc = " @brief Defines the text case attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text case.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text case.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_CASE: ArkUI_NodeAttributeType = 1007;
#[doc = " @brief Defines the letter spacing attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: letter spacing, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: letter spacing, in fp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LETTER_SPACING: ArkUI_NodeAttributeType = 1008;
#[doc = " @brief Sets the maximum number of lines in the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: maximum number of lines in the text.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: maximum number of lines in the text.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_MAX_LINES: ArkUI_NodeAttributeType = 1009;
#[doc = " @brief Horizontal alignment mode of the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: horizontal alignment mode of the text. The value is an enum of {@link ArkUI_TextAlignment}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: horizontal alignment mode of the text. The value is an enum of {@link ArkUI_TextAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_ALIGN: ArkUI_NodeAttributeType = 1010;
#[doc = " @brief Defines the text overflow attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: display mode when the text is too long. {@ArkUI_TextOverflow}\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: display mode when the text is too long. {@ArkUI_TextOverflow}\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_OVERFLOW: ArkUI_NodeAttributeType = 1011;
#[doc = " @brief Defines the font family attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: fonts, separated by commas (,).\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: fonts, separated by commas (,).\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_FAMILY: ArkUI_NodeAttributeType = 1012;
#[doc = " @brief Defines the copy option attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: copy option {@link ArkUI_CopyOptions}. The default value is <b>ARKUI_COPY_OPTIONS_NONE</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: copy option {@link ArkUI_CopyOptions. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_COPY_OPTION: ArkUI_NodeAttributeType = 1013;
#[doc = " @brief Defines the text baseline offset attribute\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: baseline offset, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: baseline offset, in fp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_BASELINE_OFFSET: ArkUI_NodeAttributeType = 1014;
#[doc = " @brief Defines the text shadow attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: blur radius of the shadow, in vp.\\n\n .value[1].i32: shadow type {@link ArkUI_ShadowType}. The default value is <b>ARKUI_SHADOW_TYPE_COLOR</b>.\\n\n .value[2].u32: shadow color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n .value[3].f32: offset of the shadow along the x-axis, in vp.\\n\n .value[4].f32: offset of the shadow along the y-axis, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: blur radius of the shadow, in vp.\\n\n .value[1].i32: shadow type {@link ArkUI_ShadowType}.\\n\n .value[2].u32: shadow color, in 0xARGB format.\\n\n .value[3].f32: offset of the shadow along the x-axis, in vp.\\n\n .value[4].f32: offset of the shadow along the y-axis, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_TEXT_SHADOW: ArkUI_NodeAttributeType = 1015;
#[doc = " @brief Defines the minimum font size attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum font size, in fp.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum font size, in fp.\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_MIN_FONT_SIZE: ArkUI_NodeAttributeType = 1016;
#[doc = " @brief Defines the maximum font size attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: maximum font size, in fp.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: maximum font size, in fp.\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_MAX_FONT_SIZE: ArkUI_NodeAttributeType = 1017;
#[doc = " @brief Defines the text style attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string?: font family. Optional. Use commas (,) to separate multiple fonts. \\n\n .value[0].f32: font size, in fp. \\n\n .value[1]?.i32: font weight. Optional. The parameter type is {@link ArkUI_FontWeight}.\n The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>. \\n\n .value[2]?.i32: font style. Optional. The parameter type is {@link ArkUI_FontStyle}.\n The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: font family. Use commas (,) to separate multiple fonts. \\n\n .value[0].f32: font size, in fp. \\n\n .value[1].i32: font weight. The parameter type is {@link ArkUI_FontWeight}.\n The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>. \\n\n .value[2].i32: font style. The parameter type is {@link ArkUI_FontStyle}.\n The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_FONT: ArkUI_NodeAttributeType = 1018;
#[doc = " @brief Defines how the adaptive height is determined for the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: how the adaptive height is determined for the text.\n The parameter type is {@link ArkUI_TextHeightAdaptivePolicy}.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: how the adaptive height is determined for the text.\n The parameter type is {@link ArkUI_TextHeightAdaptivePolicy}\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_HEIGHT_ADAPTIVE_POLICY: ArkUI_NodeAttributeType = 1019;
#[doc = " @brief Defines the indentation of the first line.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: indentation of the first line. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: indentation of the first line. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INDENT: ArkUI_NodeAttributeType = 1020;
#[doc = " @brief Defines the line break rule. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_WordBreak}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_WordBreak}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_WORD_BREAK: ArkUI_NodeAttributeType = 1021;
#[doc = " @brief Defines the ellipsis position. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_EllipsisMode}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_EllipsisMode}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_ELLIPSIS_MODE: ArkUI_NodeAttributeType = 1022;
#[doc = " @brief Defines the text line spacing attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: line spacing, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: line spacing, in fp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LINE_SPACING: ArkUI_NodeAttributeType = 1023;
#[doc = " @brief  Set the text feature effect and the NODE_FONT_FEATURE attribute,\n NODE_FONT_FEATURE is the advanced typesetting capability of OpenType\n Features such as ligatures and equal-width digits are generally used in customized fonts. \\n\n The capabilities need to be supported by the fonts, \\n\n Interfaces for setting, resetting, and obtaining attributes are supported. \\n\n Attribute setting method parameter {@Link ArkUI_AttributeItem} format: \\n\n .string: complies with the text feature format. The format is normal | \\n\n is in the format of [ | on | off],\\n.\n There can be multiple values separated by commas (,). \\n\n For example, the input format of a number with the same width is ss01 on. \\n\n \\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .string indicates the content of the text feature. Multiple text features are separated by commas (,). \\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_FEATURE: ArkUI_NodeAttributeType = 1024;
#[doc = " @brief Setting Enable Text Recognition.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32:Enable text recognition, default value false.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32Enable Text Recognition\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_ENABLE_DATA_DETECTOR: ArkUI_NodeAttributeType = 1025;
#[doc = " @brief Set the text recognition configuration.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0...].i32: Array of entity types, parameter types{@link ArkUI_TextDataDetectorType}\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0...].i32Array of entity types, parameter types{@link ArkUI_TextDataDetectorType}\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_ENABLE_DATA_DETECTOR_CONFIG: ArkUI_NodeAttributeType =
    1026;
#[doc = " @brief Defines the background color of the selected text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_SELECTED_BACKGROUND_COLOR: ArkUI_NodeAttributeType =
    1027;
#[doc = " @brief The text component uses a formatted string object to set text content properties,\n and supports property setting, property reset, and property acquisition interfaces.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object indicates ArkUI_StyledString formatted string data. The parameter type is {@link ArkUI_StyledString}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object indicates ArkUI_StyledString formatted string data. The parameter type is {@link ArkUI_StyledString}. \\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_CONTENT_WITH_STYLED_STRING: ArkUI_NodeAttributeType =
    1028;
#[doc = " @brief Sets whether to center text vertically in the text component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to center text vertically. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to center text vertically. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_HALF_LEADING: ArkUI_NodeAttributeType = 1029;
#[doc = " @brief Defines the font weight attribute, which can be set, reset, and obtained as required through APIs.\n The font weight specified by this API is not affected by any changes in the system font weight settings.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: font weight {@link ArkUI_FontWeight}. The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: font weight {@link ArkUI_FontWeight}.\\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_IMMUTABLE_FONT_WEIGHT: ArkUI_NodeAttributeType = 1030;
#[doc = " @brief Sets whether to optimize the trailing spaces at the end of each line during text layout.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n value[0].i32: whether to optimize trailing spaces at the end of each line during text layout.\n               The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: whether to optimize trailing spaces at the end of each line during text layout. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_OPTIMIZE_TRAILING_SPACE: ArkUI_NodeAttributeType = 1032;
#[doc = " @brief Defines the text line count attribute, which can only be obtained as required through APIs.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: line count of the node.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LINE_COUNT: ArkUI_NodeAttributeType = 1031;
#[doc = " @brief Sets a linear gradient effect for text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: start angle of the linear gradient.\n The setting takes effect only when <b>direction</b> is set to <b>ARKUI_LINEAR_GRADIENT_DIRECTION_CUSTOM</b>.\n A positive value indicates a clockwise rotation from the origin, (0, 0). The default value is <b>180</b>. \\n\n .value[1].i32: direction of the linear gradient. When a direction other than\n <b>ARKUI_LINEAR_GRADIENT_DIRECTION_CUSTOM</b> is set, the <b>angle</b> property is ignored.\n The parameter type is {@link ArkUI_LinearGradientDirection}. \\n\n .value[2].i32: whether the colors are repeated. The default value is <b>false</b>.\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: start angle of the linear gradient.\n When <b>direction</b> is set to <b>ARKUI_LINEAR_GRADIENT_DIRECTION_CUSTOM</b>, <b>angle</b> at the set value;\n otherwise, it is at default value. \\n\n .value[1].i32: direction of the linear gradient. \\n\n .value[2].i32: whether the colors are repeated. \\n\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LINEAR_GRADIENT: ArkUI_NodeAttributeType = 1033;
#[doc = " @brief Sets a radial gradient effect for text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: X-coordinate of the radial gradient center relative to the upper left corner of the text. \\n\n .value[1]?.f32: Y-coordinate of the radial gradient center relative to the upper left corner of the text. \\n\n .value[2]?.f32: radius of the radial gradient. The default value is <b>0</b>. \\n\n .value[3]?.i32: whether the colors are repeated.\n The value <b>1</b> means that the colors are repeated, and <b>0</b> means the opposite.\\n \\n\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X-coordinate of the radial gradient center relative to the upper left corner of the text. \\n\n .value[1].f32: Y-coordinate of the radial gradient center relative to the upper left corner of the text. \\n\n .value[2].f32: radius of the radial gradient. The default value is <b>0</b>. \\n\n .value[3].i32: whether the colors are repeated.\n The value <b>1</b> means that the colors are repeated, and <b>0</b> means the opposite.  \\n\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_RADIAL_GRADIENT: ArkUI_NodeAttributeType = 1034;
#[doc = " @brief Sets the vertical alignment of the text content.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: vertical alignment of the text content, specified using the {@link ArkUI_TextVerticalAlignment}\n enum. The default value is <b>ARKUI_TEXT_VERTICAL_ALIGNMENT_BASELINE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: vertical alignment of the text content, specified using the {@link ArkUI_TextVerticalAlignment}\n enum. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_VERTICAL_ALIGN: ArkUI_NodeAttributeType = 1035;
#[doc = " @brief Sets the content align of the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: content align of the text, specified using the {@link ArkUI_TextContentAlign}\n enum. The default value is <b>ARKUI_TEXT_CONTENT_ALIGN_CENTER</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: content align of the text, specified using the {@link ArkUI_TextContentAlign}\n enum. \\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_CONTENT_ALIGN: ArkUI_NodeAttributeType = 1036;
#[doc = " @brief Sets the minimum number of lines in the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: minimum number of lines in the text.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: minimum number of lines in the text.\\n\n\n @since 22\n"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_MIN_LINES: ArkUI_NodeAttributeType = 1037;
#[doc = " @brief Enables the selected data detector.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: Enable selected text recognition, default value true.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: Whether selected text recognition is enabled.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_ENABLE_SELECTED_DATA_DETECTOR: ArkUI_NodeAttributeType =
    1038;
#[doc = " @brief Defines the minimum text line height attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum line height.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum line height.\\n\n\n @since 22\n"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_MIN_LINE_HEIGHT: ArkUI_NodeAttributeType = 1040;
#[doc = " @brief Defines the maximum text line height attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: maximum line height.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: maximum line height.\\n\n\n @since 22\n"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_MAX_LINE_HEIGHT: ArkUI_NodeAttributeType = 1041;
#[doc = " @brief Defines line height multiple value of text, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: line height multiple value of text.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: line height multiple value of text.\\n\n\n @since 22\n"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LINE_HEIGHT_MULTIPLE: ArkUI_NodeAttributeType = 1042;
#[doc = " @brief Get the text layout manager of the text.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: the layout manager of text. The parameter type is {@link ArkUI_TextLayoutManager}.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LAYOUT_MANAGER: ArkUI_NodeAttributeType = 1043;
#[doc = " @brief Set the edit menu options of the text.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: the edit menu options of text. The parameter type is {@link ArkUI_TextEditMenuOptions}.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_EDIT_MENU_OPTIONS: ArkUI_NodeAttributeType = 1044;
#[doc = " @brief Bind the selection menu for text.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: the custom selection menu of text.\n     The parameter type is {@link ArkUI_SelectionMenuOptions}.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_BIND_SELECTION_MENU: ArkUI_NodeAttributeType = 1045;
#[doc = " @brief Defines the text content attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: content of the text span. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: content of the text span. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SPAN_CONTENT: ArkUI_NodeAttributeType = 2000;
#[doc = " @brief Defines the text background style.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the text background, in 0xARGB format, for example, <b>0xFFFF0000</b> indicating red. \\n\n The second parameter indicates the rounded corners of the text background. Two setting modes are available: \\n\n 1: .value[1].f32: radius of the four corners, in vp. \\n\n 2: .value[1].f32: radius of the upper left corner, in vp. \\n\n .value[2].f32: radius of the upper right corner, in vp. \\n\n .value[3].f32: radius of the lower left corner, in vp. \\n\n .value[4].f32: radius of the lower right corner, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the text background, in 0xARGB format. \\n\n .value[1].f32: radius of the upper left corner, in vp. \\n\n .value[2].f32: radius of the upper right corner, in vp. \\n\n .value[3].f32: radius of the lower left corner, in vp. \\n\n .value[4].f32: radius of the lower right corner, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SPAN_TEXT_BACKGROUND_STYLE: ArkUI_NodeAttributeType = 2001;
#[doc = " @brief Defines the text baseline offset attribute\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: baseline offset, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: baseline offset, in fp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SPAN_BASELINE_OFFSET: ArkUI_NodeAttributeType = 2002;
#[doc = " @brief Defines the image source of the image span.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: image address of the image span.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: image address of the image span.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_SRC: ArkUI_NodeAttributeType = 3000;
#[doc = " @brief Defines the alignment mode of the image with the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode of the image with the text.\n The value is an enum of {@link ArkUI_ImageSpanAlignment}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode of the image with the text.\n The value is an enum of {@link ArkUI_ImageSpanAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_VERTICAL_ALIGNMENT: ArkUI_NodeAttributeType =
    3001;
#[doc = " @brief Defines the placeholder image source.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_ALT: ArkUI_NodeAttributeType = 3002;
#[doc = " @brief Defines the baseline offset attribute of the <b>ImageSpan</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n A positive value means an upward offset, while a negative value means a downward offset.\n The default value is <b>0</b>, and the unit is fp. \\n\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: baseline offset, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: baseline offset, in fp. \\n\n\n @since 13"]
#[cfg(feature = "api-13")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_BASELINE_OFFSET: ArkUI_NodeAttributeType = 3003;
#[doc = " @brief Defines the color filter of the image span.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem } parameter for setting the attribute:\\n\n .value [0].f32 to . value [19].f32: filter matrix array. \\n\n .size :5 x 4 filter array size. \\n\n .object : the pointer to OH_Drawing_ColorFilter. Either . value or . object is set. \\n\n \\n\n Format of the return value {@ link ArkUI_AttributeItem ):\\n\n .value [0].f32 to .value [19].f32: filter matrix array. \\n\n .size: 5 x 4 filter array size. \\n\n .object: the pointer to OH_Drawing_ColorFilter. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_COLOR_FILTER: ArkUI_NodeAttributeType = 3004;
#[doc = " @brief Set the range of SVG parsing capabilities supported through enable switch.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether color fliter support svg. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: enable switch.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_SUPPORT_SVG2: ArkUI_NodeAttributeType = 3005;
#[doc = " @brief Defines the image source of the <Image> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: image source.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: image source.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SRC: ArkUI_NodeAttributeType = 4000;
#[doc = " @brief Defines how the image is resized to fit its container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: how the image is resized to fit its container. The value is an enum of {@link ArkUI_ObjectFit}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: how the image is resized to fit its container. The value is an enum of {@link ArkUI_ObjectFit}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_OBJECT_FIT: ArkUI_NodeAttributeType = 4001;
#[doc = " @brief Defines the interpolation effect of the image.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: interpolation effect of the image. The value is an enum of {@link ArkUI_ImageInterpolation}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: interpolation effect of the image. The value is an enum of {@link ArkUI_ImageInterpolation}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_INTERPOLATION: ArkUI_NodeAttributeType = 4002;
#[doc = " @brief Defines how the image is repeated.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: how the image is repeated. The value is an enum of {@link ArkUI_ImageRepeat}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: how the image is repeated. The value is an enum of {@link ArkUI_ImageRepeat}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_OBJECT_REPEAT: ArkUI_NodeAttributeType = 4003;
#[doc = " @brief Defines the color filter of the image.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32 to .value[19].f32: filter matrix array. \\n\n .size: 5 x 4 filter array size. \\n\n .object: the pointer to OH_Drawing_ColorFilter. Either .value or .object is set. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32 to .value[19].f32: filter matrix array. \\n\n .size: 5 x 4 filter array size. \\n\n .object: the pointer to OH_Drawing_ColorFilter. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_COLOR_FILTER: ArkUI_NodeAttributeType = 4004;
#[doc = " @brief Defines the auto resize attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32 : whether to resize the image source. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32 : whether to resize the image source. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_AUTO_RESIZE: ArkUI_NodeAttributeType = 4005;
#[doc = " @brief Defines the placeholder image source.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ALT: ArkUI_NodeAttributeType = 4006;
#[doc = " @brief Defines whether the image is draggable.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the image is draggable. The value <b>true</b> means that the image is draggable. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the image is draggable. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_DRAGGABLE: ArkUI_NodeAttributeType = 4007;
#[doc = " @brief Defines the image rendering mode. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_ImageRenderMode}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_ImageRenderMode}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_RENDER_MODE: ArkUI_NodeAttributeType = 4008;
#[doc = " @brief Defines whether the image display size follows the image source size.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: wheter to follow, true means to follow.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: wheter to follow, true means to follow.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_FIT_ORIGINAL_SIZE: ArkUI_NodeAttributeType = 4009;
#[doc = " @brief Defines the fill color of the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: fill color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: fill color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_FILL_COLOR: ArkUI_NodeAttributeType = 4010;
#[doc = " @brief Sets the resizable image options.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width of the left edge. The unit is vp. \\n\n .value[1].f32: width of the top edge. The unit is vp. \\n\n .value[2].f32: width of the right edge. The unit is vp. \\n\n .value[3].f32: width of the bottom edge. The unit is vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the left edge. The unit is vp. \\n\n .value[1].f32: width of the top edge. The unit is vp. \\n\n .value[2].f32: width of the right edge. The unit is vp. \\n\n .value[3].f32: width of the bottom edge. The unit is vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_RESIZABLE: ArkUI_NodeAttributeType = 4011;
#[doc = " @brief Defines the synchronous image loading attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to load the image synchronously. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to load the image synchronously. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SYNC_LOAD: ArkUI_NodeAttributeType = 4012;
#[doc = " @brief Defines the image decoding size attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: width of the image decoding, in px.\\n\n .value[1].i32: height of the image decoding, in px.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: width of the image decoding, in px.\\n\n .value[1].i32: height of the image decoding, in px.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SOURCE_SIZE: ArkUI_NodeAttributeType = 4013;
#[doc = " @brief Defines the display tranformation matrix for an image.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0...15].f32: 16 floating-point numbers.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0...15].f32: 16 floating-point numbers.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_IMAGE_MATRIX: ArkUI_NodeAttributeType = 4014;
#[doc = " @brief Defines the image follow text direction attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to follows the text direction.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to follows the text direction.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_MATCH_TEXT_DIRECTION: ArkUI_NodeAttributeType = 4015;
#[doc = " @brief Defines the image copy attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: copy option {@link ArkUI_CopyOptions}. The default value is <b>ARKUI_COPY_OPTIONS_NONE</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: copy option {@link ArkUI_CopyOptions.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_COPY_OPTION: ArkUI_NodeAttributeType = 4016;
#[doc = " @brief Defines the image AI analysis enable attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable AI analysis for the image.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable AI analysis for the image.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ENABLE_ANALYZER: ArkUI_NodeAttributeType = 4017;
#[doc = " @brief Defines the image dynamic display range attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: dynamic range mode {@link ArkUI_DynamicRangeMode}.\n The default value is <b>ARKUI_DYNAMIC_RANGE_MODE_STANDARD</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: dynamic range mode {@link ArkUI_DynamicRangeMode.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_DYNAMIC_RANGE_MODE: ArkUI_NodeAttributeType = 4018;
#[doc = " @brief Defines the image dynamic display brightness attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: hdr brightness. value range [0, 1]\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: hdr brightness. value range [0, 1]\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_HDR_BRIGHTNESS: ArkUI_NodeAttributeType = 4019;
#[doc = " @brief Defines the image display direction attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: orientation {@link ArkUI_Orientation}.\n The default value is <b>ARKUI_ORIENTATION_UP</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: orientation {@link ArkUI_Orientation.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ORIENTATION: ArkUI_NodeAttributeType = 4020;
#[doc = " @brief Set the range of SVG parsing capabilities supported through enable switch.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: enable switch.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: enable switch.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SUPPORT_SVG2: ArkUI_NodeAttributeType = 4021;
#[doc = " @brief Set the animation effect for the image content transformation.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: The parameter type is {@link ArkUI_ContentTransitionEffect}.\\n\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: The parameter type is {@link ArkUI_ContentTransitionEffect}.\\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_CONTENT_TRANSITION: ArkUI_NodeAttributeType = 4022;
#[doc = " @brief Defines the placeholder image during loading process.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ALT_PLACEHOLDER: ArkUI_NodeAttributeType = 4023;
#[doc = " @brief Defines the placeholder image when loading fails.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ALT_ERROR: ArkUI_NodeAttributeType = 4024;
#[doc = " @brief Defines the color of the component when it is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: background color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TOGGLE_SELECTED_COLOR: ArkUI_NodeAttributeType = 5000;
#[doc = " @brief Defines the color of the circular slider for the component of the switch type.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the circular slider, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the circular slider, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TOGGLE_SWITCH_POINT_COLOR: ArkUI_NodeAttributeType = 5001;
#[doc = " @brief Defines the toggle switch value. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the toggle. The value <b>true</b> means to enable the toggle. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable the toggle. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TOGGLE_VALUE: ArkUI_NodeAttributeType = 5002;
#[doc = " @brief Defines the color of the component when it is deselected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n.value[0].u32: background color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TOGGLE_UNSELECTED_COLOR: ArkUI_NodeAttributeType = 5003;
#[doc = " @brief Defines the foreground color of the loading progress bar.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: foreground color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: foreground color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LOADING_PROGRESS_COLOR: ArkUI_NodeAttributeType = 6000;
#[doc = " @brief Defines whether to show the loading animation for the <LoadingProgress> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show the loading animation.\n The value <b>true</b> means to show the loading animation, and <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to show the loading animation, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LOADING_PROGRESS_ENABLE_LOADING: ArkUI_NodeAttributeType =
    6001;
#[doc = " @brief Defines the default placeholder text of the single-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default placeholder text. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default placeholder text. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_PLACEHOLDER: ArkUI_NodeAttributeType = 7000;
#[doc = " @brief Defines the default text content of the single-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default text content. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default text content. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_TEXT: ArkUI_NodeAttributeType = 7001;
#[doc = " @brief Defines the caret color attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: caret color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: caret color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CARET_COLOR: ArkUI_NodeAttributeType = 7002;
#[doc = " @brief Defines the caret style attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: caret width, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: caret width, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CARET_STYLE: ArkUI_NodeAttributeType = 7003;
#[doc = " @brief Defines the underline attribute of the single-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show an underline.\n The value <b>true</b> means to show an underline, and <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to show an underline, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SHOW_UNDERLINE: ArkUI_NodeAttributeType = 7004;
#[doc = " @brief Defines the maximum number of characters in the text input.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: maximum number of characters in the text input, without a unit. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: maximum number of characters in the text input. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_MAX_LENGTH: ArkUI_NodeAttributeType = 7005;
#[doc = " @brief Defines the type of the Enter key.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: type of the Enter key{@link ArkUI_EnterKeyType}. The default value is <b>ARKUI_ENTER_KEY_TYPE_DONE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type of the Enter key{@link ArkUI_EnterKeyType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENTER_KEY_TYPE: ArkUI_NodeAttributeType = 7006;
#[doc = " @brief Defines the placeholder text color.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_PLACEHOLDER_COLOR: ArkUI_NodeAttributeType = 7007;
#[doc = " @brief Defines the placeholder text font.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: font size, in fp. Optional. The default value is <b>16.0</b>.\\n\n .value[1]?.i32: font style {@link ArkUI_FontStyle}. Optional.\n The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>. \\n\n .value[2]?.i32: font weight {@link ArkUI_FontWeight}. Optional.\n The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>. \\n\n ?.string: font family. Multiple font families are separated by commas (,).\n Example: \"font weight; font family 1, font family 2\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: font size, in fp.\\n\n .value[1].i32: font style {@link ArkUI_FontStyle}.\\n\n .value[2].i32: font weight {@link ArkUI_FontWeight}.\\n\n .string: font family. Multiple font families are separated by commas (,). \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_PLACEHOLDER_FONT: ArkUI_NodeAttributeType = 7008;
#[doc = " @brief Defines whether to enable the input method when the component obtains focus.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the input method when the component obtains focus.\n The value <b>true</b> means to enable the input method, and <b>false</b> means the opposite.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to enable the input method when the component obtains focus,\n and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENABLE_KEYBOARD_ON_FOCUS:
    ArkUI_NodeAttributeType = 7009;
#[doc = " @brief Defines the text box type. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text box type {@link ArkUI_TextInputType}.\n The default value is <b>ARKUI_TEXTINPUT_TYPE_NORMAL</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text box type {@link ArkUI_TextInputType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_TYPE: ArkUI_NodeAttributeType = 7010;
#[doc = " @brief Defines the background color of the selected text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SELECTED_BACKGROUND_COLOR:
    ArkUI_NodeAttributeType = 7011;
#[doc = " @brief Defines whether to display the password icon at the end of the password text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to display the password icon at the end of the password text box.\n The value <b>true</b> means to display the password icon, and <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to display the password icon at the end of the password text box,\n and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SHOW_PASSWORD_ICON: ArkUI_NodeAttributeType =
    7012;
#[doc = " @brief Defines the editable state for the single-line text box.\n This attribute can be set as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: whether to remain in the editable state. The value\n <b>true</b> means to remain in the editable state, and <b>false</b> means to exit the editable state. \\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for obtaining the attribute:\n .value[0].i32: whether to remain in the editable state. The value <b>true</b> means to remain in the editable\n state, and <b>false</b> means to exit the editable state. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_EDITING: ArkUI_NodeAttributeType = 7013;
#[doc = " @brief Defines the style of the cancel button on the right of the single-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: button style {@link ArkUI_CancelButtonStyle}.\n The default value is <b>ARKUI_CANCELBUTTON_STYLE_INPUT</b>.\\n\n .value[1]?.f32: button icon size, in vp.\\n\n .value[2]?.u32: button icon color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n ?.string: button icon image source. The value is the local address of the image, for example, /pages/icon.png. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: button style {@link ArkUI_CancelButtonStyle}.\\n\n .value[1].f32: icon size, in vp.\\n\n .value[2].u32: button icon color, in 0xARGB format.\\n\n .string: button icon image source. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CANCEL_BUTTON: ArkUI_NodeAttributeType = 7014;
#[doc = " @brief Sets the text selection area, which will be highlighted.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: start position of the text selection. \\n\n .value[1].i32: end position of the text selection. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: start position of the text selection. \\n\n .value[1].i32: end position of the text selection. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_TEXT_SELECTION: ArkUI_NodeAttributeType = 7015;
#[doc = " @brief Sets the color of the text underline when it is enabled.\n\n The default underline color configured for the theme is <b>'0x33182431'</b>.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the underline applied to the text being typed in.\n The value is in 0xARGB format. \\n\n .value[1].u32: color of the underline applied to the text in the normal state.\n The value is in 0xARGB format. \\n\n .value[2].u32: color of the underline applied to the text when an error is detected.\n The value is in 0xARGB format. \\n\n .value[3].u32: color of the underline applied to the text when it is disabled.\n The value is in 0xARGB format. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the underline applied to the text being typed in. The value is in 0xARGB format. \\n\n .value[1].u32: color of the underline applied to the text in the normal state. The value is in 0xARGB format. \\n\n .value[2].u32: color of the underline applied to the text when an error is detected.\n The value is in 0xARGB format. \\n\n .value[3].u32: color of the underline applied to the text when it is disabled. The value is in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_UNDERLINE_COLOR: ArkUI_NodeAttributeType = 7016;
#[doc = " @brief Sets whether to enable autofill.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable autofill. The default value is <b>true</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable autofill. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENABLE_AUTO_FILL: ArkUI_NodeAttributeType = 7017;
#[doc = " @brief Sets the autofill type.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: autofill type. The parameter type is {@link ArkUI_TextInputContentType}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: autofill type. The parameter type is {@link ArkUI_TextInputContentType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CONTENT_TYPE: ArkUI_NodeAttributeType = 7018;
#[doc = " @brief Defines the rules for generating passwords. When autofill is used, these rules are transparently\n transmitted to Password Vault for generating a new password.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: rules for generating passwords. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: rules for generating passwords. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_PASSWORD_RULES: ArkUI_NodeAttributeType = 7019;
#[doc = " @brief Sets whether to select all text in the initial state. The inline mode is not supported.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to select all text in the initial state. The default value is b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to select all text in the initial state. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SELECT_ALL: ArkUI_NodeAttributeType = 7020;
#[doc = " @brief Sets the regular expression for input filtering.\n Only inputs that comply with the regular expression can be displayed.\n Other inputs are filtered out. The specified regular expression can match single characters,\n but not strings.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: regular expression. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: regular expression. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_INPUT_FILTER: ArkUI_NodeAttributeType = 7021;
#[doc = " @brief Sets the text box to the default style or inline input style.\n\n For the inline input style, only <b>InputType.Normal</b> is supported.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text input style. The parameter type is {@link ArkUI_TextInputStyle}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text input style. The parameter type is {@link ArkUI_TextInputStyle}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_STYLE: ArkUI_NodeAttributeType = 7022;
#[doc = " @brief Sets or obtains the caret position.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n In the case of setting the caret position:\n .value[0].i32: character count from the beginning of a string to the caret position. \\n\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n In the case of obtaining the caret position: If this API is called when the caret position is updated in the\n current frame, it will not take effect.\n .value[0].i32: index of the caret position. \\n\n .value[1].f32: X coordinate of the caret relative to the text box. \\n\n .value[2].f32: Y coordinate of the caret relative to the text box. \\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CARET_OFFSET: ArkUI_NodeAttributeType = 7023;
#[doc = " @brief Obtains the position of the edited text area relative to the component and its size.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: horizontal coordinate. \\n\n .value[1].f32: vertical coordinate. \\n\n .value[2].f32: content width. \\n\n .value[3].f32: content height. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CONTENT_RECT: ArkUI_NodeAttributeType = 7024;
#[doc = " @brief Obtains the number of lines of the edited text.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of lines of the edited text. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CONTENT_LINE_COUNT: ArkUI_NodeAttributeType =
    7025;
#[doc = " @brief Sets whether to hide the text selection menu when the text box is long-pressed, double-click, or\n right-clicked. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to hide the text selection menu when the text box is long-pressed, double-click, or\n right-clicked. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to hide the text selection menu when the text box is long-pressed, double-click, or\n right-clicked. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SELECTION_MENU_HIDDEN: ArkUI_NodeAttributeType =
    7026;
#[doc = " @brief Sets whether the text box loses focus after the Enter key is pressed to submit information.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the text box loses focus. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the text box loses focus. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_BLUR_ON_SUBMIT: ArkUI_NodeAttributeType = 7027;
#[doc = " @brief Set up a custom keyboard.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .objectcustom keyboard,The parameter type is{@Link ArkUI_NodeHandle}\\n\n .value[0]?.i32Sets whether the custom keyboard supports the avoidance feature, default value false.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object:custom keyboard,The parameter type is{@Link ArkUI_NodeHandle}\\n\n .value[0].i32Set whether the custom keyboard supports the avoidance function.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CUSTOM_KEYBOARD: ArkUI_NodeAttributeType = 7028;
#[doc = " @brief Defines the line break rule. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_WordBreak}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_WordBreak}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_WORD_BREAK: ArkUI_NodeAttributeType = 7029;
#[doc = " @brief Sets whether the keyboard pops up when the input box gains focus.\n It supports property setting, property reset and property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format:\\n\n .value[0].i32: Whether to pop up the keyboard. \\n\n \\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .value[0].i32: Whether to pop up the keyboard. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SHOW_KEYBOARD_ON_FOCUS: ArkUI_NodeAttributeType =
    7030;
#[doc = " @brief When this property is set, the height of the textInput component is calculated using this property.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: set the value of numberOfLines.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: the value of numberOfLines.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_NUMBER_OF_LINES: ArkUI_NodeAttributeType = 7031;
#[doc = " @brief Sets the letter spacing of the <b>TextInput</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: letter spacing. The default unit is fp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: letter spacing. The default unit is fp. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_LETTER_SPACING: ArkUI_NodeAttributeType = 7032;
#[doc = " @brief Sets whether to enable preview text for the <b>TextInput</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable preview tex. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable preview tex. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENABLE_PREVIEW_TEXT: ArkUI_NodeAttributeType =
    7033;
#[doc = " @brief Sets whether to center text vertically in the textInput component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to center text vertically. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to center text vertically. \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_HALF_LEADING: ArkUI_NodeAttributeType = 7034;
#[doc = " @brief Set the keyboard style of textInput\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32keyboard stylethe parameter type is {@link ArkUI_KeyboardAppearanceType}\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}\\n\n .value[0].i32keyboard stylethe parameter type is {@link ArkUI_KeyboardAppearanceType}\\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_KEYBOARD_APPEARANCE: ArkUI_NodeAttributeType =
    7035;
#[doc = " @brief Set whether to enable the auto fill animation or not.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: Whether to enable the auto fill animation.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].i32: Get the flag of whether the auto fill animation is enabled.\\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENABLE_FILL_ANIMATION: ArkUI_NodeAttributeType =
    7036;
#[doc = " @brief Set the line height of the input node.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: line height value.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].i32: line height value\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_LINE_HEIGHT: ArkUI_NodeAttributeType = 7037;
#[doc = " @brief Enables selected data detector.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: Enable selected text recognition, default value true.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: Whether selected text recognition is enabled.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENABLE_SELECTED_DATA_DETECTOR:
    ArkUI_NodeAttributeType = 7038;
#[doc = " @brief Defines the counter settings. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show a character counter. The value <b>true</b> means to show a character counter. \\n\n .value[1]?.f32: threshold percentage for displaying the character counter. The character counter is displayed\n when the number of characters that have been entered is greater than the maximum number of characters multiplied\n by the threshold percentage value. The value range is 1 to 100. If the value is a decimal, it is rounded down. \\n\n .value[2]?.i32: whether to highlight the border when the number of entered characters reaches the maximum. \\n\n .object: counter configuration. The parameter type is {@link ArkUI_ShowCounterConfig}.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to show a character counter. \\n\n .value[1].f32: threshold percentage for displaying the character counter. The character counter is displayed\n when the number of characters that have been entered is greater than the maximum number of characters multiplied\n by the threshold percentage value. The value range is 1 to 100. \\n\n .value[2].i32: whether to highlight the border when the number of entered characters reaches the maximum.\n The default value is <b>true</b>. \\n\n .object: counter configuration. The parameter type is {@link ArkUI_ShowCounterConfig}.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SHOW_COUNTER: ArkUI_NodeAttributeType = 7040;
#[doc = " @brief Defines the default placeholder text for the multi-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default placeholder text. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default placeholder text. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_PLACEHOLDER: ArkUI_NodeAttributeType = 8000;
#[doc = " @brief Defines the default text content for the multi-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default text content. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default text content. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_TEXT: ArkUI_NodeAttributeType = 8001;
#[doc = " @brief Defines the maximum number of characters in the text input.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: maximum number of characters in the text input. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: maximum number of characters in the text input. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_MAX_LENGTH: ArkUI_NodeAttributeType = 8002;
#[doc = " @brief Defines the placeholder text color.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_PLACEHOLDER_COLOR: ArkUI_NodeAttributeType = 8003;
#[doc = " @brief Defines the placeholder text font.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: font size, in fp. Optional. The default value is <b>16.0</b>.\\n\n .value[1]?.i32: font style {@link ArkUI_FontStyle}. Optional. The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>.\\n\n .value[2]?.i32: font weight {@link ArkUI_FontWeight}. Optional. The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>.\\n\n ?.string: font family. Multiple font families are separated by commas (,). For example, \"font weight; font family 1, font family 2\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: font size, in fp.\\n\n .value[1].i32: font style {@link ArkUI_FontStyle}.\\n\n .value[2].i32: font weight {@link ArkUI_FontWeight}.\\n\n .string: font family. Multiple font families are separated by commas (,). \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_PLACEHOLDER_FONT: ArkUI_NodeAttributeType = 8004;
#[doc = " @brief Defines the caret color attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: background color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CARET_COLOR: ArkUI_NodeAttributeType = 8005;
#[doc = " @brief Defines the editable state for the multi-line text box.\n This attribute can be set as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to remain in the editable state. The value <b>true</b> means to remain in the\n editable state, and <b>false</b> means to exit the editable state.\\n \\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for obtaining the attribute:\n .value[0].i32: whether to remain in the editable state. The value <b>true</b> means to remain in the editable\n state, and <b>false</b> means to exit the editable state.\\n \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_EDITING: ArkUI_NodeAttributeType = 8006;
#[doc = " @brief Defines the text box type. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text box type {@link ArkUI_TextAreaType}.\n The default value is <b>ARKUI_TEXTAREA_TYPE_NORMAL</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text box type {@link ArkUI_TextAreaType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_TYPE: ArkUI_NodeAttributeType = 8007;
#[doc = " @brief Defines the counter settings. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show a character counter. The value <b>true</b> means to show a character counter. \\n\n .value[1]?.f32: threshold percentage for displaying the character counter. The character counter is displayed\n when the number of characters that have been entered is greater than the maximum number of characters multiplied\n by the threshold percentage value. The value range is 1 to 100. If the value is a decimal, it is rounded down. \\n\n .value[2]?.i32: whether to highlight the border when the number of entered characters reaches the maximum. \\n\n .object: counter configuration. The parameter type is {@link ArkUI_ShowCounterConfig}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to show a character counter. \\n\n .value[1].f32: threshold percentage for displaying the character counter. The character counter is displayed\n when the number of characters that have been entered is greater than the maximum number of characters multiplied\n by the threshold percentage value. The value range is 1 to 100. \\n\n .value[2].i32: whether to highlight the border when the number of entered characters reaches the maximum.\n The default value is <b>true</b>. \\n\n .object: counter configuration. The parameter type is {@link ArkUI_ShowCounterConfig}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_SHOW_COUNTER: ArkUI_NodeAttributeType = 8008;
#[doc = " @brief Sets whether to hide the text selection menu when the text box is long-pressed, double-click,\n or right-clicked. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to hide the text selection menu when the text box is long-pressed, double-click,\n or right-clicked. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to hide the text selection menu when the text box is long-pressed, double-click,\n or right-clicked. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_SELECTION_MENU_HIDDEN: ArkUI_NodeAttributeType =
    8009;
#[doc = " @brief Sets whether the multi-line text box loses focus after the Enter key is pressed to submit information.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the text box loses focus. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the text box loses focus. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_BLUR_ON_SUBMIT: ArkUI_NodeAttributeType = 8010;
#[doc = " @brief Sets the regular expression for input filtering.\n Only inputs that comply with the regular expression can be displayed.\n Other inputs are filtered out. The specified regular expression can match single characters,\n but not strings.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: regular expression. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: regular expression. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_INPUT_FILTER: ArkUI_NodeAttributeType = 8011;
#[doc = " @brief Defines the background color of the selected text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_SELECTED_BACKGROUND_COLOR:
    ArkUI_NodeAttributeType = 8012;
#[doc = " @brief Defines the type of the Enter key.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: type of the Enter key{@link ArkUI_EnterKeyType}. The default value is <b>ARKUI_ENTER_KEY_TYPE_DONE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type of the Enter key{@link ArkUI_EnterKeyType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_ENTER_KEY_TYPE: ArkUI_NodeAttributeType = 8013;
#[doc = " @brief Defines whether to enable the input method when the component obtains focus.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the input method when the component obtains focus.\n The value <b>true</b> means to enable the input method, and <b>false</b> means the opposite.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to enable the input method when the component obtains focus,\n and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_ENABLE_KEYBOARD_ON_FOCUS: ArkUI_NodeAttributeType =
    8014;
#[doc = " @brief Defines whether to enable the input method when the component obtains focus.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the input method when the component obtains focus.\n The value <b>true</b> means to enable the input method, and <b>false</b> means the opposite.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to enable the input method when the component obtains focus,\n and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CARET_OFFSET: ArkUI_NodeAttributeType = 8015;
#[doc = " @brief Obtains the position of the edited text area relative to the component and its size.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: horizontal coordinate. \\n\n .value[1].f32: vertical coordinate. \\n\n .value[2].f32: content width. \\n\n .value[3].f32: content height. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CONTENT_RECT: ArkUI_NodeAttributeType = 8016;
#[doc = " @brief Obtains the number of lines of the edited text.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of lines of the edited text. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CONTENT_LINE_COUNT: ArkUI_NodeAttributeType = 8017;
#[doc = " @brief Sets the text selection area, which will be highlighted.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: start position of the text selection. \\n\n .value[1].i32: end position of the text selection. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: start position of the text selection. \\n\n .value[1].i32: end position of the text selection. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_TEXT_SELECTION: ArkUI_NodeAttributeType = 8018;
#[doc = " @brief Sets whether to enable autofill.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable autofill. The default value is <b>true</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable autofill. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_ENABLE_AUTO_FILL: ArkUI_NodeAttributeType = 8019;
#[doc = " @brief Sets the autofill type.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: autofill type. The parameter type is {@link ArkUI_TextInputContentType}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: autofill type. The parameter type is {@link ArkUI_TextInputContentType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CONTENT_TYPE: ArkUI_NodeAttributeType = 8020;
#[doc = " @brief Sets whether the keyboard pops up when the input box gains focus.\n It supports property setting, property reset and property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format:\\n\n .value[0].i32: Whether to pop up the keyboard. \\n\n \\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .value[0].i32: Whether to pop up the keyboard. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_SHOW_KEYBOARD_ON_FOCUS: ArkUI_NodeAttributeType =
    8021;
#[doc = " @brief When this property is set, the height of the textArea component is calculated using this property.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: set the value of numberOfLines.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: Set the value of numberOfLines\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_NUMBER_OF_LINES: ArkUI_NodeAttributeType = 8022;
#[doc = " @brief Sets the letter spacing of the <b>TextArea</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: letter spacing. The default unit is fp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: letter spacing. The default unit is fp. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_LETTER_SPACING: ArkUI_NodeAttributeType = 8023;
#[doc = " @brief Sets whether to enable preview text for the <b>TextArea</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable preview tex. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable preview tex. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_ENABLE_PREVIEW_TEXT: ArkUI_NodeAttributeType =
    8024;
#[doc = " @brief Sets whether to center text vertically in the textArea component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to center text vertically. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to center text vertically. \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_HALF_LEADING: ArkUI_NodeAttributeType = 8025;
#[doc = " @brief Set the keyboard style of textArea\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32keyboard stylethe parameter type is {@link ArkUI_KeyboardAppearanceType}\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}\\n\n .value[0].i32keyboard stylethe parameter type is {@link ArkUI_KeyboardAppearanceType}\\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_KEYBOARD_APPEARANCE: ArkUI_NodeAttributeType =
    8026;
#[doc = " @brief Set the max lines of the node. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: max lines count.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: max lines count.\\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_MAX_LINES: ArkUI_NodeAttributeType = 8027;
#[doc = " @brief Set line spacing of the node. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: line spacing value. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: line spacing value. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_LINE_SPACING: ArkUI_NodeAttributeType = 8028;
#[doc = " @brief Set the min lines of the node. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: min lines count.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].i32: min line count.\\n\n\n @since 20\n"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_MIN_LINES: ArkUI_NodeAttributeType = 8029;
#[doc = " @brief Set the max lines of the node with scroll.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: max lines count with scroll.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].i32: max line count with scroll.\\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_MAX_LINES_WITH_SCROLL: ArkUI_NodeAttributeType =
    8030;
#[doc = " @brief Set the line height of the node. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: line height value.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].i32: line height value\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_LINE_HEIGHT: ArkUI_NodeAttributeType = 8031;
#[doc = " @brief Define bar state of the text area.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: bar state of the text area, specified using the {@link ArkUI_BarState} enum.\n The default value is <b>ARKUI_BAR_STATE_AUTO</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: bar state of the text area, specified using the {@link ArkUI_BarState} enum. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_BAR_STATE: ArkUI_NodeAttributeType = 8032;
#[doc = " @brief Enables selected data detector.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: Enable selected text recognition, default value true.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: Whether selected text recognition is enabled.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_ENABLE_SELECTED_DATA_DETECTOR:
    ArkUI_NodeAttributeType = 8033;
#[doc = " @brief Defines the color of the scrollbar. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .data[0].u32: color of the scroll bar thumb, in 0xARGB format. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .data[0].u32: color of the scroll bar thumb, in 0xARGB format. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_SCROLL_BAR_COLOR: ArkUI_NodeAttributeType = 8035;
#[doc = " @brief Sets up a custom keyboard.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: custom keyboard,The parameter type is {@Link ArkUI_NodeHandle}.\\n\n .value[0]?.i32: Sets whether the custom keyboard supports the avoidance feature, default value false.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object:custom keyboard,The parameter type is {@Link ArkUI_NodeHandle}.\\n\n .value[0].i32: Set whether the custom keyboard supports the avoidance function.\\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CUSTOM_KEYBOARD: ArkUI_NodeAttributeType = 8036;
#[doc = " @brief Defines the button text content. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default text content. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default text content. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BUTTON_LABEL: ArkUI_NodeAttributeType = 9000;
#[doc = " @brief Sets the button type. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: button type. The parameter type is {@link ArkUI_ButtonType}.\n The default value is <b>ARKUI_BUTTON_TYPE_CAPSULE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: button type. The parameter type is {@link ArkUI_ButtonType}.\n The default value is <b>ARKUI_BUTTON_TYPE_CAPSULE</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BUTTON_TYPE: ArkUI_NodeAttributeType = 9001;
#[doc = " @brief Defines the minimum font scale attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum font scale, in fp.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum font scale, in fp.\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_BUTTON_MIN_FONT_SCALE: ArkUI_NodeAttributeType = 9002;
#[doc = " @brief Defines the maximum font scale attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: maximum font scale, in fp.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: maximum font scale, in fp.\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_BUTTON_MAX_FONT_SCALE: ArkUI_NodeAttributeType = 9003;
#[doc = " @brief Defines the current value of the progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: current value of the progress indicator. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: current value of the progress indicator. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_VALUE: ArkUI_NodeAttributeType = 10000;
#[doc = " @brief Defines the total value of the progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: total value of the progress indicator. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: total value of the progress indicator. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_TOTAL: ArkUI_NodeAttributeType = 10001;
#[doc = " @brief Defines the color for the progress value on the progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_COLOR: ArkUI_NodeAttributeType = 10002;
#[doc = " @brief Defines the type of the progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: type of the progress indicator {@link ArkUI_ProgressType}.\n The default value is <b>ARKUI_PROGRESS_TYPE_LINEAR</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type of the progress indicator {@link ArkUI_ProgressType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_TYPE: ArkUI_NodeAttributeType = 10003;
#[doc = " @brief Sets the style of the linear progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n If the progress indicator type is not linear, it will not take effect.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: Use the {@link ArkUI_ProgressLinearStyleOption} object to set the style. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: Use the {@link ArkUI_ProgressLinearStyleOption} object to get the style. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_LINEAR_STYLE: ArkUI_NodeAttributeType = 10004;
#[doc = " @brief Defines whether the check box is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the check box is selected.\n The value <b>1</b> means that the check box is selected, and <b>0</b> means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means that the check box is selected, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_SELECT: ArkUI_NodeAttributeType = 11000;
#[doc = " @brief Defines the color of the check box when it is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the check box when it is selected, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the check box when it is selected, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_SELECT_COLOR: ArkUI_NodeAttributeType = 11001;
#[doc = " @brief Defines the border color of the check box when it is not selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_UNSELECT_COLOR: ArkUI_NodeAttributeType = 11002;
#[doc = " @brief Defines the internal icon style of the check box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\\n\n .value[1]?.f32: size of the internal mark, in vp. Optional.\\n\n .value[2]?.f32: stroke width of the internal mark, in vp. Optional. The default value is <b>2</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\\n\n .value[1].f32: size of the internal mark, in vp. \\n\n .value[2].f32: stroke width of the internal mark, in vp. The default value is <b>2</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_MARK: ArkUI_NodeAttributeType = 11003;
#[doc = " @brief Defines the shape of the check box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: component shape. The parameter type is {@link ArkUI_CheckboxShape}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: component shape. The parameter type is {@link ArkUI_CheckboxShape}.\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_SHAPE: ArkUI_NodeAttributeType = 11004;
#[doc = " @brief Defines the name of the checkbox.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component name. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component name. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_NAME: ArkUI_NodeAttributeType = 11005;
#[doc = " @brief Defines the name of the checkbox.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component name. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component name. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP: ArkUI_NodeAttributeType = 11006;
#[doc = " @brief Defines the ID of the <b><XComponent></b> component.\n This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component ID. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component ID. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_XCOMPONENT_ID: ArkUI_NodeAttributeType = 12000;
#[doc = " @brief Specifies the type of the <b>XComponent</b> component. This attribute is read-only. \\n\n The type of the <b>XComponent</b> component must be explicitly set during creation using {@link ARKUI_NODE_XCOMPONENT} or {@link ARKUI_NODE_XCOMPONENT_TEXTURE}, and cannot be modified afterward. \\n\n Attempting to change the type through {@link setAttribute} will cause rendering exceptions.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type {@link ArkUI_XComponentType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_XCOMPONENT_TYPE: ArkUI_NodeAttributeType = 12001;
#[doc = " @brief Specifies the size of the <b>XComponent</b> component. This attribute is read-only. \\n\n Attempting to modify the size through {@link setAttribute} will have no effect.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: width, in px. \\n\n .value[1].u32: height, in px. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_XCOMPONENT_SURFACE_SIZE: ArkUI_NodeAttributeType = 12002;
#[doc = " @brief Defines the rectangle information of surface created by the <b><XComponent></b> component.\n This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The horizontal offset of the surface relative to XComponent, in pixels. \\n\n .value[1].i32: The vertical offset of the surface relative to XComponent, in pixels. \\n\n .value[2].i32: The width of the surface created by XComponent, in pixels. \\n\n .value[3].i32: The height of the surface created by XComponent, in pixels. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The horizontal offset of the surface relative to XComponent, in pixels. \\n\n .value[1].i32: The vertical offset of the surface relative to XComponent, in pixels. \\n\n .value[2].i32: The width of the surface created by XComponent, in pixels. \\n\n .value[3].i32: The height of the surface created by XComponent, in pixels. \\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_XCOMPONENT_SURFACE_RECT: ArkUI_NodeAttributeType = 12003;
#[doc = " @brief Defines whether to enable the AI analyzer for the <b><XComponent></b> component.\n This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: The parameter type is 1 or 0.\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_XCOMPONENT_ENABLE_ANALYZER: ArkUI_NodeAttributeType = 12004;
#[doc = " @brief Defines whether to display the lunar calendar in the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to display the lunar calendar in the date picker. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to display the lunar calendar in the date picker.\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_LUNAR: ArkUI_NodeAttributeType = 13000;
#[doc = " @brief Defines the start date of the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: date. The default value is <b>\"1970-1-1\"</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: date. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_START: ArkUI_NodeAttributeType = 13001;
#[doc = " @brief Defines the end date of the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: date. The default value is <b>\"2100-12-31\"</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: date. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_END: ArkUI_NodeAttributeType = 13002;
#[doc = " @brief Defines the selected date of the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: date. The default value is <b>\"2024-01-22\"</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: date.\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_SELECTED: ArkUI_NodeAttributeType = 13003;
#[doc = " @brief Defines the font color, font size, and font weight for the top and bottom items in the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_DISAPPEAR_TEXT_STYLE: ArkUI_NodeAttributeType =
    13004;
#[doc = " @brief Defines the font color, font size, and font weight of all items except the top, bottom, and selected\n items in the date picker. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_TEXT_STYLE: ArkUI_NodeAttributeType = 13005;
#[doc = " @brief Defines the font color, font size, and font weight of the selected item in the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_SELECTED_TEXT_STYLE: ArkUI_NodeAttributeType =
    13006;
#[doc = " @brief Defines the mode of the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n value[0].i32: the mode. The value is and enum of {@link ArkUI_DatePickerMode}.\\n.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: the mode. The value is and enum of {@link ArkUI_DatePickerMode}.\\n.\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_MODE: ArkUI_NodeAttributeType = 13007;
#[doc = " @brief Defines whether haptic feedback.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to feedback. The value <b>true</b> means to feedback, and\n <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: whether to feedback.\\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_ENABLE_HAPTIC_FEEDBACK: ArkUI_NodeAttributeType =
    13008;
#[doc = " @brief Defines whether to support scroll looping for the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to support scroll looping. The value <b>true</b> means to support scroll looping, and\n <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: The value <b>1</b> means to support scroll looping, and <b>0</b> means the opposite. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_CAN_LOOP: ArkUI_NodeAttributeType = 13009;
#[doc = " @brief Defines the time of the selected item. in the timer picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: time. The default value is the current system time. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: time.\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_SELECTED: ArkUI_NodeAttributeType = 14000;
#[doc = " @brief Defines whether the display time is in 24-hour format.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the display time is in 24-hour format. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the display time is in 24-hour format.\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_USE_MILITARY_TIME: ArkUI_NodeAttributeType =
    14001;
#[doc = " @brief Defines the font color, font size, and font weight for the top and bottom items in the time picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_DISAPPEAR_TEXT_STYLE: ArkUI_NodeAttributeType =
    14002;
#[doc = " @brief Defines the font color, font size, and font weight of all items except the top, bottom, and selected items\n in the time picker. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_TEXT_STYLE: ArkUI_NodeAttributeType = 14003;
#[doc = " @brief Defines the font color, font size, and font weight of the selected item in the time picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_SELECTED_TEXT_STYLE: ArkUI_NodeAttributeType =
    14004;
#[doc = " @brief Defines the start time of the time picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: time. The default value is <b>\"00:00:00\"</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: time. The default value is <b>\"00:00:00\"</b>.\\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_START: ArkUI_NodeAttributeType = 14005;
#[doc = " @brief Defines the end time of the time picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: time. The default value is <b>\"23:59:59\"</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: time. The default value is <b>\"23:59:59\"</b>.\\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_END: ArkUI_NodeAttributeType = 14006;
#[doc = " @brief Defines whether the AM/PM option is cascaded with the time in 12-hour mode.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable cascade. The default value is <b>false</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable cascade.\\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_ENABLE_CASCADE: ArkUI_NodeAttributeType = 14007;
#[doc = " @brief Defines the data selection range of the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: type of the text picker {@link ArkUI_TextPickerRangeType}.\n The default value is <b>ARKUI_TEXTPICKER_RANGETYPE_SINGLE</b>. \\n\n ?.string: string input, whose format varies by picker type.\\n\n 1: single-column picker. The input format is a group of strings separated by semicolons (;).\\n\n 2: multi-column picker. Multiple pairs of plain text strings are supported. The pairs are separated by\n semicolons (;), and strings within each pair are separated by commas (,). \\n\n ?.object: Object input, whose format varies by picker type.\\n\n 1: single-column picker with image support. The input structure is {@link ARKUI_TextPickerRangeContent}.\\n\n 2: multi-column interconnected picker. The input structure is {@link ARKUI_TextPickerCascadeRangeContent}.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type of the text picker {@link ArkUI_TextPickerRangeType}.\\n\n ?.string: string output, whose format varies by picker type.\\n\n 1: single-column picker. The output format is a group of strings separated by semicolons (;).\\n\n 2: multi-column picker. Multiple pairs of plain text strings are supported. The pairs are separated by\n semicolons (;), and strings within each pair are separated by commas (,). \\n\n ?.string: Object output, whose format varies by picker type.\\n\n 1: single-column picker with image support. The output structure is {@link ARKUI_TextPickerRangeContent}.\\n\n 2: multi-column interconnected picker. The output structure is {@link ARKUI_TextPickerCascadeRangeContent}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_OPTION_RANGE: ArkUI_NodeAttributeType = 15000;
#[doc = " @brief Defines the index of the default selected item in the data selection range of the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: index. If there are multiple index values, add them one by one. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: index. If there are multiple index values, add them one by one.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_OPTION_SELECTED: ArkUI_NodeAttributeType = 15001;
#[doc = " @brief Defines the value of the default selected item in the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: value of the selected item. If there are multiple values, add them one by one and\n separate them with semicolons (;). \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: value of the selected item. If there are multiple values, add them one by one and\n separate them with semicolons (;).\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_OPTION_VALUE: ArkUI_NodeAttributeType = 15002;
#[doc = " @brief Defines the font color, font size, and font weight for the top and bottom items in the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_DISAPPEAR_TEXT_STYLE: ArkUI_NodeAttributeType =
    15003;
#[doc = " @brief Defines the font color, font size, and font weight for all items except the top, bottom, and selected\n items in the text picker. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_TEXT_STYLE: ArkUI_NodeAttributeType = 15004;
#[doc = " @brief Defines the font color, font size, and font weight for the selected item in the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_SELECTED_TEXT_STYLE: ArkUI_NodeAttributeType =
    15005;
#[doc = " @brief Defines the index of the default selected item in the data selection range of the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0...].i32: index of the default item in the data selection range.\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_SELECTED_INDEX: ArkUI_NodeAttributeType = 15006;
#[doc = " @brief Defines whether to support scroll looping for the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to support scroll looping. The value <b>true</b> means to support scroll looping, and\n <b>false</b> means the opposite.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: The value <b>1</b> means to support scroll looping, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_CAN_LOOP: ArkUI_NodeAttributeType = 15007;
#[doc = " @brief Defines the height of each item in the picker. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: item height, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].f32: item height, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_DEFAULT_PICKER_ITEM_HEIGHT:
    ArkUI_NodeAttributeType = 15008;
#[doc = " @brief Defines whether haptic feedback.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to feedback. The value <b>true</b> means to feedback, and\n <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: whether to feedback.\\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_ENABLE_HAPTIC_FEEDBACK: ArkUI_NodeAttributeType =
    15010;
#[doc = " @brief Defines the background color and border radius of the selected items.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: background color, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n 1: .value[1].f32: radius of the four corners. \\n\n 2: .value[1].f32: radius of the upper left corner. \\n\n .value[2].f32: radius of the upper right corner. \\n\n .value[3].f32: radius of the lower left corner. \\n\n .value[4].f32: radius of the lower right corner. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n     *\n .value[1].f32: radius of the upper left corner. \\n\n .value[2].f32: radius of the upper right corner. \\n\n .value[3].f32: radius of the lower left corner. \\n\n .value[4].f32: radius of the lower right corner. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_SELECTED_BACKGROUND_STYLE:
    ArkUI_NodeAttributeType = 15011;
#[doc = " @brief Defines the style of the background in the selected state of the calendar picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: style of the background in the selected state of the calendar picker.\n The value range is [0, +). If the value is <b>0</b>, the background is a rectangle with square corners.\nIf the value is in the 016 range, the background is a rectangle with rounded corners. If the value is equal to\n or greater than 16, the background is a circle. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: style of the background in the selected state of the calendar picker. The value range is [0, +).\n If the value is <b>0</b>, the background is a rectangle with square corners.\nIf the value is in the 016 range, the background is a rectangle with rounded corners. If the value is equal to or\n greater than 16, the background is a circle. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_HINT_RADIUS: ArkUI_NodeAttributeType = 16000;
#[doc = " @brief Defines the date of the selected item in the calendar picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: year of the selected date. \\n\n .value[1].u32: month of the selected date. \\n\n .value[2].u32: day of the selected date. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: year of the selected date. \\n\n .value[1].u32: month of the selected date. \\n\n .value[2].u32: day of the selected date. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_SELECTED_DATE: ArkUI_NodeAttributeType =
    16001;
#[doc = " @brief Defines how the calendar picker is aligned with the entry component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode. The parameter type is {@link ArkUI_CalendarAlignment}. \\n\n .value[1]?.f32: offset of the picker relative to the entry component along the x-axis after alignment based on\n the specified alignment mode. \\n\n .value[2]?.f32: offset of the picker relative to the entry component along the y-axis after alignment based on\n the specified alignment mode. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode. The parameter type is {@link ArkUI_CalendarAlignment}. \\n\n .value[1]?.f32: offset of the picker relative to the entry component along the x-axis after alignment based on\n the specified alignment mode. \\n\n .value[2]?.f32: offset of the picker relative to the entry component along the y-axis after alignment based on\n the specified alignment mode. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_EDGE_ALIGNMENT: ArkUI_NodeAttributeType =
    16002;
#[doc = " @brief Defines the font color, font size, and font weight in the entry area of the calendar picker.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.u32: font color of the entry area. \\n\n .value[1]?.f32: font size of the entry area, in fp. \\n\n .value[2]?.i32: font weight of the entry area. The parameter type is {@link ArkUI_FontWeight}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: font color of the entry area. \\n\n .value[1].f32: font size of the entry area, in fp. \\n\n .value[2].i32: font weight of the entry area. The parameter type is {@link ArkUI_FontWeight}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_TEXT_STYLE: ArkUI_NodeAttributeType = 16003;
#[doc = " @brief Defines the start date of the calendar picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: date. The value like <b>\"1970-1-1\"</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: date. \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_START: ArkUI_NodeAttributeType = 16004;
#[doc = " @brief Defines the end date of the calendar picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: date. The value like <b>\"2100-12-31\"</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: date. \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_END: ArkUI_NodeAttributeType = 16005;
#[doc = " @brief Defines the color of the slider. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the slider, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the slider, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_BLOCK_COLOR: ArkUI_NodeAttributeType = 17000;
#[doc = " @brief Defines the background color of the slider. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: background color, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_TRACK_COLOR: ArkUI_NodeAttributeType = 17001;
#[doc = " @brief Defines the color of the selected part of the slider track. This attribute can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the selected part of the slider track, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the selected part of the slider track, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_SELECTED_COLOR: ArkUI_NodeAttributeType = 17002;
#[doc = " @brief Sets whether to display the stepping value. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to display the stepping value. The value <b>1</b> means to display the stepping value,\n and <b>0</b> (default value) means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to display the stepping value. The value <b>1</b> means to display the stepping value,\n and <b>0</b> (default value) means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_SHOW_STEPS: ArkUI_NodeAttributeType = 17003;
#[doc = " @brief Defines the slider shape, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: shape. The parameter type is {@link ArkUI_SliderBlockStyle}. \\n\n .string?: depending on the shape. Optional. \\n\n ARKUI_SLIDER_BLOCK_STYLE_IMAGE: image resource of the slider. Example: /pages/common/icon.png. \\n\n ARKUI_SLIDER_BLOCK_STYLE_SHAPE: custom shape of the slider. \\n\n There are five types:\\n\n 1. Rectangle:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_RECTANGLE</b> for the rectangle shape.\\n\n .value[2].f32: width of the rectangle.\\n\n .value[3].f32: height of the rectangle.\\n\n .value[4].f32: width of the rounded corner of the rectangle.\\n\n .value[5].f32: height of the rounded corner of the rectangle.\\n\n 2. Circle:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[2].f32: width of the circle.\\n\n .value[3].f32: height of the circle.\\n\n 3.Ellipse:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[2].f32: width of the ellipse.\\n\n .value[3].f32: height of the ellipse;\\n\n 4. Path:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_PATH</b> for the path shape.\\n\n .value[2].f32: width of the path.\\n\n .value[3].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: shape. The parameter type is {@link ArkUI_SliderBlockStyle}. \\n\n .string?: depending on the shape. Optional. \\n\n ARKUI_SLIDER_BLOCK_STYLE_IMAGE: image resource of the slider. Example: /pages/common/icon.png. \\n\n ARKUI_SLIDER_BLOCK_STYLE_SHAPE: custom shape of the slider. \\n\n There are five types:\\n\n 1. Rectangle:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_RECTANGLE</b> for the rectangle shape.\\n\n .value[2].f32: width of the rectangle.\\n\n .value[3].f32: height of the rectangle.\\n\n .value[4].f32: width of the rounded corner of the rectangle.\\n\n .value[5].f32: height of the rounded corner of the rectangle.\\n\n 2. Circle:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[2].f32: width of the circle.\\n\n .value[3].f32: height of the circle.\\n\n 3.Ellipse:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[2].f32: width of the ellipse.\\n\n .value[3].f32: height of the ellipse;\\n\n 4. Path:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_PATH</b> for the path shape.\\n\n .value[2].f32: width of the path.\\n\n .value[3].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_BLOCK_STYLE: ArkUI_NodeAttributeType = 17004;
#[doc = " @brief Defines the current value of the slider. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: current value. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: current value.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_VALUE: ArkUI_NodeAttributeType = 17005;
#[doc = " @brief Defines the minimum value of the slider. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum value. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum value.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_MIN_VALUE: ArkUI_NodeAttributeType = 17006;
#[doc = " @brief Defines the maximum value of the slider. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: maximum value. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: maximum value.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_MAX_VALUE: ArkUI_NodeAttributeType = 17007;
#[doc = " @brief Defines the step of the slider. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: step. The value range is [0.01, 100]. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: step. The value range is [0.01, 100].\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_STEP: ArkUI_NodeAttributeType = 17008;
#[doc = " @brief Defines whether the slider moves horizontally or vertically. This attribute can be set, reset, and\n obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the slider moves horizontally or vertically.\n The parameter type is {@link ArkUI_SliderDirection}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the slider moves horizontally or vertically.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_DIRECTION: ArkUI_NodeAttributeType = 17009;
#[doc = " @brief Defines whether the slider values are reversed. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the slider values are reversed. The value <b>1</b> means that the slider values are\n reversed, and <b>0</b> means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the slider values are reversed. The value <b>1</b> means that the slider values are\n reversed, and <b>0</b> means the opposite.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_REVERSE: ArkUI_NodeAttributeType = 17010;
#[doc = " @brief Defines the style of the slider thumb and track. This attribute can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: style of the slider thumb and track. The parameter type is {@link ArkUI_SliderStyle}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: style of the slider thumb and track. The parameter type is {@link ArkUI_SliderStyle}.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_STYLE: ArkUI_NodeAttributeType = 17011;
#[doc = " @brief Sets the track thickness of the slider.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: track thickness of the slider, in vp. The default value is 4.0 vp when <b>NODE_SLIDER_STYLE</b>\n is set to <b>ARKUI_SLIDER_STYLE_OUT_SET</b> and 20.0 vp when <b>NODE_SLIDER_STYLE</b> is set to\n <b>ARKUI_SLIDER_STYLE_IN_SET</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: track thickness of the slider, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_TRACK_THICKNESS: ArkUI_NodeAttributeType = 17012;
#[doc = " @brief Defines whether haptic feedback.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to feedback. The value <b>true</b> means to feedback, and\n <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: whether to feedback.\\n\n When enabling haptic feedback, you need to add \"ohos.permission.VIBRATE\" in the\n requestPermissions field of the module.json5 file to enable vibration permission.\\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_ENABLE_HAPTIC_FEEDBACK: ArkUI_NodeAttributeType =
    17013;
#[doc = " @brief Sets a custom component on the leading side of the Slider component.\n\n Attribute setting method {@link ArkUI_AttributeItem} parameter format:\\n\n .object: Parameter type {@link ArkUI_NodeHandle}.\n\n The prefix component will be placed at the start position of the Slider\n typically on the left side in LTR layouts.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_PREFIX: ArkUI_NodeAttributeType = 17014;
#[doc = " @brief Sets a custom component on the trailing side of the Slider component.\n\n Attribute setting method {@link link ArkUI_AttributeItem} parameter format:\\n\n .object: Parameter type {@link ArkUI_NodeHandle}.\n\n The suffix component will be placed at the end position of the Slider,\n typically on the right side in LTR layouts.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_SUFFIX: ArkUI_NodeAttributeType = 17015;
#[doc = " @brief Defines the color of the slider block. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_BLOCK_LINEAR_GRADIENT_COLOR: ArkUI_NodeAttributeType =
    17016;
#[doc = " @brief Defines the background color of the slider. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_TRACK_LINEAR_GRADIENT_COLOR: ArkUI_NodeAttributeType =
    17017;
#[doc = " @brief Defines the color of the selected part of the slider track. This attribute can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: array of color stops, each of which consists of a color and its stop position.\n The parameter type is {@link ArkUI_ColorStop}. Invalid colors are automatically skipped. \\n \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_SELECTED_LINEAR_GRADIENT_COLOR:
    ArkUI_NodeAttributeType = 17018;
#[doc = " @brief Set the selection status of an option button. Attribute setting,\n attribute resetting, and attribute obtaining are supported.\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: check status of an option button. The default value is false.\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: selection status of an option button."]
pub const ArkUI_NodeAttributeType_NODE_RADIO_CHECKED: ArkUI_NodeAttributeType = 18000;
#[doc = " @brief Set the styles of the selected and deselected states of the option button.\n The attribute setting, attribute resetting, and attribute obtaining are supported.\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0]?. u32: color of the mother board in enabled state. \\n\n The type is 0xARGB, and the default value is 0xFF007DFF. \\n\n .value[1]?. u32: stroke color in the close state. The type is 0xARGB, \\n\n and the default value is 0xFF182431. \\n\n .value[2]?. u32: color of the internal round pie in the enabled state. \\n\n The type is 0xARGB, and the default value is 0xFFFFFFFF. \\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0]. u32: color of the mother board in enabled state. \\n\n The type is 0xARGB, and the default value is 0xFF007DFF. \\n\n .value[1]. u32: stroke color in the close state. The type is 0xARGB, \\n\n and the default value is 0xFF182431. \\n\n .value[2]. u32: color of the internal round pie in the enabled state. \\n\n The type is 0xARGB, and the default value is 0xFFFFFFF. \\n"]
pub const ArkUI_NodeAttributeType_NODE_RADIO_STYLE: ArkUI_NodeAttributeType = 18001;
#[doc = " @brief Sets the value of the current radio.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .string: radio value.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: radio value.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RADIO_VALUE: ArkUI_NodeAttributeType = 18002;
#[doc = " @brief Set the group name of the current Radio group, only one radio of the same group can be selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .string: name of the group to which the current option box belongs.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: name of the group to which the current option box belongs.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RADIO_GROUP: ArkUI_NodeAttributeType = 18003;
#[doc = " @brief Set the image frames for the image animator. Dynamic updates is not supported.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .size: number of the images.\\n\n .object: array of the images, the type is {@ArkUI_ImageAnimatorFrameInfo} array.\\n\n \\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .size: number of the images.\\n\n .object: array of the images, the type is {@ArkUI_ImageAnimatorFrameInfo} array.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_IMAGES: ArkUI_NodeAttributeType = 19000;
#[doc = " @brief Set the playback status of the animation for the image animator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the playback status of the animation, the type is {@link ArkUI_AnimationStatus},\n and the default value is ARKUI_ANIMATION_STATUS_INITIAL.\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: the playback status of the animation, the type is {@link ArkUI_AnimationStatus}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_STATE: ArkUI_NodeAttributeType = 19001;
#[doc = " @brief Set the playback duration for the image animator. When the duration is 0, no image is played.\n The value change takes effect only at the beginning of the next cycle.\n When a separate duration is set in images, the setting of this attribute is invalid.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the playback duration, the unit is ms and the default value is 1000.\\n\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: the playback duration, the unit is ms.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_DURATION: ArkUI_NodeAttributeType = 19002;
#[doc = " @brief Set the playback direction for the image animator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the playback direction. 0 indicates that images are played from the first one to the last one,\n and 1 indicates that images are played from the last one to the first one.\\n\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: the playback direction. 0 indicates that images are played from the first one to the last one,\n and 1 indicates that images are played from the last one to the first one.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_REVERSE: ArkUI_NodeAttributeType = 19003;
#[doc = " @brief Set whether the image size is the same as the component size.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: whether the image size is the same as the component size.\n 1 indicates the image size is the same as the component size.\n In this case, the width, height, top, and left attributes of the image are invalid.\n 0 indicates the image size is customized.\n The width, height, top, and left attributes of each image must be set separately.\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: whether the image size is the same as the component size.\n 1 indicates the image size is the same as the component size.\n 0 indicates the image size is customized.\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_FIXED_SIZE: ArkUI_NodeAttributeType = 19004;
#[doc = " @brief Set the status before and after execution of the animation in the current playback direction.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the status before and after execution of the animation in the current playback direction,\n the type is {ArkUI_AnimationFillMode} and the default value is ARKUI_ANIMATION_FILL_MODE_FORWARDS.\\n\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: the status before and after execution of the animation in the current playback direction,\n the type is {ArkUI_AnimationFillMode}.\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_FILL_MODE: ArkUI_NodeAttributeType = 19005;
#[doc = " @brief Set the number of times that the animation is played.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the number of times that the animation is played.\\n\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the number of times that the animation is played.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_ITERATION: ArkUI_NodeAttributeType = 19006;
#[doc = " @brief Defines the name of the checkboxgroup.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component name. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component name. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_NAME: ArkUI_NodeAttributeType = 21000;
#[doc = " @brief Defines whether the checkboxgroup is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the checkboxgroup is selected.\n The value <b>1</b> means that the checkboxgroup is selected, and <b>0</b> means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means that the checkboxgroup is selected, and <b>0</b> means the opposite. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_SELECT_ALL: ArkUI_NodeAttributeType = 21001;
#[doc = " @brief Defines the color of the checkboxgroup when it is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the checkboxgroup when it is selected, in 0xARGB format,\n for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the checkboxgroup when it is selected, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_SELECTED_COLOR: ArkUI_NodeAttributeType =
    21002;
#[doc = " @brief Defines the border color of the checkboxgroup when it is not selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_UNSELECTED_COLOR: ArkUI_NodeAttributeType =
    21003;
#[doc = " @brief Defines the internal icon style of the checkboxgroup.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\\n\n .value[1]?.f32: size of the internal mark, in vp. Optional.\\n\n .value[2]?.f32: stroke width of the internal mark, in vp. Optional. The default value is <b>2</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\\n\n .value[1].f32: size of the internal mark, in vp. \\n\n .value[2].f32: stroke width of the internal mark, in vp. The default value is <b>2</b>. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_MARK: ArkUI_NodeAttributeType = 21004;
#[doc = " @brief Defines the shape of the checkboxgroup.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: component shape. The parameter type is {@link ArkUI_CheckboxShape}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: component shape. The parameter type is {@link ArkUI_CheckboxShape}.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_SHAPE: ArkUI_NodeAttributeType = 21005;
#[doc = " @brief Defines the alignment mode of the child components in the container. This attribute can be set, reset,\n and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode. The data type is {@link ArkUI_Alignment}.\n The default value is <b>ARKUI_ALIGNMENT_CENTER</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode. The data type is {@link ArkUI_Alignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_STACK_ALIGN_CONTENT: ArkUI_NodeAttributeType = 1000000;
#[doc = " @brief Defines the scrollbar status. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: scrollbar status. The parameter type is {@link ArkUI_ScrollBarDisplayMode}. The default value is\n <b>ARKUI_SCROLL_BAR_DISPLAY_MODE_AUTO</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: scrollbar status. The parameter type is {@link ArkUI_ScrollBarDisplayMode}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BAR_DISPLAY_MODE: ArkUI_NodeAttributeType = 1002000;
#[doc = " @brief Defines the width of the scrollbar. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width of the scrollbar, in vp. The default value is <b>4</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the scrollbar, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BAR_WIDTH: ArkUI_NodeAttributeType = 1002001;
#[doc = " @brief Defines the color of the scrollbar. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .data[0].u32: color of the scrollbar, in 0xARGB format. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .data[0].u32: color of the scrollbar, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BAR_COLOR: ArkUI_NodeAttributeType = 1002002;
#[doc = " @brief Defines the scroll direction. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: scroll direction. The parameter type is {@link ArkUI_ScrollDirection}.\n The default value is <b>ARKUI_SCROLL_DIRECTION_VERTICAL</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: scroll direction. The parameter type is {@link ArkUI_ScrollDirection}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_SCROLL_DIRECTION: ArkUI_NodeAttributeType = 1002003;
#[doc = " @brief Defines the effect used at the edges of the component when the boundary of the scrollable content is\n reached. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: effect used at the edges of the component when the boundary of the scrollable content is reached.\n The parameter type is {@link ArkUI_EdgeEffect}. The default value is <b>ARKUI_EDGE_EFFECT_NONE</b>.\\n\n .value[1]?.i32: whether to enable the scroll effect when the component content size is smaller than the\n component itself. Optional. The value <b>1</b> means to enable the scroll effect, and <b>0</b> means the\n opposite. The default value for the List/Grid/WaterFlow component is <b>0</b>, and the default value for the\n Scroll component is <b>1</b>. \\n\n .value[2]?.i32: direction in which the effect takes effect. The parameter type is {@link ArkUI_EffectEdge}.\n The default value is <b>ARKUI_EFFECT_EDGE_START | ARKUI_EFFECT_EDGE_END</b>. This parameter is supported since\n API version 16. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: effect used at the edges of the component when the boundary of the scrollable content is reached.\n The parameter type is {@link ArkUI_EdgeEffect}. \\n\n .value[1].i32: whether to enable the scroll effect when the component content size is smaller than the component\n itself. Optional. The value <b>1</b> means to enable the scroll effect, and <b>0</b> means the opposite. \\n\n .value[2].i32: edge for which the effect takes effect when the boundary of the scrollable content is reached.\n The parameter type is {@link ArkUI_EffectEdge}. This parameter is supported since API version 16. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_EDGE_EFFECT: ArkUI_NodeAttributeType = 1002004;
#[doc = " @brief Defines whether to support scroll gestures. When this attribute is set to <b>false</b>, scrolling by\n finger or mouse is not supported, but the scroll controller API is not affected.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to support scroll gestures. The default value is <b>true</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to support scroll gestures. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_ENABLE_SCROLL_INTERACTION: ArkUI_NodeAttributeType =
    1002005;
#[doc = " @brief Defines the friction coefficient. It applies only to gestures in the scrolling area, and it affects only\n indirectly the scroll chaining during the inertial scrolling process.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: friction coefficient. The default value is <b>0.6</b> for non-wearable devices and <b>0.9</b>\n for wearable devices. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: friction coefficient.\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_FRICTION: ArkUI_NodeAttributeType = 1002006;
#[doc = " @brief Defines the scroll snapping mode. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode for the scroll snap position. The parameter type is {@link ArkUI_ScrollSnapAlign}.\n The default value is <b>ARKUI_SCROLL_SNAP_ALIGN_NONE</b>.\\n\n .value[1].i32: whether to enable the snap to start feature. When scroll snapping is defined for the\n <b><Scroll></b> component, setting this attribute to <b>false</b> enables the component to scroll between the\n start edge and the first snap point. The default value is <b>true</b>. It is valid only when there are multiple\n snap points.\\n\n .value[2].i32: Whether to enable the snap to end feature. When scroll snapping is defined for the\n <b><Scroll></b> component, setting this attribute to <b>false</b> enables the component to scroll between the\n end edge and the last snap point. The default value is <b>true</b>. It is valid only when there are multiple\n snap points.\\n\n .value[3...].f32: snap points for the <b><Scroll></b> component. Each snap point defines the offset from an\n edge to which the <b><Scroll></b> component can scroll.  \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode for the scroll snap position. The parameter type is {@link ArkUI_ScrollSnapAlign}.\\n\n .value[1].i32: whether to enable the snap to start feature. When scroll snapping is defined for the\n <b><Scroll></b> component, setting this attribute to <b>false</b> enables the component to scroll between the\n start edge and the first snap point.\\n\n .value[2].i32: Whether to enable the snap to end feature. When scroll snapping is defined for the\n <b><Scroll></b> component, setting this attribute to <b>false</b> enables the component to scroll between the\n end edge and the last snap point.\\n\n .value[3...].f32: snap points for the <b><Scroll></b> component. Each snap point defines the offset from an edge\n to which the <b><Scroll></b> component can scroll. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_SNAP: ArkUI_NodeAttributeType = 1002007;
#[doc = " @brief Defines the nested scrolling options. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: nested scrolling option when the component scrolls forward.\n The parameter type is {@link ArkUI_ScrollNestedMode}. \\n\n .value[1].i32: nested scrolling option when the component scrolls backward.\n The parameter type is {@link ArkUI_ScrollNestedMode}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: nested scrolling option when the component scrolls forward.\n The parameter type is {@link ArkUI_ScrollNestedMode}. \\n\n .value[1].i32: nested scrolling option when the component scrolls backward.\n The parameter type is {@link ArkUI_ScrollNestedMode}.\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_NESTED_SCROLL: ArkUI_NodeAttributeType = 1002008;
#[doc = " @brief Defines the specified position to scroll to. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: horizontal scrolling offset, in vp. \\n\n .value[1].f32: vertical scrolling offset, in vp. \\n\n .value[2]?.i32: scrolling duration, in milliseconds. Optional. \\n\n .value[3]?.i32: scrolling curve. Optional. The parameter type is {@link ArkUI_AnimationCurve}.\n                 The default value is <b>ARKUI_CURVE_EASE</b>. \\n\n .value[4]?.i32: whether to enable the default spring animation. Optional.\n                 The default value <b>0</b> means not to enable the default spring animation. \\n\n .value[5]?.i32: whether to convert the scroll animation to an overshoot animation when the boundary is reached.\n                 Optional. \\n\n .value[6]?.i32: whether the component can stop at an overscrolled position.\n                 This parameter is supported since API version 20. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: horizontal scrolling offset, in vp. \\n\n .value[1].f32: vertical scrolling offset, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_OFFSET: ArkUI_NodeAttributeType = 1002009;
#[doc = " @brief Defines the edge position to scroll to. This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: edge position to scroll to. The parameter type is {@link ArkUI_ScrollEdge}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the container at the edge position. The value <b>-1</b> means that the container is not\n at the edge position. If the container is at the edge position, the parameter type is {@link ArkUI_ScrollEdge}.\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_EDGE: ArkUI_NodeAttributeType = 1002010;
#[doc = " @brief Defines whether to enable the swipe-to-turn-pages feature. This attribute can be set, reset, and obtained\n as required through APIs.\n\n If both <b>enablePaging</b> and <b>scrollSnap</b> are set, <b>scrollSnap</b> takes effect, but\n <b>enablePaging</b> does not. \\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the swipe-to-turn-pages feature. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable the swipe-to-turn-pages feature. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_ENABLE_PAGING: ArkUI_NodeAttributeType = 1002011;
#[doc = " @brief Scroll to the next or previous page.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32 Indicates whether to scroll to next page. Value 0 indicates scroll to next page and value 1\n indicates scroll to previous page. \\n\n .value[1]?.i32 Indicates whether to enable animation. Value 1 indicates enable and 0 indicates disable. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_PAGE: ArkUI_NodeAttributeType = 1002012;
#[doc = " @brief Scroll a specified distance.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32Horizontal scrolling distance in vp; \\n\n .value[1].f32: Vertical scrolling distance in vp; \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BY: ArkUI_NodeAttributeType = 1002013;
#[doc = " @brief Performs inertial scrolling based on the initial velocity passed in.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: Initial velocity of inertial scrolling. Unit: vp/s. If the value specified is 0, it is\n considered as invalid, and the scrolling for this instance will not take effect. If the value is positive,\n the scroll will move downward; if the value is negative, the scroll will move upward. \\n\n\n @since 13"]
#[cfg(feature = "api-13")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_FLING: ArkUI_NodeAttributeType = 1002014;
#[doc = " @brief Sets the fading effect for the edges of scrollable components.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\n .value[0].i32: whether to enable the fading effect on edges. The value 0 means to disable the fading effect,\n and 1 means to enable it.\n .value[1]?.f32: length of the fading effect on edges, in vp. Default value: 32.\n\n Format of the return value {@link ArkUI_AttributeItem}:\n .value[0].i32: whether the fading effect on edges is enabled. The value 0 means that the fading effect is\n disabled, and 1 means that it is enabled.\n .value[1].f32: length of the fading effect on edges, in vp.\n\n @since 14"]
#[cfg(feature = "api-14")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_FADING_EDGE: ArkUI_NodeAttributeType = 1002015;
#[doc = " @brief Obtains the total size of all child components when fully expanded in the scrollable component.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: total width of all child components when fully expanded in the scrollable component.\n                The default unit is vp. \\n\n .value[1].f32: total height of all child components when fully expanded in the scrollable component.\n                The default unit is vp. \\n\n When <b>NODE_PADDING</b>, <b>NODE_MARGIN</b>, or <b>NODE_BORDER_WIDTH</b> is set, the values are rounded to the\n nearest pixel when being converted from vp to px.\n The returned values are calculated based on these rounded pixel values. \\n\n\n @since 14"]
#[cfg(feature = "api-14")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_SIZE: ArkUI_NodeAttributeType = 1002016;
#[doc = " @brief Sets the offset from the start of the scrollable components content.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: offset from the start of the content, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: offset from the start of the content, in vp. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_CONTENT_START_OFFSET: ArkUI_NodeAttributeType =
    1002017;
#[doc = " @brief Sets the offset from the end of the scrollable components content.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: offset from the end of the content, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: offset from the end of the content, in vp. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_CONTENT_END_OFFSET: ArkUI_NodeAttributeType = 1002018;
#[doc = " @brief Defines the maximum starting fling speed of the scrollable when the fling animation starts.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].f32: maximum starting fling speed, Unit: vp/s \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].f32: maximum starting fling speed, Unit: vp/s \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_FLING_SPEED_LIMIT: ArkUI_NodeAttributeType = 1002019;
#[doc = " @brief Defines the clip mode of the scrollable.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: clip content mode, The parameter type is {@link ArkUI_ContentClipMode}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].i32: clip content mode, The parameter type is {@link ArkUI_ContentClipMode}. \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_CLIP_CONTENT: ArkUI_NodeAttributeType = 1002020;
#[doc = " @brief Defines whether the scrollable scrolls back to top when status bar is clicked.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: whether the scrollable scrolls back to top when status bar is clicked.\n The value <b>1</b> means to scroll back to top, and <b>0</b> means the opposite. The default value is <b>0/b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].i32: whether the scrollable scrolls back to top when status bar is clicked. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BACK_TO_TOP: ArkUI_NodeAttributeType = 1002021;
#[doc = " @brief Defines the margin of the scrollbar.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: start margin of the scrollbar, in vp. The default value is <b>0</b>. \\n\n .value[1].f32: end margin of the scrollbar, in vp. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: start margin of the scrollbar, in vp. \\n\n .value[1].f32: end margin of the scrollbar, in vp. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BAR_MARGIN: ArkUI_NodeAttributeType = 1002022;
#[doc = " @brief Sets the maximum zoom scale for scrollable content.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: maximum zoom scale to set. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: current maximum zoom scale. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_MAX_ZOOM_SCALE: ArkUI_NodeAttributeType = 1002023;
#[doc = " @brief Sets the minimum zoom scale for scrollable content.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum zoom scale to set. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: current minimum zoom scale. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_MIN_ZOOM_SCALE: ArkUI_NodeAttributeType = 1002024;
#[doc = " @brief Sets the zoom scale for scrollable content.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: zoom scale to set. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: current zoom scale. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_ZOOM_SCALE: ArkUI_NodeAttributeType = 1002025;
#[doc = " @brief Sets whether to enable the zoom bounce effect when the scaling exceeds the limits.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the zoom bounce effect when the scaling exceeds the limits.\n The value <b>1</b> means to enable the effect, and <b>0</b> means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable the zoom bounce effect when the scaling exceeds the limits.\n The value <b>1</b> means to enable the effect, and <b>0</b> means the opposite. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_ENABLE_BOUNCES_ZOOM: ArkUI_NodeAttributeType =
    1002026;
#[doc = " @brief Sets the direction in which the list items are arranged.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: direction in which the list items are arranged. The parameter type is {@link ArkUI_Axis}.\n The default value is <b>ARKUI_AXIS_VERTICAL</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: direction in which the list items are arranged. The parameter type is {@link ArkUI_Axis}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_DIRECTION: ArkUI_NodeAttributeType = 1003000;
#[doc = " @brief Defines whether to pin the header to the top or the footer to the bottom in the <b><ListItemGroup></b>\n component. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to pin the header to the top or the footer to the bottom in the <b><ListItemGroup></b>\n component. It is used together with the <b><ListItemGroup></b> component. The parameter type is\n {@link ArkUI_StickyStyle}. The default value is <b>ARKUI_STICKY_STYLE_NONE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to pin the header to the top or the footer to the bottom in the <b><ListItemGroup></b>\n component. It is used together with the <b><ListItemGroup></b> component. The parameter type is\n {@link ArkUI_StickyStyle}.\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_STICKY: ArkUI_NodeAttributeType = 1003001;
#[doc = " @brief Defines the spacing between list items. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: spacing between list items along the main axis. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: spacing between list items along the main axis. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_SPACE: ArkUI_NodeAttributeType = 1003002;
#[doc = " @brief Defines the list adapter. The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_NODE_ADAPTER: ArkUI_NodeAttributeType = 1003003;
#[doc = " @brief Sets the number of cached items in the list adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of cached items in the list adapter. \\n\n .value[1]?.i32: whether to show cached items. The value <b>0</b> means to hide cached items, and <b>0</b> means\n to show cached items. The default value is <b>0</b>. This parameter is supported since API version 15. \\n\n .value[2]?.i32: maximum cache count. This parameter is supported since API version 22.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of cached items in the list adapter. \\n\n .value[1].i32: whether to show cached items. The value <b>0</b> means to hide cached items, and <b>0</b> means\n to show cached items. This parameter is supported since API version 15. \\n\n .value[2].i32: maximum cache count. This parameter is supported since API version 22.\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_CACHED_COUNT: ArkUI_NodeAttributeType = 1003004;
#[doc = " @brief Scroll to the specified index.\n\n When activating the smooth animation, all items passed through will be loaded and layout calculated, which can\n lead to performance issues when loading a large number of items.\\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32The index value of the target element to be slid to in the current container.\\n\n .value[1]?.i32Set whether there is an action when sliding to the index value of a list item in the list, where\n 1 indicates an action and 0 indicates no action. Default value: 0\\n\n .value[2]?.i32Specify the alignment of the sliding element with the current container,The parameter type is\n {@link ArkUI_ScrollAlignment}, default value is ARKUI_SCROLL_ALIGNMENT_START. \\n\n .value[3]?.f32: extra offset, in vp. The default value is <b>0</b>.\n This parameter is supported since API version 15. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_SCROLL_TO_INDEX: ArkUI_NodeAttributeType = 1003005;
#[doc = " @brief Sets the alignment mode of list items along the cross axis when the cross-axis width of the list is\n greater than the cross-axis width of list items multiplied by the value of lanes.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode of list items along the cross axis.\n The parameter type is {@link ArkUI_ListItemAlignment}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode of list items along the cross axis.\n The parameter type is {@link ArkUI_ListItemAlignment}. \\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ALIGN_LIST_ITEM: ArkUI_NodeAttributeType = 1003006;
#[doc = " @brief Set the default spindle size for the List subcomponent.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: The parameter format is {@ ArkUI-ListChildrenMainSize} \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: The parameter format is {@ ArkUI-ListChildrenMainSize} \\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_CHILDREN_MAIN_SIZE: ArkUI_NodeAttributeType = 1003007;
#[doc = " @brief Set the index value of the item displayed at the start of the viewport\n when the current List is first loaded.This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: index value of the item displayed at\n the start of the viewport when the current List is loaded for the first time. Default value: 0.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: index value of the item displayed at\n the start of the viewport when the current List is loaded for the first time. Default value: 0.\\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_INITIAL_INDEX: ArkUI_NodeAttributeType = 1003008;
#[doc = " @brief sets the ListItem splitter style. By default, there is no splitter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} Format: \\n\n.value[0].u32: divider color, type 0xargb; \\n\n.value[1].f32: dividing line width; \\n\n.value[2].f32: the distance between the divider and the beginning of the side of the list, unit vp; \\n\n.value[3].f32: the distance between the divider and the end of the side of the list (unit: vp). \\n\n \\n\n Attribute fetch method return value {@link ArkUI_AttributeItem} format: \\n\n.value[0].u32: divider color, type 0xargb; \\n\n.value[1].f32: dividing line width; \\n\n.value[2].f32: the distance between the divider and the beginning of the side of the list, unit vp; \\n\n.value[3].f32: the distance between the divider and the end of the side of the list (unit: vp). \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_DIVIDER: ArkUI_NodeAttributeType = 1003009;
#[doc = " @brief Scrolls to the item with the specified index in the specified list item group.\n\n When <b>smooth</b> is set to <b>true</b>, all passed items are loaded and counted in layout calculation.\n This may result in performance issues if a large number of items are involved. \\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: index of the target list item group in the current list. \\n\n.value[1].i32: index of the target list item in the list item group. \\n\n .value[2]?.i32: whether to enable the smooth animation for scrolling to the item with the specified index.\n The value <b>1</b> means to enable the animation, and <b>0</b> means the opposite.\n The default value is <b>0</b>. \\n\n .value[3]?.i32: how the item to scroll to is aligned with the container. The parameter type is\n {@link ArkUI_ScrollAlignment}. The default value is <b>ARKUI_SCROLL_ALIGNMENT_START</b>. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_LIST_SCROLL_TO_INDEX_IN_GROUP: ArkUI_NodeAttributeType =
    1003010;
#[doc = " @brief Sets the number of lanes in the list.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: number of lanes in the list. If the maximum and minimum lane widths are set, setting the number\n of lanes will not take effect. \\n\n .value[1]?.f32: minimum lane width, in vp. \\n\n .value[2]?.f32: maximum column width, in vp. \\n\n .value[3]?.f32: lane spacing, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: number of lanes in the list. \\n\n .value[1].f32: minimum lane width, in vp. \\n\n .value[2].f32: maximum column width, in vp. \\n\n .value[3].f32: lane spacing, in vp. \\n \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_LIST_LANES: ArkUI_NodeAttributeType = 1003011;
#[doc = " @brief Sets the list snap alignment mode.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode for the list snap position. The parameter type is {@link ArkUI_ScrollSnapAlign}.\n The default value is <b>ARKUI_SCROLL_SNAP_ALIGN_NONE</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n.value[0].i32: alignment mode for the list snap position. The parameter type is {@link ArkUI_ScrollSnapAlign}.\\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_LIST_SCROLL_SNAP_ALIGN: ArkUI_NodeAttributeType = 1003012;
#[doc = " @brief Sets whether to maintain the visible content's position when data is inserted or deleted outside the\n display area of the <b>List</b> component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to maintain the visible content's position when data is inserted or deleted outside the\n display area of the <b>List</b> component. The value <b>0</b> means not to maintain the visible content's\n position, and <b>1</b> means the opposite. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to maintain the visible content's position when data is inserted or deleted outside the\n display area of the <b>List</b> component. The value <b>0</b> means not to maintain the visible content's\n position, and <b>1</b> means the opposite. The default value is <b>0</b>. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_LIST_MAINTAIN_VISIBLE_CONTENT_POSITION:
    ArkUI_NodeAttributeType = 1003013;
#[doc = " @brief Sets whether the <b>List</b> component starts layout from the end.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the <b>List</b> component starts layout from the end. The value <b>0</b> means layout\n starts from the top, and <b>1</b> means layout starts from the end. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the <b>List</b> component starts layout from the end. The value <b>0</b> means layout\n starts from the top, and <b>1</b> means layout starts from the end. The default value is <b>0</b>. \\n\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const ArkUI_NodeAttributeType_NODE_LIST_STACK_FROM_END: ArkUI_NodeAttributeType = 1003014;
#[doc = " @brief Defines the focus wrap mode for the <b>List</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: focus wrap mode of the <b>List</b> component.\n                The parameter type is {@link ArkUI_FocusWrapMode}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: focus wrap mode of the <b>List</b> component.\n                The parameter type is {@link ArkUI_FocusWrapMode}. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_LIST_FOCUS_WRAP_MODE: ArkUI_NodeAttributeType = 1003015;
#[doc = " @brief Defines whether the <b>List</b> component loads child nodes synchronously.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the <b>List</b> component synchronously loads child nodes.\n The value <b>0</b> means loading by frames, and <b>1</b> means synchronous loading. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the <b>List</b> component synchronously loads child nodes.\n The value <b>0</b> means loading by frames, and <b>1</b> means synchronous loading. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_LIST_SYNC_LOAD: ArkUI_NodeAttributeType = 1003016;
#[doc = " @brief Defines the scroll snap animation speed for the <b>List</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n.value[0].i32: scroll snap animation speed for the <b>List</b> component.\n The parameter type is {@link ArkUI_ScrollSnapAnimationSpeed}.\n Default value: <b>ARKUI_SCROLL_SNAP_ANIMATION_NORMAL</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n.value[0].i32: scroll snap animation speed for the <b>List</b> component.\n The parameter type is {@link ArkUI_ScrollSnapAnimationSpeed}. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_LIST_SCROLL_SNAP_ANIMATION_SPEED: ArkUI_NodeAttributeType =
    1003017;
#[doc = " @brief Specifies the responsive column layout policy for the <b>List</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of columns at different breakpoint specifications.\n The data type is {@link ArkUI_ItemFillPolicy}. \\n\n .value[1]?.f32: column spacing. unit: vp. Default value: <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of columns at different breakpoint specifications.\n The data type is {@link ArkUI_ItemFillPolicy}. \\n\n .value[1].f32: column spacing. unit: vp. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_LIST_LANES_ITEMFILLPOLICY: ArkUI_NodeAttributeType = 1003018;
#[doc = " @brief Defines whether to enable loop playback for the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable loop playback. The value <b>1</b> means to enable loop playback, and <b>0</b>\n means the opposite. The default value is <b>1/b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable loop playback. The value <b>1</b> means to enable loop playback, and <b>0</b>\n means the opposite. The default value is <b>1</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_LOOP: ArkUI_NodeAttributeType = 1001000;
#[doc = " @brief Defines whether to enable automatic playback for child component switching in the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable automatic playback for child component switching. The value <b>1</b>\n means to enable automatic playback, and <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n \\n\n .value[1]?.i32: whether to stop automatic playback when the user touches the screen. The value <b>1</b> means\n to stop automatic playback, and <b>0</b> means the opposite. The default value is <b>1</b>. This parameter is\n supported since API version 16. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable automatic playback for child component switching. The value <b>1</b> means\n to enable automatic playback, and <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n .value[1].i32: whether to stop automatic playback when the user touches the screen. The value <b>1</b> means to\n stop automatic playback, and <b>0</b> means the opposite. This parameter is supported since API version 16. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_AUTO_PLAY: ArkUI_NodeAttributeType = 1001001;
#[doc = " @brief Defines whether to enable the navigation point indicator for the swiper. This attribute can be set,\n reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the navigation point indicator. The value <b>1</b> means to enable the\n navigation point indicator, and <b>0</b> means the opposite. The default value is <b>1</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable the navigation point indicator. The value <b>1</b> means to enable the\n navigation point indicator, and <b>0</b> means the opposite. The default value is <b>1</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_SHOW_INDICATOR: ArkUI_NodeAttributeType = 1001002;
#[doc = " @brief Defines the interval for automatic playback. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: interval for automatic playback, in milliseconds. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: interval for automatic playback, in milliseconds. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_INTERVAL: ArkUI_NodeAttributeType = 1001003;
#[doc = " @brief Defines whether vertical swiping is used for the swiper. This attribute can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether vertical swiping is used. The value <b>1</b> means that vertical swiping is used, and\n <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether vertical swiping is used. The value <b>1</b> means that vertical swiping is used, and\n <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_VERTICAL: ArkUI_NodeAttributeType = 1001004;
#[doc = " @brief Defines the duration of the animation for switching child components. This attribute can be set, reset,\n and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: duration of the animation for switching child components, in milliseconds. The default value is\n <b>400</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: duration of the animation for switching child components, in milliseconds. The default value is\n <b>400</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_DURATION: ArkUI_NodeAttributeType = 1001005;
#[doc = " @brief Defines the animation curve for the swiper. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: animation curve. The parameter type is {@link ArkUI_AnimationCurve}.\n The default value is <b>ARKUI_CURVE_LINEAR</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: animation curve. The parameter type is {@link ArkUI_AnimationCurve}.\n The default value is <b>ARKUI_CURVE_LINEAR</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_CURVE: ArkUI_NodeAttributeType = 1001006;
#[doc = " @brief Defines the spacing between child components in the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: spacing between child components. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: spacing between child components. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_ITEM_SPACE: ArkUI_NodeAttributeType = 1001007;
#[doc = " @brief Defines the index of the child component currently displayed in the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: index value of the child component. \\n\n .value[1]?.i32: animation mode, the parameter type is {@link ArkUI_SwiperAnimationMode}. \\n\n The default value is ARKUI_SWIPER_NO_ANIMATION. This parameter is valid only for the current call. \\n\n This parameter is supported since API version 15. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: index value of the child component. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_INDEX: ArkUI_NodeAttributeType = 1001008;
#[doc = " @brief Defines the number of elements to display per page.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of elements to display per page. \\n\n .value[1]?.i32: whether to turn pages by group. The value <b>0</b> means to turn pages by child element,\n and <b>1</b> means to turn pages by group. This parameter is supported since API version 19. \\n\n .string?: this parameter can only be set to 'auto'. When 'auto' is set, the value[] parameters are ignored.\n This parameter is supported since API version 19. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of elements to display per page. \\n\n .value[1].i32: whether to turn pages by group. This parameter is supported since API version 19. \\n\n .string: 'auto' or empty string.\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_DISPLAY_COUNT: ArkUI_NodeAttributeType = 1001009;
#[doc = " @brief Defines whether to disable the swipe feature.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to disable the swipe feature. The value <b>1</b> means to disable\n the swipe feature, and <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to disable the swipe feature. The value <b>1</b> means to disable the swipe\n feature, and <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_DISABLE_SWIPE: ArkUI_NodeAttributeType = 1001010;
#[doc = " @brief Defines whether to show the arrow when the mouse pointer hovers over the navigation point indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show the arrow when the mouse pointer hovers over the navigation point indicator.\n The parameter type is {@link ArkUI_SwiperArrow}.\\n\n The default value is <b>ARKUI_SWIPER_ARROW_HIDE</b>. \\n\n .?object: arrow style. The parameter type is {@link ArkUI_SwiperArrowStyle}. \\n\n This parameter is supported since API version 19. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to show the arrow when the mouse pointer hovers over the navigation point indicator.\n The parameter type is {@link ArkUI_SwiperArrow}.\\n\n The default value is <b>ARKUI_SWIPER_ARROW_HIDE</b>. \\n\n .object: arrow style. The parameter type is {@link ArkUI_SwiperArrowStyle}. \\n\n This parameter is supported since API version 19. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_SHOW_DISPLAY_ARROW: ArkUI_NodeAttributeType = 1001011;
#[doc = " @brief Defines the effect used at the edges of the swiper when the boundary of the scrollable content is reached.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: effect used at the edges of the swiper when the boundary of the scrollable content is reached.\n The parameter type is {@link ArkUI_EdgeEffect}.\\n\n The default value is <b>ARKUI_EDGE_EFFECT_SPRING</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: effect used at the edges of the swiper when the boundary of the scrollable content is reached.\n The parameter type is {@link ArkUI_EdgeEffect}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_EDGE_EFFECT_MODE: ArkUI_NodeAttributeType = 1001012;
#[doc = " @brief Defines the swiper adapter. The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_NODE_ADAPTER: ArkUI_NodeAttributeType = 1001013;
#[doc = " @brief Sets the number of cached items in the swiper adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of cached items in the swiper adapter. \\n\n .value[1]?.i32: whether the cached items will be displayed. \\n\n The value <b>0</b> indicates that cached items will not be displayed, \\n\n and <b>1</b> indicates that cached nodes will be displayed. The default value is <b>0</b>. \\n\n This parameter is supported from API version 19. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of cached items in the swiper adapter. \\n\n .value[1].i32: whether the cached items will be displayed. This parameter is supported from API version 19. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_CACHED_COUNT: ArkUI_NodeAttributeType = 1001014;
#[doc = " @brief Defines the front margin of the wiper.\n The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: the front margin. The unit is vp. The default value is <b>0.0</b>\\n\n .value[1]?.i32: whether to ignore blanks, the default value is 0.\n The value <b>1</b> means to ignore blank areas, and <b>0</b> means the opposite. \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: the front margin, the unit is vp. \\n\n .value[1].i32: whether to ignore blank areas. The value <b>1</b> means to ignore blank areas, and <b>0</b> means\n the opposite. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_PREV_MARGIN: ArkUI_NodeAttributeType = 1001015;
#[doc = " @brief Defines the back margin of the wiper.\n The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: the back margin. The unit is vp. The default value is <b>0.0</b>\\n\n .value[1]?.i32: whether to ignore blanks, the default value is 0.\n The value <b>1</b> means to ignore blank areas, and <b>0</b> means the opposite. \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: the back margin, the unit is vp. \\n\n .value[1].i32: whether to ignore blank areas. The value <b>1</b> means to ignore blank areas, and <b>0</b> means\n the opposite. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_NEXT_MARGIN: ArkUI_NodeAttributeType = 1001016;
#[doc = " @brief Defines the navigation indicator type of the swiper.\n The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: navigation indicator type, the parameter type is {@link ArkUI_SwiperIndicatorType}.\\n\n .object: The parameter type is {@link ArkUI_SwiperIndicator} when the indicator type \\n\n is <b>ARKUI_SWIPER_INDICATOR_TYPE_DOT</b>. The parameter type is {@link ArkUI_SwiperDigitIndicator}\n when the indicator type is <b>ARKUI_SWIPER_INDICATOR_TYPE_DIGIT</b>. \\n\n {@link ArkUI_SwiperDigitIndicator} is supported since API version 19. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: navigation indicator type, the parameter type is {@link ArkUI_SwiperIndicatorType}.\\n\n .object: The parameter type is {@link ArkUI_SwiperIndicator} when the indicator type \\n\n is <b>ARKUI_SWIPER_INDICATOR_TYPE_DOT</b>. The parameter type is {@link ArkUI_SwiperDigitIndicator}\n when the indicator type is <b>ARKUI_SWIPER_INDICATOR_TYPE_DIGIT</b>. \\n\n {@link ArkUI_SwiperDigitIndicator} is supported since API version 19. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_INDICATOR: ArkUI_NodeAttributeType = 1001017;
#[doc = " @brief Set the nested scrolling mode for the Swiper component and parent component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32Nested scrolling patterns for Swiper components and parent components. The parameter type is\n {@link ArkUI_SwiperNestedScrollMode} \\n\n The default value is <b>ARKUI_SWIPER_NESTED_SRCOLL_SELF_ONLY<b> \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32Nested scrolling patterns for Swiper components and parent components. The parameter type is\n {@link ArkUI_SwiperNestedScrollMode} \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_NESTED_SCROLL: ArkUI_NodeAttributeType = 1001018;
#[doc = " @brief Set the switcher component to flip to the specified page.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32Specify the index value of the page in Swiper.\\n\n .value[1]?.i32Set whether there is an animation effect when flipping to the specified page. 1 indicates active\n effect, 0 indicates no active effect, default value is 0\\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_SWIPE_TO_INDEX: ArkUI_NodeAttributeType = 1001019;
#[doc = " @brief Set to disable component navigation point interaction function\n\n Property setting method parameter {@link ArkUI-AttributeItem} format: \\n\n .value[0].i32Set to disable the interaction function of component navigation points. When set to true, it\n indicates that the navigation points are interactive. The default value is true. \\n\n The return value of the attribute acquisition method is in the format of {@ link ArkUI-AttributeItem} \\n\n .value[0].i32Set to disable component navigation point interaction. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_INDICATOR_INTERACTIVE: ArkUI_NodeAttributeType =
    1001020;
#[doc = " @brief Sets the page flipping mode using the mouse wheel.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: page flipping mode using the mouse wheel. The parameter type is {@link ArkUI_PageFlipMode}. \\n\n \\n\n Format of the return value {@link ArkUI_PageFlipMode}:\\n\n .value[0].i32: page flipping mode using the mouse wheel. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_PAGE_FLIP_MODE: ArkUI_NodeAttributeType = 1001021;
#[doc = " @brief Defines the minimum main axis size of child element for swiper to works out the display count.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum main axis size of the child element, Unit: vp. \\n\n .value[1]?.i32: whether to turn pages by group. The value <b>0</b> means to turn pages by child element,\n and <b>1</b> means to turn pages by group. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum main axis size of the child element, Unit: vp. \\n\n .value[1].i32: whether to turn pages by group. \\n\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_AUTO_FILL: ArkUI_NodeAttributeType = 1001022;
#[doc = " @brief Sets whether to maintain the visible content's position when data is inserted or deleted outside\n the display area of the <b>Swiper</b> component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to maintain the visible content's position when data is inserted or deleted outside\n the display area of the <b>Swiper</b> component. The value <b>0</b> means not to maintain the visible content's\n position, and <b>1</b> means the opposite. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to maintain the visible content's position when data is inserted or deleted outside\n the display area of the <b>Swiper</b> component. The value <b>0</b> means not to maintain the visible content's\n position, and <b>1</b> means the opposite. The default value is <b>0</b>. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_MAINTAIN_VISIBLE_CONTENT_POSITION:
    ArkUI_NodeAttributeType = 1001023;
#[doc = " @brief Specifies the responsive column layout policy for the <b>Swiper</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: number of columns at different breakpoint specifications.\n The data type is {@link ArkUI_ItemFillPolicy}. \\n\n .value[1]?.i32: whether to paginate by group. The value <b>0</b> means to paginate by individual child elements,\n and <b>1</b> means to paginate by groups of child elements displayed within the viewport.\n The default value is <b>0</b>.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].i32: number of columns at different breakpoint specifications.\n The data type is {@link ArkUI_ItemFillPolicy}. \\n\n .value[1].i32: whether to paginate by group. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_ITEMFILLPOLICY: ArkUI_NodeAttributeType = 1001024;
#[doc = " @brief: Set the delineation component of the ListItem, supporting property settings, property resets, and\n property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .object: Construct using the {@link ArkUI_ListitemSwipeActionOption} object. \\n\n \\n\n The return value of the attribute acquisition method {@link ArkUI_AttributeItem} format: \\n\n .object: Construct using the {@link ArkUI_ListitemSwipeActionOption} object. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_SWIPE_ACTION: ArkUI_NodeAttributeType = 1004000;
#[doc = " @brief Defines the header of the list item group.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeHandle} object to be used as the header of the list item group. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: {@link ArkUI_NodeHandle} object to be used as the header of the list item group. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_SET_HEADER: ArkUI_NodeAttributeType =
    1005000;
#[doc = " @brief Defines the footer of the list item group. This attribute can be set, reset, and obtained as\n required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeHandle} object to be used as the footer of the list item group. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: {@link ArkUI_NodeHandle} object to be used as the footer of the list item group. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_SET_FOOTER: ArkUI_NodeAttributeType =
    1005001;
#[doc = " @brief Defines the style of the divider for the list items. This attribute can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the divider, in 0xARGB format.\\n\n .value[1].f32: stroke width of the divider, in vp.\\n\n .value[2].f32: distance between the divider and the start of the list, in vp.\\n\n .value[3].f32: distance between the divider and the end of the list, in vp.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the divider, in 0xARGB format.\\n\n .value[1].f32: stroke width of the divider, in vp.\\n\n .value[2].f32: distance between the divider and the start of the list, in vp.\\n\n .value[3].f32: distance between the divider and the end of the list, in vp.\\n \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_SET_DIVIDER: ArkUI_NodeAttributeType =
    1005002;
#[doc = " @brief Set the default spindle size for the ListItem Group subcomponent.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: The parameter format is {@ ArkUI-ListChildrenMainSize} \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: The parameter format is {@ ArkUI-ListChildrenMainSize} \\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_CHILDREN_MAIN_SIZE: ArkUI_NodeAttributeType =
    1005003;
#[doc = " @brief Defines the list item group adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: {@link ArkUI_NodeAdapter} object. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_NODE_ADAPTER: ArkUI_NodeAttributeType =
    1005004;
#[doc = " @brief Defines the horizontal alignment mode of child components in the column.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: horizontal alignment mode of child components.\n The parameter type is {@link ArkUI_HorizontalAlignment}.\\n\n Default value: <b>ARKUI_HORIZONTAL_ALIGNMENT_CENTER</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: horizontal alignment mode of child components.\n The parameter type is {@link ArkUI_HorizontalAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_COLUMN_ALIGN_ITEMS: ArkUI_NodeAttributeType = 1006000;
#[doc = " @brief Defines the vertical alignment mode of child components in the column.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: vertical alignment mode of child components. The parameter type is {@link ArkUI_FlexAlignment}.\\n\n Default value: <b>ARKUI_FLEX_ALIGNMENT_START</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: vertical alignment mode of child components. The parameter type is {@link ArkUI_FlexAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_COLUMN_JUSTIFY_CONTENT: ArkUI_NodeAttributeType = 1006001;
#[doc = " @brief Defines the vertical alignment mode of child components in the row.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: vertical alignment mode of child components.\n The parameter type is {@link ArkUI_VerticalAlignment}.\\n\n Default value: <b>ARKUI_VERTICAL_ALIGNMENT_CENTER</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: vertical alignment mode of child components.\n The parameter type is {@link ArkUI_VerticalAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ROW_ALIGN_ITEMS: ArkUI_NodeAttributeType = 1007000;
#[doc = " @brief Defines the horizontal alignment mode of child components in the row.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: horizontal alignment mode of child components.\n The parameter type is {@link ArkUI_FlexAlignment}.\\n\n Default value: <b>ARKUI_FLEX_ALIGNMENT_START</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: horizontal alignment mode of child components.\n The parameter type is {@link ArkUI_FlexAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ROW_JUSTIFY_CONTENT: ArkUI_NodeAttributeType = 1007001;
#[doc = " @brief Defines the flex attribute. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.i32: direction in which flex items are arranged. The parameter type is {@link ArkUI_FlexDirection}.\n The default value is <b>ARKUI_FLEX_DIRECTION_ROW</b>.\\n\n .value[1]?.i32: how the flex items are wrapped. The parameter type is {@link ArkUI_FlexWrap}.\n The default value is <b>ARKUI_FLEX_WRAP_NO_WRAP</b>.\\n\n .value[2]?.i32: alignment mode along the main axis. The parameter type is {@link ArkUI_FlexAlignment}.\n The default value is <b>ARKUI_FLEX_ALIGNMENT_START</b>.\\n\n .value[3]?.i32: alignment mode along the cross axis. The parameter type is {@link ArkUI_ItemAlignment}.\n The default value is <b>ARKUI_ITEM_ALIGNMENT_START</b>.\\n\n .value[4]?.i32: alignment mode along the cross axis for multi-line content. The parameter type is\n {@link ArkUI_FlexAlignment}. The default value is <b>ARKUI_FLEX_ALIGNMENT_START</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: direction in which flex items are arranged. \\n\n .value[1].i32: how the flex items are wrapped. \\n\n .value[2].i32: alignment mode along the main axis. \\n\n .value[3].i32: alignment mode along the cross axis. \\n\n .value[4].i32: alignment mode along the cross axis for multi-line content.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FLEX_OPTION: ArkUI_NodeAttributeType = 1008000;
#[doc = " @brief Sets whether the component is being refreshed.\n This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_REFRESHING: ArkUI_NodeAttributeType = 1009000;
#[doc = " @brief Sets the custom content in the pull-down area.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: The parameter type is {@Link ArkUI_NodeHandle}.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_CONTENT: ArkUI_NodeAttributeType = 1009001;
#[doc = " @brief Set the pull-down hand coefficient.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32Pull-down hand coefficient, valid value between 0 and 1.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32Pull-down hand coefficient, valid value between 0 and 1.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_PULL_DOWN_RATIO: ArkUI_NodeAttributeType = 1009002;
#[doc = " @brief Sets the pull-down offset that initiates a refresh.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: pull-down offset, in vp. The default value is <b>64vp</b>.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: pull-down offset, in vp. The default value is <b>64vp</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_OFFSET: ArkUI_NodeAttributeType = 1009003;
#[doc = " @brief Sets whether to initiate a refresh when the pull-down distance exceeds the value of <b>refreshOffset</b>.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to initiate a refresh. The value <b>true</b> means to initiate a refresh, and\n <b>false</b> means the opposite.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to initiate a refresh. The value <b>1</b> means to initiate a refresh, and\n <b>0</b> means the opposite.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_PULL_TO_REFRESH: ArkUI_NodeAttributeType = 1009004;
#[doc = " @brief Sets the maximum pull-down distance for refreshing.\n This attribute can be set, reset, and obtained through the API as required.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: maximum pull-down distance, in vp.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: maximum pull-down distance, in vp.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_MAX_PULL_DOWN_DISTANCE: ArkUI_NodeAttributeType =
    1009005;
#[doc = " @brief Defines the main axis direction of the <b><WaterFlow></b> component layout.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: main axis direction. The parameter type is {@Link ArkUI_FlexDirection}.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: main axis direction. The parameter type is {@Link ArkUI_FlexDirection}.\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_LAYOUT_DIRECTION: ArkUI_NodeAttributeType =
    1010000;
#[doc = " @brief Sets the number of columns in the water flow layout. If this parameter is not set, one column is used\n by default. This attribute can be set, reset, and obtained as required through APIs.\n For example, <b>'1fr 1fr 2fr'</b> indicates three columns, with the first column taking up 1/4 of the parent\n component's full width, the second column 1/4, and the third column 2/4.\n You can use <b>columnsTemplate('repeat(auto-fill,track-size)')</b> to automatically calculate the number of\n columns based on the specified column width <b>track-size</b>.\n <b>repeat</b> and <b>auto-fill</b> are keywords. The units for <b>track-size</b> can be px, vp (default), %,\n or a valid number.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: number of columns in the layout.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: number of columns in the layout.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_COLUMN_TEMPLATE: ArkUI_NodeAttributeType =
    1010001;
#[doc = " @brief Sets the number of rows in the water flow layout. If this parameter is not set, one row is used\n by default. This attribute can be set, reset, and obtained as required through APIs.\n For example, <b>'1fr 1fr 2fr'</b> indicates three rows, with the first row taking up 1/4 of the parent\n component's full height, the second row 1/4, and the third row 2/4.\n You can use <b>rowsTemplate('repeat(auto-fill,track-size)')</b> to automatically calculate the number of rows\n based on the specified row height <b>track-size</b>.\n <b>repeat</b> and <b>auto-fill</b> are keywords. The units for <b>track-size</b> can be px, vp (default), %,\n or a valid number.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: number of rows in the layout. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: number of rows in the layout. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_ROW_TEMPLATE: ArkUI_NodeAttributeType = 1010002;
#[doc = " @brief Sets the gap between columns.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: gap between columns, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: gap between columns, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_COLUMN_GAP: ArkUI_NodeAttributeType = 1010003;
#[doc = " @brief Sets the gap between rows.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: gap between lines, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: gap between lines, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_ROW_GAP: ArkUI_NodeAttributeType = 1010004;
#[doc = " @brief Defines the water flow section configuration.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: An index calculated from 0 is converted to an integer,\n indicating that you want to start changing the position of the group.\n .object: {@ArkUI_WaterFlowSectionOption} object.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: {@ArkUI_WaterFlowSectionOption} object.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_SECTION_OPTION: ArkUI_NodeAttributeType = 1010005;
#[doc = " @brief Defines the water flow adapter. The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_NODE_ADAPTER: ArkUI_NodeAttributeType = 1010006;
#[doc = " @brief Sets the number of cached items in the water flow adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n value[0].i32number of cached items in the water flow adapter. \\n\n .value[1]?.i32whether to the cached items will be displayed, 0: not displayed, 1: displayed, default value: 0.\n This parameter is supported since API version 16. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of cached items in the water flow adapter. \\n\n .value[1].i32: whether to the cached items will be displayed, 0: not displayed, 1: displayed, default value: 0.\n This parameter is supported since API version 16. \\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_CACHED_COUNT: ArkUI_NodeAttributeType = 1010007;
#[doc = " @brief Set the custom display component at the end of the waterfall flow component.\n\n Attribute setting method {@link ArkUI_AttributeItem} parameter format: \\n\n .object: Parameter type {@link ArkUI_NodeHandle}.\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_FOOTER: ArkUI_NodeAttributeType = 1010008;
#[doc = " @brief Scroll to the specified index.\n\n When activating the smooth animation, all items passed through will be loaded and layout calculated, which can\n lead to performance issues when loading a large number of items.\\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32The index value of the target element to be slid to in the current container.\\n\n .value[1]?.i32Set whether there is an action when sliding to the index value of a list item in the list, where\n 1 indicates an action and 0 indicates no action. Default value is 0\\n\n .value[2]?.i32Specify the alignment of the sliding element with the current containerThe parameter type is\n {@link ArkUI_ScrollAlignment}. Default value is </b>ARKUI_SCROLL_ALIGNMENT_START</b>\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_SCROLL_TO_INDEX: ArkUI_NodeAttributeType =
    1010009;
#[doc = " @brief Defines the size constraints to apply to water flow items.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum width, in vp.\\n\n .value[1].f32: maximum width, in vp.\\n\n .value[2].f32: minimum height, in vp.\\n\n .value[3].f32: maximum height, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum width, in vp.\\n\n .value[1].f32: maximum width, in vp.\\n\n .value[2].f32: minimum height, in vp.\\n\n .value[3].f32: maximum height, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_ITEM_CONSTRAINT_SIZE: ArkUI_NodeAttributeType =
    1010010;
#[doc = " @brief Defines the layout mode of the <b><WaterFlow></b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: waterflow layout mode. The parameter type is {@Link ArkUI_WaterFlowLayoutMode}.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: waterflow layout mode. The parameter type is {@Link ArkUI_WaterFlowLayoutMode}.\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_LAYOUT_MODE: ArkUI_NodeAttributeType = 1010011;
#[doc = " @brief Defines whether the <b>WaterFlow</b> component loads child nodes synchronously.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the <b>WaterFlow</b> component synchronously loads child nodes.\n The value <b>0</b> means loading by frames, and <b>1</b> means synchronous loading. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the <b>WaterFlow</b> component synchronously loads child nodes.\n The value <b>0</b> means loading by frames, and <b>1</b> means synchronous loading. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_SYNC_LOAD: ArkUI_NodeAttributeType = 1010012;
#[doc = " @brief Specifies the responsive column layout policy for the <b>WaterFlow</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of columns at different breakpoint specifications.\n The data type is {@link ArkUI_ItemFillPolicy}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of columns at different breakpoint specifications.\n The data type is {@link ArkUI_ItemFillPolicy}. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_COLUMN_TEMPLATE_ITEMFILLPOLICY:
    ArkUI_NodeAttributeType = 1010013;
#[doc = " @brief Set the auxiliary line in the RelativeContaine container, supporting property setting,\n property reset and property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .object: Auxiliary lines within the RelativeContaine container: \\n\n\\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .object: Auxiliary lines within the RelativeContaine container: \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RELATIVE_CONTAINER_GUIDE_LINE: ArkUI_NodeAttributeType =
    1012000;
#[doc = " @brief Sets the barrier within the RelativeContaine container and supports property setting,\n property reset and property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .object: Auxiliary lines within the RelativeContaine container: \\n\n\\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .object: Barrier within the RelativeContaine container: \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RELATIVE_CONTAINER_BARRIER: ArkUI_NodeAttributeType =
    1012001;
#[doc = " @brief Sets the number of columns in the grid layout. If this parameter is not set, one column is used\n by default. This attribute can be set, reset, and obtained as required through APIs.\n For example, <b>'1fr 1fr 2fr'</b> indicates three columns, with the first column taking up 1/4 of the parent\n component's full width, the second column 1/4, and the third column 2/4.\n You can use <b>columnsTemplate('repeat(auto-fill,track-size)')</b> to automatically calculate the number of\n columns based on the specified column width <b>track-size</b>.\n <b>repeat</b> and <b>auto-fill</b> are keywords. The units for <b>track-size</b> can be px, vp (default), %,\n or a valid number.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: number of columns in the layout.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: number of columns in the layout.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_COLUMN_TEMPLATE: ArkUI_NodeAttributeType = 1013000;
#[doc = " @brief Sets the number of rows in the grid layout. If this parameter is not set, one row is used\n by default. This attribute can be set, reset, and obtained as required through APIs.\n For example, <b>'1fr 1fr 2fr'</b> indicates three rows, with the first row taking up 1/4 of the parent\n component's full height, the second row 1/4, and the third row 2/4.\n You can use <b>rowsTemplate('repeat(auto-fill,track-size)')</b> to automatically calculate the number of rows\n based on the specified row height <b>track-size</b>.\n <b>repeat</b> and <b>auto-fill</b> are keywords. The units for <b>track-size</b> can be px, vp (default), %,\n or a valid number.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: number of rows in the layout. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: number of rows in the layout. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_ROW_TEMPLATE: ArkUI_NodeAttributeType = 1013001;
#[doc = " @brief Sets the gap between columns. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: gap between columns, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: gap between columns, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_COLUMN_GAP: ArkUI_NodeAttributeType = 1013002;
#[doc = " @brief Sets the gap between rows. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: gap between lines, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: gap between lines, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_ROW_GAP: ArkUI_NodeAttributeType = 1013003;
#[doc = " @brief Defines the grid adapter. The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_NODE_ADAPTER: ArkUI_NodeAttributeType = 1013004;
#[doc = " @brief Sets the number of cached items in the grid adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of cached items in the grid adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_CACHED_COUNT: ArkUI_NodeAttributeType = 1013005;
#[doc = " @brief Defines the focus wrap mode for the <b>Grid</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: focus wrap mode of the <b>Grid</b> component.\n                The parameter type is {@link ArkUI_FocusWrapMode}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: focus wrap mode of the <b>Grid</b> component.\n                The parameter type is {@link ArkUI_FocusWrapMode}. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_GRID_FOCUS_WRAP_MODE: ArkUI_NodeAttributeType = 1013006;
#[doc = " @brief Defines whether the <b>Grid</b> component loads child nodes synchronously.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the <b>Grid</b> component synchronously loads child nodes.\n The value <b>0</b> means loading by frames, and <b>1</b> means synchronous loading. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the <b>Grid</b> component synchronously loads child nodes.\n The value <b>0</b> means loading by frames, and <b>1</b> means synchronous loading. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_GRID_SYNC_LOAD: ArkUI_NodeAttributeType = 1013007;
#[doc = " @brief Specifies the alignment of <b>GridItem</b> components in the parent <b>Grid</b> container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment of <b>GridItem</b> components in the parent <b>Grid</b> container, \\n\n specified using the {@link ArkUI_GridItemAlignment} enum. \\n\n The default value is <b>GRID_ITEM_ALIGNMENT_DEFAULT</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment of <b>GridItem</b> components in the parent <b>Grid</b> container, \\n\n specified using the {@link ArkUI_GridItemAlignment} enum. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_GRID_ALIGN_ITEMS: ArkUI_NodeAttributeType = 1013008;
#[doc = " @brief Specifies the layout options of the <b>Grid</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .object: layout options, with the parameter format of {@link ArkUI_GridLayoutOptions}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: current {@link ArkUI_GridLayoutOptions} object. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_GRID_LAYOUT_OPTIONS: ArkUI_NodeAttributeType = 1013009;
#[doc = " @brief Specifies the responsive column layout policy for the <b>Grid</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of columns at different breakpoint specifications.\n The data type is {@link ArkUI_ItemFillPolicy}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of columns at different breakpoint specifications.\n The data type is {@link ArkUI_ItemFillPolicy}. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_GRID_COLUMN_TEMPLATE_ITEMFILLPOLICY:
    ArkUI_NodeAttributeType = 1013010;
#[doc = " @brief Sets the style of the <b>GridItem</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: style of the <b>GridItem</b> component, specified using {@link ArkUI_SliderStyle}. \\n\n The default value is <b>GRID_ITEM_STYLE_NONE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: style of the <b>GridItem</b> component, specified using {@link ArkUI_SliderStyle}. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeAttributeType_NODE_GRID_ITEM_STYLE: ArkUI_NodeAttributeType = 1014000;
#[doc = " @brief Defines the column width of the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: percentage of total width. The default value is that all colulmns are equal width.\\n\n .value[1]?.f32: percentage of total width. The default value is that all colulmns are equal width.\\n\n .value[2]?.f32: percentage of total width. The default value is that all colulmns are equal width.\\n\n ...\\n\n .value[n]?.f32: percentage of total width. The default value is that all colulmns are equal width.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].f32: percentage of total width.\\n\n value[1].f32: percentage of total width.\\n\n value[2].f32: percentage of total width.\\n\n ...\\n\n value[n].f32: percentage of total width.\\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_COLUMN_WIDTHS: ArkUI_NodeAttributeType = 15009;
#[doc = " @brief Defines the disabled date range of the calendar picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: A string of dates. The `1st start date`,`1st end date`,`2nd start date`,`2nd end date`,\n ...,`nth start date`,`nth end date` of the disabled date range.\\n\n  Example: 1910-01-01,1910-12-31,2020-01-01,2020-12-31\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: A string of dates.\\n\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_DISABLED_DATE_RANGE:
    ArkUI_NodeAttributeType = 16006;
#[doc = " @brief Defines whether the calendar picker marks today.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n value[0].i32: whether the calendar picker marks today. The default value is <b>false</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: whether the calendar picker marks today.\\n\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_MARK_TODAY: ArkUI_NodeAttributeType = 16007;
#[doc = " @brief Defines the want used to start EmbeddedAbility.\n This attribute can be set as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: The want of EmbeddedComponent, with parameter type {@AbilityBase_Want}.\n The default value is <b>nullptr</b>.\\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_EMBEDDED_COMPONENT_WANT: ArkUI_NodeAttributeType = 1016000;
#[doc = " @brief Set onError and onTerminated callbacks for EMBEDDED_COMPONENT.\n This attribute can be set as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: The option for EmbeddedComponent, with parameter type {@ArkUI_EmbeddedComponentOption}.\\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeAttributeType_NODE_EMBEDDED_COMPONENT_OPTION: ArkUI_NodeAttributeType = 1016001;
#[doc = " @brief Defines the ArkUI style attributes that can be set on the native side.\n\n @since 12"]
pub type ArkUI_NodeAttributeType = u32;
#[doc = " @brief Defines the parameter type of the component callback event.\n\n @since 12"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArkUI_NodeComponentEvent {
    #[doc = " Data array object."]
    pub data: [ArkUI_NumberValue; 12usize],
}
#[doc = " @brief Defines the string type parameter used by the component callback event.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_StringAsyncEvent {
    #[doc = " String."]
    pub pStr: *const ::std::os::raw::c_char,
}
#[doc = " @brief Defines a hybrid data structure for component events.\n\n @since 15"]
#[cfg(feature = "api-15")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TextChangeEvent {
    #[doc = " String data"]
    pub pStr: *const ::std::os::raw::c_char,
    #[doc = " Extended string data"]
    pub pExtendStr: *const ::std::os::raw::c_char,
    #[doc = " Numeric data"]
    pub number: i32,
}
#[doc = " @brief Defines the gesture event type.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}."]
pub const ArkUI_NodeEventType_NODE_TOUCH_EVENT: ArkUI_NodeEventType = 0;
#[doc = " @brief Defines the mount event.\n\n This event is triggered when the component is mounted and displayed. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_APPEAR: ArkUI_NodeEventType = 1;
#[doc = " @brief Defines the unmount event.\n\n This event is triggered when the component is unmounted and hidden. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_DISAPPEAR: ArkUI_NodeEventType = 2;
#[doc = " @brief Defines the area change event.\n\n This event is triggered when the component's size, position, or any other attribute that may\n affect its display area changes. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n  {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains 12 parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: original width of the target element, in vp.\n The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: original height of the target element, in vp.\n The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: original X coordinate of the target element's upper left corner\n relative to the parent element's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[3].f32</b>: original Y coordinate of the target element's upper left corner\n relative to the parent element's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[4].f32</b>: original X coordinate of the target element's upper left corner\n relative to the page's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[5].f32</b>: original Y coordinate of the target element's upper left corner\n relative to the page's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[6].f32</b>: new width of the target element, in vp. The value is a number. \\n\n <b>ArkUI_NodeComponentEvent.data[7].f32</b>: new height of the target element, in vp. The value is a number. \\n\n <b>ArkUI_NodeComponentEvent.data[8].f32</b>: new X coordinate of the target element's upper left corner relative\n to the parent element's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[9].f32</b>: new Y coordinate of the target element's upper left corner relative\n to the parent element's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[10].f32</b>: new X coordinate of the target element's upper left corner relative\n to the page's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[11].f32</b>: new Y coordinate of the target element's upper left corner relative\n to the page's, in vp. The value type is number. \\n"]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_AREA_CHANGE: ArkUI_NodeEventType = 3;
#[doc = " @brief Defines the focus event.\n\n This event is triggered when the component obtains the focus. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_ON_FOCUS: ArkUI_NodeEventType = 4;
#[doc = " @brief Defines the blur event.\n\n This event is triggered when the component loses the focus. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_ON_BLUR: ArkUI_NodeEventType = 5;
#[doc = " @brief Defines the click event.\n\n This event is triggered when the component is clicked. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains 12 parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: X coordinate of the click relative to the upper left corner of the\n clicked component's original area, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: Y coordinate of the click relative to the upper left corner of the\n clicked component's original area, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: event timestamp. It is the interval between the time when the event\n is triggered and the time when the system starts, in microseconds. \\n\n <b>ArkUI_NodeComponentEvent.data[3].i32</b>: event input device. The value <b>1</b> indicates the mouse,\n <b>2</b> indicates the touchscreen, and <b>4</b> indicates the key. \\n\n <b>ArkUI_NodeComponentEvent.data[4].f32</b>: X coordinate of the click relative to the upper left corner of the\n application window, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[5].f32</b>: Y coordinate of the click relative to the upper left corner of the\n application window, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[6].f32</b>: X coordinate of the click relative to the upper left corner of the\n application screen, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[7].f32</b>: Y coordinate of the click relative to the upper left corner of the\n application screen, in vp. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_CLICK: ArkUI_NodeEventType = 6;
#[doc = " @brief Defines event interception.\n\n This event is triggered when the component is touched. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_TOUCH_INTERCEPT: ArkUI_NodeEventType = 7;
#[doc = " @brief Defines the visible area change event.\n\n This event is triggered when the ratio of the component's visible area to its total area is greater than or less\n than the threshold.\n Before registering this event, you must set <b>NODE_VISIBLE_AREA_CHANGE_RATIO</b>. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: how the ratio of the component's visible area to its total area\n changes compared to the previous one. The value <b>1</b> indicates an increase, and <b>0</b> indicates a\n decrease. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: ratio of the component's visible area to its total area when this\n callback is invoked. \\n"]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_VISIBLE_AREA_CHANGE: ArkUI_NodeEventType = 8;
#[doc = " @brief Defines the event triggered when the mouse pointer is moved over or away from the component.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: whether the mouse pointer is hovered over the component.\n The value <b>1</b> indicates that the mouse pointer is hovered over the component, and <b>0</b> indicates that\n the mouse pointer is moved away from the component. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_HOVER: ArkUI_NodeEventType = 9;
#[doc = " @brief Defines the click event.\n\n This event is triggered when the component is clicked by a mouse device button or when the mouse pointer moves\n within the component. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_MOUSE: ArkUI_NodeEventType = 10;
#[doc = " @brief Defines the attach event.\n\n This event is triggered when the component is attached. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_ATTACH: ArkUI_NodeEventType = 11;
#[doc = " @brief Defines the detach event.\n\n This event is triggered when the component is detached. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_DETACH: ArkUI_NodeEventType = 12;
#[doc = " @brief Defines the accessibility action event.\n\n This event is triggered when The accessibility operation type has been set and\n corresponding operations have been carried out. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].u32</b>: accessibility action typethe union type is\n {@link ArkUI_AccessibilityActionType} \\n\n"]
pub const ArkUI_NodeEventType_NODE_ON_ACCESSIBILITY_ACTIONS: ArkUI_NodeEventType = 13;
#[doc = " @brief Notifies the listener of the interaction state prior to a drop and drop operation.\n\n This event is triggered when a drag operation is about to start on a draggable item. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: corresponds to {@link ArkUI_PreDragStatus}. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_PRE_DRAG: ArkUI_NodeEventType = 14;
#[doc = " @brief Called when the user starts to drag an ite\n\n A drag operation is recognized only when the dragged item is moved far enough. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_START: ArkUI_NodeEventType = 15;
#[doc = " @brief Called when a dragged item enters the boundaries of the current component.\n\n The current component refers to the component that listens for this event. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_ENTER: ArkUI_NodeEventType = 16;
#[doc = " @brief Called  when a dragged item moves in the current component.\n\n The current component refers to the component that listens for this event. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_MOVE: ArkUI_NodeEventType = 17;
#[doc = " @brief Called when a dragged item leaves the boundaries of the current component.\n\n The current component refers to the component that listens for this event. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_LEAVE: ArkUI_NodeEventType = 18;
#[doc = " @brief Called when a dragged item is dropped on the current component.\n The component can obtain the drag data for processing through the callback.\n\n The current component refers to the component that listens for this event. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DROP: ArkUI_NodeEventType = 19;
#[doc = " @brief Called when a drag operation ends.\n The drag source can obtain the drag result by registering this callback.\n\n A drag operation ends when the dragged item is released.\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_END: ArkUI_NodeEventType = 20;
#[doc = " @brief Defines the event triggered when a key event occurs.\n\n The callback can be triggered during interactions with a focused window using an external keyboard or other input\n device. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n\n @since 14"]
#[cfg(feature = "api-14")]
pub const ArkUI_NodeEventType_NODE_ON_KEY_EVENT: ArkUI_NodeEventType = 21;
#[doc = " @brief Defines the event triggered before the input method responds to the key action.\n\n If the return value of this callback is <b>true</b>, it is considered that the key event has been consumed, and\n subsequent event callbacks (<b>keyboardShortcut</b>, input method events, <b>onKeyEvent</b>) will be intercepted\n and no longer triggered.\n The callback can be triggered during interactions with a focused window using an external keyboard or other input\n device. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n\n @since 14"]
#[cfg(feature = "api-14")]
pub const ArkUI_NodeEventType_NODE_ON_KEY_PRE_IME: ArkUI_NodeEventType = 22;
#[doc = " @brief Defines the event triggered when the bound component receives a focus axis event after gaining focus.\n\n The event callback is triggered by interactions with a joystick and a focused component. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeEventType_NODE_ON_FOCUS_AXIS: ArkUI_NodeEventType = 23;
#[doc = " @brief Dispatch key event on the component node.\n\n When the component node receives a key event, this callback will be triggered instead of dispatching event to its\n children. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeEventType_NODE_DISPATCH_KEY_EVENT: ArkUI_NodeEventType = 24;
#[doc = " @brief Defines the event triggered when the bound component receives an axis event.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}. \\n\n\n @since 17"]
#[cfg(feature = "api-17")]
pub const ArkUI_NodeEventType_NODE_ON_AXIS: ArkUI_NodeEventType = 25;
#[doc = " @brief Defines the event triggered when the bound component is clicked.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}.  \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeEventType_NODE_ON_CLICK_EVENT: ArkUI_NodeEventType = 26;
#[doc = " @brief Defines the event triggered when the mouse pointer hovers over or moves away from a component.\n\n This event is triggered when the mouse pointer enters or leaves the component's bounding box. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}. \\n\n\n@since 17"]
#[cfg(feature = "api-17")]
pub const ArkUI_NodeEventType_NODE_ON_HOVER_EVENT: ArkUI_NodeEventType = 27;
#[doc = " @brief Sets the callback for the NODE_EVENT_ON_VISIBLE_AREA_CHANGE event, which limits the callback interval.\n\n The callback is triggered when the ratio of the component's visible area to its total area is greater than or\n less than the threshold. Before registering the callback, you must configure the threshold and update interval\n using <b>NODE_VISIBLE_AREA_APPROXIMATE_CHANGE_RATIO</b>. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: how the ratio of the component's visible area to its total area\n changes compared to the previous one. The value <b>1</b> indicates an increase, and <b>0</b> indicates\n a decrease. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: ratio of the component's visible area to its total area\n when this callback is invoked. \\n\n\n @since 17"]
#[cfg(feature = "api-17")]
pub const ArkUI_NodeEventType_NODE_VISIBLE_AREA_APPROXIMATE_CHANGE_EVENT: ArkUI_NodeEventType = 28;
#[doc = " @brief Defines the hover event.\n\n The event is triggered when the pointer is hovered by a pen device.\n within the component. \\n\n When the event callback occurs, the {@link ArkUI_NodeEvent} object can be obtained from the\n {@link ArkUI_UIInputEvent} object. \\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeEventType_NODE_ON_HOVER_MOVE: ArkUI_NodeEventType = 29;
#[doc = " @brief Defines the size change event.\n\n The event will be triggered when the component size changes.\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}.\n {@link ArkUI_NodeComponentEvent} contains four parameters:\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: the width of the old rectangle.\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: the height of the old rectangle.\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: the width of the new rectangle.\n <b>ArkUI_NodeComponentEvent.data[3].f32</b>: the height of the new rectangle.\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeEventType_NODE_ON_SIZE_CHANGE: ArkUI_NodeEventType = 30;
#[doc = " @brief Defines the coasting axis event.\n\n The event is triggered when user swipes with two fingers on the touchpad, the system constructs\n sliding events based on the speed at the moment the fingers are lifted, according to a certain\n decay curve. You can listen for such events to handle the flick effect immediately after the\n regular axis events. \\n\n When the event callback occurs, the {@link ArkUI_UIInputEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object through {@link OH_ArkUI_NodeEvent_GetInputEvent}.\n And the {@link ArkUI_CoastingAxisEvent} object can be obtained from the {@link ArkUI_UIInputEvent}\n object through {@link OH_ArkUI_UIInputEvent_GetCoastingAxisEvent}. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeEventType_NODE_ON_COASTING_AXIS_EVENT: ArkUI_NodeEventType = 31;
#[doc = " @brief Defines the pre-touch test of sub component in touch events. Called to specify how to perform the touch test on the children of this component.\n\n The event is triggered when the component is touched. \\n\n When the event callback occurs, the {@link ArkUI_NodeEvent} object can be obtained from the\n {@link ArkUI_TouchTestInfo} object. \\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeEventType_NODE_ON_CHILD_TOUCH_TEST: ArkUI_NodeEventType = 32;
#[doc = " @brief Triggers onDetectResultUpdate callback\n when the text is set to TextDataDetectorConfig and recognized successfully.\n\n Trigger this event when TextDataDetectorConfig is set and recognized successfully.\\n\n When the event callback occurs, the event parameter{@link ArkUI_NodeEvent}The union type in the object is\n {@link ArkUI_StringAsyncEvent}.\\n\n {@link ArkUI_StringAsyncEvent}contains 1 parameter\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>Indicates the result of text recognition, in Json format.\\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_ON_DETECT_RESULT_UPDATE: ArkUI_NodeEventType = 1000;
#[doc = " @brief Defines the long press event for span.\n\n The event is triggered when the span is long pressed.\n When the event callback occurs, the {@link ArkUI_NodeEvent} object can be obtained from the\n {@link ArkUI_UIInputEvent} object. \\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeEventType_NODE_TEXT_SPAN_ON_LONG_PRESS: ArkUI_NodeEventType = 1001;
#[doc = " @brief Defines the image loading success event.\n\n This event is triggered when an image is successfully loaded or decoded. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains nine parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: loading status. The value <b>0</b> indicates that the image is\n loaded successfully, and the value <b>1</b> indicates that the image is decoded successfully. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: width of the image, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: height of the image, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[3].f32</b>: width of the component, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[4].f32</b>: height of the component, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[5].f32</b>: offset of the rendered content relative to the component on the\n x-axis, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[6].f32</b>: offset of the rendered content relative to the component on the\n y-axis, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[7].f32</b>: actual rendered width of the image, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[8].f32</b>: actual rendered height of the image, in px. \\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ON_COMPLETE: ArkUI_NodeEventType = 4000;
#[doc = " @brief Defines the image loading failure event.\n\n This event is triggered when an error occurs during image loading. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>error code:\\n\n 401: The image could not be obtained because the image path is invalid. \\n\n 103101: The image format is not supported. \\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ON_ERROR: ArkUI_NodeEventType = 4001;
#[doc = " @brief Defines the SVG animation playback completion event.\n\n This event is triggered when the animation playback in the loaded SVG image is complete. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_IMAGE_ON_SVG_PLAY_FINISH: ArkUI_NodeEventType = 4002;
#[doc = " @brief Defines image download process event.\n\n This event is triggered when downloading webpage images from page components.\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].u32</b>: the num of bytes downloaded. \\n\n <b>ArkUI_NodeComponentEvent.data[1].u32</b>: the total number of bytes to download. \\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ON_DOWNLOAD_PROGRESS: ArkUI_NodeEventType = 4003;
#[doc = " @brief Defines the event triggered when the toggle status changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter: \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: toggle status. <b>1</b>: on; <b>0</b>: off.\n"]
pub const ArkUI_NodeEventType_NODE_TOGGLE_ON_CHANGE: ArkUI_NodeEventType = 5000;
#[doc = " @brief Defines the event triggered when the text input content changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text input.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CHANGE: ArkUI_NodeEventType = 7000;
#[doc = " @brief Defines the event triggered when the Enter key of the text input method is pressed.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: Enter key type of the input method.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_SUBMIT: ArkUI_NodeEventType = 7001;
#[doc = " @brief Defines the event triggered when the cut button on the pasteboard, which displays when the text box\n is long pressed, is clicked.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text that is cut.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CUT: ArkUI_NodeEventType = 7002;
#[doc = " @brief Defines the event triggered when the paste button on the pasteboard, which displays when the text box\n is long pressed, is clicked.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text that is pasted\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_PASTE: ArkUI_NodeEventType = 7003;
#[doc = " @brief Defines the event triggered when the text selection position changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: start position of the text selection area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: end position of the text selection area. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_TEXT_SELECTION_CHANGE: ArkUI_NodeEventType = 7004;
#[doc = " @brief Defines the event triggered when the input status changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: <b>true</b> indicates that text input is in progress. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_EDIT_CHANGE: ArkUI_NodeEventType = 7005;
#[doc = " @brief textInput This event is triggered when the input content changes.\n\n Conditions for triggering this event: When the input content changes. \\n\n When the event callback occurs, the union type in the event parameter\n {@link ArkUI_NodeEvent} object is {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains 2 parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: Indicates the width of the text. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: Indicates the height of the text. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CONTENT_SIZE_CHANGE: ArkUI_NodeEventType = 7006;
#[doc = " @brief Defines the event triggered when matching with the regular expression specified by\n <b>NODE_TEXT_INPUT_INPUT_FILTER</b> fails.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: content that is filtered out when regular expression matching fails. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_INPUT_FILTER_ERROR: ArkUI_NodeEventType = 7007;
#[doc = " @brief This callback is triggered when the text content is scrolled.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: Indicates the horizontal offset of the text in the content area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: Indicates the vertical coordinate offset of \\n\n the text in the content area. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CONTENT_SCROLL: ArkUI_NodeEventType = 7008;
#[doc = " @brief Defines the event triggered when text is about to be entered.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>.\n @return Returns <b>true</b> if the text is entered; returns <b>false</b> otherwise.\n You can set the return value using <b>OH_ArkUI_NodeEvent_SetReturnNumberValue</b>. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_WILL_INSERT: ArkUI_NodeEventType = 7009;
#[doc = " @brief Defines the event triggered when text is entered.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>."]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_DID_INSERT: ArkUI_NodeEventType = 7010;
#[doc = " @brief Defines the event triggered when text is about to be deleted.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text to delete, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n value.i32: direction for deleting the text, with the index of <b>1</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. The value <b>0</b> indicates backward-delete, and <b>1</b> indicates\n forward-delete. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>.\n @return Returns <b>true</b> if the text is deleted; returns <b>false</b> otherwise. \\n\n You can set the return value using <b>OH_ArkUI_NodeEvent_SetReturnNumberValue</b>. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_WILL_DELETE: ArkUI_NodeEventType = 7011;
#[doc = " @brief Defines the event triggered when text is deleted.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text deleted, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n value.i32: direction for deleting the text, with the index of <b>1</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. The value <b>0</b> indicates backward-delete, and <b>1</b> indicates\n forward-delete. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>."]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_DID_DELETE: ArkUI_NodeEventType = 7012;
#[doc = " @brief Defines the event triggered when content (including preview text) changes in the <b>TextInput</b>\n component.\n\n When the event callback occurs, the union type {@link ArkUI_NodeEvent} is {@link ArkUI_TextChangeEvent}. \\n\n {@link ArkUI_TextChangeEvent} contains the following parameters: \\n\n <b>ArkUI_TextChangeEvent.pStr</b>: content in the <b>TextInput</b> component.\n <b>ArkUI_TextChangeEvent.pExtendStr</b>: content of the preview text in the <b>TextInput</b> component.\n <b>ArkUI_TextChangeEvent.number</b>: start position of the preview text in the <b>TextInput</b> component.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CHANGE_WITH_PREVIEW_TEXT: ArkUI_NodeEventType =
    7013;
#[doc = " @brief Defines the event triggered before content changes\n\n When the event callback occurs, the union type {@link ArkUI_NodeEvent} is {@link ArkUI_TextChangeEvent}. \\n\n {@link ArkUI_TextChangeEvent} contains the following parameters: \\n\n <b>ArkUI_TextChangeEvent.pStr</b>: content in the <b>TextInput</b> component.\n <b>ArkUI_TextChangeEvent.pExtendStr</b>: content of the preview text in the <b>TextInput</b> component.\n <b>ArkUI_TextChangeEvent.number</b>: start position of the preview text in the <b>TextInput</b> component.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_WILL_CHANGE: ArkUI_NodeEventType = 7014;
#[doc = " @brief Defines the event triggered when the input in the text box changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text entered.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_CHANGE: ArkUI_NodeEventType = 8000;
#[doc = " @brief Defines the event triggered when the paste button on the pasteboard, which displays when the text box is\n long pressed, is clicked.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text that is pasted\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_PASTE: ArkUI_NodeEventType = 8001;
#[doc = " @brief Defines the event triggered when the text selection position changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: start position of the text selection area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: end position of the text selection area. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_TEXT_SELECTION_CHANGE: ArkUI_NodeEventType = 8002;
#[doc = " @brief Defines the event triggered when matching with the regular expression specified by\n <b>NODE_TEXT_AREA_INPUT_FILTER</b> fails.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: content that is filtered out when regular expression matching fails. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_INPUT_FILTER_ERROR: ArkUI_NodeEventType = 8003;
#[doc = " @brief This callback is triggered when the text content is scrolled.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: Indicates the horizontal offset of the text in the content area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: Indicates the vertical coordinate offset of \\n\n the text in the content area. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_CONTENT_SCROLL: ArkUI_NodeEventType = 8004;
#[doc = " @brief Defines the event triggered when the input status changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is \\n\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: <b>true</b> indicates that text input is in progress. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_EDIT_CHANGE: ArkUI_NodeEventType = 8005;
#[doc = " @brief Defines the event triggered when the Enter key on the keyboard is pressed for the multi-line text box.\n\n This event is not triggered when <b>keyType</b> is <b>ARKUI_ENTER_KEY_TYPE_NEW_LINE</b>. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is \\n\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: type of the Enter key.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_SUBMIT: ArkUI_NodeEventType = 8006;
#[doc = " @brief textArea This event is triggered when the input content changes.\n\n Conditions for triggering this event: When the input content changes. \\n\n When the event callback occurs, the union type in the event parameter {@link ArkUI_NodeEvent} object is \\n\n {@link ArkUI_NodeComponentEvent}.\\n\n {@link ArkUI_NodeComponentEvent} contains 2 parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: Indicates the width of the text. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: Indicates the height of the text. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_CONTENT_SIZE_CHANGE: ArkUI_NodeEventType = 8007;
#[doc = " @brief Defines the event triggered when text is about to be entered.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>.\n @return Returns <b>true</b> if the text is entered; returns <b>false</b> otherwise.\n You can set the return value using <b>OH_ArkUI_NodeEvent_SetReturnNumberValue</b>. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_WILL_INSERT: ArkUI_NodeEventType = 8008;
#[doc = " @brief Defines the event triggered when text is entered.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>."]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_DID_INSERT: ArkUI_NodeEventType = 8009;
#[doc = " @brief Defines the event triggered when text is about to be deleted.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text to delete, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n value.i32: direction for deleting the text, with the index of <b>1</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. The value <b>0</b> indicates backward-delete, and <b>1</b> indicates\n forward-delete. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>.\n @return Returns <b>true</b> if the text is deleted; returns <b>false</b> otherwise. \\n\n You can set the return value using <b>OH_ArkUI_NodeEvent_SetReturnNumberValue</b>. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_WILL_DELETE: ArkUI_NodeEventType = 8010;
#[doc = " @brief Defines the event triggered when text is deleted.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text deleted, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n value.i32: direction for deleting the text, with the index of <b>1</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. The value <b>0</b> indicates backward-delete, and <b>1</b> indicates\n forward-delete. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>."]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_DID_DELETE: ArkUI_NodeEventType = 8011;
#[doc = " @brief Defines the event triggered when content (including preview text) changes in the <b>TextArea</b>\n component.\n\n When the event callback occurs, the union type {@link ArkUI_NodeEvent} is {@link ArkUI_TextChangeEvent}. \\n\n {@link ArkUI_TextChangeEvent} contains the following parameters: \\n\n <b>ArkUI_TextChangeEvent.pStr</b>: content in the <b>TextArea</b> component.\n <b>ArkUI_TextChangeEvent.pExtendStr</b>: content of the preview text in the <b>TextArea</b> component.\n <b>ArkUI_TextChangeEvent.number</b>: start position of the preview text in the <b>TextArea</b> component.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_CHANGE_WITH_PREVIEW_TEXT: ArkUI_NodeEventType =
    8012;
#[doc = " @brief Defines the event triggered before content changes.\n\n When the event callback occurs, the union type {@link ArkUI_NodeEvent} is {@link ArkUI_TextChangeEvent}. \\n\n {@link ArkUI_TextChangeEvent} contains the following parameters: \\n\n <b>ArkUI_TextChangeEvent.pStr</b>: content in the <b>TextArea</b> component.\n <b>ArkUI_TextChangeEvent.pExtendStr</b>: content of the preview text in the <b>TextArea</b> component.\n <b>ArkUI_TextChangeEvent.number</b>: start position of the preview text in the <b>TextArea</b> component.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_WILL_CHANGE: ArkUI_NodeEventType = 8013;
#[doc = " @brief Defines the event triggered when the selected status of the <b>ARKUI_NODE_CHECKBOX</b> component changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b><b>1</b>: selected; <b>0</b>: not selected.\\n"]
pub const ArkUI_NodeEventType_NODE_CHECKBOX_EVENT_ON_CHANGE: ArkUI_NodeEventType = 11000;
#[doc = " @brief Defines the event triggered when a date is selected in the <b>ARKUI_NODE_DATE_PICKER</b> component.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains three parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: year of the selected date. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: month of the selected date. Value range: [0-11]. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: day of the selected date. \\n"]
pub const ArkUI_NodeEventType_NODE_DATE_PICKER_EVENT_ON_DATE_CHANGE: ArkUI_NodeEventType = 13000;
#[doc = " @brief Defines the event triggered when a time is selected in the <b>ARKUI_NODE_TIME_PICKER</b> component.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: hour of the selected time. Value range: [0-23]. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: minute of the selected time. Value range: [0-59]. \\n"]
pub const ArkUI_NodeEventType_NODE_TIME_PICKER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 14000;
#[doc = " @brief Defines the event triggered when an item is selected in the <b>ARKUI_NODE_TEXT_PICKER</b> component.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0...11].i32</b>: value of the selected item. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_PICKER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 15000;
#[doc = " @brief Defines the event triggered when an item is selected and scrolling has stopped in the\n <b>ARKUI_NODE_TEXT_PICKER</b> component.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0...11].i32</b>: value of the selected item. \\n\n\n @since 14"]
#[cfg(feature = "api-14")]
pub const ArkUI_NodeEventType_NODE_TEXT_PICKER_EVENT_ON_SCROLL_STOP: ArkUI_NodeEventType = 15001;
#[doc = " @brief Defines the event triggered when a date is selected in the <b>NODE_CALENDAR_PICKER</b>.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n <b>ArkUI_NodeComponent.data[0].u32</b>: year of the selected date. \\n\n <b>ArkUI_NodeComponent.data[1].u32</b>: month of the selected date. \\n\n <b>ArkUI_NodeComponent.data[2].u32</b>: day of the selected date. \\n"]
pub const ArkUI_NodeEventType_NODE_CALENDAR_PICKER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 16000;
#[doc = " @brief Defines the event triggered when the <b>ARKUI_NODE_SLIDER</b> component is dragged or clicked.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: current slider value. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: state triggered by the event.\\n"]
pub const ArkUI_NodeEventType_NODE_SLIDER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 17000;
#[doc = " @brief Defines the event callback function triggered when an object is dragged or clicked by ARKUI_NODE_RADIO.\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains one parameter:\\n\n ArkUI_NodeComponentEvent.data[0].i32: option button status. \\n"]
pub const ArkUI_NodeEventType_NODE_RADIO_EVENT_ON_CHANGE: ArkUI_NodeEventType = 18000;
#[doc = " @brief Defines the event callback function triggered when the animation starts to play.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_START: ArkUI_NodeEventType = 19000;
#[doc = " @brief Defines the event callback function triggered when the animation playback is paused.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_PAUSE: ArkUI_NodeEventType = 19001;
#[doc = " @brief Defines the event callback function triggered when the animation playback is repeated.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_REPEAT: ArkUI_NodeEventType = 19002;
#[doc = " @brief Defines the event callback function when the animation playback returns to the initial state.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_CANCEL: ArkUI_NodeEventType = 19003;
#[doc = " @brief Defines the event callback function triggered when the animation playback is complete or stopped.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_FINISH: ArkUI_NodeEventType = 19004;
#[doc = " @brief Defines the callback triggered when the selected status of the <b>ARKUI_NODE_CHECKBOX_GROOUP</b>\n or checkbox changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n <b>ArkUI_StringAsyncEvent.pStr</b>\n Name: The names of the selected checkboxes;\n Status:\n 0: All checkboxes are selected.\n 1: Some checkboxes are selected.\n 2: No checkboxes are selected. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeEventType_NODE_CHECKBOX_GROUP_EVENT_ON_CHANGE: ArkUI_NodeEventType = 21000;
#[doc = " @brief Defines the event triggered when the index of the currently displayed element of this\n <b>ARKUI_NODE_SWIPER</b> instance changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the currently displayed element. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 1001000;
#[doc = " @brief Defines the event triggered when the switching animation of this <b>ARKUI_NODE_SWIPER</b> instance starts.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains five parameters: \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the currently displayed element. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: index of the target element to switch to. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: offset of the currently displayed element relative to the\n start position of the swiper along the main axis. \\n\n <b>ArkUI_NodeComponentEvent.data[3].f32</b>: offset of the target element relative to the start position\n of the swiper along the main axis. \\n\n <b>ArkUI_NodeComponentEvent.data[4].f32</b>: hands-off velocity. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_ANIMATION_START: ArkUI_NodeEventType = 1001001;
#[doc = " @brief Defines the event triggered when the switching animation of this <b>ARKUI_NODE_SWIPER</b> instance ends.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the currently displayed element. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: offset of the currently displayed element relative to the\n start position of the swiper along the main axis. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_ANIMATION_END: ArkUI_NodeEventType = 1001002;
#[doc = " @brief Defines the event triggered on a frame-by-frame basis when the page is turned by a swipe in this\n <b>ARKUI_NODE_SWIPER</b> instance.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the currently displayed element. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: offset of the currently displayed element relative to the\n start position of the swiper along the main axis. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_GESTURE_SWIPE: ArkUI_NodeEventType = 1001003;
#[doc = " @brief Define the <b>ARKUI_NODE_SWIPER</b> to listen for Swiper page slide events.\n Instruction: \\n\n 1. If the {@link ArkUI_SwiperDisplayModeType} attribute is set to \\n\n ARKUI_SWIPER_DISPLAY_MODE_AUTO_LINEAR, the interface does not take effect. \\n\n 2, circular scenario, set prevMargin and nextMargin attributes, \\n\n so that Swiper front and back end display the same page, the interface does not take effect. \\n\n 3. During page sliding, the ContentDidScrollCallback callback is \\n\n triggered frame-by-frame for all pages in the window. \\n\n For example, when there are two pages in the window with subscripts 0 and 1, \\n\n callbacks with index values 0 and 1 are triggered twice per frame. \\n\n 4, set the swipeByGroup parameter of the displayCount property to \\n\n true if at least one page in the same group is in the window, \\n\n A callback is triggered for all pages in the group. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains four parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b> : indicates the index of the Swiper component, \\n\n which is consistent with the index change in the onChange event. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b> : The index of a page in the window. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b> : The proportion of page movement relative to \\n\n the start position of the Swiper spindle (selectedIndex corresponds to the start position of the page). \\n\n <b>ArkUI_NodeComponentEvent.data[3].f32</b> : The length of the page in the axis direction. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_CONTENT_DID_SCROLL: ArkUI_NodeEventType =
    1001004;
#[doc = " @brief Defines the event triggered when content in the swiper component will scroll.\n Instructions: Before page scrolling, the </b>ContentWillScrollCallback</b> callback is invoked. \\n \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains three parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: the index value of the current child page. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: the index value of the child page that will display. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: the sliding offset of each frame.\n Positive numbers indicating slide backward(e.g. from index=1 to index=0), negative numbers indicating\n slide forward(e.g. from index=0 to index=1). \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_CONTENT_WILL_SCROLL: ArkUI_NodeEventType =
    1001007;
#[doc = " @brief Defines the event triggered when the selected index of the <b>ARKUI_NODE_SWIPER</b> changed.\n\n This event is triggered under the following scenarios: \\n\n 1. When the page switching animation starts after the user lifts their finger after swiping and the swipe meets\n the threshold for page turning. \\n\n 2. When the page is changed programmatically using either <b>NODE_SWIPER_INDEX</b> or\n <b>NODE_SWIPER_SWIPE_TO_INDEX</b>. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the currently selected element. \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_SELECTED: ArkUI_NodeEventType = 1001005;
#[doc = " @brief Defines the event triggered when the selected index of the <b>ARKUI_NODE_SWIPER</b> changed.\n\n This event is triggered under the following scenarios: \\n\n 1. When the page switching animation starts after the user lifts their finger after swiping and the swipe meets\n the threshold for page turning. \\n\n 2. When the page is changed programmatically using either <b>NODE_SWIPER_INDEX</b> or\n <b>NODE_SWIPER_SWIPE_TO_INDEX</b>. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: the index of the element becomes unselected. \\n\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_UNSELECTED: ArkUI_NodeEventType = 1001006;
#[doc = " @brief Defines the <b>ARKUI_NODE_SWIPER</b> scroll state change event.\n This event is triggered when the scroll state of the <b>Swiper</b> component changes during user dragging,\n during the animation phase after the user lifts their finger, or upon stopping of scrolling.\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: current scroll state. The parameter type is\n {@link ArkUI_ScrollState}. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_SCROLL_STATE_CHANGED: ArkUI_NodeEventType =
    1001008;
#[doc = " @brief Defines the event triggered when the <b>ARKUI_NODE_SCROLL</b> component scrolls.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started by the <b>ARKUI_NODE_SCROLL</b> component or other input\n settings, such as keyboard and mouse operations. \\n\n 2. Scrolling can be initiated by calling the controller API. \\n\n 3. The out-of-bounds bounce effect is supported. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: horizontal scrolling offset. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: vertical scrolling offset. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL: ArkUI_NodeEventType = 1002000;
#[doc = " @brief Defines the event triggered when each frame scrolling starts in the <b>ARKUI_NODE_SCROLL</b> component.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started by the <b>ARKUI_NODE_SCROLL</b> component or other input\n settings, such as keyboard and mouse operations. \\n\n 2. This event is not triggered when the controller API is called. \\n\n 3. This event does not support the out-of-bounds bounce effect. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: amount to scroll by. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: current scrolling state. \\n\n <b>::ArkUI_NodeComponentEvent</b> contains one return value:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: The event handler can work out the amount by which the component\n needs to scroll based on the real-world situation and return the result in this parameter. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL_FRAME_BEGIN: ArkUI_NodeEventType =
    1002001;
#[doc = " @brief Define the enumeration value of the pre sliding trigger event for the scrolling container component.\n\n The conditions that trigger this event: \\n\n 1. When the scrolling component triggers scrolling, it supports input settings such as keyboard and mouse\n operations that trigger scrolling.\\n\n 2. Called through the rolling controller API interface.\\n\n 3. Cross boundary rebound.\\n\n When an event callback occurs, the union type in the event parameter {@ link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains four parameters: \\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: The offset for each frame of scrolling is positive when scrolling to\n the left and negative when scrolling to the right, measured in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: The offset of each frame scrolling, with a positive offset when\n scrolling up and a negative offset when scrolling down, measured in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: Current sliding state, \\n\n parameter type is {@link ArkUI_ScrollState}. \\n\n <b>ArkUI_NodeComponentEvent.data[3].i32</b>: Current scroll source, \\n\n parameter type is {@link ArkUI_ScrollSource}. \\n\n @return Does not return or returns a number that sets the actual scroll distance of the scroll component."]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_WILL_SCROLL: ArkUI_NodeEventType = 1002002;
#[doc = " @brief Define the event enumeration value triggered when sliding a scrolling container component.\n\n The conditions that trigger this event: \\n\n 1. When the scrolling component triggers scrolling, it supports input settings such as keyboard and mouse\n operations that trigger scrolling.\\n\n 2. Called through the rolling controller API interface.\\n\n 3. Cross boundary rebound.\\n\n When an event callback occurs, the union type in the event parameter {@ link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains three parameters: \\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: The offset for each frame of scrolling is positive when scrolling to\n the left and negative when scrolling to the right, measured in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: The offset of each frame scrolling, with a positive offset when\n scrolling up and a negative offset when scrolling down, measured in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: Current sliding state, \\n\nparameter type is {@link ArkUI_ScrollState}. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_DID_SCROLL: ArkUI_NodeEventType = 1002003;
#[doc = " @brief Defines the event triggered when scrolling starts in the <b>ARKUI_NODE_SCROLL</b> component.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started, with support for other input settings, such as keyboard\n and mouse operations. \\n\n 2. This event is triggered when the controller API is called, accompanied by a transition animation. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL_START: ArkUI_NodeEventType = 1002004;
#[doc = " @brief Defines the event triggered when scrolling of the <b>ARKUI_NODE_SCROLL</b> component stops.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is stopped by the <b>ARKUI_NODE_SCROLL</b> component or other input\n settings, such as keyboard and mouse operations. \\n\n 2. This event is triggered when the controller API is called, accompanied by a transition animation. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL_STOP: ArkUI_NodeEventType = 1002005;
#[doc = " @brief Defines the event triggered when scrolling of the <b>ARKUI_NODE_SCROLL</b> component reaches\n one of the edges.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling reaches the edge after being started by the <b>ARKUI_NODE_SCROLL</b>\n component or other input settings, such as keyboard and mouse operations. \\n\n 2. Scrolling can be initiated by calling the controller API. \\n\n 3. The out-of-bounds bounce effect is supported. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter. \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: edge (top, bottom, left, or right) that the scrolling reaches. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL_EDGE: ArkUI_NodeEventType = 1002006;
#[doc = " @brief Define that a callback is triggered when the scrolling container component reaches the start position.\n Condition for triggering the event: \\n\n Triggered when the component reaches the start position. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameters. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_REACH_START: ArkUI_NodeEventType = 1002007;
#[doc = " @brief Define that a callback is triggered when the scrolling container component ends. \\n\n Condition for triggering the event: \\n\n Triggered when the component reaches the end. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameters. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_REACH_END: ArkUI_NodeEventType = 1002008;
#[doc = " @brief Defines the callback for when the user is about to release the drag on the scrollable container component.\n\n This event is triggered when the user is about to release the drag on the scrollable container component. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter: \\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: speed at which the user releases the drag, in vp. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_WILL_STOP_DRAGGING: ArkUI_NodeEventType =
    1002009;
#[doc = " @brief Defines the callback for the <b>Scroll</b> component's zoom event,\n triggered at the end of each frame during zooming. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object\n is {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: current zoom scale. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_DID_ZOOM: ArkUI_NodeEventType = 1002010;
#[doc = " @brief Defines the callback for the <b>Scroll</b> component's zoom start event,\n triggered when zooming begins. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object\n is {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_ZOOM_START: ArkUI_NodeEventType = 1002011;
#[doc = " @brief Defines the callback for the <b>Scroll</b> component's zoom end event,\n triggered when zooming ends. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object\n is {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters. \\n\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_ZOOM_STOP: ArkUI_NodeEventType = 1002012;
#[doc = " @brief Defines the callback for when the scrollable will start dragging.\n\n This event is triggered when the scrollable will start dragging. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains no parameters: \\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_WILL_START_DRAGGING: ArkUI_NodeEventType =
    1002013;
#[doc = " @brief Defines the callback for when the scrollable did end dragging.\n\n This event is triggered when the scrollable did end dragging. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter: \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: whether start fling animation. \\n\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_DID_STOP_DRAGGING: ArkUI_NodeEventType = 1002014;
#[doc = " @brief Defines the callback for when the scrollable will start fling.\n\n This event is triggered when the scrollable will start fling. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains no parameters: \\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_WILL_START_FLING: ArkUI_NodeEventType = 1002015;
#[doc = " @brief Defines the callback for when the scrollable did end fling.\n\n This event is triggered when the scrollable did end fling. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains no parameters: \\n\n @since 21"]
#[cfg(feature = "api-21")]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_DID_STOP_FLING: ArkUI_NodeEventType = 1002016;
#[doc = " @brief Defines the enumerated values of the event triggered, \\n\n when a subcomponent of ARKUI_NODE_LIST is moved into or out of the list display area. \\n\n Condition for triggering the event: \\n\n This method is triggered once during list initialization. \\n\n It is triggered when the index value of the first or last subcomponent in the list display area changes. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains three parameters: \\n\n ArkUI_NodeComponentEvent.data[0].i32: List Displays the index value of \\n\n the first child component in the region. \\n\n ArkUI_NodeComponentEvent.data[1].i32: List Displays the index value of \\n\n the last child component in the region. \\n\n ArkUI_NodeComponentEvent.data[2].i32: List Displays the index value of \\n\n the subcomponent in the middle of the area. \\n"]
pub const ArkUI_NodeEventType_NODE_LIST_ON_SCROLL_INDEX: ArkUI_NodeEventType = 1003000;
#[doc = " @brief Defines the enumerated values of the event triggered\n before the sliding of the ARKUI_NODE_LIST component. \\n\n Condition for triggering the event: \\n\n This event is triggered when the scrolling component triggers scrolling. \\n\n Other inputs that trigger scrolling, such as keyboard and mouse operations, can be set. \\n\n Called through the scroll controller API. \\n\n Out-of-bounds rebound. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains three parameters: \\n\n ArkUI_NodeComponentEvent.data[0].f32: offset of each frame scrolling. \\n\n The offset is positive when the list content is scrolled up and \\n\n is negative when the list content is scrolled down. \\n\n ArkUI_NodeComponentEvent.data[1].i32: Current sliding state. \\n\n parameter type is {@link ArkUI_ScrollState}. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: Current scroll source, \\n\n parameter type is {@link ArkUI_ScrollSource}. \\n\n @return Does not return or returns a number that sets the actual scroll distance of the scroll component. \\n"]
pub const ArkUI_NodeEventType_NODE_LIST_ON_WILL_SCROLL: ArkUI_NodeEventType = 1003001;
#[doc = " @brief Define the enumerated values of the event triggered when the ARKUI_NODE_LIST component is flicked.\n Condition for triggering the event: \\n\n This event is triggered when the scrolling component triggers scrolling. \\n\n Other inputs that trigger scrolling, such as keyboard and mouse operations, can be set. \\n\n Called through the scroll controller API. \\n\n Out-of-bounds rebound. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains two parameters:\\n\n ArkUI_NodeComponentEvent.data[0].f32: offset of each frame scrolling. \\n\n The offset is positive when the list content is scrolled up and \\n\n is negative when the list content is scrolled down. \\n\n ArkUI_NodeComponentEvent.data[1].i32: Current sliding state. \\n"]
pub const ArkUI_NodeEventType_NODE_LIST_ON_DID_SCROLL: ArkUI_NodeEventType = 1003002;
#[doc = " @brief Defines the event triggered when the currently displayed content of the <b>ARKUI_NODE_LIST</b> changes.\n\n Notes for triggering the event:\\n\n This event is triggered once when the list is initialized and when the index of the first child component or the\n next child component in the list display area changes.\n During index calculation, the list item, header of the list item group, and footer of the list item group each\n are counted as a child component. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains three parameters: \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the first child component in the list display area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: area in the list item group where the list display area starts.\n The type is {@link ArkUI_ListItemGroupArea}. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: index of the list item at the start of the list display area\n in the list item group.\n If the start of the list display area is not on a list item, the value is <b>-1</b>. \\n\n <b>ArkUI_NodeComponentEvent.data[3].i32</b>: index of the last child component in the list display area. \\n\n <b>ArkUI_NodeComponentEvent.data[4].i32</b>: area in the list item group where the list display area ends.\n The type is {@link ArkUI_ListItemGroupArea}. \\n\n <b>ArkUI_NodeComponentEvent.data[5].i32</b>: index of the list item at the end of the list display area in the\n list item group.\n If the end of the list display area is not on a list item, the value is <b>-1</b>. \\n\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_NodeEventType_NODE_LIST_ON_SCROLL_VISIBLE_CONTENT_CHANGE: ArkUI_NodeEventType =
    1003003;
#[doc = " @brief Defines the event triggered when the refresh state of the <b>ARKUI_NODE_REFRESH</b> object changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: refresh state. \\n"]
pub const ArkUI_NodeEventType_NODE_REFRESH_STATE_CHANGE: ArkUI_NodeEventType = 1009000;
#[doc = " @brief Defines the event triggered when the <b>ARKUI_NODE_REFRESH</b> object enters the refresh state.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters:\\n"]
pub const ArkUI_NodeEventType_NODE_REFRESH_ON_REFRESH: ArkUI_NodeEventType = 1009001;
#[doc = " @brief Defines the event that is triggered when the <b>ARKUI_NODE_REFRESH</b> drop-down distance changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: Pull-down distance. \\n"]
pub const ArkUI_NodeEventType_NODE_REFRESH_ON_OFFSET_CHANGE: ArkUI_NodeEventType = 1009002;
#[doc = " @brief Defines the event triggered when the <b>ARKUI_NODE_SCROLL</b> component is about to scroll.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started by the <b>ARKUI_NODE_SCROLL</b> component or other\n input settings, such as keyboard and mouse operations. \\n\n 2. Scrolling can be initiated by calling the controller API. \\n\n 3. The out-of-bounds bounce effect is supported. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains three parameters: \\n\n ArkUI_NodeComponentEvent.data[0].f32: offset of each frame scrolling. \\n\n The offset is positive when the list content is scrolled up and \\n\n is negative when the list content is scrolled down. \\n\n ArkUI_NodeComponentEvent.data[1].i32: Current sliding state. \\n\n parameter type is {@link ArkUI_ScrollState}. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: Current scroll source, \\n\n parameter type is {@link ArkUI_ScrollSource}. \\n\n @return Does not return or returns a number that sets the actual scroll distance of the scroll component. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_WILL_SCROLL: ArkUI_NodeEventType = 1010000;
#[doc = " @brief Define the enumerated values of the event triggered when the ARKUI_NODE_WATER_FLOW component slides.\n Condition for triggering the event: \\n\n This event is triggered when the scrolling component triggers scrolling.\n Other inputs that trigger scrolling, such as keyboard and mouse operations, can be set. \\n\n Called through the scroll controller API. \\n\n Out-of-bounds rebound. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains two parameters:\\n\n ArkUI_NodeComponentEvent.data[0].f32: offset of each frame scrolling. \\n\n The offset is positive when the content is scrolled up and is negative when the content is scrolled down. \\n\n ArkUI_NodeComponentEvent.data[1].i32: Current sliding state. \\n"]
pub const ArkUI_NodeEventType_NODE_WATER_FLOW_ON_DID_SCROLL: ArkUI_NodeEventType = 1010001;
#[doc = " @brief Defines the enumerated values of the event triggered,\n when the subcomponent of the start position or end position displayed in the current waterfall changes.\n Condition for triggering the event: \\n\n This event is triggered when the index value of the \\n\n first or last subcomponent in the waterfall display area changes. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains three parameters: \\n\n ArkUI_NodeComponentEvent.data[0].i32: The index value of the \\n\n start position of the currently displayed WaterFlow. \\n\n ArkUI_NodeComponentEvent.data[1].i32: The index value of \\n\n the end position of the currently displayed waterfall. \\n"]
pub const ArkUI_NodeEventType_NODE_WATER_FLOW_ON_SCROLL_INDEX: ArkUI_NodeEventType = 1010002;
#[doc = " @brief Defines the event triggered when a child component enters or leaves the grid display area.\n\n Notes for triggering the event:\\n\n This event is triggered once when the grid is initialized and when the index of the first or \\n\n last child component in the grid display area changes. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is \\n\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the first child component in the grid display area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: index of the last child component in the grid display area. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeEventType_NODE_GRID_ON_SCROLL_INDEX: ArkUI_NodeEventType = 1013000;
#[doc = " @brief Defines the event triggered when the grid is about to scroll.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started by the scrollable component or other input settings,\n such as keyboard and mouse operations. \\n\n 2. Scrolling can be initiated by calling the controller API. \\n\n 3. The out-of-bounds bounce effect is supported. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains three parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>:\n Scroll offset of each frame. A positive offset indicates content scrolling upward, \\n\n and a negative offset indicates content scrolling downward. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: current scroll state. The parameter type is\n {@link ArkUI_ScrollState}. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: scroll source. The parameter type is {@link ArkUI_ScrollSource}. \\n\n @return Returns one or no number to indicate the actual amount by which the scroll component scrolls.\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeEventType_NODE_GRID_ON_WILL_SCROLL: ArkUI_NodeEventType = 1013001;
#[doc = " @brief Defines the event triggered when the grid scrolls.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started by the scrollable component or other input settings,\n such as keyboard and mouse operations. \\n\n 2. Scrolling can be initiated by calling the controller API. \\n\n 3. The out-of-bounds bounce effect is supported. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>:\n Scroll offset of each frame. A positive offset indicates content scrolling upward, \\n\n and a negative offset indicates content scrolling downward. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: current scroll state. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeEventType_NODE_GRID_ON_DID_SCROLL: ArkUI_NodeEventType = 1013002;
#[doc = " @brief Defines the event triggered at the end of each frame layout of the <b>ARKUI_NODE_GRID</b> component,\n which is used to set the position and length of the scrollbar.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.i32 at index 0:offset of the first visible grid item,\n obtained using <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n value.f32 at index 1: offset of the first visible item relative to the grid's display starting position, in vp,\n obtained using <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n @return Information about the scrollbar position and length. \\n\n You can set the return value using <b>OH_ArkUI_NodeEvent_SetReturnNumberValue</b>. \\n\n value.f32 at index 0: total offset of the grid content relative to the display area, in px. \\n\n value.f32 at index 1: total length of the grid content, in px. \\n\n\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NodeEventType_NODE_GRID_ON_SCROLL_BAR_UPDATE: ArkUI_NodeEventType = 1013003;
#[doc = " @brief Enumerates the event types supported by the NativeNode component.\n\n @since 12"]
pub type ArkUI_NodeEventType = u32;
extern "C" {
    #[doc = " @brief Obtains the type of a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the type of the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetEventType(event: *mut ArkUI_NodeEvent) -> ArkUI_NodeEventType;
}
extern "C" {
    #[doc = " @brief Obtains the custom ID of a component event.\n\n The event ID is passed in as a parameter when the {@link registerNodeEvent} function is called and can be applied\n to the dispatch logic of the same event entry function {@link registerNodeEventReceiver}.\n\n @param event Indicates the pointer to the component event.\n @return Returns the custom ID of the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetTargetId(event: *mut ArkUI_NodeEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the component object that triggers a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the component object that triggers the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetNodeHandle(event: *mut ArkUI_NodeEvent) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Obtains input event (for example, touch event) data for a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the pointer to the input event data.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetInputEvent(event: *mut ArkUI_NodeEvent)
        -> *mut ArkUI_UIInputEvent;
}
extern "C" {
    #[doc = " @brief Obtains the numerical data in a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the pointer to the numerical data.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetNodeComponentEvent(
        event: *mut ArkUI_NodeEvent,
    ) -> *mut ArkUI_NodeComponentEvent;
}
extern "C" {
    #[doc = " @brief Obtains the string data in a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the pointer to the string data.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetStringAsyncEvent(
        event: *mut ArkUI_NodeEvent,
    ) -> *mut ArkUI_StringAsyncEvent;
}
extern "C" {
    #[doc = " @brief Obtains the ArkUI_TextChangeEvent data from a component event.\n\n @param event Pointer to a component event. It cannot be null.\n @return Returns the pointer to the <b>ArkUI_TextChangeEvent</b> object.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_NodeEvent_GetTextChangeEvent(
        event: *mut ArkUI_NodeEvent,
    ) -> *mut ArkUI_TextChangeEvent;
}
extern "C" {
    #[doc = " @brief Obtains the custom data in a component event.\n\n This parameter is passed in {@link registerNodeEvent} and can be applied to the service logic when the event\n is triggered.\n\n @param event Indicates the pointer to the component event.\n @return Returns the pointer to the custom data.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetUserData(
        event: *mut ArkUI_NodeEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the numeric-type parameter of a component event.\n\n @param event Indicates the pointer to the component event.\n @param index Indicates the index of the return value.\n @param value Indicates the return value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INDEX_OUT_OF_RANGE} if the parameter length exceeds\n         the limit.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INVALID} if the data does not exist in the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetNumberValue(
        event: *mut ArkUI_NodeEvent,
        index: i32,
        value: *mut ArkUI_NumberValue,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the string-type parameter of a component event. The string data is valid only during an event\n callback. To use it outside an event callback, you are advised to copy the string data.\n\n @param event Indicates the pointer to the component event.\n @param index Indicates the index of the return value.\n @param string Indicates the pointer to the string array.\n @param stringSize Indicates the length of the string array.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INDEX_OUT_OF_RANGE} if the parameter length exceeds\n         the limit.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INVALID} if the data does not exist in the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetStringValue(
        event: *mut ArkUI_NodeEvent,
        index: i32,
        string: *mut *mut ::std::os::raw::c_char,
        stringSize: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the return value for a component event.\n\n @param event Indicates the pointer to the component event.\n @param value Indicates the numeric-type array.\n @param size Indicates the array length.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_NO_RETURN} if the component event does not support return values.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INVALID} if data does not exist in the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_SetReturnNumberValue(
        event: *mut ArkUI_NodeEvent,
        value: *mut ArkUI_NumberValue,
        size: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>ArkUI_TouchTestInfo</b> object from the specified <b>ArkUI_NodeEvent</b> object.\n\n @param {pointer} nodeEvent Indicates the pointer to an <b>ArkUI_NodeEvent</b> object.\n @return Returns the pointer to an <b>ArkUI_TouchTestInfo</b> object.\n         Returns <b>null</b> if the parameter passed in is invalid or is not a touch test info.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_NodeEvent_GetTouchTestInfo(
        nodeEvent: *mut ArkUI_NodeEvent,
    ) -> *mut ArkUI_TouchTestInfo;
}
#[doc = " @brief Remeasure.\n\n When this type of flag is specified, re-layout is triggered by default."]
pub const ArkUI_NodeDirtyFlag_NODE_NEED_MEASURE: ArkUI_NodeDirtyFlag = 1;
#[doc = " Re-layout."]
pub const ArkUI_NodeDirtyFlag_NODE_NEED_LAYOUT: ArkUI_NodeDirtyFlag = 2;
#[doc = " Re-rendering."]
pub const ArkUI_NodeDirtyFlag_NODE_NEED_RENDER: ArkUI_NodeDirtyFlag = 3;
#[doc = " @brief Defines the dirty area flag passed in the <b>::markDirty</b> API.\n\n @since 12"]
pub type ArkUI_NodeDirtyFlag = u32;
#[doc = " Measure type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_MEASURE: ArkUI_NodeCustomEventType =
    1;
#[doc = " Layout type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_LAYOUT: ArkUI_NodeCustomEventType =
    2;
#[doc = " Draw type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_DRAW: ArkUI_NodeCustomEventType = 4;
#[doc = " Foreground type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_FOREGROUND_DRAW:
    ArkUI_NodeCustomEventType = 8;
#[doc = " Overlay type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_OVERLAY_DRAW:
    ArkUI_NodeCustomEventType = 16;
#[doc = " Draw front type.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_DRAW_FRONT:
    ArkUI_NodeCustomEventType = 32;
#[doc = " Draw behind type.\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_DRAW_BEHIND:
    ArkUI_NodeCustomEventType = 64;
#[doc = " @brief Defines the custom component event type.\n\n @since 12"]
pub type ArkUI_NodeCustomEventType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeCustomEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeAdapter {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the component adapter, which is used for lazy loading of elements of scrollable components.\n\n @since 12"]
pub type ArkUI_NodeAdapterHandle = *mut ArkUI_NodeAdapter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeAdapterEvent {
    _unused: [u8; 0],
}
#[doc = " This event occurs when the component is attached to the adapter."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_WILL_ATTACH_TO_NODE:
    ArkUI_NodeAdapterEventType = 1;
#[doc = " This event occurs when the component is detached from the adapter."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_WILL_DETACH_FROM_NODE:
    ArkUI_NodeAdapterEventType = 2;
#[doc = " This event occurs when the adapter obtains the unique ID of the new element to add."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_ON_GET_NODE_ID: ArkUI_NodeAdapterEventType =
    3;
#[doc = " This event occurs when the adapter obtains the content of the new element to add."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_ON_ADD_NODE_TO_ADAPTER:
    ArkUI_NodeAdapterEventType = 4;
#[doc = " This event occurs when the adapter removes an element."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_ON_REMOVE_NODE_FROM_ADAPTER:
    ArkUI_NodeAdapterEventType = 5;
#[doc = " @brief Enumerates component adapter events.\n\n @since 12"]
pub type ArkUI_NodeAdapterEventType = u32;
extern "C" {
    #[doc = " @brief Creates a component adapter.\n\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_Create() -> ArkUI_NodeAdapterHandle;
}
extern "C" {
    #[doc = " @brief Destroys a component adapter.\n\n @param handle Indicates the target component adapter.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_Dispose(handle: ArkUI_NodeAdapterHandle);
}
extern "C" {
    #[doc = " @brief Sets the total number of elements in the specified adapter.\n\n @param handle Indicates the target component adapter.\n @param size Indicates the number of elements.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_SetTotalNodeCount(
        handle: ArkUI_NodeAdapterHandle,
        size: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the total number of elements in the specified adapter.\n\n @param handle Indicates the target component adapter.\n @return Returns the total number of elements in the adapter.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_GetTotalNodeCount(handle: ArkUI_NodeAdapterHandle) -> u32;
}
extern "C" {
    #[doc = " @brief Registers an event callback for the adapter.\n\n @param handle Indicates the target component adapter.\n @param userData Indicates custom data.\n @param receiver Indicates the event receiver callback.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_RegisterEventReceiver(
        handle: ArkUI_NodeAdapterHandle,
        userData: *mut ::std::os::raw::c_void,
        receiver: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeAdapterEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Deregisters an event callback for the adapter.\n\n @param handle Indicates the target component adapter.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_UnregisterEventReceiver(handle: ArkUI_NodeAdapterHandle);
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to reload all elements.\n\n @param handle Indicates the target component adapter.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_ReloadAllItems(handle: ArkUI_NodeAdapterHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to reload certain elements.\n\n @param handle Indicates the target component adapter.\n @param startPosition Indicates the start position of the elements to reload.\n @param itemCount Indicates the number of the elements to reload.\n  @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_ReloadItem(
        handle: ArkUI_NodeAdapterHandle,
        startPosition: u32,
        itemCount: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to remove certain elements.\n\n @param handle Indicates the target component adapter.\n @param startPosition Indicates the start position of the elements to remove.\n @param itemCount Indicates the number of the elements to remove.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_RemoveItem(
        handle: ArkUI_NodeAdapterHandle,
        startPosition: u32,
        itemCount: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to insert certain elements.\n\n @param handle Indicates the target component adapter.\n @param startPosition Indicates the start position of the elements to insert.\n @param itemCount Indicates the number of the elements to insert.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_InsertItem(
        handle: ArkUI_NodeAdapterHandle,
        startPosition: u32,
        itemCount: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to move certain elements.\n\n @param handle Indicates the target component adapter.\n @param from Indicates the start position of the elements to move.\n @param to  Indicates the end position of the elements to move.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_MoveItem(
        handle: ArkUI_NodeAdapterHandle,
        from: u32,
        to: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains all elements stored in the specified adapter.\n\n This API returns the pointer to the array of the elements. You need to manually release the memory data\n to which the pointer points.\n\n @param handle Indicates the target component adapter.\n @param items Indicates the pointer to the array of the elements in the adapter.\n @param size Indicates the number of elements.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_GetAllItems(
        handle: ArkUI_NodeAdapterHandle,
        items: *mut *mut ArkUI_NodeHandle,
        size: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the custom data passed in during registration of the specified event.\n\n @param event Indicates the target adapter event.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetUserData(
        event: *mut ArkUI_NodeAdapterEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the event type.\n\n @param event Indicates the target adapter event.\n @return Returns the event type.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetType(
        event: *mut ArkUI_NodeAdapterEvent,
    ) -> ArkUI_NodeAdapterEventType;
}
extern "C" {
    #[doc = " @brief Obtains the element to be removed for the event to be destroyed.\n\n @param event Indicates the target adapter event.\n @return Returns the element to be removed.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetRemovedNode(
        event: *mut ArkUI_NodeAdapterEvent,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Obtains the index of the element to be operated for the specified adapter event.\n\n @param event Indicates the target adapter event.\n @return Returns the index of the element.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetItemIndex(event: *mut ArkUI_NodeAdapterEvent) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the scrollable container node that uses the specified adapter.\n\n @param event Indicates the target adapter event.\n @return Returns the scrollable container node that uses the specified adapter.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetHostNode(
        event: *mut ArkUI_NodeAdapterEvent,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Sets the component to be added to the specified adapter.\n\n @param event Indicates the target adapter event.\n @param node Indicates the component to be added.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_SetItem(
        event: *mut ArkUI_NodeAdapterEvent,
        node: ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the component ID to be generated.\n\n @param event Indicates the target adapter event.\n @param id Indicates the component ID to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_SetNodeId(event: *mut ArkUI_NodeAdapterEvent, id: i32) -> i32;
}
#[doc = " @brief Declares a collection of native node APIs provided by ArkUI.\n\n The APIs related to the native node must be called in the main thread.\n\n @version 1\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeNodeAPI_1 {
    #[doc = " Struct version."]
    pub version: i32,
    #[doc = " @brief Creates a component based on {@link ArkUI_NodeType} and returns the pointer to the created component.\n\n @param type Indicates the type of component to create.\n @return Returns the pointer to the created component. If the component fails to be created, NULL is returned."]
    pub createNode:
        ::std::option::Option<unsafe extern "C" fn(type_: ArkUI_NodeType) -> ArkUI_NodeHandle>,
    #[doc = " @brief Destroys the component to which the specified pointer points.\n\n @param node Indicates the pointer."]
    pub disposeNode: ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle)>,
    #[doc = " @brief Adds a component to a parent node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed on\n             BuilderNode generated nodes: setting or resetting attributes, setting events, or adding or editing subnodes.\n         Returns {@link ARKUI_ERROR_CODE_NODE_IS_ADOPTED} if the child node has already been adopted. add since api 22."]
    pub addChild: ::std::option::Option<
        unsafe extern "C" fn(parent: ArkUI_NodeHandle, child: ArkUI_NodeHandle) -> i32,
    >,
    #[doc = " @brief Removes a component from its parent node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub removeChild: ::std::option::Option<
        unsafe extern "C" fn(parent: ArkUI_NodeHandle, child: ArkUI_NodeHandle) -> i32,
    >,
    #[doc = " @brief Inserts a component to a parent node after the specified <b>sibling</b> node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @param sibling Indicates the pointer to the sibling node after which the target node is to be inserted.\n If the value is null, the node is inserted at the start of the parent node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed on BuilderNode generated\n             nodes: setting or resetting attributes, setting events, or adding or editing subnodes.\n         Returns {@link ARKUI_ERROR_CODE_NODE_IS_ADOPTED} if the child node has already been adopted. add since api 22."]
    pub insertChildAfter: ::std::option::Option<
        unsafe extern "C" fn(
            parent: ArkUI_NodeHandle,
            child: ArkUI_NodeHandle,
            sibling: ArkUI_NodeHandle,
        ) -> i32,
    >,
    #[doc = " @brief Inserts a component to a parent node before the specified <b>sibling</b> node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @param sibling Indicates the pointer to the sibling node before which the target node is to be inserted.\n If the value is null, the node is inserted at the end of the parent node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed on BuilderNode generated\n             nodes: setting or resetting attributes, setting events, or adding or editing subnodes.\n         Returns {@link ARKUI_ERROR_CODE_NODE_IS_ADOPTED} if the child node has already been adopted. add since api 22."]
    pub insertChildBefore: ::std::option::Option<
        unsafe extern "C" fn(
            parent: ArkUI_NodeHandle,
            child: ArkUI_NodeHandle,
            sibling: ArkUI_NodeHandle,
        ) -> i32,
    >,
    #[doc = " @brief Inserts a component to the specified position in a parent node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @param position Indicates the position to which the target child node is to be inserted. If the value is a\n negative number or invalid, the node is inserted at the end of the parent node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed on BuilderNode generated\n             nodes: setting or resetting attributes, setting events, or adding or editing subnodes.\n         Returns {@link ARKUI_ERROR_CODE_NODE_IS_ADOPTED} if the child node has already been adopted. add since api 22."]
    pub insertChildAt: ::std::option::Option<
        unsafe extern "C" fn(
            parent: ArkUI_NodeHandle,
            child: ArkUI_NodeHandle,
            position: i32,
        ) -> i32,
    >,
    #[doc = " @brief Sets the attribute of a node.\n\n @param node Indicates the node whose attribute needs to be set.\n @param attribute Indicates the type of attribute to set.\n @param value Indicates the attribute value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} if the dynamic implementation library\n         of the native API was not found.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n         on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub setAttribute: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            attribute: ArkUI_NodeAttributeType,
            item: *const ArkUI_AttributeItem,
        ) -> i32,
    >,
    #[doc = " @brief Obtains an attribute.\n\n The pointer returned by this API is an internal buffer pointer of the ArkUI framework. As such, you do not need\n to call <b>delete</b> to release the memory. However, the pointer must be used before this API is called next\n time. Otherwise, the pointer may be overwritten by other values.\n @param node Indicates the node whose attribute needs to be obtained.\n @param attribute Indicates the type of attribute to obtain.\n @return Returns the attribute value. If the operation fails, a null pointer is returned."]
    pub getAttribute: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            attribute: ArkUI_NodeAttributeType,
        ) -> *const ArkUI_AttributeItem,
    >,
    #[doc = " @brief Resets an attribute.\n\n @param node Indicates the node whose attribute needs to be reset.\n @param attribute Indicates the type of attribute to reset.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} if the dynamic implementation library\n         of the native API was not found.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n         on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub resetAttribute: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, attribute: ArkUI_NodeAttributeType) -> i32,
    >,
    #[doc = " @brief Registers an event for the specified node.\n\n When the component is being displayed, this API must be called in the main thread.\n\n @param node Indicates the target node.\n @param eventType Indicates the type of event to register.\n @param targetId Indicates the custom event ID, which is passed in the callback of {@link ArkUI_NodeEvent}\n when the event is triggered.\n @param userData Indicates the custom event parameter, which is passed in the callback of {@link ArkUI_NodeEvent}\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} if the dynamic implementation library\n         of the native API was not found.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n         on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub registerNodeEvent: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventType: ArkUI_NodeEventType,
            targetId: i32,
            userData: *mut ::std::os::raw::c_void,
        ) -> i32,
    >,
    #[doc = " @brief Unregisters an event for the specified node.\n\n When the component is being displayed, this API must be called in the main thread.\n\n @param node Indicates the target node.\n @param eventType Indicates the type of event to unregister."]
    pub unregisterNodeEvent: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, eventType: ArkUI_NodeEventType),
    >,
    #[doc = " @brief Registers an event receiver.\n\n The ArkUI framework collects component events generated during the process and calls back the events through\n the registered event receiver. \\n\n A new call to this API will overwrite the previously registered event receiver. \\n\n Do not directly save the <b>ArkUI_NodeEvent</b> object pointer. The data will be destroyed after the\n callback is complete. \\n\n To bind with a component instance, you can use the <b>addNodeEventReceiver</b> function. \\n\n\n @param eventReceiver Indicates the event receiver to register."]
    pub registerNodeEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            eventReceiver: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeEvent)>,
        ),
    >,
    #[doc = " @brief Unregisters the event receiver.\n"]
    pub unregisterNodeEventReceiver: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " @brief Forcibly marks the current node that needs to be measured, laid out, or rendered again.\n\n Regarding updates to system attributes, the ArkUI framework automatically marks the dirty area and performs\n measuring, layout, or rendering again. In this case, you do not need to call this API.\n @param node Indicates the node for which you want to mark as dirty area.\n @param dirtyFlag Indicates type of dirty area."]
    pub markDirty: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, dirtyFlag: ArkUI_NodeDirtyFlag),
    >,
    #[doc = " @brief Obtains the number of subnodes.\n\n @param node Indicates the target node.\n @return the number of subnodes. If not, returns 0."]
    pub getTotalChildCount:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> u32>,
    #[doc = " @brief Obtains a subnode.\n\n @param node Indicates the target node.\n @param position Indicates the position of the subnode.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getChildAt: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, position: i32) -> ArkUI_NodeHandle,
    >,
    #[doc = " @brief Obtains the first subnode.\n\n @param node Indicates the target node.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getFirstChild:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Obtains the last subnode.\n\n @param node Indicates the target node.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getLastChild:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Obtains the previous sibling node.\n\n @param node Indicates the target node.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getPreviousSibling:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Obtains the next sibling node.\n\n @param node Indicates the target node.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getNextSibling:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Registers a custom event for a node. When the event is triggered, the value is returned through the entry\n point function registered by <b>registerNodeCustomEventReceiver</b>.\n\n @param node Indicates the target node.\n @param eventType Indicates the type of event to register.\n @param targetId Indicates the custom event ID, which is passed in the callback of {@link ArkUI_NodeCustomEvent}\n when the event is triggered.\n @param userData Indicates the custom event parameter, which is passed in the callback of\n {@link ArkUI_NodeCustomEvent} when the event is triggered.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} if the dynamic implementation library\n         of the native API was not found."]
    pub registerNodeCustomEvent: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventType: ArkUI_NodeCustomEventType,
            targetId: i32,
            userData: *mut ::std::os::raw::c_void,
        ) -> i32,
    >,
    #[doc = " @brief Unregisters a custom event for a node.\n\n @param node Indicates the target node.\n @param eventType Indicates the type of event to unregister."]
    pub unregisterNodeCustomEvent: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, eventType: ArkUI_NodeCustomEventType),
    >,
    #[doc = " @brief Registers a unified entry point function for custom node event callbacks.\n\n The ArkUI framework collects custom component events generated during the process and calls back the events\n through the registered <b>registerNodeCustomEventReceiver</b>. \\n\n A new call to this API will overwrite the previously registered event receiver.\n Do not directly save the <b>ArkUI_NodeCustomEvent</b> object pointer.\n The data will be destroyed after the callback is complete. \\n\n To bind with a component instance, you can use the <b>addNodeCustomEventReceiver</b> function. \\n\n\n @param eventReceiver Indicates the event receiver to register."]
    pub registerNodeCustomEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            eventReceiver: ::std::option::Option<
                unsafe extern "C" fn(event: *mut ArkUI_NodeCustomEvent),
            >,
        ),
    >,
    #[doc = " @brief Unregisters the unified entry point function for custom node event callbacks.\n"]
    pub unregisterNodeCustomEventReceiver: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " @brief Sets the width and height for a component after the measurement.\n\n @param node Indicates the target node.\n @param width Indicates the width.\n @param height Indicates the height.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub setMeasuredSize: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, width: i32, height: i32) -> i32,
    >,
    #[doc = " @brief Sets the position for a component.\n\n @param node Indicates the target node.\n @param positionX Indicates the X coordinate.\n @param positionY Indicates the Y coordinate.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub setLayoutPosition: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, positionX: i32, positionY: i32) -> i32,
    >,
    #[doc = " @brief Obtains the width and height of a component after measurement.\n\n @param node Indicates the target node.\n @return Returns the width and height of the component."]
    pub getMeasuredSize:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_IntSize>,
    #[doc = " @brief Obtains the position of a component after the layout is complete.\n\n @param node Indicates the target node.\n @return Returns the position of the component."]
    pub getLayoutPosition:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_IntOffset>,
    #[doc = " @brief Measures a node. You can use the <b>getMeasuredSize</b> API to obtain the size after the measurement.\n\n @param node Indicates the target node.\n @param Constraint Indicates the size constraint.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub measureNode: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            Constraint: *mut ArkUI_LayoutConstraint,
        ) -> i32,
    >,
    #[doc = " @brief Lays outs a component and passes the expected position of the component relative to its parent component.\n\n When the component is being displayed, this API must be called in the main thread.\n\n @param node Indicates the target node.\n @param positionX Indicates the X coordinate.\n @param positionY Indicates the Y coordinate.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub layoutNode: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, positionX: i32, positionY: i32) -> i32,
    >,
    #[doc = " @brief Adds a component event callback function to a component to receive component events generated\n by the component.\n\n Unlike the global registration function <b>registerNodeEventReceiver</b>, this API allows multiple event\n receivers to be added to the same component. \\n\n The callback added by this API is triggered before the global callback registered by\n <b>registerNodeEventReceiver</b>. \\n\n Do not directly save the <b>ArkUI_NodeEvent</b> object pointer.\n The data will be destroyed after the callback is complete. \\n\n\n @param node Indicates the component for which you want to add the event callback function.\n @param eventReceiver Indicates the component event callback function to add.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub addNodeEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventReceiver: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeEvent)>,
        ) -> i32,
    >,
    #[doc = " @brief Removes the registered component event callback function from a component.\n\n @param node Indicates the component from which you want to remove the event callback function.\n @param eventReceiver Indicates the component event callback function to remove.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub removeNodeEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventReceiver: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeEvent)>,
        ) -> i32,
    >,
    #[doc = " @brief Adds a custom event callback function to a component to receive custom events\n (such as layout and drawing events) generated by the component.\n\n Unlike the global registration function <b>registerNodeCustomEventReceiver</b>, this API allows\n multiple event receivers to be added to the same component. \\n\n The callback added by this API is triggered before the global callback registered by\n <b>registerNodeCustomEventReceiver</b>. \\n\n Do not directly save the <b>ArkUI_NodeCustomEvent</b> object pointer.\n The data will be destroyed after the callback is complete. \\n\n\n @param node Indicates the component for which you want to add the custom event callback function.\n @param eventReceiver Indicates the custom event callback function to add.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub addNodeCustomEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventReceiver: ::std::option::Option<
                unsafe extern "C" fn(event: *mut ArkUI_NodeCustomEvent),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Removes a registered custom event callback function from a component.\n\n @param node Indicates the component from which you want to remove the custom event callback function.\n @param eventReceiver Indicates the custom event callback function to remove.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub removeNodeCustomEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventReceiver: ::std::option::Option<
                unsafe extern "C" fn(event: *mut ArkUI_NodeCustomEvent),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Saves custom data on the specified component.\n\n @param node Indicates the component on which the custom data will be saved.\n @param userData Indicates the custom data to be saved.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub setUserData: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, userData: *mut ::std::os::raw::c_void) -> i32,
    >,
    #[doc = " @brief Obtains the custom data saved on the specified component.\n\n @param node Indicates the target component.\n @return Returns the custom data."]
    pub getUserData: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " @brief Sets the unit for a component.\n\n @param node Indicates the component for which you want to set the unit.\n @param unit Indicates the unit, which is an enumerated value of {@link ArkUI_LengthMetricUnit}.\n The default value is <b>ARKUI_LENGTH_METRIC_UNIT_DEFAULT</b>.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setLengthMetricUnit: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, unit: ArkUI_LengthMetricUnit) -> i32,
    >,
    #[doc = " @brief Get the parent node.\n\n @param node target node object.\n @return Returns the pointer of the component, if not return NULL"]
    pub getParent:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Uninstall all child nodes from the parent component.\n\n @param parent target node object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub removeAllChildren:
        ::std::option::Option<unsafe extern "C" fn(parent: ArkUI_NodeHandle) -> i32>,
}
extern "C" {
    #[doc = " @brief Obtains the size constraint for measurement through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the pointer to the size constraint.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetLayoutConstraintInMeasure(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> *mut ArkUI_LayoutConstraint;
}
extern "C" {
    #[doc = " @brief Obtains the expected position of a component relative to its parent component in the layout phase through a\n custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the expected position relative to the parent component.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetPositionInLayout(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> ArkUI_IntOffset;
}
extern "C" {
    #[doc = " @brief Obtains the drawing context through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the drawing context.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetDrawContextInDraw(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> *mut ArkUI_DrawContext;
}
extern "C" {
    #[doc = " @brief Obtains the ID of a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the ID of the custom component event.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetEventTargetId(event: *mut ArkUI_NodeCustomEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains custom event parameters through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the custom event parameters.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetUserData(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains a component object through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the component object.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetNodeHandle(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Obtains the event type through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the type of the custom component event.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetEventType(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> ArkUI_NodeCustomEventType;
}
extern "C" {
    #[doc = " @brief Obtains the measurement information of a custom span through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @param info Indicates the measurement information to be obtained.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetCustomSpanMeasureInfo(
        event: *mut ArkUI_NodeCustomEvent,
        info: *mut ArkUI_CustomSpanMeasureInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the measurement metrics of a custom span through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @param metrics Indicates the measurement metrics to set.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_SetCustomSpanMetrics(
        event: *mut ArkUI_NodeCustomEvent,
        metrics: *mut ArkUI_CustomSpanMetrics,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the drawing information of a custom span through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @param info Indicates the drawing information to obtain.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetCustomSpanDrawInfo(
        event: *mut ArkUI_NodeCustomEvent,
        info: *mut ArkUI_CustomSpanDrawInfo,
    ) -> i32;
}
#[doc = " Defines the attach event."]
pub const ArkUI_NodeContentEventType_NODE_CONTENT_EVENT_ON_ATTACH_TO_WINDOW:
    ArkUI_NodeContentEventType = 0;
#[doc = " Defines the detach event."]
pub const ArkUI_NodeContentEventType_NODE_CONTENT_EVENT_ON_DETACH_FROM_WINDOW:
    ArkUI_NodeContentEventType = 1;
#[doc = " @brief Defines the node content event type.\n\n @since 12"]
pub type ArkUI_NodeContentEventType = u32;
#[doc = " @error Success."]
#[cfg(feature = "api-15")]
pub const ArkUI_InspectorErrorCode_ARKUI_INSPECTOR_NATIVE_RESULT_SUCCESSFUL:
    ArkUI_InspectorErrorCode = 0;
#[doc = " @error Invalid parameter."]
#[cfg(feature = "api-15")]
pub const ArkUI_InspectorErrorCode_ARKUI_INSPECTOR_NATIVE_RESULT_BAD_PARAMETER:
    ArkUI_InspectorErrorCode = -1;
#[doc = " @brief Enumerates the inspector error codes.\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_InspectorErrorCode = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeContentEvent {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the callback function of a node content event.\n @since 12"]
pub type ArkUI_NodeContentCallback =
    ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeContentEvent)>;
extern "C" {
    #[doc = " @brief register a callback function to a node content.\n\n @param content Indicates the pointer to the node content instance.\n @param callback Indicates the callback function.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_RegisterCallback(
        content: ArkUI_NodeContentHandle,
        callback: ArkUI_NodeContentCallback,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the type of a node content event.\n\n @param event Indicates the pointer to the node content event.\n @return Returns the type of the node content event.\n @since 12"]
    pub fn OH_ArkUI_NodeContentEvent_GetEventType(
        event: *mut ArkUI_NodeContentEvent,
    ) -> ArkUI_NodeContentEventType;
}
extern "C" {
    #[doc = " @brief Obtains the node content object that triggers a node content event.\n\n @param event Indicates the pointer to the node content event.\n @return Returns the node content object that triggers the node content event.\n @since 12"]
    pub fn OH_ArkUI_NodeContentEvent_GetNodeContentHandle(
        event: *mut ArkUI_NodeContentEvent,
    ) -> ArkUI_NodeContentHandle;
}
extern "C" {
    #[doc = " @brief Saves custom data on the specified node content.\n\n @param content Indicates the node content on which the custom data will be saved.\n @param userData Indicates the custom data to be saved.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_SetUserData(
        content: ArkUI_NodeContentHandle,
        userData: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the custom data saved on the specified node content.\n\n @param content Indicates the target node content.\n @return Returns the custom data.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_GetUserData(
        content: ArkUI_NodeContentHandle,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Add a node to a node content.\n\n @param content Indicates the pointer to the node content instance.\n @param node Indicates the pointer to the node\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NODE_IS_ADOPTED} if the node has already been adopted. add since api 22.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_AddNode(
        content: ArkUI_NodeContentHandle,
        node: ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief remove a node from a node content.\n\n @param content Indicates the pointer to the node content instance.\n @param node Indicates the pointer to the node\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_RemoveNode(
        content: ArkUI_NodeContentHandle,
        node: ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief insert a node into a node content at a given position.\n\n @param content Indicates the pointer to the node content instance.\n @param node Indicates the pointer to the node\n @param position Indicates the position for inserting the node\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NODE_IS_ADOPTED} if the node has already been adopted. add since api 22.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_InsertNode(
        content: ArkUI_NodeContentHandle,
        node: ArkUI_NodeHandle,
        position: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the size of the component layout area.\n The layout area size does not include graphic variation attributes such as scaling.\n\n @param node ArkUI_NodeHandle pointer.\n @param size The drawing area size of the component handle, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetLayoutSize(
        node: ArkUI_NodeHandle,
        size: *mut ArkUI_IntSize,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component layout area relative to the parent component.\n The relative position of the layout area does not include graphic variation attributes, such as translation.\n\n @param node ArkUI_NodeHandle pointer.\n @param localOffset The offset value of the component handle relative to the parent component, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetLayoutPosition(
        node: ArkUI_NodeHandle,
        localOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component layout area relative to the window.\n The relative position of the layout area does not include graphic variation attributes, such as translation.\n\n @param node ArkUI_NodeHandle pointer.\n @param globalOffset The offset value of the component handle relative to the window, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetLayoutPositionInWindow(
        node: ArkUI_NodeHandle,
        globalOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component layout area relative to the screen.\n The relative position of the layout area does not include graphic variation attributes, such as translation.\n\n @param node ArkUI_NodeHandle pointer.\n @param screenOffset The offset value of the component handle relative to the screen, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetLayoutPositionInScreen(
        node: ArkUI_NodeHandle,
        screenOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the offset of a component relative to the global display.\n The relative position does not count in transformation attributes, such as translate.\n\n @param node Pointer to the <b>ArkUI_NodeHandle</b> representing the component.\n @param offset Offset of the component relative to the global display, in px.\n @return Result code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_NodeUtils_GetLayoutPositionInGlobalDisplay(
        node: ArkUI_NodeHandle,
        offset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component in the window, including the properties of graphic translation changes.\n\n @param node ArkUI_NodeHandle pointer.\n @param translateOffset The cumulative offset value of the component handle itself,\n parent components, and ancestor nodes, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetPositionWithTranslateInWindow(
        node: ArkUI_NodeHandle,
        translateOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component on the screen, including the attributes of graphic translation changes.\n\n @param node ArkUI_NodeHandle pointer.\n @param translateOffset The cumulative offset value of the component handle itself,\n parent components, and ancestor nodes, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetPositionWithTranslateInScreen(
        node: ArkUI_NodeHandle,
        translateOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Add the custom property of the component. This interface only works on the main thread.\n\n @param node ArkUI_NodeHandle pointer.\n @param name The name of the custom property. Passing null pointers is not allowed.\n @param value The value of the custom property. Passing null pointers is not allowed.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_ArkUI_NodeUtils_AddCustomProperty(
        node: ArkUI_NodeHandle,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Remove the custom property of the component.\n\n @param node ArkUI_NodeHandle pointer.\n @param name The name of the custom property.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_ArkUI_NodeUtils_RemoveCustomProperty(
        node: ArkUI_NodeHandle,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Get the value of the custom property of the component.\n\n @param node ArkUI-NodeHandle pointer.\n @param name The name of the custom attribute.\n @param handle The structure of the custom attribute corresponding to the key parameter name obtained.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_NodeUtils_GetCustomProperty(
        node: ArkUI_NodeHandle,
        name: *const ::std::os::raw::c_char,
        handle: *mut *mut ArkUI_CustomProperty,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the parent node to obtain the component nodes created by ArkTs.\n\n @param node Target node object.\n @return Return the pointer of the component.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_NodeUtils_GetParentInPageTree(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Retrieve all active child nodes of a node. Span will not be counted in the children.\n\n @param head Pass in the node that needs to be obtained.\n @param handle The structure corresponding to the sub node information of the head node.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_NodeUtils_GetActiveChildrenInfo(
        head: ArkUI_NodeHandle,
        handle: *mut *mut ArkUI_ActiveChildrenInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Retrieve the root node of the current page.\n\n @param node Target node object.\n @return Return the pointer of the component.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_NodeUtils_GetCurrentPageRootNode(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Retrieve whether the component is labeled by C-API.\n\n @param node Target node object.\n @return Return whether the node is a Tag created by C-API,\n         true represents created by C-API, false represents not created by C-API.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_NodeUtils_IsCreatedByNDK(node: ArkUI_NodeHandle) -> bool;
}
extern "C" {
    #[doc = " @brief Get the type of node.\n\n @param node Target node object.\n @return Return the type of the node.\n         For specific open types, refer to {@link ArkUI_NodeType}. For unopened nodes, return -1.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_NodeUtils_GetNodeType(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Get info of the window to which the node belongs.\n\n @param node Target node object.\n @param info Window info. Use {@link OH_ArkUI_HostWindowInfo_Destroy} to release memory.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n         {@link ARKUI_ERROR_CODE_NODE_NOT_ON_MAIN_TREE} The node is not mounted.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_NodeUtils_GetWindowInfo(
        node: ArkUI_NodeHandle,
        info: *mut *mut ArkUI_HostWindowInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the index of the current FrameNode's first child node which is on the tree.\n\n @param node Indicates the target node.\n @param index The index of the subnode.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_NodeUtils_GetFirstChildIndexWithoutExpand(
        node: ArkUI_NodeHandle,
        index: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the index of the current FrameNode's last child node which is on the tree.\n\n @param node Indicates the target node.\n @param index the index of the subnode.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_NodeUtils_GetLastChildIndexWithoutExpand(
        node: ArkUI_NodeHandle,
        index: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a subnode by position with the expand mode.\n\n @param node Indicates the target node.\n @param position Indicates the position of the subnode.\n @param subnode The pointer to the subnode.\n @param expandMode Indicates the expand mode. {@link ArkUI_ExpandMode}.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_NodeUtils_GetChildWithExpandMode(
        node: ArkUI_NodeHandle,
        position: i32,
        subnode: *mut ArkUI_NodeHandle,
        expandMode: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Collapse the ListItem in its expanded state.\n\n @param node Node objects that need to be registered for events.\n @param userData Custom event parameters are carried back in the callback parameter when the event is triggered.\n @param onFinish The callback triggered after the completion of the folding animation.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n         {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} The component does not support this event.\n @since 12"]
    pub fn OH_ArkUI_List_CloseAllSwipeActions(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onFinish: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the UIContext pointer to the page where the node is located.\n\n @param node The node.\n @return The UIContext pointer.\n         If a null pointer is returned, it may be because the node is empty.\n @since 12"]
    pub fn OH_ArkUI_GetContextByNode(node: ArkUI_NodeHandle) -> ArkUI_ContextHandle;
}
extern "C" {
    #[doc = " @brief The event called when the system color mode changes.\n        Only one system color change callback can be registered for the same component.\n\n @param node Indicates the target node.\n @param userData Indicates the custom data to be saved.\n @param onColorModeChange Callback Events.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 12"]
    pub fn OH_ArkUI_RegisterSystemColorModeChangeEvent(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onColorModeChange: ::std::option::Option<
            unsafe extern "C" fn(
                colorMode: ArkUI_SystemColorMode,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregister the event callback when the system color mode changes.\n\n @param node Indicates the target node.\n @since 12"]
    pub fn OH_ArkUI_UnregisterSystemColorModeChangeEvent(node: ArkUI_NodeHandle);
}
extern "C" {
    #[doc = " @brief The event called when the system font style changes.\n        Only one system font change callback can be registered for the same component.\n\n @param node Indicates the target node.\n @param userData Indicates the custom data to be saved.\n @param onFontStyleChange Callback Events.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 12"]
    pub fn OH_ArkUI_RegisterSystemFontStyleChangeEvent(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onFontStyleChange: ::std::option::Option<
            unsafe extern "C" fn(
                event: *mut ArkUI_SystemFontStyleEvent,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregister the event callback when the system font style changes.\n\n @param node Indicates the target node.\n @since 12"]
    pub fn OH_ArkUI_UnregisterSystemFontStyleChangeEvent(node: ArkUI_NodeHandle);
}
extern "C" {
    #[doc = " @brief Retrieve the font size value for system font change events.\n\n @param event Indicates a pointer to the current system font change event.\n @return Updated system font size scaling factor. Default value: 1.0.\n @since 12"]
    pub fn OH_ArkUI_SystemFontStyleEvent_GetFontSizeScale(
        event: *const ArkUI_SystemFontStyleEvent,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Retrieve the font thickness values for system font change events.\n\n @param event Indicates a pointer to the current system font change event.\n @return The updated system font thickness scaling factor. Default value: 1.0.\n @since 12"]
    pub fn OH_ArkUI_SystemFontStyleEvent_GetFontWeightScale(
        event: *const ArkUI_SystemFontStyleEvent,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Move the node handle to target parent node as child.\n\n @param node The node handle of the node to move.\n @param target_parent The node handle of target parent.\n @param index Indicates the index which the node is moved to. If the value is a nagative number of invalid, the\n              node is moved to the end of the target parent node.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n         {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n         {@link ARKUI_ERROR_CODE_NODE_IS_ADOPTED} if the node has already been adopted. add since api 22.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_NodeUtils_MoveTo(
        node: ArkUI_NodeHandle,
        target_parent: ArkUI_NodeHandle,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Triggers node updates in the current frame.\n When node attributes are modified after the current frame's build phase (i.e., after\n the unified processing of dirty nodes), the node updates will be deferred to the next\n frame. This function forces immediate node updates within the current frame to\n ensure rendering effects are applied synchronously.\n\n @param node ArkUI_NodeHandle pointer.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_NativeModule_InvalidateAttributes(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Set the cross-language option of the target node handle.\n\n @param node The target node handle.\n @param option The cross-language option {@link ArkUI_CrossLanguageOption}.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_NodeUtils_SetCrossLanguageOption(
        node: ArkUI_NodeHandle,
        option: *mut ArkUI_CrossLanguageOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the cross-language option of the target node handle.\n\n @param node The target node handle.\n @param option The cross-language option {@link ArkUI_CrossLanguageOption}.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_NodeUtils_GetCrossLanguageOption(
        node: ArkUI_NodeHandle,
        option: *mut ArkUI_CrossLanguageOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a callback for node when layout is completed.\n\n @param node Indicates the target node.\n @param userData Indicates the custom data used in onLayoutCompleted callback function.\n @param onLayoutCompleted Indicates the function when layout completed is callback.\n @return error code\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter is incorrect.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_RegisterLayoutCallbackOnNodeHandle(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onLayoutCompleted: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a callback for node when draw is completed.\n\n @param node Indicates the target node.\n @param userData Indicates the custom data used in onDrawCompleted callback function.\n @param onDrawCompleted Indicates the function when draw completed is callback.\n @return error code\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter is incorrect.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_RegisterDrawCallbackOnNodeHandle(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onDrawCompleted: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregisters the layout completed callback for node.\n\n @param node Indicates the target node.\n @return error code\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter is incorrect.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_UnregisterLayoutCallbackOnNodeHandle(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Unregisters the draw completed callback for node.\n\n @param node Indicates the target node.\n @return error code\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter is incorrect.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_UnregisterDrawCallbackOnNodeHandle(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Get the node handle by id.\n\n @param id The id of the target node handle.\n @param node The handle of target node handle.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_NodeUtils_GetAttachedNodeHandleById(
        id: *const ::std::os::raw::c_char,
        node: *mut ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the snapshot pixelmap for the given node synchronously, will get error if the node is not on the\n tree or is not rendered yet.\n Note: the pixelmap should be released through OH_PixelmapNative_Release when it's not used any more.\n\n @param node Indicates the target node.\n @param snapshotOptions the given configuration for taking snapshot, can be null for using default.\n @param pixelmap Pixelmap pointer created by system, it's the out result.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_INTERNAL_ERROR} if the snapshot taking failed will null pixelmap returned.\n         Returns {@link ARKUI_ERROR_CODE_COMPONENT_SNAPSHOT_TIMEOUT} if the snapshot taking is timeout.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_GetNodeSnapshot(
        node: ArkUI_NodeHandle,
        snapshotOptions: *mut ArkUI_SnapshotOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the offset of a specific node relative to its parent node.\n\n @param node Target node.\n @param globalOffset Offset of the target node relative to its parent node, in px.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_NodeUtils_GetPositionToParent(
        node: ArkUI_NodeHandle,
        globalOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Adds the UI state style supported by the component. To handle states change efficiently, need to specify the\n states of interest and the corresponding handler. When a state of interest occurs, the handler will be executed.\n  - You can adjust the UI style based on the current state within the callback. If this API is called multiple\n times on the same node, the last set of states and handler will take precedence.\n  - Some component types have default system handling for certain states. For example, the <b>Button</b>\n component has a default style effect for the PRESSED state. When custom state handling is implemented on such\n components, the default style effect will be applied first, followed by the custom style changes, resulting in\n a combined effect. To disable the default style effects, set <b>excludeInner</b> to <b>true</b>, if this is allowed\n by the system implementation.\n  - And when this API is called, the provided handler function will be executed immediately.\n  - There is no need to explicitly register a listener for the NORMAL state. Once a non-NORMAL state is registered,\n the system will automatically notify your application when the state changes back to NORMAL.\n\n @param node Target node.\n @param uiStates Target UI states to be handled on the node.\n        The combined result of all target UI states can be calculated using the <b>|</b> operator.\n        Example: <b>targetUIStates = ArkUI_UIState::PRESSED | ArkUI_UIState::FOCUSED</b>.\n @param statesChangeHandler Handler for UI state changes.\n        It rturns the current UI status. The value is the result of combining all current state enum values using the\n        <b>|</b> operator. You can determine the state using the <b>&</b> operator.\n        Example: <b>if (currentStates & ArkUI_UIState::PRESSED == ArkUI_UIState::PRESSED)</b>.\n        However, for checking the normal state, use the equality operator directly.\n        Example: <b>if (currentStates == ArkUI_UIState::NORMAL)</b>.\n @param excludeInner Whether to disable the default state styles.\n @param userData Custom data used in the <b>statesChangeHandler</b> callback.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_AddSupportedUIStates(
        node: ArkUI_NodeHandle,
        uiStates: i32,
        statesChangeHandler: ::std::option::Option<
            unsafe extern "C" fn(currentStates: i32, userData: *mut ::std::os::raw::c_void),
        >,
        excludeInner: bool,
        userData: *mut ::std::os::raw::c_void,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Removes registered UI states. When all states registered using <b>OH_ArkUI_AddSupportedUIStates</b>\n are removed, the registered <b>stateChangeHandler</b> will no longer be executed.\n\n @param node Target node.\n @param uiStates Target UI states to be removed.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_RemoveSupportedUIStates(
        node: ArkUI_NodeHandle,
        uiStates: i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Run a custom function inside the UIContext scope.\n\n @param uiContext ArkUI_ContextHandle.\n @param userData Indicates the pointer to the custom data.\n @param callback The custom function.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n         Returns {@link ARKUI_ERROR_CODE_UI_CONTEXT_INVALID} if the uiContext is invalid.\n         Returns {@link ARKUI_ERROR_CODE_CALLBACK_INVALID} if the callback function is invalid.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_RunTaskInScope(
        uiContext: ArkUI_ContextHandle,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the node handle by uniqueId.\n\n @param uniqueId The uniqueId of the target node handle.\n @param node The handle of target node handle.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n         {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_NodeUtils_GetNodeHandleByUniqueId(
        uniqueId: u32,
        node: *mut ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the uniqueId of the target node handle.\n\n @param node The ArkUI-NodeHandle pointer.\n @param uniqueId The uniqueId of the target node handle, default value is -1.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n         {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_NodeUtils_GetNodeUniqueId(node: ArkUI_NodeHandle, uniqueId: *mut i32) -> i32;
}
extern "C" {
    #[doc = " @brief The current node adopts the target child node. The node being adopted must not have an existing parent node.\n This operation does not actually append it as a child, but only allows it to receive life-cycle\n callbacks as if it were a child.\n\n @param node ArkUI_NodeHandle pointer, the parent node that will adopt the child node.\n @param child ArkUI_NodeHandle pointer, the target node being adopted.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n         {@link ARKUI_ERROR_CODE_NODE_HAS_PARENT} The child already has a parent node.\n         {@link ARKUI_ERROR_CODE_NODE_CAN_NOT_BE_ADOPTED} The child can not be adopted.\n         {@link ARKUI_ERROR_CODE_NODE_CAN_NOT_ADOPT_TO} The node can not adopt children.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_NativeModule_AdoptChild(node: ArkUI_NodeHandle, child: ArkUI_NodeHandle)
        -> i32;
}
extern "C" {
    #[doc = " @brief Remove the target adopted child node.\n\n @param node ArkUI_NodeHandle pointer, the parent node.\n @param child ArkUI_NodeHandle pointer, the node being removed.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n         {@link ARKUI_ERROR_CODE_NODE_IS_NOT_IN_ADOPTED_CHILDREN} This child node is not adopted by the parent node.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_NativeModule_RemoveAdoptedChild(
        node: ArkUI_NodeHandle,
        child: ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the inverse color algorithm for components and instances.\n\n @param uiContext Indicates the context in which the inverse color feature should take effect.\n     If the value is null, the feature applies to the entire application process.\n @param forceDark Indicates whether the inverse color feature is enabled.\n @param nodeType Indicates the component type for which to enable the inverse color feature.\n     If the value is ARKUI_NODE_UNDEFINED, enabling the feature for all components.\n @param colorInvertFunc Indicates the user-defined inverse color algorithm.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if CAPI init error.\n         Returns {@link ARKUI_ERROR_CODE_FORCE_DARK_CONFIG_INVALID} if force dark config is invalid.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_SetForceDarkConfig(
        uiContext: ArkUI_ContextHandle,
        forceDark: bool,
        nodeType: ArkUI_NodeType,
        colorInvertFunc: ::std::option::Option<unsafe extern "C" fn(color: u32) -> u32>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Post UI task to background threads.\n\n @param context UIContext pointer of the page where the UI task located.\n @param asyncUITaskData Parameter of asyncUITask and onFinish.\n @param asyncUITask Function executed by a background thread.\n @param onFinish Function executed by UI thread after async UI task is executed.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if context or asyncUITask is nullptr.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_PostAsyncUITask(
        context: ArkUI_ContextHandle,
        asyncUITaskData: *mut ::std::os::raw::c_void,
        asyncUITask: ::std::option::Option<
            unsafe extern "C" fn(asyncUITaskData: *mut ::std::os::raw::c_void),
        >,
        onFinish: ::std::option::Option<
            unsafe extern "C" fn(asyncUITaskData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Post UI task to UI thread.\n\n @param context UIContext pointer of the page where the UI task located.\n @param taskData Parameter of task.\n @param task Function executed by UI thread.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if context or task is nullptr.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_PostUITask(
        context: ArkUI_ContextHandle,
        taskData: *mut ::std::os::raw::c_void,
        task: ::std::option::Option<unsafe extern "C" fn(taskData: *mut ::std::os::raw::c_void)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Post UI task to UI thread and wait until UI task finished.\n\n @param context UIContext pointer of the page where the UI task located.\n @param taskData Parameter of task.\n @param task Function executed by UI thread.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if context or task is nullptr.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_PostUITaskAndWait(
        context: ArkUI_ContextHandle,
        taskData: *mut ::std::os::raw::c_void,
        task: ::std::option::Option<unsafe extern "C" fn(taskData: *mut ::std::os::raw::c_void)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Register common event callback of target node.\n\n @param node The ArkUI-NodeHandle pointer.\n @param eventType Indicates the type of event to set.\n @param userData Indicates the pointer to the custom data.\n @param callback Indicates the event callback function.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function params is invalid.\n         Returns {@link ARKUI_ERROR_CODE_NODE_UNSUPPORTED_EVENT_TYPE} Function parameter eventType is not supported.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_NativeModule_RegisterCommonEvent(
        node: ArkUI_NodeHandle,
        eventType: ArkUI_NodeEventType,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregister common event callback of target node.\n\n @param node The ArkUI-NodeHandle pointer.\n @param eventType Indicates the type of event to set.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function params is invalid.\n         Returns {@link ARKUI_ERROR_CODE_NODE_UNSUPPORTED_EVENT_TYPE} Function parameter eventType is not supported.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_NativeModule_UnregisterCommonEvent(
        node: ArkUI_NodeHandle,
        eventType: ArkUI_NodeEventType,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Register common visible area approximate change event callback of target node.\n\n @param node The ArkUI-NodeHandle pointer.\n @param ratios Threshold array representing the visible area of the component.\n @param size The size of the ratios.\n @param expectedUpdateInterval The expected calculation interval for developers.\n @param userData Indicates the pointer to the custom data.\n @param callback Indicates the event callback function.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function params is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_NativeModule_RegisterCommonVisibleAreaApproximateChangeEvent(
        node: ArkUI_NodeHandle,
        ratios: *mut f32,
        size: i32,
        expectedUpdateInterval: f32,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregister common visible area approximate change event callback of target node.\n\n @param node The ArkUI-NodeHandle pointer.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function params is invalid.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_ArkUI_NativeModule_UnregisterCommonVisibleAreaApproximateChangeEvent(
        node: ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Stop the animation being executed by the Swiper node.\n\n @param node ArkUI_NodeHandle pointer.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_Swiper_FinishAnimation(node: ArkUI_NodeHandle) -> i32;
}
#[doc = " Touching the system-defined Back button or pressing the Esc key."]
pub const ArkUI_DismissReason_DIALOG_DISMISS_BACK_PRESS: ArkUI_DismissReason = 0;
#[doc = " Touching the mask."]
pub const ArkUI_DismissReason_DIALOG_DISMISS_TOUCH_OUTSIDE: ArkUI_DismissReason = 1;
#[doc = " Touching the Close button."]
pub const ArkUI_DismissReason_DIALOG_DISMISS_CLOSE_BUTTON: ArkUI_DismissReason = 2;
#[doc = " Sliding down."]
pub const ArkUI_DismissReason_DIALOG_DISMISS_SLIDE_DOWN: ArkUI_DismissReason = 3;
#[doc = " @brief Enumerates the actions for triggering closure of the dialog box.\n\n @since 12"]
pub type ArkUI_DismissReason = u32;
#[doc = " @brief Uninitialized.\n @syscap SystemCapability.ArkUI.ArkUI.Full\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_DialogState_DIALOG_UNINITIALIZED: ArkUI_DialogState = 0;
#[doc = " @brief Initialized.\n @syscap SystemCapability.ArkUI.ArkUI.Full\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_DialogState_DIALOG_INITIALIZED: ArkUI_DialogState = 1;
#[doc = " @brief Appearing.\n @syscap SystemCapability.ArkUI.ArkUI.Full\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_DialogState_DIALOG_APPEARING: ArkUI_DialogState = 2;
#[doc = " @brief Appeared.\n @syscap SystemCapability.ArkUI.ArkUI.Full\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_DialogState_DIALOG_APPEARED: ArkUI_DialogState = 3;
#[doc = " @brief Disappearing.\n @syscap SystemCapability.ArkUI.ArkUI.Full\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_DialogState_DIALOG_DISAPPEARING: ArkUI_DialogState = 4;
#[doc = " @brief Disappeared.\n @syscap SystemCapability.ArkUI.ArkUI.Full\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_DialogState_DIALOG_DISAPPEARED: ArkUI_DialogState = 5;
#[doc = " @brief Enumerates the state of dialog.\n\n @syscap SystemCapability.ArkUI.ArkUI.Full\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type ArkUI_DialogState = u32;
#[doc = " overlay mode."]
#[cfg(feature = "api-15")]
pub const ArkUI_LevelMode_ARKUI_LEVEL_MODE_OVERLAY: ArkUI_LevelMode = 0;
#[doc = " embedded mode."]
#[cfg(feature = "api-15")]
pub const ArkUI_LevelMode_ARKUI_LEVEL_MODE_EMBEDDED: ArkUI_LevelMode = 1;
#[doc = " @brief Enumerates the level mode.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_LevelMode = u32;
#[doc = " Mask covering the parent node area."]
#[cfg(feature = "api-15")]
pub const ArkUI_ImmersiveMode_ARKUI_IMMERSIVE_MODE_DEFAULT: ArkUI_ImmersiveMode = 0;
#[doc = " Mask extend safe area includes status bar and navigation bar."]
#[cfg(feature = "api-15")]
pub const ArkUI_ImmersiveMode_ARKUI_IMMERSIVE_MODE_EXTEND: ArkUI_ImmersiveMode = 1;
#[doc = " @brief Enumerates the immersive mode.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_ImmersiveMode = u32;
#[doc = " @brief Invoked when the dialog box is closed.\n\n @since 12"]
pub type ArkUI_OnWillDismissEvent =
    ::std::option::Option<unsafe extern "C" fn(reason: i32) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DialogDismissEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CustomDialogOptions {
    _unused: [u8; 0],
}
#[doc = " @brief Provides the custom dialog box APIs for the native side.\n\n @version 1\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeDialogAPI_1 {
    #[doc = " @brief Creates a custom dialog box and returns the pointer to the created dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @return Returns the pointer to the created custom dialog box; returns a null pointer if the creation fails."]
    pub create: ::std::option::Option<unsafe extern "C" fn() -> ArkUI_NativeDialogHandle>,
    #[doc = " @brief Destroys a custom dialog box.\n\n @param handle Indicates the pointer to the custom dialog box controller."]
    pub dispose: ::std::option::Option<unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle)>,
    #[doc = " @brief Attaches the content of a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param content Indicates the pointer to the root node of the custom dialog box content.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setContent: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, content: ArkUI_NodeHandle) -> i32,
    >,
    #[doc = " @brief Detaches the content of a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub removeContent:
        ::std::option::Option<unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle) -> i32>,
    #[doc = " @brief Sets the alignment mode for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param alignment Indicates the alignment mode. The parameter type is {@link ArkUI_Alignment}.\n @param offsetX Indicates the horizontal offset of the custom dialog box. The value is a floating point number.\n @param offsetY Indicates the vertical offset of the custom dialog box. The value is a floating point number.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setContentAlignment: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            alignment: i32,
            offsetX: f32,
            offsetY: f32,
        ) -> i32,
    >,
    #[doc = " @brief Resets the alignment mode of a custom dialog box to its default settings.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub resetContentAlignment:
        ::std::option::Option<unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle) -> i32>,
    #[doc = " @brief Sets the modal mode for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param isModal Specifies whether the custom dialog box is a modal, which has a mask applied. The value\n <b>true</b> means that the custom dialog box is a modal, and <b>false</b> means the opposite.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setModalMode: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, isModal: bool) -> i32,
    >,
    #[doc = " @brief Specifies whether to allow users to touch the mask to dismiss the custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param autoCancel Specifies whether to allow users to touch the mask to dismiss the dialog box.\n The value <b>true</b> means to allow users to do so, and <b>false</b> means the opposite.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setAutoCancel: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, autoCancel: bool) -> i32,
    >,
    #[doc = " @brief Sets the mask for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param maskColor Indicates the mask color, in 0xARGB format.\n @param maskRect Indicates the pointer to the mask area. Events outside the mask area are transparently\n transmitted, and events within the mask area are not. The parameter type is {@link ArkUI_Rect}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setMask: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            maskColor: u32,
            maskRect: *const ArkUI_Rect,
        ) -> i32,
    >,
    #[doc = " @brief Sets the background color for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param backgroundColor Indicates the background color of the custom dialog box, in 0xARGB format.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setBackgroundColor: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, backgroundColor: u32) -> i32,
    >,
    #[doc = " @brief Sets the background corner radius for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param topLeft Indicates the radius of the upper left corner of the custom dialog box background.\n @param topRight Indicates the radius of the upper right corner of the custom dialog box background.\n @param bottomLeft Indicates the radius of the lower left corner of the custom dialog box background.\n @param bottomRight Indicates the radius of the lower right corner of the custom dialog box background.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setCornerRadius: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            topLeft: f32,
            topRight: f32,
            bottomLeft: f32,
            bottomRight: f32,
        ) -> i32,
    >,
    #[doc = " @brief Sets the number of grid columns occupied by a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param gridCount Indicates the number of grid columns occupied by the dialog box. The default value is subject to\n the window size, and the maximum value is the maximum number of columns supported by the system.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setGridColumnCount: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, gridCount: i32) -> i32,
    >,
    #[doc = " @brief Specifies whether to use a custom style for the custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param enableCustomStyle Specifies whether to use a custom style for the dialog box.\n <b>true</b>: The dialog box automatically adapts its width to the child components; the rounded corner is 0;\n the background color is transparent.\n <b>false</b>: The dialog box automatically adapts its width to the grid system and its height to the child\n components; the rounded corner is 24 vp.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub enableCustomStyle: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, enableCustomStyle: bool) -> i32,
    >,
    #[doc = " @brief Specifies whether to use a custom animation for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param enableCustomAnimation Specifies whether to use a custom animation. The value <b>true</b> means to use a\n custom animation, and <b>false</b> means to use the default animation.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub enableCustomAnimation: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, enableCustomAnimation: bool) -> i32,
    >,
    #[doc = " @brief Registers a callback for a custom dialog box so that the user can decide whether to close the dialog box\n after they touch the Back button or press the Esc key.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param eventHandler Indicates the callback to register. The parameter type is {@link ArkUI_OnWillDismissEvent}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub registerOnWillDismiss: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            eventHandler: ArkUI_OnWillDismissEvent,
        ) -> i32,
    >,
    #[doc = " @brief Shows a custom dialog box.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param showInSubWindow Specifies whether to show the dialog box in a sub-window.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub show: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, showInSubWindow: bool) -> i32,
    >,
    #[doc = " @brief Closes a custom dialog box. If the dialog box has been closed, this API does not take effect.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub close: ::std::option::Option<unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle) -> i32>,
    #[doc = " @brief Registers a listener for the dismiss event of the custom dialog box.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param userData Indicates the pointer to the custom data.\n @param callback Indicates the callback for the dismiss event of the custom dialog box.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub registerOnWillDismissWithUserData: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            userData: *mut ::std::os::raw::c_void,
            callback: ::std::option::Option<
                unsafe extern "C" fn(event: *mut ArkUI_DialogDismissEvent),
            >,
        ) -> i32,
    >,
}
#[doc = " @brief Provides the custom dialog box APIs for the native side.\n\n @version 2\n @since 15"]
#[cfg(feature = "api-15")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeDialogAPI_2 {
    #[doc = " @brief Provides the custom dialog box APIs for the native side. The API scope is {@link ArkUI_NativeDialogAPI_1}\n\n @since 15"]
    pub nativeDialogAPI1: ArkUI_NativeDialogAPI_1,
    #[doc = " @brief Defines the distance between the customDialog and system keyboard.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param distance distance, in vp.\n @param unit  Indicates the unit, which is an enumerated value of {@link ArkUI_LengthMetricUnit}\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub setKeyboardAvoidDistance: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            distance: f32,
            unit: ArkUI_LengthMetricUnit,
        ) -> i32,
    >,
    #[doc = " @brief Sets the level mode for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param levelMode Indicates the level mode. The parameter type is {@link ArkUI_LevelMode}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub setLevelMode: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, levelMode: ArkUI_LevelMode) -> i32,
    >,
    #[doc = " @brief Sets the level uniqueId for a custom dialog box.\n\n @note This method must be called before the <b>setLevelMode</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param uniqueId Indicates the uniquedId of any nodes in router or navigation pages.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub setLevelUniqueId: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, uniqueId: i32) -> i32,
    >,
    #[doc = " @brief Sets the immersive mode for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param immersiveMode Indicates the immersive mode. The parameter type is {@link ArkUI_ImmersiveMode}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub setImmersiveMode: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            immersiveMode: ArkUI_ImmersiveMode,
        ) -> i32,
    >,
}
#[doc = " @brief Provides the custom dialog box APIs for the native side.\n\n @version 3\n @since 19"]
#[cfg(feature = "api-19")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeDialogAPI_3 {
    #[doc = " @brief Provides the custom dialog box APIs for the native side. The API scope is {@link ArkUI_NativeDialogAPI_1}\n\n @since 19"]
    pub nativeDialogAPI1: ArkUI_NativeDialogAPI_1,
    #[doc = " @brief Provides the custom dialog box APIs for the native side. The API scope is {@link ArkUI_NativeDialogAPI_2}\n\n @since 19"]
    pub nativeDialogAPI2: ArkUI_NativeDialogAPI_2,
    #[doc = " @brief Sets the display order for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param levelOrder Indicates the display order. The valid range is [-100000.0, 100000.0].\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    pub setLevelOrder: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, levelOrder: f64) -> i32,
    >,
    #[doc = " @brief Registers a listener callback before the dialog openAnimation starts.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param userData Indicates the pointer to the custom data.\n @param callback Indicates the callback before the dialog openAnimation starts.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    pub registerOnWillAppear: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            userData: *mut ::std::os::raw::c_void,
            callback: ::std::option::Option<
                unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Registers a listener callback when the dialog appears.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param userData Indicates the pointer to the custom data.\n @param callback Indicates the callback when the dialog appears.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    pub registerOnDidAppear: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            userData: *mut ::std::os::raw::c_void,
            callback: ::std::option::Option<
                unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Registers a listener callback before the dialog closeAnimation starts.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param userData Indicates the pointer to the custom data.\n @param callback Indicates the callback before the dialog closeAnimation starts.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    pub registerOnWillDisappear: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            userData: *mut ::std::os::raw::c_void,
            callback: ::std::option::Option<
                unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Registers a listener callback when the dialog disappears.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param userData Indicates the pointer to the custom data.\n @param callback Indicates the callback when the dialog disappears.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    pub registerOnDidDisappear: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            userData: *mut ::std::os::raw::c_void,
            callback: ::std::option::Option<
                unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Sets the border width of the dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param top Width of the top border.\n @param right Width of the right border.\n @param bottom Width of the bottom border.\n @param left Width of the left border.\n @param unit Unit of the width. The default value is vp.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub setBorderWidth: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            top: f32,
            right: f32,
            bottom: f32,
            left: f32,
            unit: ArkUI_LengthMetricUnit,
        ) -> i32,
    >,
    #[doc = " @brief Sets the border color of the dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param top Color of the top border.\n @param right Color of the right border.\n @param bottom Color of the bottom border.\n @param left Color of the left border.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub setBorderColor: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            top: u32,
            right: u32,
            bottom: u32,
            left: u32,
        ) -> i32,
    >,
    #[doc = " @brief Sets the border style of the dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param top Style of the top border.\n @param right Style of the right border.\n @param bottom Style of the bottom border.\n @param left Style of the left border.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub setBorderStyle: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            top: i32,
            right: i32,
            bottom: i32,
            left: i32,
        ) -> i32,
    >,
    #[doc = " @brief Sets the width of the dialog box background.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param width Width of the background.\n @param unit Unit of the width. The default value is vp.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub setWidth: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            width: f32,
            unit: ArkUI_LengthMetricUnit,
        ) -> i32,
    >,
    #[doc = " @brief Sets the height of the dialog box background.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param height Height of the background.\n @param unit Unit of the height. The default value is vp.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub setHeight: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            height: f32,
            unit: ArkUI_LengthMetricUnit,
        ) -> i32,
    >,
    #[doc = " @brief Sets the shadow of the dialog box background.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param shadow Shadow style of the background, specified by an enumerated value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub setShadow: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, shadow: ArkUI_ShadowStyle) -> i32,
    >,
    #[doc = " @brief Sets the custom shadow of the dialog box background.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param customShadow Custom shadow parameter. The format is the same as that of the <b>NODE_SHADOW</b> property.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub setCustomShadow: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            customShadow: *const ArkUI_AttributeItem,
        ) -> i32,
    >,
    #[doc = " @brief Sets the background blur style of the dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param blurStyle Background blur style, specified by an enumerated value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub setBackgroundBlurStyle: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, blurStyle: ArkUI_BlurStyle) -> i32,
    >,
    #[doc = " @brief Sets the keyboard avoidance mode of the dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param keyboardAvoidMode Keyboard avoidance mode, specified by an enumerated value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub setKeyboardAvoidMode: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            keyboardAvoidMode: ArkUI_KeyboardAvoidMode,
        ) -> i32,
    >,
    #[doc = " @brief Sets whether to enable the hover mode for the dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param enableHoverMode Whether to enable the hover mode. The default value is <b>false</b>.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur..\n @since 19"]
    pub enableHoverMode: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, enableHoverMode: bool) -> i32,
    >,
    #[doc = " @brief Set the default display area of the dialog box in hover mode.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Pointer to the dialog box controller.\n @param hoverModeAreaType Display area in hover mode, specified by an enumerated value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occur.\n @since 19"]
    pub setHoverModeArea: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            hoverModeAreaType: ArkUI_HoverModeAreaType,
        ) -> i32,
    >,
    #[doc = " @brief Sets whether to get focus when the custom dialog is displayed.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param focusable Specifies whether to get focus when the custom dialog is displayed. The default value is true.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    pub setFocusable: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, focusable: bool) -> i32,
    >,
    #[doc = " @brief Sets the background blur effect for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param backgroundBlurStyleOptions Background blur effect options.\n        Format of the {@link ArkUI_AttributeItem} parameter: \\n\n        .value[0].i32: color mode. The value is an enum of {@link ArkUI_ColorMode}. \\n\n        .value[1]?.i32: adaptive color mode. The value is an enum of {@link ArkUI_AdaptiveColor}. \\n\n        .value[2]?.f32: blur degree. The value range is [0.0, 1.0]. \\n\n        .value[3]?.u32: brightness of black in the grayscale blur. The value range is [0, 127]. \\n\n        .value[4]?.u32: degree of darkening the white color in the grayscale blur. The value range is [0, 127]. \\n\n        .value[5]?.i32: blur activation policy. The value is an enum of {@link ArkUI_BlurStyleActivePolicy}. \\n\n        .value[6]?.u32: background color, in 0xARGB format, of the components within the window after the window\n                        loses focus (in which case, the blur effect on the components within the window is\n                        removed). \\n\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    pub setBackgroundBlurStyleOptions: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            backgroundBlurStyleOptions: *const ArkUI_AttributeItem,
        ) -> i32,
    >,
    #[doc = " @brief Sets the background effect parameters for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param backgroundEffect Background effect.\n        Format of the {@link ArkUI_AttributeItem} parameter: \\n\n        .value[0].f32: blur radius, in vp. \\n\n        .value[1]?.f32: saturation. \\n\n        .value[2]?.f32: brightness. \\n\n        .value[3]?.u32: color, in 0xARGB format. \\n\n        .value[4]?.i32: adaptive color mode. The value is an enum of {@link ArkUI_AdaptiveColor}. \\n\n        .value[5]?.u32: brightness of black in the grayscale blur. The value range is [0, 127]. \\n\n        .value[6]?.u32: degree of darkening the white color in the grayscale blur. The value range is [0, 127]. \\n\n        .value[7]?.i32: blur activation policy. The value is an enum of {@link ArkUI_BlurStyleActivePolicy}. \\n\n        .value[8]?.u32: background color, in 0xARGB format, of the components within the window after the window\n                        loses focus (in which case, the blur effect on the components within the window is\n                        removed). \\n\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    pub setBackgroundEffect: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            backgroundEffect: *const ArkUI_AttributeItem,
        ) -> i32,
    >,
}
extern "C" {
    #[doc = " @brief Sets whether to block the system behavior of dismissing a dialog box.\n\n @param event Indicates the pointer to a dialog box dismiss event object.\n @param shouldBlockDismiss Indicates whether to block the system behavior of dismissing the dialog box. The value\n                           <b>true</b> means to block the system behavior, and <b>false</b> means the opposite.\n @since 12"]
    pub fn OH_ArkUI_DialogDismissEvent_SetShouldBlockDismiss(
        event: *mut ArkUI_DialogDismissEvent,
        shouldBlockDismiss: bool,
    );
}
extern "C" {
    #[doc = " @brief Obtains the pointer to user data in a dialog box dismiss event object.\n\n @param event Indicates the pointer to a dialog box dismiss event object.\n\n @return Returns the pointer to user data.\n @since 12"]
    pub fn OH_ArkUI_DialogDismissEvent_GetUserData(
        event: *mut ArkUI_DialogDismissEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the c from a dialog box dismiss event object.\n\n @param event Indicates the pointer to a dialog box dismiss event object.\n\n @return Returns the dismissal reason. Returns <b>-1</b> if an exception occurs.\n         {@link DIALOG_DISMISS_BACK_PRESS}: touching the Back button, swiping left or right on the screen, or\n                                            pressing the Esc key.\n         {@link DIALOG_DISMISS_TOUCH_OUTSIDE}: touching the mask.\n         {@link DIALOG_DISMISS_CLOSE_BUTTON}: touching the Close button.\n         {@link DIALOG_DISMISS_SLIDE_DOWN}: sliding down.\n @since 12"]
    pub fn OH_ArkUI_DialogDismissEvent_GetDismissReason(
        event: *mut ArkUI_DialogDismissEvent,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Displays a custom dialog box.\n\n @param options Dialog box parameters.\n @param callback Callback to be invoked when the custom dialog box displays.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_OpenDialog(
        options: *mut ArkUI_CustomDialogOptions,
        callback: ::std::option::Option<unsafe extern "C" fn(dialogId: i32)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Updates a custom dialog box.\n\n @param options Dialog box parameters.\n @param callback Callback to be invoked when the custom dialog box updates.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_UpdateDialog(
        options: *mut ArkUI_CustomDialogOptions,
        callback: ::std::option::Option<unsafe extern "C" fn(dialogId: i32)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Closes a custom dialog box.\n\n @param dialogId Dialog id.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_CloseDialog(dialogId: i32) -> i32;
}
extern "C" {
    #[doc = " @brief Creates custom dialog box options.\n\n @param content Content of the custom dialog box.\n @return Returns the pointer to the custom dialog box options.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_CreateOptions(
        content: ArkUI_NodeHandle,
    ) -> *mut ArkUI_CustomDialogOptions;
}
extern "C" {
    #[doc = " @brief Destroys the custom dialog box options.\n\n @param options The pointer to the custom dialog box options.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_DisposeOptions(options: *mut ArkUI_CustomDialogOptions);
}
extern "C" {
    #[doc = " @brief Sets the level mode for a custom dialog box.\n\n @note This method must be called before the <b>OH_ArkUI_CustomDialog_OpenDialog</b> method.\n @param options Indicates the pointer to the custom dialog options.\n @param levelMode Indicates the level mode. The parameter type is {@link ArkUI_LevelMode}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetLevelMode(
        options: *mut ArkUI_CustomDialogOptions,
        levelMode: ArkUI_LevelMode,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the level uniqueId for a custom dialog box.\n\n @param options Indicates the pointer to the custom dialog options.\n @param uniqueId Indicates the unique id of any nodes in router or navigation pages.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetLevelUniqueId(
        options: *mut ArkUI_CustomDialogOptions,
        uniqueId: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the immersive mode for a custom dialog box.\n\n @note This method must be called before the <b>OH_ArkUI_CustomDialog_OpenDialog</b> method.\n @param options Indicates the pointer to the custom dialog options.\n @param immersiveMode Indicates the immersive mode. The parameter type is {@link ArkUI_ImmersiveMode}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetImmersiveMode(
        options: *mut ArkUI_CustomDialogOptions,
        immersiveMode: ArkUI_ImmersiveMode,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the background color of the dialog box.\n\n @param options Dialog box parameters.\n @param backgroundColor Background color of the dialog box.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetBackgroundColor(
        options: *mut ArkUI_CustomDialogOptions,
        backgroundColor: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the corner radius for a custom dialog box.\n\n @param options Dialog box parameters.\n @param topLeft Corner radius of the upper left corner.\n @param topRight Corner radius of the upper right corner.\n @param bottomLeft Corner radius of the lower left corner.\n @param bottomRight Corner radius of the lower right corner.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetCornerRadius(
        options: *mut ArkUI_CustomDialogOptions,
        topLeft: f32,
        topRight: f32,
        bottomLeft: f32,
        bottomRight: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the border width of the dialog box.\n\n @param options Dialog box parameters.\n @param top Width of the top border.\n @param right Width of the right border.\n @param bottom Width of the bottom border.\n @param left Width of the left border.\n @param unit Unit of the width. The default value is vp.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetBorderWidth(
        options: *mut ArkUI_CustomDialogOptions,
        top: f32,
        right: f32,
        bottom: f32,
        left: f32,
        unit: ArkUI_LengthMetricUnit,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the border color of the dialog box.\n\n @param options Dialog box parameters.\n @param top Color of the top border.\n @param right Color of the right border.\n @param bottom Color of the bottom border.\n @param left Color of the left border.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetBorderColor(
        options: *mut ArkUI_CustomDialogOptions,
        top: u32,
        right: u32,
        bottom: u32,
        left: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the border style of the dialog box.\n\n @param options Dialog box parameters.\n @param top Style of the top border.\n @param right Style of the right border.\n @param bottom Style of the bottom border.\n @param left Style of the left border.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetBorderStyle(
        options: *mut ArkUI_CustomDialogOptions,
        top: i32,
        right: i32,
        bottom: i32,
        left: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the width of the dialog box background.\n\n @param options Dialog box parameters.\n @param width Width of the background.\n @param unit Unit of the width. The default value is vp.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetWidth(
        options: *mut ArkUI_CustomDialogOptions,
        width: f32,
        unit: ArkUI_LengthMetricUnit,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the height of the dialog box background.\n\n @param options Dialog box parameters.\n @param height Height of the background.\n @param unit Unit of the height. The default value is vp.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetHeight(
        options: *mut ArkUI_CustomDialogOptions,
        height: f32,
        unit: ArkUI_LengthMetricUnit,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the shadow of the dialog box background.\n\n @param options Dialog box parameters.\n @param shadow Shadow style of the background, specified by an enumerated value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetShadow(
        options: *mut ArkUI_CustomDialogOptions,
        shadow: ArkUI_ShadowStyle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the custom shadow of the dialog box background.\n\n @param options Dialog box parameters.\n @param customShadow Custom shadow parameter. The format is the same as that of\n the <b>NODE_CUSTOM_SHADOW</b> property.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetCustomShadow(
        options: *mut ArkUI_CustomDialogOptions,
        customShadow: *const ArkUI_AttributeItem,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the background blur style of the dialog box.\n\n @param options Dialog box parameters.\n @param blurStyle Background blur style, specified by an enumerated value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetBackgroundBlurStyle(
        options: *mut ArkUI_CustomDialogOptions,
        blurStyle: ArkUI_BlurStyle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the alignment mode of the dialog box.\n\n @param options Dialog box parameters.\n @param alignment Alignment mode of the dialog box. The parameter type is {@link ArkUI_Alignment}.\n @param offsetX Indicates the horizontal offset of the custom dialog box. The value is a floating point number.\n @param offsetY Indicates the vertical offset of the custom dialog box. The value is a floating point number.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetAlignment(
        options: *mut ArkUI_CustomDialogOptions,
        alignment: i32,
        offsetX: f32,
        offsetY: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the modal mode for a custom dialog box.\n\n @param options Dialog box parameters.\n @param isModal Whether the dialog box is a modal. A modal dialog box has a mask applied,\n while a non-modal dialog box does not. The value <b>true</b> means that the dialog box is a modal.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetModalMode(
        options: *mut ArkUI_CustomDialogOptions,
        isModal: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Specifies whether to allow users to touch the mask to dismiss the custom dialog box.\n\n @param options Dialog box parameters.\n @param autoCancel Specifies whether to allow users to touch the mask to dismiss the dialog box.\n The value <b>true</b> means to allow users to do so, and <b>false</b> means the opposite.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetAutoCancel(
        options: *mut ArkUI_CustomDialogOptions,
        autoCancel: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to display the dialog box in a subwindow.\n\n @param options Dialog box parameters.\n @param showInSubwindow Whether to display the dialog box in a subwindow when it is not in the main window.\n The default value is <b>false</b>, meaning the dialog box is displayed within the application, not in a\n separate subwindow.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetSubwindowMode(
        options: *mut ArkUI_CustomDialogOptions,
        showInSubwindow: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the mask for a custom dialog box.\n\n @param options Dialog box parameters.\n @param maskColor Mask color, in 0xargb format.\n @param maskRect Pointer to the mask area. Events outside the mask area are transparently transmitted,\n and events within the mask area are not. The parameter type is {@link ArkUI_Rect}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetMask(
        options: *mut ArkUI_CustomDialogOptions,
        maskColor: u32,
        maskRect: *const ArkUI_Rect,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the keyboard avoidance mode of the dialog box.\n\n @param options Dialog box parameters.\n @param keyboardAvoidMode Keyboard avoidance mode, specified by an enumerated value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetKeyboardAvoidMode(
        options: *mut ArkUI_CustomDialogOptions,
        keyboardAvoidMode: ArkUI_KeyboardAvoidMode,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the hover mode for the dialog box.\n\n @param options Dialog box parameters.\n @param enabled Whether to enable the hover mode. The default value is <b>false</b>.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetHoverModeEnabled(
        options: *mut ArkUI_CustomDialogOptions,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the default display area of the dialog box in hover mode.\n\n @param options Dialog box parameters.\n @param hoverModeAreaType Display area in hover mode, specified by an enumerated value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetHoverModeArea(
        options: *mut ArkUI_CustomDialogOptions,
        hoverModeAreaType: ArkUI_HoverModeAreaType,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a callback for the dismissal event of the custom dialog box.\n\n @param options Dialog box parameters.\n @param userData Pointer to the user-defined data.\n @param callback Callback for the dismissal event of the custom dialog box.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_RegisterOnWillDismissCallback(
        options: *mut ArkUI_CustomDialogOptions,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_DialogDismissEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a callback to be invoked when the custom dialog box is about to appear.\n\n @param options Dialog box parameters.\n @param userData Pointer to the user-defined data.\n @param callback Callback to be invoked when the dialog box is about to appear.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_RegisterOnWillAppearCallback(
        options: *mut ArkUI_CustomDialogOptions,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a callback to be invoked when the custom dialog box appears.\n\n @param options Dialog box parameters.\n @param userData Pointer to the user-defined data.\n @param callback Callback to be invoked when the custom dialog box appears.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_RegisterOnDidAppearCallback(
        options: *mut ArkUI_CustomDialogOptions,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a callback to be invoked when the custom dialog box is about to disappear.\n\n @param options Dialog box parameters.\n @param userData Pointer to the user-defined data.\n @param callback Callback to be invoked when the dialog box is about to disappear.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_RegisterOnWillDisappearCallback(
        options: *mut ArkUI_CustomDialogOptions,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a callback to be invoked when the custom dialog box disappears.\n\n @param options Dialog box parameters.\n @param userData Pointer to the user-defined data.\n @param callback Callback to be invoked when the custom dialog box disappears.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_RegisterOnDidDisappearCallback(
        options: *mut ArkUI_CustomDialogOptions,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get state of dialog.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param state Dialog state object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_CustomDialog_GetState(
        handle: ArkUI_NativeDialogHandle,
        state: *mut ArkUI_DialogState,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the background blur effect for a dialog box.\n\n @param options Dialog box parameters.\n @param backgroundBlurStyleOptions Background blur effect options of the dialog box.\n        Format of the {@link ArkUI_AttributeItem} parameter: \\n\n        .value[0].i32: color mode. The value is an enum of {@link ArkUI_ColorMode}. \\n\n        .value[1]?.i32: adaptive color mode. The value is an enum of {@link ArkUI_AdaptiveColor}. \\n\n        .value[2]?.f32: blur degree. The value range is [0.0, 1.0]. \\n\n        .value[3]?.u32: brightness of black in the grayscale blur. The value range is [0, 127]. \\n\n        .value[4]?.u32: degree of darkening the white color in the grayscale blur. The value range is [0, 127]. \\n\n        .value[5]?.i32: blur activation policy. The value is an enum of {@link ArkUI_BlurStyleActivePolicy}. \\n\n        .value[6]?.u32: background color, in 0xARGB format, of the components within the window after the window loses\n                        focus (in which case, the blur effect on the components within the window is removed). \\n\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetBackgroundBlurStyleOptions(
        options: *mut ArkUI_CustomDialogOptions,
        backgroundBlurStyleOptions: *const ArkUI_AttributeItem,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the background effect parameters for a dialog box.\n\n @param options Dialog box parameters.\n @param backgroundEffect Background effect of the dialog box.\n        Format of the {@link ArkUI_AttributeItem} parameter: \\n\n        .value[0].f32: blur radius, in vp. \\n\n        .value[1]?.f32: saturation. \\n\n        .value[2]?.f32: brightness. \\n\n        .value[3]?.u32: color, in 0xARGB format. \\n\n        .value[4]?.i32: adaptive color mode. The value is an enum of {@link ArkUI_AdaptiveColor}. \\n\n        .value[5]?.u32: brightness of black in the grayscale blur. The value range is [0, 127]. \\n\n        .value[6]?.u32: degree of darkening the white color in the grayscale blur. The value range is [0, 127]. \\n\n        .value[7]?.i32: blur activation policy. The value is an enum of {@link ArkUI_BlurStyleActivePolicy}. \\n\n        .value[8]?.u32: background color, in 0xARGB format, of the components within the window after the window loses\n                        focus (in which case, the blur effect on the components within the window is removed). \\n\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_CustomDialog_SetBackgroundEffect(
        options: *mut ArkUI_CustomDialogOptions,
        backgroundEffect: *const ArkUI_AttributeItem,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GestureRecognizer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GestureInterruptInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GestureEvent {
    _unused: [u8; 0],
}
#[doc = " Triggered."]
pub const ArkUI_GestureEventActionType_GESTURE_EVENT_ACTION_ACCEPT: ArkUI_GestureEventActionType =
    1;
#[doc = " Updated."]
pub const ArkUI_GestureEventActionType_GESTURE_EVENT_ACTION_UPDATE: ArkUI_GestureEventActionType =
    2;
#[doc = " Ended."]
pub const ArkUI_GestureEventActionType_GESTURE_EVENT_ACTION_END: ArkUI_GestureEventActionType = 4;
#[doc = " Canceled."]
pub const ArkUI_GestureEventActionType_GESTURE_EVENT_ACTION_CANCEL: ArkUI_GestureEventActionType =
    8;
#[doc = " @brief Enumerates gesture event types.\n\n @since 12"]
pub type ArkUI_GestureEventActionType = u32;
#[doc = " @brief Defines a set of gesture event types.\n\n Example: ArkUI_GestureEventActionTypeMask actions = GESTURE_EVENT_ACTION_ACCEPT | GESTURE_EVENT_ACTION_UPDATE;\\n\n\n @since 12"]
pub type ArkUI_GestureEventActionTypeMask = u32;
#[doc = " Normal."]
pub const ArkUI_GesturePriority_NORMAL: ArkUI_GesturePriority = 0;
#[doc = " High-priority."]
pub const ArkUI_GesturePriority_PRIORITY: ArkUI_GesturePriority = 1;
#[doc = " Parallel."]
pub const ArkUI_GesturePriority_PARALLEL: ArkUI_GesturePriority = 2;
#[doc = " @brief Enumerates gesture event modes.\n\n @since 12"]
pub type ArkUI_GesturePriority = u32;
#[doc = " Sequential recognition. Gestures are recognized in the registration sequence until all gestures are recognized\n successfully. Once one gesture fails to be recognized, all subsequent gestures fail to be recognized.\n Only the last gesture in the gesture group can respond to the end event."]
pub const ArkUI_GroupGestureMode_SEQUENTIAL_GROUP: ArkUI_GroupGestureMode = 0;
#[doc = " Parallel recognition. Registered gestures are recognized concurrently until all gestures are recognized.\n The recognition result of each gesture does not affect each other."]
pub const ArkUI_GroupGestureMode_PARALLEL_GROUP: ArkUI_GroupGestureMode = 1;
#[doc = " Exclusive recognition. Registered gestures are identified concurrently.\n If one gesture is successfully recognized, gesture recognition ends."]
pub const ArkUI_GroupGestureMode_EXCLUSIVE_GROUP: ArkUI_GroupGestureMode = 2;
#[doc = " @brief Enumerates gesture group modes.\n\n @since 12"]
pub type ArkUI_GroupGestureMode = u32;
#[doc = " All directions."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_ALL: ArkUI_GestureDirection = 15;
#[doc = " Horizontal direction."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_HORIZONTAL: ArkUI_GestureDirection = 3;
#[doc = " Vertical direction."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_VERTICAL: ArkUI_GestureDirection = 12;
#[doc = " Leftward."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_LEFT: ArkUI_GestureDirection = 1;
#[doc = " Rightward."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_RIGHT: ArkUI_GestureDirection = 2;
#[doc = " Upward."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_UP: ArkUI_GestureDirection = 4;
#[doc = " Downward."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_DOWN: ArkUI_GestureDirection = 8;
#[doc = " None."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_NONE: ArkUI_GestureDirection = 0;
#[doc = " @brief Enumerates gesture directions.\n\n @since 12"]
pub type ArkUI_GestureDirection = u32;
#[doc = " @brief Defines a set of gesture directions.\n\n Example: ArkUI_GestureDirectionMask directions = GESTURE_DIRECTION_LEFT | GESTURE_DIRECTION_RIGHT \\n\n This example indicates that the leftward and rightward directions are supported. \\n\n\n @since 12"]
pub type ArkUI_GestureDirectionMask = u32;
#[doc = " The gestures of child components are enabled and recognized based on the default gesture recognition sequence."]
pub const ArkUI_GestureMask_NORMAL_GESTURE_MASK: ArkUI_GestureMask = 0;
#[doc = " The gestures of child components are disabled, including the built-in gestures."]
pub const ArkUI_GestureMask_IGNORE_INTERNAL_GESTURE_MASK: ArkUI_GestureMask = 1;
#[doc = " @brief Enumerates gesture masking modes.\n\n @since 12"]
pub type ArkUI_GestureMask = u32;
#[doc = " Tap."]
pub const ArkUI_GestureRecognizerType_TAP_GESTURE: ArkUI_GestureRecognizerType = 0;
#[doc = " Long press."]
pub const ArkUI_GestureRecognizerType_LONG_PRESS_GESTURE: ArkUI_GestureRecognizerType = 1;
#[doc = " Pan."]
pub const ArkUI_GestureRecognizerType_PAN_GESTURE: ArkUI_GestureRecognizerType = 2;
#[doc = " Pinch."]
pub const ArkUI_GestureRecognizerType_PINCH_GESTURE: ArkUI_GestureRecognizerType = 3;
#[doc = " Rotate."]
pub const ArkUI_GestureRecognizerType_ROTATION_GESTURE: ArkUI_GestureRecognizerType = 4;
#[doc = " Swipe."]
pub const ArkUI_GestureRecognizerType_SWIPE_GESTURE: ArkUI_GestureRecognizerType = 5;
#[doc = " A group of gestures."]
pub const ArkUI_GestureRecognizerType_GROUP_GESTURE: ArkUI_GestureRecognizerType = 6;
#[doc = " The click gesture registed through onClick.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_GestureRecognizerType_CLICK_GESTURE: ArkUI_GestureRecognizerType = 7;
#[doc = " Drag gesture used for drag and drop.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const ArkUI_GestureRecognizerType_DRAG_DROP: ArkUI_GestureRecognizerType = 8;
#[doc = " @brief Enumerates gesture types.\n\n @since 12"]
pub type ArkUI_GestureRecognizerType = u32;
#[doc = " The gesture recognition process continues."]
pub const ArkUI_GestureInterruptResult_GESTURE_INTERRUPT_RESULT_CONTINUE:
    ArkUI_GestureInterruptResult = 0;
#[doc = " The gesture recognition process is paused."]
pub const ArkUI_GestureInterruptResult_GESTURE_INTERRUPT_RESULT_REJECT:
    ArkUI_GestureInterruptResult = 1;
#[doc = " @brief Enumerates gesture interruption results.\n\n @since 12"]
pub type ArkUI_GestureInterruptResult = u32;
#[doc = " Ready."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_READY:
    ArkUI_GestureRecognizerState = 0;
#[doc = " Detecting."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_DETECTING:
    ArkUI_GestureRecognizerState = 1;
#[doc = " Pending."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_PENDING:
    ArkUI_GestureRecognizerState = 2;
#[doc = " Blocked."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_BLOCKED:
    ArkUI_GestureRecognizerState = 3;
#[doc = " Successful."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_SUCCESSFUL:
    ArkUI_GestureRecognizerState = 4;
#[doc = " Failed."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_FAILED:
    ArkUI_GestureRecognizerState = 5;
#[doc = " @brief Enumerates the gesture recognizer states.\n\n @since 12"]
pub type ArkUI_GestureRecognizerState = u32;
#[doc = " @brief Defines the gesture recognizer handle.\n\n @since 12"]
pub type ArkUI_GestureRecognizerHandle = *mut ArkUI_GestureRecognizer;
#[doc = " @brief Defines the gesture recognizer handle array.\n\n @since 12"]
pub type ArkUI_GestureRecognizerHandleArray = *mut ArkUI_GestureRecognizerHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GestureEventTargetInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ParallelInnerGestureEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TouchRecognizer {
    _unused: [u8; 0],
}
#[doc = " @brief Defines a touch recognizer handle.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_TouchRecognizerHandle = *mut ArkUI_TouchRecognizer;
#[doc = " @brief Defines an array of touch recognizer handle.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub type ArkUI_TouchRecognizerHandleArray = *mut ArkUI_TouchRecognizerHandle;
#[doc = " @brief Defines a callback function for notifying gesture recognizer destruction.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param userData Indicates the custom data.\n @since 12"]
pub type ArkUI_GestureRecognizerDisposeNotifyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        recognizer: *mut ArkUI_GestureRecognizer,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Checks whether a gesture is a built-in gesture of the component.\n\n @param event Indicates the pointer to the gesture interruption information.\n @return Returns <b>true</b> if the gesture is a built-in gesture; returns <b>false</b> otherwise.\n\n @since 12"]
    pub fn OH_ArkUI_GestureInterruptInfo_GetSystemFlag(
        event: *const ArkUI_GestureInterruptInfo,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains the pointer to interrupted gesture recognizer.\n\n @param event Indicates the pointer to the gesture interruption information.\n @return Returns the pointer to interrupted gesture recognizer.\n @since 12"]
    pub fn OH_ArkUI_GestureInterruptInfo_GetRecognizer(
        event: *const ArkUI_GestureInterruptInfo,
    ) -> *mut ArkUI_GestureRecognizer;
}
extern "C" {
    #[doc = " @brief Obtains the pointer to the interrupted gesture event.\n\n @param event Indicates the pointer to the gesture interruption information.\n @return Returns the pointer to the interrupted gesture event.\n @since 12"]
    pub fn OH_ArkUI_GestureInterruptInfo_GetGestureEvent(
        event: *const ArkUI_GestureInterruptInfo,
    ) -> *mut ArkUI_GestureEvent;
}
extern "C" {
    #[doc = " @brief Obtains the type of the system gesture to trigger.\n\n @param event Indicates the pointer to the gesture interruption information.\n @return Returns the type of the system gesture to trigger. If the gesture to trigger is not a system gesture,\n         <b>-1</b> is returned.\n @since 12"]
    pub fn OH_ArkUI_GestureInterruptInfo_GetSystemRecognizerType(
        event: *const ArkUI_GestureInterruptInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the touch recognizer handles from the gesture interrupt info.\n\n @param info Indicates the pointer to a gesture interrupt info.\n @param recognizers Indicates the pointer to an array of touch recognizer handles.\n @param size Indicates the size of recognizers.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_GestureInterruptInfo_GetTouchRecognizers(
        info: *const ArkUI_GestureInterruptInfo,
        recognizers: *mut ArkUI_TouchRecognizerHandleArray,
        size: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get component object of the specific touch recognizer.\n\n @param recognizer Indicates the pointer to the TouchRecognizer.\n @return Get component object of the specific touch recognizer.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_TouchRecognizer_GetNodeHandle(
        recognizer: ArkUI_TouchRecognizerHandle,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Send touch-cancel event to the touch recognizer in a gesture interruption callback.\n\n @param recognizer Indicates the touch recognizer handle.\n @param info Indicates the pointer to a gesture interrupt info.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_TouchRecognizer_CancelTouch(
        recognizer: ArkUI_TouchRecognizerHandle,
        info: *mut ArkUI_GestureInterruptInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the gesture event type.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the gesture event type.\n @since 12"]
    pub fn OH_ArkUI_GestureEvent_GetActionType(
        event: *const ArkUI_GestureEvent,
    ) -> ArkUI_GestureEventActionType;
}
extern "C" {
    #[doc = " @brief Obtains gesture input.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the pointer to the input event of the gesture event.\n @since 12"]
    pub fn OH_ArkUI_GestureEvent_GetRawInputEvent(
        event: *const ArkUI_GestureEvent,
    ) -> *const ArkUI_UIInputEvent;
}
extern "C" {
    #[doc = " @brief Obtains the number of times that a long press gesture is triggered periodically.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the number of times that the long press gesture is triggered periodically.\n @since 12"]
    pub fn OH_ArkUI_LongPress_GetRepeatCount(event: *const ArkUI_GestureEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the velocity of a pan gesture along the main axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the velocity of the pan gesture along the main axis, in px/s.\n         The value is the square root of the sum of the squares of the velocity on the x-axis and y-axis.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetVelocity(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the velocity of a pan gesture along the x-axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the velocity of the pan gesture along the x-axis, in px/s.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetVelocityX(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the velocity of a pan gesture along the y-axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the velocity of the pan gesture along the y-axis, in px/s.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetVelocityY(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the relative offset of a pan gesture along the x-axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the relative offset of the gesture along the x-axis, in px.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetOffsetX(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the relative offset of a pan gesture along the y-axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the relative offset of the gesture along the y-axis, in px.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetOffsetY(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle information of the swipe gesture.\n\n After a swipe gesture is recognized, a line connecting the two fingers is identified as the initial line.\n As the fingers swipe, the line between the fingers rotates. \\n\n Based on the coordinates of the initial line's and current line's end points, the arc tangent function is used to\n calculate the respective included angle of the points relative to the horizontal direction \\n\n by using the following formula: Rotation angle = arctan2(cy2-cy1,cx2-cx1) - arctan2(y2-y1,x2-x1). \\n\n The initial line is used as the coordinate system. Values from 0 to 180 degrees represent clockwise rotation,\n while values from 180 to 0 degrees represent counterclockwise rotation. \\n\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the angle of the swipe gesture, which is the result obtained based on the aforementioned formula.\n @since 12"]
    pub fn OH_ArkUI_SwipeGesture_GetAngle(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the average velocity of all fingers used in the swipe gesture.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the average velocity of all fingers used in the swipe gesture, in px/s.\n @since 12"]
    pub fn OH_ArkUI_SwipeGesture_GetVelocity(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle information of a rotation gesture.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the rotation angle.\n @since 12"]
    pub fn OH_ArkUI_RotationGesture_GetAngle(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the scale ratio of a pinch gesture.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the scale ratio.\n @since 12"]
    pub fn OH_ArkUI_PinchGesture_GetScale(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of the center of the pinch gesture, in vp,\n relative to the upper left corner of the current component.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the X coordinate of the center of the pinch gesture, in vp,\n relative to the upper left corner of the current component.\n @since 12"]
    pub fn OH_ArkUI_PinchGesture_GetCenterX(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of the center of the pinch gesture, in vp,\n relative to the upper left corner of the current component.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the Y coordinate of the center of the pinch gesture, in vp,\n relative to the upper left corner of the current component.\n @since 12"]
    pub fn OH_ArkUI_PinchGesture_GetCenterY(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Get the ARKUI component bound to the gesture.\n\n @param event gesture event.\n @return ARKUI component bound to the gesture.If Null is returned, it means event is an invalid value.\n @since 12"]
    pub fn OH_ArkUI_GestureEvent_GetNode(event: *const ArkUI_GestureEvent) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Obtains information about a gesture response chain.\n\n @param event Indicates the pointer to the gesture interruption information.\n @param responseChain Indicates the pointer to an array of gesture recognizers on the response chain.\n @param count Indicates the pointer to the number of gesture recognizers on the response chain.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_GetResponseRecognizersFromInterruptInfo(
        event: *const ArkUI_GestureInterruptInfo,
        responseChain: *mut ArkUI_GestureRecognizerHandleArray,
        count: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the enabled state of a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param enabled Indicates the enabled state.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_SetGestureRecognizerEnabled(
        recognizer: *mut ArkUI_GestureRecognizer,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable strict finger count checking. If this feature is enabled and the actual number of touch\n        fingers does not match the set number, the gesture recognition fails.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param limitFingerCount Indicates whether to enable strict finger count checking.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_SetGestureRecognizerLimitFingerCount(
        recognizer: *mut ArkUI_GestureRecognizer,
        limitFingerCount: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the enabled state of a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @return Returns <b>true</b> if the gesture recognizer is enabled.\n         Returns <b>false</b> if the gesture recognizer is disabled.\n @since 12"]
    pub fn OH_ArkUI_GetGestureRecognizerEnabled(recognizer: *mut ArkUI_GestureRecognizer) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains the state of a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param state Indicates the pointer to the state of the gesture recognizer.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_GetGestureRecognizerState(
        recognizer: *mut ArkUI_GestureRecognizer,
        state: *mut ArkUI_GestureRecognizerState,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the information about a gesture event target.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param info Indicates the information about a gesture event target.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_GetGestureEventTargetInfo(
        recognizer: *mut ArkUI_GestureRecognizer,
        info: *mut *mut ArkUI_GestureEventTargetInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether this scroll container is scrolled to the top.\n\n @param info Indicates the information about a gesture event target.\n @param ret Indicates whether the scroll container is scrolled to the top.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_NON_SCROLLABLE_CONTAINER} if the component is not a scroll container.\n @since 12"]
    pub fn OH_ArkUI_GestureEventTargetInfo_IsScrollBegin(
        info: *mut ArkUI_GestureEventTargetInfo,
        ret: *mut bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether this scroll container is scrolled to the bottom.\n\n @param info Indicates the information about a gesture event target.\n @param ret Indicates whether the scroll container is scrolled to the bottom.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_NON_SCROLLABLE_CONTAINER} if the component is not a scroll container.\n @since 12"]
    pub fn OH_ArkUI_GestureEventTargetInfo_IsScrollEnd(
        info: *mut ArkUI_GestureEventTargetInfo,
        ret: *mut bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the direction of a pan gesture.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param directionMask Indicates the pan direction.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_GetPanGestureDirectionMask(
        recognizer: *mut ArkUI_GestureRecognizer,
        directionMask: *mut ArkUI_GestureDirectionMask,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether a gesture is a built-in gesture.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @return Returns <b>true</b> if the gesture is a built-in gesture; returns <b>false</b> otherwise.\n @since 12"]
    pub fn OH_ArkUI_IsBuiltInGesture(recognizer: *mut ArkUI_GestureRecognizer) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains the tag of a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param buffer Indicates the buffer.\n @param bufferSize Indicates the buffer size.\n @param result Indicates the length of the string to be written to the buffer.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_NOT_ENOUGH} if the buffer is not large enough.\n @since 12"]
    pub fn OH_ArkUI_GetGestureTag(
        recognizer: *mut ArkUI_GestureRecognizer,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        result: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of the component linked to a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param nodeId Indicates the component ID.\n @param size Indicates the buffer size.\n @param result Indicates the length of the string to be written to the buffer.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_NOT_ENOUGH} if the buffer is not large enough.\n @since 12"]
    pub fn OH_ArkUI_GetGestureBindNodeId(
        recognizer: *mut ArkUI_GestureRecognizer,
        nodeId: *mut ::std::os::raw::c_char,
        size: i32,
        result: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether a gesture recognizer is valid.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @return Returns <b>true</b> if the gesture recognizer is valid.\n         Returns <b>false</b> if the gesture recognizer is invalid.\n @since 12"]
    pub fn OH_ArkUI_IsGestureRecognizerValid(recognizer: *mut ArkUI_GestureRecognizer) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains custom data in the parallel internal gesture event.\n\n @param event Indicates the pointer to a parallel internal gesture event.\n @return Returns the pointer to custom data.\n @since 12"]
    pub fn OH_ArkUI_ParallelInnerGestureEvent_GetUserData(
        event: *mut ArkUI_ParallelInnerGestureEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the current gesture recognizer in a parallel internal gesture event.\n\n @param event Indicates the pointer to a parallel internal gesture event.\n @return Returns the pointer to the current gesture recognizer.\n @since 12"]
    pub fn OH_ArkUI_ParallelInnerGestureEvent_GetCurrentRecognizer(
        event: *mut ArkUI_ParallelInnerGestureEvent,
    ) -> *mut ArkUI_GestureRecognizer;
}
extern "C" {
    #[doc = " @brief Obtains the conflicting gesture recognizers in a parallel internal gesture event.\n\n @param event Indicates the pointer to a parallel internal gesture event.\n @param array Indicates the pointer to the array of conflicting gesture recognizers.\n @param size Indicates the size of the array of conflicting gesture recognizers.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_ParallelInnerGestureEvent_GetConflictRecognizers(
        event: *mut ArkUI_ParallelInnerGestureEvent,
        array: *mut ArkUI_GestureRecognizerHandleArray,
        size: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets a callback function for notifying gesture recognizer destruction.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param callback Indicates the callback function for notifying gesture recognizer destruction.\n @param userData Indicates the custom data.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_SetArkUIGestureRecognizerDisposeNotify(
        recognizer: *mut ArkUI_GestureRecognizer,
        callback: ArkUI_GestureRecognizerDisposeNotifyCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the swipe direction of a gesture recognizer.\n\n @param recognizer Pointer to a gesture recognizer.\n @param directMask Swipe direction of the gesture recognizer.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GetGestureParam_DirectMask(
        recognizer: *mut ArkUI_GestureRecognizer,
        directMask: *mut ArkUI_GestureDirectionMask,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of fingers used by a gesture recognizer.\n\n @param recognizer Pointer to a gesture recognizer.\n @param finger Number of fingers used by the gesture recognizer.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GetGestureParam_FingerCount(
        recognizer: *mut ArkUI_GestureRecognizer,
        finger: *mut ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Checks whether a gesture recognizer has a finger count limit.\n\n @param recognizer Pointer to a gesture recognizer.\n @param isLimited Whether the gesture recognizer has a finger count limit.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GetGestureParam_limitFingerCount(
        recognizer: *mut ArkUI_GestureRecognizer,
        isLimited: *mut bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Checks whether a gesture recognizer supports repeated event callbacks.\n\n @param recognizer Pointer to a gesture recognizer.\n @param isRepeat Whether the gesture recognizer supports repeated event callbacks.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is not\n supported.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GetGestureParam_repeat(
        recognizer: *mut ArkUI_GestureRecognizer,
        isRepeat: *mut bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the allowed movement distance range for a gesture recognizer.\n\n @param recognizer Pointer to a gesture recognizer.\n @param distance Allowed movement distance range of the gesture recognizer.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is not\n supported.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GetGestureParam_distance(
        recognizer: *mut ArkUI_GestureRecognizer,
        distance: *mut f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the minimum swipe speed recognized by a gesture recognizer.\n\n @param recognizer Pointer to a gesture recognizer.\n @param speed Minimum swipe speed recognized by a gesture recognizer.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is not\n supported.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GetGestureParam_speed(
        recognizer: *mut ArkUI_GestureRecognizer,
        speed: *mut f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the minimum duration required to trigger a long press by a gesture recognizer.\n\n @param recognizer Pointer to a gesture recognizer.\n @param duration Minimum duration for a long press.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is not\n supported.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GetGestureParam_duration(
        recognizer: *mut ArkUI_GestureRecognizer,
        duration: *mut ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the minimum angle change required for a rotation gesture to be recognized by a gesture recognizer.\n\n @param recognizer Pointer to a gesture recognizer.\n @param angle Minimum angle change.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is not\n supported.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GetGestureParam_angle(
        recognizer: *mut ArkUI_GestureRecognizer,
        angle: *mut f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the movement threshold for gestures to be recognized by a gesture recognizer.\n\n @param recognizer Pointer to a gesture recognizer.\n @param distanceThresHold Movement threshold.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is not\n supported.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GetGestureParam_distanceThreshold(
        recognizer: *mut ArkUI_GestureRecognizer,
        distanceThreshold: *mut f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the maximum moving distance for gestures to be recognized by a long press gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param allowableMovement Indicates maximum moving distance.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is\n                 not supported.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_LongPressGesture_SetAllowableMovement(
        recognizer: *mut ArkUI_GestureRecognizer,
        allowableMovement: f64,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the maximum moving distance for gestures to be recognized by a long press gesture recognizer.\n\n @param recognizer Pointer to a gesture recognizer.\n @param allowableMovement Indicates maximum moving distance.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is not\n supported.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_LongPressGesture_GetAllowableMovement(
        recognizer: *mut ArkUI_GestureRecognizer,
        allowableMovement: *mut f64,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets the minimum movement distance thresholds for gestures to be recognized by a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param size Size of the array of minimum movement distance thresholds.\n @param toolTypeArray Pointer to the array of tool types for which thresholds are set.\n @param distanceArray Pointer to the array of minimum movement distances, in px.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is\n                 not supported.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_PanGesture_SetDistanceMap(
        recognizer: *mut ArkUI_GestureRecognizer,
        size: ::std::os::raw::c_int,
        toolTypeArray: *mut ::std::os::raw::c_int,
        distanceArray: *mut f64,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the movement threshold for gestures to be recognized by a gesture recognizer for a specific tool type.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param toolType Tool type for which you want to obtain the threshold.\n @param distance Gesture movement threshold of the gesture recognizer, in px.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_RECOGNIZER_TYPE_NOT_SUPPORTED} if the gesture recognizer type is\n                 not supported.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_PanGesture_GetDistanceByToolType(
        recognizer: *mut ArkUI_GestureRecognizer,
        toolType: ::std::os::raw::c_int,
        distance: *mut f64,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Registers a callback that is executed after all gesture recognizers are collected.\n When the user begins touching the screen, the system performs hit testing and collects gesture recognizers\n based on the touch location. Subsequently, before processing any move events, the component can use this API\n to determine the gesture recognizers that will participate in and compete for recognition.\n\n @param node Handle to the node on which the callback is to be set.\n @param userData Custom data.\n @param touchTestDone Callback for completion of gesture recognizer collection.\n                      - event: Basic information of the gesture.\n                      - recognizers: Array of gesture recognizers.\n                      - count: Number of gesture recognizers.\n @return Result code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR}: The operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID}: A parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_SetTouchTestDoneCallback(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        touchTestDone: ::std::option::Option<
            unsafe extern "C" fn(
                event: *mut ArkUI_GestureEvent,
                recognizers: ArkUI_GestureRecognizerHandleArray,
                count: i32,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> ArkUI_ErrorCode;
}
#[doc = " @brief Defines the gesture APIs.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeGestureAPI_1 {
    #[doc = " The struct version is 1."]
    pub version: i32,
    #[doc = " @brief Creates a tap gesture.\n\n        1. This API is used to trigger a tap gesture with one, two, or more taps. \\n\n        2. If multi-tap is configured, the timeout interval between a lift and the next tap is 300 ms. \\n\n        3. If the distance between the last tapped position and the current tapped position exceeds 60 vp,\n           gesture recognition fails. \\n\n        4. If the value is greater than 1, the tap gesture will fail to be recognized when the number of fingers\n           touching the screen within 300 ms of the first finger touch is less than the required number, \\n\n           or when the number of fingers lifted from the screen within 300 ms of the first finger's being lifted\n           is less than the required number. \\n\n        5. When the number of fingers touching the screen exceeds the set value, the gesture can be recognized. \\n\n\n @param countNum Indicates the number of consecutive taps. If the value is less than 1 or is not set,\n        the default value <b>1</b> is used.\n @param fingersNum Indicates the number of fingers required to trigger a tap. The value ranges\n        from 1 to 10. If the value is less than 1 or is not set, the default value <b>1</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createTapGesture: ::std::option::Option<
        unsafe extern "C" fn(countNum: i32, fingersNum: i32) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a long press gesture.\n\n        1. This API is used to trigger a long press gesture, which requires one or more fingers with a minimum\n           The value ranges 500 ms hold-down time. \\n\n        2. In components that support drag actions by default, such as <b><Text></b>, <b><TextInput></b>,\n           <b><TextArea></b>, <b><Hyperlink></b>, <b><Image></b>, and <b>RichEditor></b>, the long press gesture \\n\n           may conflict with the drag action. If this occurs, they are handled as follows: \\n\n           If the minimum duration of the long press gesture is less than 500 ms, the long press gesture receives\n           a higher response priority than the drag action. \\n\n           If the minimum duration of the long press gesture is greater than or equal to 500 ms,\n           the drag action receives a higher response priority than the long press gesture. \\n\n        3. If a finger moves more than 15 px after being pressed, the gesture recognition fails. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a long press gesture.\n        The value ranges from 1 to 10.\n @param repeatResult Indicates whether to continuously trigger the event callback.\n @param durationNum Indicates the minimum hold-down time, in ms.\n        If the value is less than or equal to 0, the default value <b>500</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createLongPressGesture: ::std::option::Option<
        unsafe extern "C" fn(
            fingersNum: i32,
            repeatResult: bool,
            durationNum: i32,
        ) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a pan gesture.\n\n        1. This API is used to trigger a pan gesture when the movement distance of a finger on the screen exceeds\n           the minimum value. \\n\n        2. If a pan gesture and a tab swipe occur at the same time, set <b>distanceNum</b> to <b>1</b>\n           so that the gesture can be more easily recognized. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a pan gesture. The value ranges from 1 to 10.\n        If the value is less than 1 or is not set, the default value <b>1</b> is used.\n @param directions Indicates the pan direction. The value supports the AND (&amp;) and OR (\\|) operations.\n @param distanceNum Indicates the minimum pan distance to trigger the gesture, in vp. If this parameter is\n        set to a value less than or equal to 0, the default value <b>5</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createPanGesture: ::std::option::Option<
        unsafe extern "C" fn(
            fingersNum: i32,
            directions: ArkUI_GestureDirectionMask,
            distanceNum: f64,
        ) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a pinch gesture.\n\n        1. This API is used to trigger a pinch gesture, which requires two to five fingers with a minimum 5 vp\n           distance between the fingers. \\n\n        2. While more fingers than the minimum number can be pressed to trigger the gesture, only the first\n           fingers of the minimum number participate in gesture calculation. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a pinch. The value ranges from 2 to 5.\n        Default value: <b>2</b>\n @param distanceNum Indicates the minimum recognition distance, in px. If this parameter is set to a value less\n        than or equal to 0, the default value <b>5</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createPinchGesture: ::std::option::Option<
        unsafe extern "C" fn(fingersNum: i32, distanceNum: f64) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a rotation gesture.\n\n        1. This API is used to trigger a rotation gesture, which requires two to five fingers with a\n           minimum 1-degree rotation angle. \\n\n        2. While more fingers than the minimum number can be pressed to trigger the gesture, only the first\n           two fingers participate in gesture calculation. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a rotation. The value ranges from 2 to 5.\n        Default value: <b>2</b>\n @param angleNum Indicates the minimum degree that can trigger the rotation gesture. Default value: <b>1</b>\n        If this parameter is set to a value less than or equal to 0 or greater than 360,\n        the default value <b>1</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createRotationGesture: ::std::option::Option<
        unsafe extern "C" fn(fingersNum: i32, angleNum: f64) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a swipe gesture.\n\n        This API is used to implement a swipe gesture, which can be recognized when the swipe speed is 100\n        vp/s or higher. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a swipe gesture.\n        The value ranges from 1 to 10.\n @param directions Indicates the swipe direction.\n @param speedNum Indicates the minimum speed of the swipe gesture, in px/s.\n        If this parameter is set to a value less than or equal to 0, the default value <b>100</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createSwipeGesture: ::std::option::Option<
        unsafe extern "C" fn(
            fingersNum: i32,
            directions: ArkUI_GestureDirectionMask,
            speedNum: f64,
        ) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a gesture group.\n\n @param gestureMode Indicates the gesture group mode.\n @return Returns the pointer to the created gesture group."]
    pub createGroupGesture: ::std::option::Option<
        unsafe extern "C" fn(gestureMode: ArkUI_GroupGestureMode) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Disposes a gesture to release resources.\n\n @param recognizer Indicates the pointer to the gesture to dispose."]
    pub dispose:
        ::std::option::Option<unsafe extern "C" fn(recognizer: *mut ArkUI_GestureRecognizer)>,
    #[doc = " @brief Adds a gesture to a gesture group.\n\n @param group Indicates the pointer to the gesture group.\n @param child Indicates the gesture to be added to the gesture group.\n @return Returns <b>0</b> if success.\n         Returns <b>401</b> if a parameter exception occurs. Returns 401 if a parameter exception occurs."]
    pub addChildGesture: ::std::option::Option<
        unsafe extern "C" fn(
            group: *mut ArkUI_GestureRecognizer,
            child: *mut ArkUI_GestureRecognizer,
        ) -> i32,
    >,
    #[doc = " @brief Removes a gesture to a gesture group.\n\n @param group Indicates the pointer to the gesture group.\n @param child Indicates the gesture to be removed to the gesture group.\n @return Returns <b>0</b> if success.\n         Returns <b>401</b> if a parameter exception occurs."]
    pub removeChildGesture: ::std::option::Option<
        unsafe extern "C" fn(
            group: *mut ArkUI_GestureRecognizer,
            child: *mut ArkUI_GestureRecognizer,
        ) -> i32,
    >,
    #[doc = " @brief Registers a callback for gestures.\n\n @param recognizer Indicates the pointer to the gesture recognizer.\n @param actionTypeMask Indicates the set of gesture event types. Multiple callbacks can be registered at once,\n        with the callback event types distinguished in the callbacks.\n        Example: actionTypeMask = GESTURE_EVENT_ACTION_ACCEPT | GESTURE_EVENT_ACTION_UPDATE;\n @param extraParams Indicates the context passed in the <b>targetReceiver</b> callback.\n @param targetReceiver Indicates the callback to register for processing the gesture event types.\n        <b>event</b> indicates the gesture callback data.\n @return Returns <b>0</b> if success.\n         Returns <b>401</b> if a parameter exception occurs."]
    pub setGestureEventTarget: ::std::option::Option<
        unsafe extern "C" fn(
            recognizer: *mut ArkUI_GestureRecognizer,
            actionTypeMask: ArkUI_GestureEventActionTypeMask,
            extraParams: *mut ::std::os::raw::c_void,
            targetReceiver: ::std::option::Option<
                unsafe extern "C" fn(
                    event: *mut ArkUI_GestureEvent,
                    extraParams: *mut ::std::os::raw::c_void,
                ),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Adds a gesture to a UI component.\n\n @param node Indicates the UI component to which you want to add the gesture.\n @param recognizer Indicates the gesture to be added to the UI component.\n @param mode Indicates the gesture event mode. Available options are <b>NORMAL_GESTURE</b>,\n        <b>PARALLEL_GESTURE</b>, and <b>PRIORITY_GESTURE</b>.\n @param mask Indicates the gesture masking mode.\n @return Returns <b>0</b> if success.\n         Returns <b>401</b> if a parameter exception occurs."]
    pub addGestureToNode: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            recognizer: *mut ArkUI_GestureRecognizer,
            mode: ArkUI_GesturePriority,
            mask: ArkUI_GestureMask,
        ) -> i32,
    >,
    #[doc = " @brief Removes a gesture from a node.\n\n @param node Indicates the node from which you want to remove the gesture.\n @param recognizer Indicates the gesture to be removed.\n @return Returns <b>0</b> if success.\n Returns <b>401</b> if a parameter exception occurs."]
    pub removeGestureFromNode: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            recognizer: *mut ArkUI_GestureRecognizer,
        ) -> i32,
    >,
    #[doc = " @brief Sets a gesture interruption callback for a node.\n\n @param node Indicates the node for which you want to set a gesture interruption callback.\n @param interrupter Indicates the gesture interruption callback to set.\n        <b>info</b> indicates the gesture interruption data. If <b>interrupter</b> returns\n        <b>GESTURE_INTERRUPT_RESULT_CONTINUE</b>, the gesture recognition process continues. If it returns\n        <b>GESTURE_INTERRUPT_RESULT_REJECT</b>, the gesture recognition process is paused.\n @return Returns <b>0</b> if success.\n Returns <b>401</b> if a parameter exception occurs."]
    pub setGestureInterrupterToNode: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            interrupter: ::std::option::Option<
                unsafe extern "C" fn(
                    info: *mut ArkUI_GestureInterruptInfo,
                ) -> ArkUI_GestureInterruptResult,
            >,
        ) -> i32,
    >,
    #[doc = " @brief Obtains the type of a gesture.\n\n @param recognizer Indicates the pointer to the gesture.\n @return Returns the gesture type."]
    pub getGestureType: ::std::option::Option<
        unsafe extern "C" fn(
            recognizer: *mut ArkUI_GestureRecognizer,
        ) -> ArkUI_GestureRecognizerType,
    >,
    #[doc = " @brief Sets the callback function for a parallel internal gesture event.\n\n @param node Indicates the ArkUI node for which the callback of a parallel internal gesture event is to be set.\n @param userData Indicates the custom data.\n @param parallelInnerGesture Indicates the parallel internal gesture event. <b>event</b> returns the data of the\n        parallel internal gesture event; <b>parallelInnerGesture</b> returns the pointer to the gesture recognizer\n        that requires parallel recognition.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs."]
    pub setInnerGestureParallelTo: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            userData: *mut ::std::os::raw::c_void,
            parallelInnerGesture: ::std::option::Option<
                unsafe extern "C" fn(
                    event: *mut ArkUI_ParallelInnerGestureEvent,
                ) -> *mut ArkUI_GestureRecognizer,
            >,
        ) -> i32,
    >,
    #[doc = " @brief Creates a tap gesture that is subject to distance restrictions.\n\n        1. This API is used to trigger a tap gesture with one, two, or more taps. \\n\n        2. If multi-tap is configured, the timeout interval between a lift and the next tap is 300 ms. \\n\n        3. If the distance between the last tapped position and the current tapped position exceeds 60 vp,\n           gesture recognition fails. \\n\n        4. If the value is greater than 1, the tap gesture will fail to be recognized when the number of fingers\n           touching the screen within 300 ms of the first finger touch is less than the required number,\n           or when the number of fingers lifted from the screen within 300 ms of the first finger's being lifted\n           is less than the required number. \\n\n        5. When the number of fingers touching the screen exceeds the set value, the gesture can be recognized. \\n\n        6. If the finger moves beyond the preset distance limit, gesture recognition fails. \\n\n\n @param countNum Indicates the number of consecutive taps. If the value is less than 1 or is not set, the default\n        value <b>1</b> is used.\n @param fingersNum Indicates the number of fingers required to trigger a tap. The value ranges from 1 to 10.\n        If the value is less than 1 or is not set, the default value <b>1</b> is used.\n @param distanceThreshold Indicates the allowed moving distance of a finger.\n        If the value is less than 0 or is not set, it will be converted to the default value of infinity.\n @return Returns the pointer to the created gesture."]
    pub createTapGestureWithDistanceThreshold: ::std::option::Option<
        unsafe extern "C" fn(
            countNum: i32,
            fingersNum: i32,
            distanceThreshold: f64,
        ) -> *mut ArkUI_GestureRecognizer,
    >,
}
#[doc = " @brief Defines the gesture APIs.\n\n @since 18"]
#[cfg(feature = "api-18")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeGestureAPI_2 {
    #[doc = " @brief Pointer to the <b>ArkUI_NativeGestureAPI_1</b> struct."]
    pub gestureApi1: *mut ArkUI_NativeGestureAPI_1,
    #[doc = " @brief Sets the callback for gesture interruption events.\n\n @param node Node for which you want to set a gesture interruption callback.\n @param userData Custom data.\n @param interrupter Gesture interruption callback to set. <b>info</b> indicates the gesture interruption data.\n If <b>interrupter</b> returns <b>GESTURE_INTERRUPT_RESULT_CONTINUE</b>, the gesture recognition process proceeds\n properly. If it returns <b>GESTURE_INTERRUPT_RESULT_REJECT</b>, the gesture recognition process is paused.\n @return Returns <b>0</b> if success.\n         Returns <b>401</b> if a parameter error occurs."]
    pub setGestureInterrupterToNode: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            userData: *mut ::std::os::raw::c_void,
            interrupter: ::std::option::Option<
                unsafe extern "C" fn(
                    info: *mut ArkUI_GestureInterruptInfo,
                ) -> ArkUI_GestureInterruptResult,
            >,
        ) -> i32,
    >,
}
extern "C" {
    #[doc = " @brief Obtains the custom data from a gesture interruption event.\n\n @param event Pointer to the gesture interruption information.\n @return Returns the pointer to the custom data.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_GestureInterrupter_GetUserData(
        event: *mut ArkUI_GestureInterruptInfo,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Prevents a gesture recognizer from participating in the current gesture recognition before all fingers are\n lifted.\n If the system has already determined the result of the gesture recognizer (regardless of success or failure),\n calling this API will be ineffective.\n\n @param recognizer Pointer to a gesture recognizer.\n @return Result code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR}: The operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID}: A parameter error occurs.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_PreventGestureRecognizerBegin(
        recognizer: *mut ArkUI_GestureRecognizer,
    ) -> ArkUI_ErrorCode;
}
#[doc = " API related to UI components. For details, see the struct definition in <arkui/native_node.h>."]
pub const ArkUI_NativeAPIVariantKind_ARKUI_NATIVE_NODE: ArkUI_NativeAPIVariantKind = 0;
#[doc = " API related to dialog boxes. For details, see the struct definition in <arkui/native_dialog.h>."]
pub const ArkUI_NativeAPIVariantKind_ARKUI_NATIVE_DIALOG: ArkUI_NativeAPIVariantKind = 1;
#[doc = " API related to gestures. For details, see the struct definition in <arkui/native_gesture.h>."]
pub const ArkUI_NativeAPIVariantKind_ARKUI_NATIVE_GESTURE: ArkUI_NativeAPIVariantKind = 2;
#[doc = " API related to animations. For details, see the struct definition in <arkui/native_animate.h>."]
pub const ArkUI_NativeAPIVariantKind_ARKUI_NATIVE_ANIMATE: ArkUI_NativeAPIVariantKind = 3;
#[doc = " API related to supported multi thread UI components.\n For details, see the struct definition in <arkui/native_node.h>.\n @since 22"]
#[cfg(feature = "api-22")]
pub const ArkUI_NativeAPIVariantKind_ARKUI_MULTI_THREAD_NATIVE_NODE: ArkUI_NativeAPIVariantKind = 4;
#[doc = " @brief Defines the native API types.\n\n @since 12"]
pub type ArkUI_NativeAPIVariantKind = u32;
extern "C" {
    #[doc = " @brief Obtains the native API set of a specified type.\n\n @param type Indicates the type of the native API set provided by ArkUI, for example, <b>ARKUI_NATIVE_NODE</b>\n and <b>ARKUI_NATIVE_GESTURE</b>.\n @param structName Indicates the name of a native struct defined in the corresponding header file, for example,\n <b>ArkUI_NativeNodeAPI_1</b> in <arkui/native_node.h>.\n @return Returns the pointer to the abstract native API, which can be used after being converted into a specific type.\n @code {.cpp}\n #include<arkui/native_interface.h>\n #include<arkui/native_node.h>\n #include<arkui/native_gesture.h>\n\n auto* anyNativeAPI = OH_ArkUI_QueryModuleInterfaceByName(ARKUI_NATIVE_NODE, \"ArkUI_NativeNodeAPI_1\");\n if (anyNativeAPI) {\n     auto nativeNodeApi = reinterpret_cast<ArkUI_NativeNodeAPI_1*>(anyNativeAPI);\n }\n auto anyGestureAPI = OH_ArkUI_QueryModuleInterface(ARKUI_NATIVE_GESTURE, \"ArkUI_NativeGestureAPI_1\");\n if (anyNativeAPI) {\n     auto basicGestureApi = reinterpret_cast<ArkUI_NativeGestureAPI_1*>(anyGestureAPI);\n }\n @endcode\n\n @since 12"]
    pub fn OH_ArkUI_QueryModuleInterfaceByName(
        type_: ArkUI_NativeAPIVariantKind,
        structName: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Unknown (or unrecognized) key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_UNKNOWN: ArkUI_KeyCode = -1;
#[doc = " Function (Fn) key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_FN: ArkUI_KeyCode = 0;
#[doc = " Volume Up key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_VOLUME_UP: ArkUI_KeyCode = 16;
#[doc = " Volume Down key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_VOLUME_DOWN: ArkUI_KeyCode = 17;
#[doc = " Power key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_POWER: ArkUI_KeyCode = 18;
#[doc = " Shutter key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_CAMERA: ArkUI_KeyCode = 19;
#[doc = " Speaker Mute key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_VOLUME_MUTE: ArkUI_KeyCode = 22;
#[doc = " Mute key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MUTE: ArkUI_KeyCode = 23;
#[doc = " Brightness Up key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BRIGHTNESS_UP: ArkUI_KeyCode = 40;
#[doc = " Brightness Down key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BRIGHTNESS_DOWN: ArkUI_KeyCode = 41;
#[doc = " Key 0"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_0: ArkUI_KeyCode = 2000;
#[doc = " Key 1"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_1: ArkUI_KeyCode = 2001;
#[doc = " Key 2"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_2: ArkUI_KeyCode = 2002;
#[doc = " Key 3"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_3: ArkUI_KeyCode = 2003;
#[doc = " Key 4"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_4: ArkUI_KeyCode = 2004;
#[doc = " Key 5"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_5: ArkUI_KeyCode = 2005;
#[doc = " Key 6"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_6: ArkUI_KeyCode = 2006;
#[doc = " Key 7"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_7: ArkUI_KeyCode = 2007;
#[doc = " Key 8"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_8: ArkUI_KeyCode = 2008;
#[doc = " Key 9"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_9: ArkUI_KeyCode = 2009;
#[doc = " Key +"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_STAR: ArkUI_KeyCode = 2010;
#[doc = " Key #"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_POUND: ArkUI_KeyCode = 2011;
#[doc = " Up key on D-pad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_UP: ArkUI_KeyCode = 2012;
#[doc = " Down key on D-pad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_DOWN: ArkUI_KeyCode = 2013;
#[doc = " Left key on D-pad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_LEFT: ArkUI_KeyCode = 2014;
#[doc = " Right key on D-pad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_RIGHT: ArkUI_KeyCode = 2015;
#[doc = " OK key on D-pad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_CENTER: ArkUI_KeyCode = 2016;
#[doc = " Key A"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_A: ArkUI_KeyCode = 2017;
#[doc = " Key B"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_B: ArkUI_KeyCode = 2018;
#[doc = " Key C"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_C: ArkUI_KeyCode = 2019;
#[doc = " Key D"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_D: ArkUI_KeyCode = 2020;
#[doc = " Key E"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_E: ArkUI_KeyCode = 2021;
#[doc = " Key F"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F: ArkUI_KeyCode = 2022;
#[doc = " Key G"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_G: ArkUI_KeyCode = 2023;
#[doc = " Key H"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_H: ArkUI_KeyCode = 2024;
#[doc = " Key I"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_I: ArkUI_KeyCode = 2025;
#[doc = " Key J"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_J: ArkUI_KeyCode = 2026;
#[doc = " Key K"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_K: ArkUI_KeyCode = 2027;
#[doc = " Key L"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_L: ArkUI_KeyCode = 2028;
#[doc = " Key M"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_M: ArkUI_KeyCode = 2029;
#[doc = " Key N"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_N: ArkUI_KeyCode = 2030;
#[doc = " Key O"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_O: ArkUI_KeyCode = 2031;
#[doc = " Key P"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_P: ArkUI_KeyCode = 2032;
#[doc = " Key R"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_Q: ArkUI_KeyCode = 2033;
#[doc = " Key R"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_R: ArkUI_KeyCode = 2034;
#[doc = " Key S"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_S: ArkUI_KeyCode = 2035;
#[doc = " Key T"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_T: ArkUI_KeyCode = 2036;
#[doc = " Key U"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_U: ArkUI_KeyCode = 2037;
#[doc = " Key V"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_V: ArkUI_KeyCode = 2038;
#[doc = " Key W"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_W: ArkUI_KeyCode = 2039;
#[doc = " Key X"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_X: ArkUI_KeyCode = 2040;
#[doc = " Key Y"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_Y: ArkUI_KeyCode = 2041;
#[doc = " Key Z"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_Z: ArkUI_KeyCode = 2042;
#[doc = " Key #"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_COMMA: ArkUI_KeyCode = 2043;
#[doc = " Key #"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_PERIOD: ArkUI_KeyCode = 2044;
#[doc = " Left Alt key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ALT_LEFT: ArkUI_KeyCode = 2045;
#[doc = " Right Alt key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ALT_RIGHT: ArkUI_KeyCode = 2046;
#[doc = " Left Shift key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SHIFT_LEFT: ArkUI_KeyCode = 2047;
#[doc = " Right Shift key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SHIFT_RIGHT: ArkUI_KeyCode = 2048;
#[doc = " Tab key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_TAB: ArkUI_KeyCode = 2049;
#[doc = " Space key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SPACE: ArkUI_KeyCode = 2050;
#[doc = " Symbol key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SYM: ArkUI_KeyCode = 2051;
#[doc = " Explorer key, used to start the explorer application"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_EXPLORER: ArkUI_KeyCode = 2052;
#[doc = " Email key, used to start the email application"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ENVELOPE: ArkUI_KeyCode = 2053;
#[doc = " Enter key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ENTER: ArkUI_KeyCode = 2054;
#[doc = " Backspace key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DEL: ArkUI_KeyCode = 2055;
#[doc = " Key `"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_GRAVE: ArkUI_KeyCode = 2056;
#[doc = " Key -"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MINUS: ArkUI_KeyCode = 2057;
#[doc = " Key ="]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_EQUALS: ArkUI_KeyCode = 2058;
#[doc = " Key ["]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_LEFT_BRACKET: ArkUI_KeyCode = 2059;
#[doc = " Key ]"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_RIGHT_BRACKET: ArkUI_KeyCode = 2060;
#[doc = " Key \\\\"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BACKSLASH: ArkUI_KeyCode = 2061;
#[doc = " Key ;"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SEMICOLON: ArkUI_KeyCode = 2062;
#[doc = " Key '"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_APOSTROPHE: ArkUI_KeyCode = 2063;
#[doc = " Key /"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SLASH: ArkUI_KeyCode = 2064;
#[doc = " Key @"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_AT: ArkUI_KeyCode = 2065;
#[doc = " Key +"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_PLUS: ArkUI_KeyCode = 2066;
#[doc = " Menu key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MENU: ArkUI_KeyCode = 2067;
#[doc = " Page Up key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_PAGE_UP: ArkUI_KeyCode = 2068;
#[doc = " Page Down key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_PAGE_DOWN: ArkUI_KeyCode = 2069;
#[doc = " ESC key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ESCAPE: ArkUI_KeyCode = 2070;
#[doc = " Delete key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_FORWARD_DEL: ArkUI_KeyCode = 2071;
#[doc = " Left Ctrl key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_CTRL_LEFT: ArkUI_KeyCode = 2072;
#[doc = " Right Ctrl key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_CTRL_RIGHT: ArkUI_KeyCode = 2073;
#[doc = " Caps Lock key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_CAPS_LOCK: ArkUI_KeyCode = 2074;
#[doc = " Scroll Lock key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SCROLL_LOCK: ArkUI_KeyCode = 2075;
#[doc = " Left Meta key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_META_LEFT: ArkUI_KeyCode = 2076;
#[doc = " Right Meta key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_META_RIGHT: ArkUI_KeyCode = 2077;
#[doc = " Function key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_FUNCTION: ArkUI_KeyCode = 2078;
#[doc = " System Request/Print Screen key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SYSRQ: ArkUI_KeyCode = 2079;
#[doc = " Break/Pause key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BREAK: ArkUI_KeyCode = 2080;
#[doc = " Move to Home key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MOVE_HOME: ArkUI_KeyCode = 2081;
#[doc = " Move to End key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MOVE_END: ArkUI_KeyCode = 2082;
#[doc = " Insert key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_INSERT: ArkUI_KeyCode = 2083;
#[doc = " Forward key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_FORWARD: ArkUI_KeyCode = 2084;
#[doc = " Play key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_PLAY: ArkUI_KeyCode = 2085;
#[doc = " Pause key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_PAUSE: ArkUI_KeyCode = 2086;
#[doc = " Close key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_CLOSE: ArkUI_KeyCode = 2087;
#[doc = " Eject key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_EJECT: ArkUI_KeyCode = 2088;
#[doc = " Record key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_RECORD: ArkUI_KeyCode = 2089;
#[doc = " F1 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F1: ArkUI_KeyCode = 2090;
#[doc = " F2 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F2: ArkUI_KeyCode = 2091;
#[doc = " F3 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F3: ArkUI_KeyCode = 2092;
#[doc = " F4 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F4: ArkUI_KeyCode = 2093;
#[doc = " F5 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F5: ArkUI_KeyCode = 2094;
#[doc = " F6 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F6: ArkUI_KeyCode = 2095;
#[doc = " F7 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F7: ArkUI_KeyCode = 2096;
#[doc = " F8 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F8: ArkUI_KeyCode = 2097;
#[doc = " F9 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F9: ArkUI_KeyCode = 2098;
#[doc = " F10 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F10: ArkUI_KeyCode = 2099;
#[doc = " F11 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F11: ArkUI_KeyCode = 2100;
#[doc = " F12 key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F12: ArkUI_KeyCode = 2101;
#[doc = " Number Lock key on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUM_LOCK: ArkUI_KeyCode = 2102;
#[doc = " Key 0 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_0: ArkUI_KeyCode = 2103;
#[doc = " Key 1 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_1: ArkUI_KeyCode = 2104;
#[doc = " Key 2 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_2: ArkUI_KeyCode = 2105;
#[doc = " Key 3 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_3: ArkUI_KeyCode = 2106;
#[doc = " Key 4 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_4: ArkUI_KeyCode = 2107;
#[doc = " Key 5 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_5: ArkUI_KeyCode = 2108;
#[doc = " Key 6 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_6: ArkUI_KeyCode = 2109;
#[doc = " Key 7 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_7: ArkUI_KeyCode = 2110;
#[doc = " Key 8 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_8: ArkUI_KeyCode = 2111;
#[doc = " Key 9 on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_9: ArkUI_KeyCode = 2112;
#[doc = " Key / on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_DIVIDE: ArkUI_KeyCode = 2113;
#[doc = " Key ) on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_MULTIPLY: ArkUI_KeyCode = 2114;
#[doc = " Key - on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_SUBTRACT: ArkUI_KeyCode = 2115;
#[doc = " Key + on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_ADD: ArkUI_KeyCode = 2116;
#[doc = " Key . on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_DOT: ArkUI_KeyCode = 2117;
#[doc = " Key , on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_COMMA: ArkUI_KeyCode = 2118;
#[doc = " Enter key on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_ENTER: ArkUI_KeyCode = 2119;
#[doc = " Key = on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_EQUALS: ArkUI_KeyCode = 2120;
#[doc = " Key ( on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_LEFT_PAREN: ArkUI_KeyCode = 2121;
#[doc = " Key ) on numeric keypad"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_RIGHT_PAREN: ArkUI_KeyCode = 2122;
#[doc = " Joystick key A\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_A: ArkUI_KeyCode = 2301;
#[doc = " Joystick key B\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_B: ArkUI_KeyCode = 2302;
#[doc = " Joystick key X\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_X: ArkUI_KeyCode = 2304;
#[doc = " Joystick key Y\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_Y: ArkUI_KeyCode = 2305;
#[doc = " Joystick key L1\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_L1: ArkUI_KeyCode = 2307;
#[doc = " Joystick key R1\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_R1: ArkUI_KeyCode = 2308;
#[doc = " Joystick key L2\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_L2: ArkUI_KeyCode = 2309;
#[doc = " Joystick key R2\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_R2: ArkUI_KeyCode = 2310;
#[doc = " Joystick key Select\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_SELECT: ArkUI_KeyCode = 2311;
#[doc = " Joystick key Start\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_START: ArkUI_KeyCode = 2312;
#[doc = " Joystick key Mode\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_MODE: ArkUI_KeyCode = 2313;
#[doc = " Joystick key THUMBL\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_THUMBL: ArkUI_KeyCode = 2314;
#[doc = " Joystick key THUMBR\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_THUMBR: ArkUI_KeyCode = 2315;
#[doc = " @brief Defines an enum for the key codes in key events.\n\n @since 14"]
#[cfg(feature = "api-14")]
pub type ArkUI_KeyCode = i32;
#[doc = " Unknown type"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_UNKNOWN: ArkUI_KeyEventType = -1;
#[doc = " Pressing of a key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_DOWN: ArkUI_KeyEventType = 0;
#[doc = " Release of a key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_UP: ArkUI_KeyEventType = 1;
#[doc = " Long press of a key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_LONG_PRESS: ArkUI_KeyEventType = 2;
#[doc = " Click of a key"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_CLICK: ArkUI_KeyEventType = 3;
#[doc = " @brief Defines an enum for the key event types.\n\n @since 14"]
#[cfg(feature = "api-14")]
pub type ArkUI_KeyEventType = i32;
#[doc = " Unknown type"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeySourceType_ARKUI_KEY_SOURCE_UNKNOWN: ArkUI_KeySourceType = 0;
#[doc = " Mouse"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeySourceType_ARKUI_KEY_SOURCE_TYPE_MOUSE: ArkUI_KeySourceType = 1;
#[doc = " Keyboard"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeySourceType_ARKUI_KEY_SOURCE_TYPE_KEYBOARD: ArkUI_KeySourceType = 4;
#[doc = " @brief Joystick.\n\n @since 15"]
#[cfg(feature = "api-15")]
pub const ArkUI_KeySourceType_ARKUI_KEY_SOURCE_TYPE_JOYSTICK: ArkUI_KeySourceType = 5;
#[doc = " @brief Defines an enum for the types of devices that trigger a key event.\n\n @since 14"]
#[cfg(feature = "api-14")]
pub type ArkUI_KeySourceType = u32;
#[doc = " Unknown intention"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_UNKNOWN: ArkUI_KeyIntension = -1;
#[doc = "Upward"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_UP: ArkUI_KeyIntension = 1;
#[doc = " Downward"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_DOWN: ArkUI_KeyIntension = 2;
#[doc = " Leftward"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_LEFT: ArkUI_KeyIntension = 3;
#[doc = " Rightward"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_RIGHT: ArkUI_KeyIntension = 4;
#[doc = " Select"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_SELECT: ArkUI_KeyIntension = 5;
#[doc = " Escape"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_ESCAPE: ArkUI_KeyIntension = 6;
#[doc = " Back"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_BACK: ArkUI_KeyIntension = 7;
#[doc = " Forward"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_FORWARD: ArkUI_KeyIntension = 8;
#[doc = " Menu"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_MENU: ArkUI_KeyIntension = 9;
#[doc = " Home"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_HOME: ArkUI_KeyIntension = 10;
#[doc = " Page up"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_PAGE_UP: ArkUI_KeyIntension = 11;
#[doc = " Page down"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_PAGE_DOWN: ArkUI_KeyIntension = 12;
#[doc = " Zoom out"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_ZOOM_OUT: ArkUI_KeyIntension = 13;
#[doc = " Zoom in"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_ZOOM_IN: ArkUI_KeyIntension = 14;
#[doc = " Play or pause"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_PLAY_PAUSE: ArkUI_KeyIntension = 100;
#[doc = " Fast-forward"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_FAST_FORWARD: ArkUI_KeyIntension = 101;
#[doc = " Fast playback"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_FAST_PLAYBACK: ArkUI_KeyIntension = 103;
#[doc = " Play next"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_NEXT: ArkUI_KeyIntension = 104;
#[doc = " Play previous"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_PREVIOUS: ArkUI_KeyIntension = 105;
#[doc = " Mute"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_MUTE: ArkUI_KeyIntension = 106;
#[doc = " Volume up"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_VOLUME_UP: ArkUI_KeyIntension = 107;
#[doc = " Volume down"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_VOLUME_DOWN: ArkUI_KeyIntension = 108;
#[doc = " Answer a call"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_CALL: ArkUI_KeyIntension = 200;
#[doc = " Camera"]
#[cfg(feature = "api-14")]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_CAMERA: ArkUI_KeyIntension = 300;
#[doc = " @brief Defines an enum for key intentions.\n\n @since 14"]
#[cfg(feature = "api-14")]
pub type ArkUI_KeyIntension = i32;
extern "C" {
    #[doc = " @brief Obtains the type of a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the key event type.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_KeyEvent_GetType(event: *const ArkUI_UIInputEvent) -> ArkUI_KeyEventType;
}
extern "C" {
    #[doc = " @brief Obtains the key code from a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the key code.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_KeyEvent_GetKeyCode(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the key value from a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the key value.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_KeyEvent_GetKeyText(
        event: *const ArkUI_UIInputEvent,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Obtains the type of device that triggers a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the device type.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_KeyEvent_GetKeySource(event: *const ArkUI_UIInputEvent) -> ArkUI_KeySourceType;
}
extern "C" {
    #[doc = " @brief Prevents a key event from bubbling up.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param stopPropagation Whether to stop event propagation.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_KeyEvent_StopPropagation(
        event: *const ArkUI_UIInputEvent,
        stopPropagation: bool,
    );
}
extern "C" {
    #[doc = " @brief Obtains the intention code associated with a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the intention code associated with the key event.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_KeyEvent_GetKeyIntensionCode(
        event: *const ArkUI_UIInputEvent,
    ) -> ArkUI_KeyIntension;
}
extern "C" {
    #[doc = " @brief Obtains the Unicode value associated with a key event.\n Non-space basic Latin characters in the 0x0021-0x007E range are supported. Characters with a value of 0 are not\n supported. In the case of key combination, this API returns the Unicode value of the key corresponding to the key\n event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the Unicode value.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_KeyEvent_GetUnicode(event: *const ArkUI_UIInputEvent) -> u32;
}
extern "C" {
    #[doc = " @brief Sets whether a key event is consumed in the key event callback.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param isConsumed Whether the event is consumed.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_KeyEvent_SetConsumed(event: *const ArkUI_UIInputEvent, isConsumed: bool);
}
extern "C" {
    #[doc = " @brief Dispatch key event to a specific component node.\n\n @param node Indicates the pointer to a component node.\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_ArkUI_KeyEvent_Dispatch(node: ArkUI_NodeHandle, event: *const ArkUI_UIInputEvent);
}
extern "C" {
    #[doc = " @brief Get the Num Lock state of the key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param state Return whether the Num Lock is on.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_KeyEvent_IsNumLockOn(
        event: *const ArkUI_UIInputEvent,
        state: *mut bool,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the Caps Lock state of the key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param state Return whether the Caps Lock is on.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_KeyEvent_IsCapsLockOn(
        event: *const ArkUI_UIInputEvent,
        state: *mut bool,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the Scroll Lock state of the key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param state Return whether the Scroll Lock is on.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_ArkUI_KeyEvent_IsScrollLockOn(
        event: *const ArkUI_UIInputEvent,
        state: *mut bool,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains a <b>FrameNode</b> object on the ArkTS side and maps it to an <b>ArkUI_NodeHandle</b> object on the\n native side.\n\n @param env Indicates the NAPI environment pointer.\n @param frameNode Indicates the <b>FrameNode</b> object created on the ArkTS side.\n @param handle Indicates the pointer to the <b>ArkUI_NodeHandle</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetNodeHandleFromNapiValue(
        env: napi_env,
        frameNode: napi_value,
        handle: *mut ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>UIContext</b> object on the ArkTS side and maps it to an <b>ArkUI_ContextHandle</b> object on the\n native side.\n\n @param env ndicates the NAPI environment pointer.\n @param value Indicates the <b>UIContext</b> object created on the ArkTS side.\n @param context Indicates the pointer to the <b>ArkUI_ContextHandle</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetContextFromNapiValue(
        env: napi_env,
        value: napi_value,
        context: *mut ArkUI_ContextHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>NodeContent</b> object on the ArkTS side and maps it to an <b>ArkUI_NodeContentHandle</b>\n object on the native side.\n\n @param env ndicates the NAPI environment pointer.\n @param value Indicates the <b>NodeContent</b> object created on the ArkTS side.\n @param content Indicates the pointer to the <b>ArkUI_NodeContentHandle</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetNodeContentFromNapiValue(
        env: napi_env,
        value: napi_value,
        content: *mut ArkUI_NodeContentHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>DrawableDescriptor</b> object on the ArkTS side and maps it to an\n <b>ArkUI_DrawableDescriptro</b> object on the native side.\n\n @param env Indicates the NAPI environment pointer.\n @param value Indicates the <b>DrawableDescriptor</b> object created on the ArkTS side.\n @param drawableDescriptor Indicates the pointer to the <b>ArkUI_DrawableDescriptro</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetDrawableDescriptorFromNapiValue(
        env: napi_env,
        value: napi_value,
        drawableDescriptor: *mut *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>Resource</b> object on the ArkTS side and maps it to an\n <b>ArkUI_DrawableDescriptro</b> object on the native side.\n\n @param env Indicates the NAPI environment pointer.\n @param value Indicates the <b>Resource</b> object created on the ArkTS side.\n @param drawableDescriptor Indicates the pointer to the <b>ArkUI_DrawableDescriptro</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetDrawableDescriptorFromResourceNapiValue(
        env: napi_env,
        value: napi_value,
        drawableDescriptor: *mut *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the ID of the Navigation component where the node is located.\n\n @param node The node.\n @param buffer The buffer to which NavigationID writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetNavigationId(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the name of the NavDestination component where the node is located.\n\n @param node The node.\n @param buffer The buffer to which NavDestination name writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationName(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Based on the given index value, obtain the length of the Navigation stack where the node is located.\n\n @param node The node.\n @param length The length of the stack. After the operation succeeds, the result is written back to this parameter.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or length is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n @since 12"]
    pub fn OH_ArkUI_GetNavStackLength(node: ArkUI_NodeHandle, length: *mut i32) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Based on the given index value, obtain the page name of the corresponding position\n        in the navigation stack where the node is located.\n        Index values are counted from 0, with 0 being the bottom of the stack.\n\n @param node The node.\n @param index The index of the NavDestination in the stack is queried.\n @param buffer The buffer to which NavDestination index writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_NODE_INDEX_INVALID} if index is an invalid value.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationNameByIndex(
        node: ArkUI_NodeHandle,
        index: i32,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the ID of the NavDestination component where the node is located.\n\n @param node The node.\n @param buffer The buffer to which NavDestination ID writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationId(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the state of the NavDestination component where the node is located.\n\n @param node The node.\n @param state The state value of NavDestination is written back into this parameter.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or state is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationState(
        node: ArkUI_NodeHandle,
        state: *mut ArkUI_NavDestinationState,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the index of the NavDestination component on the Navigation stack where the node is located.\n\n @param node The node.\n @param index Index value, counted from 0.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or index is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationIndex(
        node: ArkUI_NodeHandle,
        index: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the parameters of the NavDestination component where the node is located.\n\n @param node The node.\n @return The parameters.\n         If a null pointer is returned, it may be because the node is empty or the parameters does not exist.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationParam(node: ArkUI_NodeHandle) -> napi_value;
}
extern "C" {
    #[doc = " @brief Obtain the index of the page where the node resides in the Router page stack.\n\n @param node The node.\n @param index Index value, counted from 1.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or index is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPageIndex(node: ArkUI_NodeHandle, index: *mut i32) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the name of the page where the node is located.\n\n @param node The node.\n @param buffer The buffer to which page name writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPageName(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the path of the page where the node is located.\n\n @param node The node.\n @param buffer The buffer to which page path writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPagePath(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the state of the page where the node is located.\n\n @param node The node.\n @param state The state value of the page is written back to this parameter.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or state is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPageState(
        node: ArkUI_NodeHandle,
        state: *mut ArkUI_RouterPageState,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the ID of the page where the node is located.\n\n @param node The node.\n @param buffer The buffer to which page ID writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPageId(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Register a callback to be executed when rendering in the next frame. Cannot be called on\n        the non-UI thread. Checking for non-UI thread calls will abort.\n\n @param uiContext ArkUI_ContextHandle.\n @param userData Indicates the custom data to be saved.\n @param callback Custom callback function.\n @param nanoTimestamp Timestamp of frame signal.\n @param frameCount Frame count.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n         Returns {@link ARKUI_ERROR_CODE_UI_CONTEXT_INVALID} if the uiContext is invalid.\n         Returns {@link ARKUI_ERROR_CODE_CALLBACK_INVALID} if the callback function is invalid.\n @since 18"]
    #[cfg(feature = "api-18")]
    pub fn OH_ArkUI_PostFrameCallback(
        uiContext: ArkUI_ContextHandle,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                nanoTimestamp: u64,
                frameCount: u32,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Initialize the ArkTS method for the specified env environment. Cannot be called on\n        the non-UI thread. Checking for non-UI thread calls will abort.\n\n @param env napi environment pointer.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if env is null or failed to set the whitelist.\n         {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_InitModuleForArkTSEnv(env: napi_env) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Notify the specified env environment is invalid. Cannot be called on\n        the non-UI thread. Checking for non-UI thread calls will abort.\n\n @param env napi environment pointer.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_NotifyArkTSEnvDestroy(env: napi_env);
}
extern "C" {
    #[doc = " @brief Register a callback to be executed at the end of the next idle frame.\n        If there is no next frame, will request one automatically.\n\n @param uiContext ArkUI_ContextHandle.\n @param userData Indicates the custom data to be saved.\n @param callback Custom callback function.\n @param nanoTimeLeft Time remaining until the end of the current frame.\n @param frameCount Frame count.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n         Returns {@link ARKUI_ERROR_CODE_UI_CONTEXT_INVALID} if the uiContext is invalid.\n         Returns {@link ARKUI_ERROR_CODE_CALLBACK_INVALID} if the callback function is invalid.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_ArkUI_PostIdleCallback(
        uiContext: ArkUI_ContextHandle,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                nanoTimeLeft: u64,
                frameCount: u32,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_StyledString {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates a pointer to the ArkUI_StyledString object.\n\n @param style A pointer to OH_Drawing_TypographyStyle, obtained by {@link OH_Drawing_CreateTypographyStyle}.\n @param collection A pointer to OH_Drawing_FontCollection, obtained by {@link OH_Drawing_CreateFontCollection}.\n @return Creates a pointer to the ArkUI_StyledString object. If the object returns a null pointer,\n         the creation failed, either because the address space was full,\n         or because the style, collection parameter was an exception such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_StyledString_Create(
        style: *mut OH_Drawing_TypographyStyle,
        collection: *mut OH_Drawing_FontCollection,
    ) -> *mut ArkUI_StyledString;
}
extern "C" {
    #[doc = " @brief Free the memory occupied by the ArkUI_StyledString object.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @since 12"]
    pub fn OH_ArkUI_StyledString_Destroy(handle: *mut ArkUI_StyledString);
}
extern "C" {
    #[doc = " @brief Sets the new layout style to the top of the current format string style stack.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @param style A pointer to the OH_Drawing_TextStyle object.\n @since 12"]
    pub fn OH_ArkUI_StyledString_PushTextStyle(
        handle: *mut ArkUI_StyledString,
        style: *mut OH_Drawing_TextStyle,
    );
}
extern "C" {
    #[doc = " @brief Sets the corresponding text content based on the current format string style.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @param content A pointer to the text content.\n @since 12"]
    pub fn OH_ArkUI_StyledString_AddText(
        handle: *mut ArkUI_StyledString,
        content: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Removes the top style from the stack in the current format string object.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @since 12"]
    pub fn OH_ArkUI_StyledString_PopTextStyle(handle: *mut ArkUI_StyledString);
}
extern "C" {
    #[doc = " @brief Creates a pointer to an OH_Drawing_Typography object based on a format string object\n for advanced text estimation and typography.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @return A pointer to the OH_Drawing_Typography object. If the object returns a null pointer,\n         the creation fails because the handle parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_StyledString_CreateTypography(
        handle: *mut ArkUI_StyledString,
    ) -> *mut OH_Drawing_Typography;
}
extern "C" {
    #[doc = " @brief Set the placeholder.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @param placeholder A pointer to the OH_Drawing_PlaceholderSpan object.\n @since 12"]
    pub fn OH_ArkUI_StyledString_AddPlaceholder(
        handle: *mut ArkUI_StyledString,
        placeholder: *mut OH_Drawing_PlaceholderSpan,
    );
}
extern "C" {
    #[doc = " @brief Creates an <b>ArkUI_StyledString_Descriptor</b> object.\n\n @return Returns the pointer to the <b>ArkUI_StyledString_Descriptor</b> object created.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_StyledString_Descriptor_Create() -> *mut ArkUI_StyledString_Descriptor;
}
extern "C" {
    #[doc = " @brief Destroys an <b>ArkUI_StyledString_Descriptor</b> object and reclaims the memory occupied by the object.\n\n @param descriptor Pointer to an <b>ArkUI_StyledString_Descriptor</b> object.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_StyledString_Descriptor_Destroy(descriptor: *mut ArkUI_StyledString_Descriptor);
}
extern "C" {
    #[doc = " @brief Converts styled string information into HTML.\n\n @param descriptor Pointer to an <b>ArkUI_StyledString_Descriptor</b> object.\n @return Returns the pointer to the resulting HTML string. This pointer is managed internally and should be destroyed\n         by calling <b>OH_ArkUI_StyledString_Descriptor_Destroy()</b> when no longer needed to free the memory.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_ConvertToHtml(
        descriptor: *mut ArkUI_StyledString_Descriptor,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Deserializes a byte array containing styled string information into a styled string.\n\n @param buffer Byte array to be deserialized.\n @param bufferSize Length of the byte array.\n @param descriptor Pointer to an <b>ArkUI_StyledString_Descriptor</b> object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_UnmarshallStyledStringDescriptor(
        buffer: *mut u8,
        bufferSize: usize,
        descriptor: *mut ArkUI_StyledString_Descriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Serializes the styled string information into a byte array.\n\n @param buffer Byte array where the serialized data will be stored.\n @param bufferSize Length of the byte array.\n @param descriptor Pointer to an <b>ArkUI_StyledString_Descriptor</b> object.\n @param resultSize Actual length of the byte array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_INVALID_STYLED_STRING} if the styled string is invalid.\n @since 14"]
    #[cfg(feature = "api-14")]
    pub fn OH_ArkUI_MarshallStyledStringDescriptor(
        buffer: *mut u8,
        bufferSize: usize,
        descriptor: *mut ArkUI_StyledString_Descriptor,
        resultSize: *mut usize,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TextLayoutManager {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Dispose an object of the text layout manager.\n\n @param layoutManager Pointer to the ArkUI_TextLayoutManager object to be disposed.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextLayoutManager_Dispose(layoutManager: *mut ArkUI_TextLayoutManager);
}
extern "C" {
    #[doc = " @brief Gets the line count.\n\n @param layoutManager Indicates the pointer to an <b>ArkUI_TextLayoutManager</b> object.\n @param outLineCount Returns the line count.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextLayoutManager_GetLineCount(
        layoutManager: *mut ArkUI_TextLayoutManager,
        outLineCount: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Gets the rects for range.\n\n @param layoutManager Indicates the pointer to an <b>ArkUI_TextLayoutManager</b> object.\n @param start Indicates the start of range to set.\n @param end Indicates the end of range to set.\n @param widthStyle Indicates the width style to set.\n     For details, see the enum <b>OH_Drawing_RectWidthStyle</b>.\n @param heightStyle Indicates the height style to set.\n     For details, see the enum <b>OH_Drawing_RectHeightStyle</b>.\n @param outTextBoxes Returns the array of rects for range.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextLayoutManager_GetRectsForRange(
        layoutManager: *mut ArkUI_TextLayoutManager,
        start: i32,
        end: i32,
        widthStyle: OH_Drawing_RectWidthStyle,
        heightStyle: OH_Drawing_RectHeightStyle,
        outTextBoxes: *mut *mut OH_Drawing_TextBox,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Gets the glyph position at coordinate.\n\n @param layoutManager Indicates the pointer to an <b>ArkUI_TextLayoutManager</b> object.\n @param dx Indicates the positionX of typography to set.\n @param dy Indicates the positionY of typography to set.\n @param outPos Returns the glyph position at coordinate.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextLayoutManager_GetGlyphPositionAtCoordinate(
        layoutManager: *mut ArkUI_TextLayoutManager,
        dx: f64,
        dy: f64,
        outPos: *mut *mut OH_Drawing_PositionAndAffinity,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get line metrics information.\n\n @param layoutManager Indicates the pointer to a typography object <b>ArkUI_TextLayoutManager</b>.\n @param lineNumber Indicates the number of line.\n @param outMetrics Indicates the pointer to a line metrics object <b>OH_Drawing_LineMetrics</b>.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 22"]
    #[cfg(feature = "api-22")]
    pub fn OH_ArkUI_TextLayoutManager_GetLineMetrics(
        layoutManager: *mut ArkUI_TextLayoutManager,
        lineNumber: i32,
        outMetrics: *mut OH_Drawing_LineMetrics,
    ) -> ArkUI_ErrorCode;
}
