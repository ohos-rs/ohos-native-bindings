/* automatically generated by rust-bindgen 0.65.1 */

#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(clippy::missing_safety_doc)]

use napi_sys_ohos::*;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DrawableDescriptor {
    _unused: [u8; 0],
}
#[doc = " @brief Introduces the native pixel map information defined by Image Kit.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PixelmapNative {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to OH_PixelmapNative.\n\n @since 12"]
pub type OH_PixelmapNativeHandle = *mut OH_PixelmapNative;
extern "C" {
    #[doc = " @brief Creates a DrawableDescriptor from a Pixelmap.\n\n @param pixelMap Indicates the pointer to a Pixelmap\n @return Returns the pointer to the drawableDescriptor.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_CreateFromPixelMap(
        pixelMap: OH_PixelmapNativeHandle,
    ) -> *mut ArkUI_DrawableDescriptor;
}
extern "C" {
    #[doc = " @brief Creates a DrawableDescriptor from a Pixelmap array.\n\n @param array Indicates the pointer to a Pixelmap array.\n @param size Indicates the size of the Pixelmap array.\n @return Returns the pointer to the drawableDescriptor.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_CreateFromAnimatedPixelMap(
        array: *mut OH_PixelmapNativeHandle,
        size: i32,
    ) -> *mut ArkUI_DrawableDescriptor;
}
extern "C" {
    #[doc = " @brief Destroys the pointer to the drawableDescriptor.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_Dispose(drawableDescriptor: *mut ArkUI_DrawableDescriptor);
}
extern "C" {
    #[doc = " @brief Obtains the Pixelmap object.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Returns the pointer to the PixelMap.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetStaticPixelMap(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> OH_PixelmapNativeHandle;
}
extern "C" {
    #[doc = " @brief Obtains the Pixelmap array used to play the animation.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Returns the pointer to the PixelMap array.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimatedPixelMapArray(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> *mut OH_PixelmapNativeHandle;
}
extern "C" {
    #[doc = " @brief Obtains the size of the Pixelmap array used to play the animation.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Returns the size of the Pixelmap array.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimatedPixelMapArraySize(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the total playback duration.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @param duration Indicates the total playback duration. The unit is millisecond.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_SetAnimationDuration(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
        duration: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the total playback duration.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Return the total playback duration. The unit is millisecond.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimationDuration(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the number of playback times.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @param iterations Indicates the number of playback times.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_SetAnimationIteration(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
        iteration: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the number of playback times.\n\n @param drawableDescriptor Indicates the pointer to the drawableDescriptor.\n @return Returns the number of playback times.\n @since 12"]
    pub fn OH_ArkUI_DrawableDescriptor_GetAnimationIteration(
        drawableDescriptor: *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
#[doc = " @brief Defines the ArkUI native component object.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeContent {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer type of the ArkUI node content\n\n @since 12"]
pub type ArkUI_NodeContentHandle = *mut ArkUI_NodeContent;
#[doc = " @brief Defines the custom dialog box controller of ArkUI on the native side.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeDialog {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_LayoutConstraint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DrawContext {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to the ArkUI native component object.\n\n @since 12"]
pub type ArkUI_NodeHandle = *mut ArkUI_Node;
#[doc = " @brief Defines the pointer to the custom dialog box controller of ArkUI on the native side.\n\n @since 12"]
pub type ArkUI_NativeDialogHandle = *mut ArkUI_NativeDialog;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_WaterFlowSectionOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ListItemSwipeActionItem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ListItemSwipeActionOption {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the ArkUI native context object.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Context {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to the context instance object pointer definition of ArkUI on the native side.\n\n @since 12"]
pub type ArkUI_ContextHandle = *mut ArkUI_Context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_SwiperIndicator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_StyledString_Descriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AlignmentRuleOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GuidelineOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_BarrierOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ListChildrenMainSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ImageAnimatorFrameInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AccessibilityState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AccessibilityValue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CustomProperty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_HostWindowInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ActiveChildrenInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ProgressLinearStyleOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CrossLanguageOption {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the event callback type.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ContextCallback {
    #[doc = " Custom type."]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " Event callback."]
    pub callback:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
}
#[doc = " @brief Provides the number types of ArkUI in the native code.\n\n @since 12"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ArkUI_NumberValue {
    #[doc = " Floating-point type."]
    pub f32_: f32,
    #[doc = " Signed integer."]
    pub i32_: i32,
    #[doc = " Unsigned integer."]
    pub u32_: u32,
}
#[doc = " Top start."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_TOP_START: ArkUI_Alignment = 0;
#[doc = " Top center."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_TOP: ArkUI_Alignment = 1;
#[doc = " Top end."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_TOP_END: ArkUI_Alignment = 2;
#[doc = " Vertically centered start."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_START: ArkUI_Alignment = 3;
#[doc = " Horizontally and vertically centered."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_CENTER: ArkUI_Alignment = 4;
#[doc = " Vertically centered end."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_END: ArkUI_Alignment = 5;
#[doc = " Bottom start."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_BOTTOM_START: ArkUI_Alignment = 6;
#[doc = " Horizontally centered on the bottom."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_BOTTOM: ArkUI_Alignment = 7;
#[doc = " Bottom end."]
pub const ArkUI_Alignment_ARKUI_ALIGNMENT_BOTTOM_END: ArkUI_Alignment = 8;
#[doc = " @brief Enumerates the alignment modes.\n\n @since 12"]
pub type ArkUI_Alignment = ::std::os::raw::c_uint;
#[doc = " The image is not repeatedly drawn."]
pub const ArkUI_ImageRepeat_ARKUI_IMAGE_REPEAT_NONE: ArkUI_ImageRepeat = 0;
#[doc = " The image is repeatedly drawn only along the x-axis."]
pub const ArkUI_ImageRepeat_ARKUI_IMAGE_REPEAT_X: ArkUI_ImageRepeat = 1;
#[doc = " The image is repeatedly drawn only along the y-axis."]
pub const ArkUI_ImageRepeat_ARKUI_IMAGE_REPEAT_Y: ArkUI_ImageRepeat = 2;
#[doc = " The image is repeatedly drawn along both axes."]
pub const ArkUI_ImageRepeat_ARKUI_IMAGE_REPEAT_XY: ArkUI_ImageRepeat = 3;
#[doc = " @brief Enumerates the image repeat patterns.\n\n @since 12"]
pub type ArkUI_ImageRepeat = ::std::os::raw::c_uint;
#[doc = " Standard font style."]
pub const ArkUI_FontStyle_ARKUI_FONT_STYLE_NORMAL: ArkUI_FontStyle = 0;
#[doc = " Italic font style."]
pub const ArkUI_FontStyle_ARKUI_FONT_STYLE_ITALIC: ArkUI_FontStyle = 1;
#[doc = " @brief Enumerates the font styles.\n\n @since 12"]
pub type ArkUI_FontStyle = ::std::os::raw::c_uint;
#[doc = " 100"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W100: ArkUI_FontWeight = 0;
#[doc = " 200"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W200: ArkUI_FontWeight = 1;
#[doc = " 300"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W300: ArkUI_FontWeight = 2;
#[doc = " 400"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W400: ArkUI_FontWeight = 3;
#[doc = " 500"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W500: ArkUI_FontWeight = 4;
#[doc = " 600"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W600: ArkUI_FontWeight = 5;
#[doc = " 700"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W700: ArkUI_FontWeight = 6;
#[doc = " 800"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W800: ArkUI_FontWeight = 7;
#[doc = " 900"]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_W900: ArkUI_FontWeight = 8;
#[doc = " The font weight is bold."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_BOLD: ArkUI_FontWeight = 9;
#[doc = " The font weight is normal."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_NORMAL: ArkUI_FontWeight = 10;
#[doc = " The font weight is bolder."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_BOLDER: ArkUI_FontWeight = 11;
#[doc = " The font weight is lighter."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_LIGHTER: ArkUI_FontWeight = 12;
#[doc = " The font weight is medium."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_MEDIUM: ArkUI_FontWeight = 13;
#[doc = " The font weight is normal."]
pub const ArkUI_FontWeight_ARKUI_FONT_WEIGHT_REGULAR: ArkUI_FontWeight = 14;
#[doc = " @brief Enumerates the font weights.\n\n @since 12"]
pub type ArkUI_FontWeight = ::std::os::raw::c_uint;
#[doc = " Aligned with the start."]
pub const ArkUI_TextAlignment_ARKUI_TEXT_ALIGNMENT_START: ArkUI_TextAlignment = 0;
#[doc = " Horizontally centered."]
pub const ArkUI_TextAlignment_ARKUI_TEXT_ALIGNMENT_CENTER: ArkUI_TextAlignment = 1;
#[doc = " Aligned with the end."]
pub const ArkUI_TextAlignment_ARKUI_TEXT_ALIGNMENT_END: ArkUI_TextAlignment = 2;
#[doc = " Aligned with both margins."]
pub const ArkUI_TextAlignment_ARKUI_TEXT_ALIGNMENT_JUSTIFY: ArkUI_TextAlignment = 3;
#[doc = " @brief Enumerates the text alignment mode.\n\n @since 12"]
pub type ArkUI_TextAlignment = ::std::os::raw::c_uint;
#[doc = " The Enter key is labeled \"Go.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_GO: ArkUI_EnterKeyType = 2;
#[doc = " The Enter key is labeled \"Search.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_SEARCH: ArkUI_EnterKeyType = 3;
#[doc = " The Enter key is labeled \"Send.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_SEND: ArkUI_EnterKeyType = 4;
#[doc = " The Enter key is labeled \"Next.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_NEXT: ArkUI_EnterKeyType = 5;
#[doc = " The Enter key is labeled \"Done.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_DONE: ArkUI_EnterKeyType = 6;
#[doc = " The Enter key is labeled \"Previous.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_PREVIOUS: ArkUI_EnterKeyType = 7;
#[doc = " The Enter key is labeled \"New Line.\""]
pub const ArkUI_EnterKeyType_ARKUI_ENTER_KEY_TYPE_NEW_LINE: ArkUI_EnterKeyType = 8;
#[doc = " @brief Enumerates the types of the Enter key for a single-line text box.\n\n @since 12"]
pub type ArkUI_EnterKeyType = ::std::os::raw::c_uint;
#[doc = " Normal input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NORMAL: ArkUI_TextInputType = 0;
#[doc = " Number input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NUMBER: ArkUI_TextInputType = 2;
#[doc = " Phone number input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_PHONE_NUMBER: ArkUI_TextInputType = 3;
#[doc = " Email address input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_EMAIL: ArkUI_TextInputType = 5;
#[doc = " Password input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_PASSWORD: ArkUI_TextInputType = 7;
#[doc = " Numeric password input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NUMBER_PASSWORD: ArkUI_TextInputType = 8;
#[doc = " Lock screen password input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_SCREEN_LOCK_PASSWORD: ArkUI_TextInputType = 9;
#[doc = " Username input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_USER_NAME: ArkUI_TextInputType = 10;
#[doc = " New password input mode."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NEW_PASSWORD: ArkUI_TextInputType = 11;
#[doc = " Number input mode with a decimal point."]
pub const ArkUI_TextInputType_ARKUI_TEXTINPUT_TYPE_NUMBER_DECIMAL: ArkUI_TextInputType = 12;
#[doc = " @brief Enumerates the text input types.\n\n @since 12"]
pub type ArkUI_TextInputType = ::std::os::raw::c_uint;
#[doc = " Normal input mode."]
pub const ArkUI_TextAreaType_ARKUI_TEXTAREA_TYPE_NORMAL: ArkUI_TextAreaType = 0;
#[doc = " Number input mode."]
pub const ArkUI_TextAreaType_ARKUI_TEXTAREA_TYPE_NUMBER: ArkUI_TextAreaType = 2;
#[doc = " Phone number input mode."]
pub const ArkUI_TextAreaType_ARKUI_TEXTAREA_TYPE_PHONE_NUMBER: ArkUI_TextAreaType = 3;
#[doc = " Email address input mode."]
pub const ArkUI_TextAreaType_ARKUI_TEXTAREA_TYPE_EMAIL: ArkUI_TextAreaType = 5;
#[doc = " @brief Enumerates the text box types.\n\n @since 12"]
pub type ArkUI_TextAreaType = ::std::os::raw::c_uint;
#[doc = " The Cancel button is always displayed."]
pub const ArkUI_CancelButtonStyle_ARKUI_CANCELBUTTON_STYLE_CONSTANT: ArkUI_CancelButtonStyle = 0;
#[doc = " The Cancel button is always hidden."]
pub const ArkUI_CancelButtonStyle_ARKUI_CANCELBUTTON_STYLE_INVISIBLE: ArkUI_CancelButtonStyle = 1;
#[doc = " The Cancel button is displayed when there is text input."]
pub const ArkUI_CancelButtonStyle_ARKUI_CANCELBUTTON_STYLE_INPUT: ArkUI_CancelButtonStyle = 2;
#[doc = " @brief Enumerates the styles of the Cancel button.\n\n @since 12"]
pub type ArkUI_CancelButtonStyle = ::std::os::raw::c_uint;
#[doc = " The custom content of EGL/OpenGL ES and media data is displayed individually on the screen."]
pub const ArkUI_XComponentType_ARKUI_XCOMPONENT_TYPE_SURFACE: ArkUI_XComponentType = 0;
#[doc = " The custom content of EGL/OpenGL ES and media data is grouped and displayed together with content\n of the component."]
pub const ArkUI_XComponentType_ARKUI_XCOMPONENT_TYPE_TEXTURE: ArkUI_XComponentType = 2;
#[doc = " @brief Enumerates the types of the <b><XComponent></b> component.\n\n @since 12"]
pub type ArkUI_XComponentType = ::std::os::raw::c_uint;
#[doc = " Linear style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_LINEAR: ArkUI_ProgressType = 0;
#[doc = " Indeterminate ring style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_RING: ArkUI_ProgressType = 1;
#[doc = " Eclipse style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_ECLIPSE: ArkUI_ProgressType = 2;
#[doc = " Determinate ring style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_SCALE_RING: ArkUI_ProgressType = 3;
#[doc = " Capsule style."]
pub const ArkUI_ProgressType_ARKUI_PROGRESS_TYPE_CAPSULE: ArkUI_ProgressType = 4;
#[doc = " @brief Enumerates the styles of the progress indicator.\n\n @since 12"]
pub type ArkUI_ProgressType = ::std::os::raw::c_uint;
#[doc = " No text decoration."]
pub const ArkUI_TextDecorationType_ARKUI_TEXT_DECORATION_TYPE_NONE: ArkUI_TextDecorationType = 0;
#[doc = " Line under the text."]
pub const ArkUI_TextDecorationType_ARKUI_TEXT_DECORATION_TYPE_UNDERLINE: ArkUI_TextDecorationType =
    1;
#[doc = " Line over the text."]
pub const ArkUI_TextDecorationType_ARKUI_TEXT_DECORATION_TYPE_OVERLINE: ArkUI_TextDecorationType =
    2;
#[doc = " Line through the text."]
pub const ArkUI_TextDecorationType_ARKUI_TEXT_DECORATION_TYPE_LINE_THROUGH:
    ArkUI_TextDecorationType = 3;
#[doc = " @brief Enumerates the text decoration types.\n\n @since 12"]
pub type ArkUI_TextDecorationType = ::std::os::raw::c_uint;
#[doc = " Single solid line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_SOLID: ArkUI_TextDecorationStyle =
    0;
#[doc = " Double solid line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_DOUBLE: ArkUI_TextDecorationStyle =
    1;
#[doc = " Dotted line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_DOTTED: ArkUI_TextDecorationStyle =
    2;
#[doc = " Dashed line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_DASHED: ArkUI_TextDecorationStyle =
    3;
#[doc = " Wavy line."]
pub const ArkUI_TextDecorationStyle_ARKUI_TEXT_DECORATION_STYLE_WAVY: ArkUI_TextDecorationStyle = 4;
#[doc = " @brief Enumerates the text decoration styles.\n\n @since 12"]
pub type ArkUI_TextDecorationStyle = ::std::os::raw::c_uint;
#[doc = " The original case of the text is retained."]
pub const ArkUI_TextCase_ARKUI_TEXT_CASE_NORMAL: ArkUI_TextCase = 0;
#[doc = " All letters in the text are in lowercase."]
pub const ArkUI_TextCase_ARKUI_TEXT_CASE_LOWER: ArkUI_TextCase = 1;
#[doc = " All letters in the text are in uppercase."]
pub const ArkUI_TextCase_ARKUI_TEXT_CASE_UPPER: ArkUI_TextCase = 2;
#[doc = " @brief Enumerates the text cases.\n\n @since 12"]
pub type ArkUI_TextCase = ::std::os::raw::c_uint;
#[doc = " Copy is not allowed."]
pub const ArkUI_CopyOptions_ARKUI_COPY_OPTIONS_NONE: ArkUI_CopyOptions = 0;
#[doc = " Intra-application copy is allowed."]
pub const ArkUI_CopyOptions_ARKUI_COPY_OPTIONS_IN_APP: ArkUI_CopyOptions = 1;
#[doc = " Intra-device copy is allowed."]
pub const ArkUI_CopyOptions_ARKUI_COPY_OPTIONS_LOCAL_DEVICE: ArkUI_CopyOptions = 2;
#[doc = " Cross-device copy is allowed."]
pub const ArkUI_CopyOptions_ARKUI_COPY_OPTIONS_CROSS_DEVICE: ArkUI_CopyOptions = 3;
#[doc = " @brief Enumerates the text copy and paste modes.\n\n @since 12"]
pub type ArkUI_CopyOptions = ::std::os::raw::c_uint;
#[doc = " Color."]
pub const ArkUI_ShadowType_ARKUI_SHADOW_TYPE_COLOR: ArkUI_ShadowType = 0;
#[doc = " Blur."]
pub const ArkUI_ShadowType_ARKUI_SHADOW_TYPE_BLUR: ArkUI_ShadowType = 1;
#[doc = " @brief Enumerates the shadow types.\n\n @since 12"]
pub type ArkUI_ShadowType = ::std::os::raw::c_uint;
#[doc = " Single-column text picker."]
pub const ArkUI_TextPickerRangeType_ARKUI_TEXTPICKER_RANGETYPE_SINGLE: ArkUI_TextPickerRangeType =
    0;
#[doc = " Multi-column text picker."]
pub const ArkUI_TextPickerRangeType_ARKUI_TEXTPICKER_RANGETYPE_MULTI: ArkUI_TextPickerRangeType = 1;
#[doc = " Single-column text picker with image resources."]
pub const ArkUI_TextPickerRangeType_ARKUI_TEXTPICKER_RANGETYPE_RANGE_CONTENT:
    ArkUI_TextPickerRangeType = 2;
#[doc = " Interconnected multi-column text picker."]
pub const ArkUI_TextPickerRangeType_ARKUI_TEXTPICKER_RANGETYPE_CASCADE_RANGE_CONTENT:
    ArkUI_TextPickerRangeType = 3;
#[doc = " @brief Enumerates the types of the text picker.\n\n @since 12"]
pub type ArkUI_TextPickerRangeType = ::std::os::raw::c_uint;
#[doc = " @brief Defines the input structure of the single-column text picker with image resources.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARKUI_TextPickerRangeContent {
    #[doc = " Image resource."]
    pub icon: *const ::std::os::raw::c_char,
    #[doc = " Text information."]
    pub text: *const ::std::os::raw::c_char,
}
#[doc = " @brief Defines the input structure of the interconnected multi-column text picker.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARKUI_TextPickerCascadeRangeContent {
    #[doc = " Text information."]
    pub text: *const ::std::os::raw::c_char,
    #[doc = " Interconnected data."]
    pub children: *const ARKUI_TextPickerRangeContent,
    #[doc = " Size of the interconnected data array."]
    pub size: i32,
}
#[doc = " Spring effect. When at one of the edges, the component can move beyond the bounds based on the initial\n  speed or through touches, and produces a bounce effect when the user releases their finger."]
pub const ArkUI_EdgeEffect_ARKUI_EDGE_EFFECT_SPRING: ArkUI_EdgeEffect = 0;
#[doc = " Fade effect. When at one of the edges, the component produces a fade effect."]
pub const ArkUI_EdgeEffect_ARKUI_EDGE_EFFECT_FADE: ArkUI_EdgeEffect = 1;
#[doc = " No effect after the scrollbar is moved to the edge."]
pub const ArkUI_EdgeEffect_ARKUI_EDGE_EFFECT_NONE: ArkUI_EdgeEffect = 2;
#[doc = " @brief Enumerates the effects used at the edges of the component when the boundary of the scrollable content is\n reached.\n\n @since 12"]
pub type ArkUI_EdgeEffect = ::std::os::raw::c_uint;
#[doc = " Only vertical scrolling is supported."]
pub const ArkUI_ScrollDirection_ARKUI_SCROLL_DIRECTION_VERTICAL: ArkUI_ScrollDirection = 0;
#[doc = " Only horizontal scrolling is supported."]
pub const ArkUI_ScrollDirection_ARKUI_SCROLL_DIRECTION_HORIZONTAL: ArkUI_ScrollDirection = 1;
#[doc = " Scrolling is not allowed."]
pub const ArkUI_ScrollDirection_ARKUI_SCROLL_DIRECTION_NONE: ArkUI_ScrollDirection = 3;
#[doc = " @brief Enumerates the scroll directions for the <b><Scroll></b> component.\n\n @since 12"]
pub type ArkUI_ScrollDirection = ::std::os::raw::c_uint;
#[doc = " No alignment. This is the default value."]
pub const ArkUI_ScrollSnapAlign_ARKUI_SCROLL_SNAP_ALIGN_NONE: ArkUI_ScrollSnapAlign = 0;
#[doc = " The first item in the view is aligned at the start of the list."]
pub const ArkUI_ScrollSnapAlign_ARKUI_SCROLL_SNAP_ALIGN_START: ArkUI_ScrollSnapAlign = 1;
#[doc = " The middle items in the view are aligned in the center of the list."]
pub const ArkUI_ScrollSnapAlign_ARKUI_SCROLL_SNAP_ALIGN_CENTER: ArkUI_ScrollSnapAlign = 2;
#[doc = " The last item in the view is aligned at the end of the list."]
pub const ArkUI_ScrollSnapAlign_ARKUI_SCROLL_SNAP_ALIGN_END: ArkUI_ScrollSnapAlign = 3;
#[doc = " @brief Enumerates the alignment modes of list items when scrolling ends.\n\n @since 12"]
pub type ArkUI_ScrollSnapAlign = ::std::os::raw::c_uint;
#[doc = " Hide."]
pub const ArkUI_ScrollBarDisplayMode_ARKUI_SCROLL_BAR_DISPLAY_MODE_OFF: ArkUI_ScrollBarDisplayMode =
    0;
#[doc = " Display on demand (displays when the screen is touched and disappears after 2s)."]
pub const ArkUI_ScrollBarDisplayMode_ARKUI_SCROLL_BAR_DISPLAY_MODE_AUTO:
    ArkUI_ScrollBarDisplayMode = 1;
#[doc = " Always display."]
pub const ArkUI_ScrollBarDisplayMode_ARKUI_SCROLL_BAR_DISPLAY_MODE_ON: ArkUI_ScrollBarDisplayMode =
    2;
#[doc = " @brief Enumerates the scrollbar display modes.\n\n @since 12"]
pub type ArkUI_ScrollBarDisplayMode = ::std::os::raw::c_uint;
#[doc = " Only vertical scrolling is supported."]
pub const ArkUI_Axis_ARKUI_AXIS_VERTICAL: ArkUI_Axis = 0;
#[doc = " Only horizontal scrolling is supported."]
pub const ArkUI_Axis_ARKUI_AXIS_HORIZONTAL: ArkUI_Axis = 1;
#[doc = " @brief Enumerates the scroll directions for the <b><List></b> component.\n\n @since 12"]
pub type ArkUI_Axis = ::std::os::raw::c_uint;
#[doc = " In the list item group, the header is not pinned to the top, and the footer is not pinned to the bottom."]
pub const ArkUI_StickyStyle_ARKUI_STICKY_STYLE_NONE: ArkUI_StickyStyle = 0;
#[doc = " In the list item group, the header is pinned to the top, and the footer is not pinned to the bottom."]
pub const ArkUI_StickyStyle_ARKUI_STICKY_STYLE_HEADER: ArkUI_StickyStyle = 1;
#[doc = " In the list item group, the footer is pinned to the bottom, and the header is not pinned to the top."]
pub const ArkUI_StickyStyle_ARKUI_STICKY_STYLE_FOOTER: ArkUI_StickyStyle = 2;
#[doc = " In the list item group, the footer is pinned to the bottom, and the header is pinned to the top."]
pub const ArkUI_StickyStyle_ARKUI_STICKY_STYLE_BOTH: ArkUI_StickyStyle = 3;
#[doc = " @brief Enumerates the modes for pinning the header to the top or the footer to the bottom.\n\n @since 12"]
pub type ArkUI_StickyStyle = ::std::os::raw::c_uint;
#[doc = " Solid border."]
pub const ArkUI_BorderStyle_ARKUI_BORDER_STYLE_SOLID: ArkUI_BorderStyle = 0;
#[doc = " Dashed border."]
pub const ArkUI_BorderStyle_ARKUI_BORDER_STYLE_DASHED: ArkUI_BorderStyle = 1;
#[doc = " Dotted border."]
pub const ArkUI_BorderStyle_ARKUI_BORDER_STYLE_DOTTED: ArkUI_BorderStyle = 2;
#[doc = " @brief Enumerates the border styles.\n\n @since 12"]
pub type ArkUI_BorderStyle = ::std::os::raw::c_uint;
#[doc = " Both the node and its child node respond to the hit test of a touch event, but its sibling node is blocked from\n  the hit test."]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_DEFAULT: ArkUI_HitTestMode = 0;
#[doc = " The node responds to the hit test of a touch event, but its child node and sibling node are blocked from the\n  hit test."]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_BLOCK: ArkUI_HitTestMode = 1;
#[doc = " Both the node and its child node respond to the hit test of a touch event, and its sibling node is also\n considered during the hit test."]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_TRANSPARENT: ArkUI_HitTestMode = 2;
#[doc = " The node does not respond to the hit test of a touch event."]
pub const ArkUI_HitTestMode_ARKUI_HIT_TEST_MODE_NONE: ArkUI_HitTestMode = 3;
#[doc = " @brief Enumerates the hit test modes.\n\n @since 12"]
pub type ArkUI_HitTestMode = ::std::os::raw::c_uint;
#[doc = " Mini shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_DEFAULT_XS: ArkUI_ShadowStyle = 0;
#[doc = " Little shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_DEFAULT_SM: ArkUI_ShadowStyle = 1;
#[doc = " Medium shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_DEFAULT_MD: ArkUI_ShadowStyle = 2;
#[doc = " Large shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_DEFAULT_LG: ArkUI_ShadowStyle = 3;
#[doc = " Floating small shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_FLOATING_SM: ArkUI_ShadowStyle = 4;
#[doc = " Floating medium shadow."]
pub const ArkUI_ShadowStyle_ARKUI_SHADOW_STYLE_OUTER_FLOATING_MD: ArkUI_ShadowStyle = 5;
#[doc = " @brief Enumerates the shadow styles.\n\n @since 12"]
pub type ArkUI_ShadowStyle = ::std::os::raw::c_uint;
#[doc = " The animation speed keeps unchanged."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_LINEAR: ArkUI_AnimationCurve = 0;
#[doc = " The animation starts slowly, accelerates, and then slows down towards the end."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EASE: ArkUI_AnimationCurve = 1;
#[doc = " The animation starts at a low speed and then picks up speed until the end."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EASE_IN: ArkUI_AnimationCurve = 2;
#[doc = " The animation ends at a low speed."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EASE_OUT: ArkUI_AnimationCurve = 3;
#[doc = " The animation starts and ends at a low speed."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EASE_IN_OUT: ArkUI_AnimationCurve = 4;
#[doc = " The animation uses the standard curve"]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_FAST_OUT_SLOW_IN: ArkUI_AnimationCurve = 5;
#[doc = " The animation uses the deceleration curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_LINEAR_OUT_SLOW_IN: ArkUI_AnimationCurve = 6;
#[doc = " The animation uses the acceleration curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_FAST_OUT_LINEAR_IN: ArkUI_AnimationCurve = 7;
#[doc = " The animation uses the extreme deceleration curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_EXTREME_DECELERATION: ArkUI_AnimationCurve = 8;
#[doc = " The animation uses the sharp curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_SHARP: ArkUI_AnimationCurve = 9;
#[doc = " The animation uses the rhythm curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_RHYTHM: ArkUI_AnimationCurve = 10;
#[doc = " The animation uses the smooth curve."]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_SMOOTH: ArkUI_AnimationCurve = 11;
#[doc = " The animation uses the friction curve"]
pub const ArkUI_AnimationCurve_ARKUI_CURVE_FRICTION: ArkUI_AnimationCurve = 12;
#[doc = " @brief Enumerates the animation curves.\n\n @since 12"]
pub type ArkUI_AnimationCurve = ::std::os::raw::c_uint;
#[doc = " The arrow is not displayed for the navigation point indicator."]
pub const ArkUI_SwiperArrow_ARKUI_SWIPER_ARROW_HIDE: ArkUI_SwiperArrow = 0;
#[doc = " The arrow is displayed for the navigation point indicator."]
pub const ArkUI_SwiperArrow_ARKUI_SWIPER_ARROW_SHOW: ArkUI_SwiperArrow = 1;
#[doc = " The arrow is displayed only when the mouse pointer hovers over the navigation point indicator."]
pub const ArkUI_SwiperArrow_ARKUI_SWIPER_ARROW_SHOW_ON_HOVER: ArkUI_SwiperArrow = 2;
#[doc = " @brief Enumerates arrow styles of the navigation point indicator.\n\n @since 12"]
pub type ArkUI_SwiperArrow = ::std::os::raw::c_uint;
#[doc = " Swiper only scrolls on its own and is not linked to its parent component."]
pub const ArkUI_SwiperNestedScrollMode_ARKUI_SWIPER_NESTED_SRCOLL_SELF_ONLY:
    ArkUI_SwiperNestedScrollMode = 0;
#[doc = " The Swiper itself scrolls first, and the parent component scrolls after it reaches the edge. After the parent\n component scrolls to the edge, if the parent component has an edge effect, the parent component triggers the edge\n effect; otherwise, the Swiper triggers the edge effect."]
pub const ArkUI_SwiperNestedScrollMode_ARKUI_SWIPER_NESTED_SRCOLL_SELF_FIRST:
    ArkUI_SwiperNestedScrollMode = 1;
#[doc = " @brief Nested scrolling mode for Swiper components and parent components.\n\n @since 12"]
pub type ArkUI_SwiperNestedScrollMode = ::std::os::raw::c_uint;
#[doc = " When the mouse wheel is scrolled continuously, multiple pages are flipped, which is determined by the number of\n  times that mouse events are reported."]
pub const ArkUI_PageFlipMode_ARKUI_PAGE_FLIP_MODE_CONTINUOUS: ArkUI_PageFlipMode = 0;
#[doc = " The system does not respond to other mouse wheel events until the page flipping animation ends."]
pub const ArkUI_PageFlipMode_ARKUI_PAGE_FLIP_MODE_SINGLE: ArkUI_PageFlipMode = 1;
#[doc = " @brief Enumerates the page flipping modes using the mouse wheel for the <b>Swiper</b> component.\n\n @since 15"]
pub type ArkUI_PageFlipMode = ::std::os::raw::c_uint;
#[doc = " Jump to target index without animation."]
pub const ArkUI_SwiperAnimationMode_ARKUI_SWIPER_NO_ANIMATION: ArkUI_SwiperAnimationMode = 0;
#[doc = " Scroll to target index with animation."]
pub const ArkUI_SwiperAnimationMode_ARKUI_SWIPER_DEFAULT_ANIMATION: ArkUI_SwiperAnimationMode = 1;
#[doc = " Jump to some index near the target index without animation, then scroll to target index with animation."]
pub const ArkUI_SwiperAnimationMode_ARKUI_SWIPER_FAST_ANIMATION: ArkUI_SwiperAnimationMode = 2;
#[doc = " @brief Enumerates the animation modes for {@link NODE_SWIPER_INDEX}.\n\n @since 15"]
pub type ArkUI_SwiperAnimationMode = ::std::os::raw::c_uint;
#[doc = " Whether the component can be identified by the accessibility service is dependent on the component."]
pub const ArkUI_AccessibilityMode_ARKUI_ACCESSIBILITY_MODE_AUTO: ArkUI_AccessibilityMode = 0;
#[doc = " The component can be identified by the accessibility service."]
pub const ArkUI_AccessibilityMode_ARKUI_ACCESSIBILITY_MODE_ENABLED: ArkUI_AccessibilityMode = 1;
#[doc = " The component cannot be identified by the accessibility service."]
pub const ArkUI_AccessibilityMode_ARKUI_ACCESSIBILITY_MODE_DISABLED: ArkUI_AccessibilityMode = 2;
#[doc = " The component and all its child components cannot be identified by the accessibility service."]
pub const ArkUI_AccessibilityMode_ARKUI_ACCESSIBILITY_MODE_DISABLED_FOR_DESCENDANTS:
    ArkUI_AccessibilityMode = 3;
#[doc = " @brief Enumerates the accessibility modes.\n\n @since 12"]
pub type ArkUI_AccessibilityMode = ::std::os::raw::c_uint;
#[doc = " Copy is not allowed."]
pub const ArkUI_TextCopyOptions_ARKUI_TEXT_COPY_OPTIONS_NONE: ArkUI_TextCopyOptions = 0;
#[doc = " Intra-application copy is allowed."]
pub const ArkUI_TextCopyOptions_ARKUI_TEXT_COPY_OPTIONS_IN_APP: ArkUI_TextCopyOptions = 1;
#[doc = " Intra-device copy is allowed."]
pub const ArkUI_TextCopyOptions_ARKUI_TEXT_COPY_OPTIONS_LOCAL_DEVICE: ArkUI_TextCopyOptions = 2;
#[doc = " Cross-device copy is allowed."]
pub const ArkUI_TextCopyOptions_ARKUI_TEXT_COPY_OPTIONS_CROSS_DEVICE: ArkUI_TextCopyOptions = 3;
#[doc = " @brief Defines whether copy and paste is allowed for text content.\n\n @since 12"]
pub type ArkUI_TextCopyOptions = ::std::os::raw::c_uint;
#[doc = " Prioritize the <b>maxLines</b> settings."]
pub const ArkUI_TextHeightAdaptivePolicy_ARKUI_TEXT_HEIGHT_ADAPTIVE_POLICY_MAX_LINES_FIRST:
    ArkUI_TextHeightAdaptivePolicy = 0;
#[doc = " Prioritize the <b>minFontSize</b> settings."]
pub const ArkUI_TextHeightAdaptivePolicy_ARKUI_TEXT_HEIGHT_ADAPTIVE_POLICY_MIN_FONT_SIZE_FIRST:
    ArkUI_TextHeightAdaptivePolicy = 1;
#[doc = " Prioritize the layout constraint settings in terms of height."]
pub const ArkUI_TextHeightAdaptivePolicy_ARKUI_TEXT_HEIGHT_ADAPTIVE_POLICY_LAYOUT_CONSTRAINT_FIRST : ArkUI_TextHeightAdaptivePolicy = 2 ;
#[doc = " @brief Defines how the adaptive height is determined for the text.\n\n @since 12"]
pub type ArkUI_TextHeightAdaptivePolicy = ::std::os::raw::c_uint;
#[doc = " The scrolling is contained within the component, and no scroll chaining occurs, that is, the parent component\n does not scroll when the component scrolling reaches the boundary."]
pub const ArkUI_ScrollNestedMode_ARKUI_SCROLL_NESTED_MODE_SELF_ONLY: ArkUI_ScrollNestedMode = 0;
#[doc = " The component scrolls first, and when it hits the boundary, the parent component scrolls.\n  When the parent component hits the boundary, its edge effect is displayed. If no edge\n  effect is specified for the parent component, the edge effect of the child component is displayed instead."]
pub const ArkUI_ScrollNestedMode_ARKUI_SCROLL_NESTED_MODE_SELF_FIRST: ArkUI_ScrollNestedMode = 1;
#[doc = " The parent component scrolls first, and when it hits the boundary, the component scrolls.\n  When the component hits the boundary, its edge effect is displayed. If no edge effect is specified for the\n  component, the edge effect of the parent component is displayed instead."]
pub const ArkUI_ScrollNestedMode_ARKUI_SCROLL_NESTED_MODE_PARENT_FIRST: ArkUI_ScrollNestedMode = 2;
#[doc = " The component and its parent component scroll at the same time. When both the component and its parent component\n  hit the boundary, the edge effect of the component is displayed. If no edge effect is specified for the\n  component, the edge effect of the parent component is displayed instead."]
pub const ArkUI_ScrollNestedMode_ARKUI_SCROLL_NESTED_MODE_PARALLEL: ArkUI_ScrollNestedMode = 3;
#[doc = " @brief Defines nested scrolling options.\n\n @since 12"]
pub type ArkUI_ScrollNestedMode = ::std::os::raw::c_uint;
#[doc = " Top edge in the vertical direction."]
pub const ArkUI_ScrollEdge_ARKUI_SCROLL_EDGE_TOP: ArkUI_ScrollEdge = 0;
#[doc = " Bottom edge in the vertical direction."]
pub const ArkUI_ScrollEdge_ARKUI_SCROLL_EDGE_BOTTOM: ArkUI_ScrollEdge = 1;
#[doc = " Start position in the horizontal direction."]
pub const ArkUI_ScrollEdge_ARKUI_SCROLL_EDGE_START: ArkUI_ScrollEdge = 2;
#[doc = " End position in the horizontal direction."]
pub const ArkUI_ScrollEdge_ARKUI_SCROLL_EDGE_END: ArkUI_ScrollEdge = 3;
#[doc = " @brief Defines the edge to which the component scrolls.\n\n @since 12"]
pub type ArkUI_ScrollEdge = ::std::os::raw::c_uint;
#[doc = " Align the head. Align the head of the specified item with the head of the container."]
pub const ArkUI_ScrollAlignment_ARKUI_SCROLL_ALIGNMENT_START: ArkUI_ScrollAlignment = 0;
#[doc = " Center alignment. Align the axis direction of the specified item to the center of the container."]
pub const ArkUI_ScrollAlignment_ARKUI_SCROLL_ALIGNMENT_CENTER: ArkUI_ScrollAlignment = 1;
#[doc = " Tail alignment. Align the tail of the specified item with the tail of the container."]
pub const ArkUI_ScrollAlignment_ARKUI_SCROLL_ALIGNMENT_END: ArkUI_ScrollAlignment = 2;
#[doc = " Automatic alignment. If the specified item is completely in the display area, no adjustments will be made.\n Otherwise, according to the principle of the shortest sliding distance, align the head or tail of the specified\n item with the container, so that the specified item is completely in the display area."]
pub const ArkUI_ScrollAlignment_ARKUI_SCROLL_ALIGNMENT_AUTO: ArkUI_ScrollAlignment = 3;
#[doc = " @brief Alignment when scrolling to specific items.\n\n @since 12"]
pub type ArkUI_ScrollAlignment = ::std::os::raw::c_uint;
#[doc = " Idle state. Trigger when using the method provided by the controller to control scrolling, and trigger when\n dragging the scroll bar to scroll."]
pub const ArkUI_ScrollState_ARKUI_SCROLL_STATE_IDLE: ArkUI_ScrollState = 0;
#[doc = " Scroll state. Triggered when dragging the container with fingers to scroll."]
pub const ArkUI_ScrollState_ARKUI_SCROLL_STATE_SCROLL: ArkUI_ScrollState = 1;
#[doc = " Inertial rolling state. Triggered when inertia rolling and bouncing back to the edge are performed after\n releasing the hand quickly."]
pub const ArkUI_ScrollState_ARKUI_SCROLL_STATE_FLING: ArkUI_ScrollState = 2;
#[doc = " @brief Define the current scrolling state.\n\n @since 12"]
pub type ArkUI_ScrollState = ::std::os::raw::c_uint;
#[doc = " Round slider."]
pub const ArkUI_SliderBlockStyle_ARKUI_SLIDER_BLOCK_STYLE_DEFAULT: ArkUI_SliderBlockStyle = 0;
#[doc = " Slider with an image background."]
pub const ArkUI_SliderBlockStyle_ARKUI_SLIDER_BLOCK_STYLE_IMAGE: ArkUI_SliderBlockStyle = 1;
#[doc = " Slider in a custom shape."]
pub const ArkUI_SliderBlockStyle_ARKUI_SLIDER_BLOCK_STYLE_SHAPE: ArkUI_SliderBlockStyle = 2;
#[doc = " @brief Enumerates the types of the slider in the block direction.\n\n @since 12"]
pub type ArkUI_SliderBlockStyle = ::std::os::raw::c_uint;
#[doc = " Vertical direction."]
pub const ArkUI_SliderDirection_ARKUI_SLIDER_DIRECTION_VERTICAL: ArkUI_SliderDirection = 0;
#[doc = " Horizontal direction."]
pub const ArkUI_SliderDirection_ARKUI_SLIDER_DIRECTION_HORIZONTAL: ArkUI_SliderDirection = 1;
#[doc = " @brief Enumerates the scroll directions of the slider.\n\n @since 12"]
pub type ArkUI_SliderDirection = ::std::os::raw::c_uint;
#[doc = " The slider is on the slider track."]
pub const ArkUI_SliderStyle_ARKUI_SLIDER_STYLE_OUT_SET: ArkUI_SliderStyle = 0;
#[doc = " The slider is in the slider track."]
pub const ArkUI_SliderStyle_ARKUI_SLIDER_STYLE_IN_SET: ArkUI_SliderStyle = 1;
#[doc = " No slider."]
pub const ArkUI_SliderStyle_ARKUI_SLIDER_STYLE_NONE: ArkUI_SliderStyle = 2;
#[doc = " @brief Enumerates the slider styles.\n\n @since 12"]
pub type ArkUI_SliderStyle = ::std::os::raw::c_uint;
#[doc = " Circle."]
pub const ArkUI_CheckboxShape_ArkUI_CHECKBOX_SHAPE_CIRCLE: ArkUI_CheckboxShape = 0;
#[doc = " Rounded square."]
pub const ArkUI_CheckboxShape_ArkUI_CHECKBOX_SHAPE_ROUNDED_SQUARE: ArkUI_CheckboxShape = 1;
#[doc = " @brief Enumerates the shapes of the check box\n\n @since 12"]
pub type ArkUI_CheckboxShape = ::std::os::raw::c_uint;
#[doc = " The animation is played forwards."]
pub const ArkUI_AnimationPlayMode_ARKUI_ANIMATION_PLAY_MODE_NORMAL: ArkUI_AnimationPlayMode = 0;
#[doc = " The animation is played reversely."]
pub const ArkUI_AnimationPlayMode_ARKUI_ANIMATION_PLAY_MODE_REVERSE: ArkUI_AnimationPlayMode = 1;
#[doc = " The animation is played normally for an odd number of times (1, 3, 5...) and reversely for an even number\n  of times (2, 4, 6...)."]
pub const ArkUI_AnimationPlayMode_ARKUI_ANIMATION_PLAY_MODE_ALTERNATE: ArkUI_AnimationPlayMode = 2;
#[doc = " The animation is played reversely for an odd number of times (1, 3, 5...) and normally for an even number\n  of times (2, 4, 6...)."]
pub const ArkUI_AnimationPlayMode_ARKUI_ANIMATION_PLAY_MODE_ALTERNATE_REVERSE:
    ArkUI_AnimationPlayMode = 3;
#[doc = " @brief Enumerates the animation playback modes.\n\n @since 12"]
pub type ArkUI_AnimationPlayMode = ::std::os::raw::c_uint;
#[doc = " The original image aspect ratio is retained."]
pub const ArkUI_ImageSize_ARKUI_IMAGE_SIZE_AUTO: ArkUI_ImageSize = 0;
#[doc = " Default value. The image is scaled with its aspect ratio retained for both sides to be greater than or equal\n  to the display boundaries."]
pub const ArkUI_ImageSize_ARKUI_IMAGE_SIZE_COVER: ArkUI_ImageSize = 1;
#[doc = " The image is scaled with its aspect ratio retained for the content to be completely displayed within the display\n  boundaries."]
pub const ArkUI_ImageSize_ARKUI_IMAGE_SIZE_CONTAIN: ArkUI_ImageSize = 2;
#[doc = " @brief Defines the image size.\n\n @since 12"]
pub type ArkUI_ImageSize = ::std::os::raw::c_uint;
#[doc = " Adaptive color mode is not used."]
pub const ArkUI_AdaptiveColor_ARKUI_ADAPTIVE_COLOR_DEFAULT: ArkUI_AdaptiveColor = 0;
#[doc = " Adaptive color mode is used."]
pub const ArkUI_AdaptiveColor_ARKUI_ADAPTIVE_COLOR_AVERAGE: ArkUI_AdaptiveColor = 1;
#[doc = " @brief Enumerates the adaptive color modes.\n\n @since 12"]
pub type ArkUI_AdaptiveColor = ::std::os::raw::c_uint;
#[doc = " Following the system color mode."]
pub const ArkUI_ColorMode_ARKUI_COLOR_MODE_SYSTEM: ArkUI_ColorMode = 0;
#[doc = " Light color mode."]
pub const ArkUI_ColorMode_ARKUI_COLOR_MODE_LIGHT: ArkUI_ColorMode = 1;
#[doc = " Dark color mode."]
pub const ArkUI_ColorMode_ARKUI_COLOR_MODE_DARK: ArkUI_ColorMode = 2;
#[doc = " @brief Enumerates the color modes.\n\n @since 12"]
pub type ArkUI_ColorMode = ::std::os::raw::c_uint;
#[doc = " Light color mode."]
pub const ArkUI_SystemColorMode_ARKUI_SYSTEM_COLOR_MODE_LIGHT: ArkUI_SystemColorMode = 0;
#[doc = " Dark color mode."]
pub const ArkUI_SystemColorMode_ARKUI_SYSTEM_COLOR_MODE_DARK: ArkUI_SystemColorMode = 1;
#[doc = " @brief Enumerates the system color modes.\n\n @since 12"]
pub type ArkUI_SystemColorMode = ::std::os::raw::c_uint;
#[doc = " Thin material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_THIN: ArkUI_BlurStyle = 0;
#[doc = " Regular material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_REGULAR: ArkUI_BlurStyle = 1;
#[doc = " Thick material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_THICK: ArkUI_BlurStyle = 2;
#[doc = " Material that creates the minimum depth of field effect."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_BACKGROUND_THIN: ArkUI_BlurStyle = 3;
#[doc = " Material that creates a medium shallow depth of field effect."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_BACKGROUND_REGULAR: ArkUI_BlurStyle = 4;
#[doc = " Material that creates a high shallow depth of field effect."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_BACKGROUND_THICK: ArkUI_BlurStyle = 5;
#[doc = " Material that creates the maximum depth of field effect."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_BACKGROUND_ULTRA_THICK: ArkUI_BlurStyle = 6;
#[doc = " No blur."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_NONE: ArkUI_BlurStyle = 7;
#[doc = " Component ultra-thin material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_ULTRA_THIN: ArkUI_BlurStyle = 8;
#[doc = " Component thin material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_THIN: ArkUI_BlurStyle = 9;
#[doc = " Component regular material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_REGULAR: ArkUI_BlurStyle = 10;
#[doc = " Component thick material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_THICK: ArkUI_BlurStyle = 11;
#[doc = " Component ultra-thick material."]
pub const ArkUI_BlurStyle_ARKUI_BLUR_STYLE_COMPONENT_ULTRA_THICK: ArkUI_BlurStyle = 12;
#[doc = " @brief Enumerates the blur styles.\n\n @since 12"]
pub type ArkUI_BlurStyle = ::std::os::raw::c_uint;
#[doc = " Top aligned."]
pub const ArkUI_VerticalAlignment_ARKUI_VERTICAL_ALIGNMENT_TOP: ArkUI_VerticalAlignment = 0;
#[doc = " Center aligned. This is the default alignment mode."]
pub const ArkUI_VerticalAlignment_ARKUI_VERTICAL_ALIGNMENT_CENTER: ArkUI_VerticalAlignment = 1;
#[doc = " Bottom aligned."]
pub const ArkUI_VerticalAlignment_ARKUI_VERTICAL_ALIGNMENT_BOTTOM: ArkUI_VerticalAlignment = 2;
#[doc = " @brief Enumerates the vertical alignment modes.\n\n @since 12"]
pub type ArkUI_VerticalAlignment = ::std::os::raw::c_uint;
#[doc = " Aligned with the start edge in the same direction as the language in use."]
pub const ArkUI_HorizontalAlignment_ARKUI_HORIZONTAL_ALIGNMENT_START: ArkUI_HorizontalAlignment = 0;
#[doc = " Center aligned. This is the default alignment mode."]
pub const ArkUI_HorizontalAlignment_ARKUI_HORIZONTAL_ALIGNMENT_CENTER: ArkUI_HorizontalAlignment =
    1;
#[doc = " Aligned with the end edge in the same direction as the language in use."]
pub const ArkUI_HorizontalAlignment_ARKUI_HORIZONTAL_ALIGNMENT_END: ArkUI_HorizontalAlignment = 2;
#[doc = " @brief Enumerates the alignment mode in the horizontal direction.\n\n @since 12"]
pub type ArkUI_HorizontalAlignment = ::std::os::raw::c_uint;
#[doc = " Extra-long text is not clipped."]
pub const ArkUI_TextOverflow_ARKUI_TEXT_OVERFLOW_NONE: ArkUI_TextOverflow = 0;
#[doc = " Extra-long text is clipped."]
pub const ArkUI_TextOverflow_ARKUI_TEXT_OVERFLOW_CLIP: ArkUI_TextOverflow = 1;
#[doc = " An ellipsis (...) is used to represent text overflow."]
pub const ArkUI_TextOverflow_ARKUI_TEXT_OVERFLOW_ELLIPSIS: ArkUI_TextOverflow = 2;
#[doc = " Text continuously scrolls when text overflow occurs."]
pub const ArkUI_TextOverflow_ARKUI_TEXT_OVERFLOW_MARQUEE: ArkUI_TextOverflow = 3;
#[doc = " @brief Enumerates the display modes when the text is too long.\n\n @since 12"]
pub type ArkUI_TextOverflow = ::std::os::raw::c_uint;
#[doc = " The image is bottom aligned with the text baseline."]
pub const ArkUI_ImageSpanAlignment_ARKUI_IMAGE_SPAN_ALIGNMENT_BASELINE: ArkUI_ImageSpanAlignment =
    0;
#[doc = " The image is bottom aligned with the text."]
pub const ArkUI_ImageSpanAlignment_ARKUI_IMAGE_SPAN_ALIGNMENT_BOTTOM: ArkUI_ImageSpanAlignment = 1;
#[doc = " The image is centered aligned with the text."]
pub const ArkUI_ImageSpanAlignment_ARKUI_IMAGE_SPAN_ALIGNMENT_CENTER: ArkUI_ImageSpanAlignment = 2;
#[doc = " The image is top aligned with the text."]
pub const ArkUI_ImageSpanAlignment_ARKUI_IMAGE_SPAN_ALIGNMENT_TOP: ArkUI_ImageSpanAlignment = 3;
#[doc = " @brief Enumerates the alignment mode of the image with the text.\n\n @since 12"]
pub type ArkUI_ImageSpanAlignment = ::std::os::raw::c_uint;
#[doc = " The image is scaled with its aspect ratio retained for the content to be completely displayed within the\n  display boundaries."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_CONTAIN: ArkUI_ObjectFit = 0;
#[doc = " The image is scaled with its aspect ratio retained for both sides to be greater than or equal to the\n  display boundaries."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_COVER: ArkUI_ObjectFit = 1;
#[doc = " The image is scaled automatically to fit the display area."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_AUTO: ArkUI_ObjectFit = 2;
#[doc = " The image is scaled to fill the display area, and its aspect ratio is not retained."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_FILL: ArkUI_ObjectFit = 3;
#[doc = " The image content is displayed with its aspect ratio retained. The size is smaller than or equal to the\n  original size."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_SCALE_DOWN: ArkUI_ObjectFit = 4;
#[doc = " The original size is retained."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE: ArkUI_ObjectFit = 5;
#[doc = " Not resized, the image is aligned with the start edge of the top of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_TOP_START: ArkUI_ObjectFit = 6;
#[doc = " Not resized, the image is horizontally centered at the top of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_TOP: ArkUI_ObjectFit = 7;
#[doc = " Not resized, the image is aligned with the end edge at the top of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_TOP_END: ArkUI_ObjectFit = 8;
#[doc = " Not resized, the image is vertically centered on the start edge of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_START: ArkUI_ObjectFit = 9;
#[doc = " Not resized, the image is horizontally and vertically centered in the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_CENTER: ArkUI_ObjectFit = 10;
#[doc = " Not resized, the image is vertically centered on the end edge of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_END: ArkUI_ObjectFit = 11;
#[doc = " Not resized, the image is aligned with the start edge at the bottom of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_BOTTOM_START: ArkUI_ObjectFit = 12;
#[doc = " Not resized, the image is horizontally centered at the bottom of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_BOTTOM: ArkUI_ObjectFit = 13;
#[doc = " Not resized, the image is aligned with the end edge at the bottom of the container."]
pub const ArkUI_ObjectFit_ARKUI_OBJECT_FIT_NONE_AND_ALIGN_BOTTOM_END: ArkUI_ObjectFit = 14;
#[doc = " @brief Defines how the image is resized to fit its container.\nImageSpanAlignment\n @since 12"]
pub type ArkUI_ObjectFit = ::std::os::raw::c_uint;
#[doc = " No image interpolation."]
pub const ArkUI_ImageInterpolation_ARKUI_IMAGE_INTERPOLATION_NONE: ArkUI_ImageInterpolation = 0;
#[doc = " Low quality interpolation."]
pub const ArkUI_ImageInterpolation_ARKUI_IMAGE_INTERPOLATION_LOW: ArkUI_ImageInterpolation = 1;
#[doc = " Medium quality interpolation."]
pub const ArkUI_ImageInterpolation_ARKUI_IMAGE_INTERPOLATION_MEDIUM: ArkUI_ImageInterpolation = 2;
#[doc = " High quality interpolation. This mode produces scaled images of the highest possible quality."]
pub const ArkUI_ImageInterpolation_ARKUI_IMAGE_INTERPOLATION_HIGH: ArkUI_ImageInterpolation = 3;
#[doc = " @brief Enumerates the image interpolation effect.\n\n @since 12"]
pub type ArkUI_ImageInterpolation = ::std::os::raw::c_uint;
#[doc = " The top image is superimposed on the bottom image without any blending."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_NONE: ArkUI_BlendMode = 0;
#[doc = " The target pixels covered by the source pixels are erased by being turned to completely transparent."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_CLEAR: ArkUI_BlendMode = 1;
#[doc = " r = s: Only the source pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC: ArkUI_BlendMode = 2;
#[doc = " r = d: Only the target pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST: ArkUI_BlendMode = 3;
#[doc = " r = s + (1 - sa) * d: The source pixels are blended based on opacity and cover the target pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC_OVER: ArkUI_BlendMode = 4;
#[doc = " r = d + (1 - da) * s: The target pixels are blended based on opacity and cover on the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST_OVER: ArkUI_BlendMode = 5;
#[doc = " r = s * da: Only the part of the source pixels that overlap with the target pixels is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC_IN: ArkUI_BlendMode = 6;
#[doc = " r = d * sa: Only the part of the target pixels that overlap with the source pixels is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST_IN: ArkUI_BlendMode = 7;
#[doc = " r = s * (1 - da): Only the part of the source pixels that do not overlap with the target pixels is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC_OUT: ArkUI_BlendMode = 8;
#[doc = " r = d * (1 - sa): Only the part of the target pixels that do not overlap with the source pixels is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST_OUT: ArkUI_BlendMode = 9;
#[doc = " r = s * da + d * (1 - sa): The part of the source pixels that overlap with the target pixels is displayed and\n  the part of the target pixels that do not overlap with the source pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SRC_ATOP: ArkUI_BlendMode = 10;
#[doc = " r = d * sa + s * (1 - da): The part of the target pixels that overlap with the source pixels and the part of\n  the source pixels that do not overlap with the target pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DST_ATOP: ArkUI_BlendMode = 11;
#[doc = " r = s * (1 - da) + d * (1 - sa): Only the non-overlapping part between the source pixels and the target pixels\n is displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_XOR: ArkUI_BlendMode = 12;
#[doc = " r = min(s + d, 1): New pixels resulting from adding the source pixels to the target pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_PLUS: ArkUI_BlendMode = 13;
#[doc = " r = s * d: New pixels resulting from multiplying the source pixels with the target pixels are displayed."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_MODULATE: ArkUI_BlendMode = 14;
#[doc = " r = s + d - s * d: Pixels are blended by adding the source pixels to the target pixels and subtracting the\n  product of their multiplication."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SCREEN: ArkUI_BlendMode = 15;
#[doc = " The MULTIPLY or SCREEN mode is used based on the target pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_OVERLAY: ArkUI_BlendMode = 16;
#[doc = " rc = s + d - max(s * da, d * sa), ra = kSrcOver: When two colors overlap, whichever is darker is used."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DARKEN: ArkUI_BlendMode = 17;
#[doc = " rc = s + d - min(s * da, d * sa), ra =\nkSrcOver: The final pixels are composed of the lightest values of pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_LIGHTEN: ArkUI_BlendMode = 18;
#[doc = " The colors of the target pixels are lightened to reflect the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_COLOR_DODGE: ArkUI_BlendMode = 19;
#[doc = " The colors of the target pixels are darkened to reflect the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_COLOR_BURN: ArkUI_BlendMode = 20;
#[doc = " The MULTIPLY or SCREEN mode is used, depending on the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_HARD_LIGHT: ArkUI_BlendMode = 21;
#[doc = " The LIGHTEN or DARKEN mode is used, depending on the source pixels."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SOFT_LIGHT: ArkUI_BlendMode = 22;
#[doc = " rc = s + d - 2 * (min(s * da, d * sa)), ra =\nkSrcOver: The final pixel is the result of subtracting the darker of the two pixels (source and target) from\nthe lighter one."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_DIFFERENCE: ArkUI_BlendMode = 23;
#[doc = " rc = s + d - two(s * d), ra = kSrcOver: The final pixel is similar to <b>DIFFERENCE</b>, but with less contrast."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_EXCLUSION: ArkUI_BlendMode = 24;
#[doc = " r = s * (1 - da) + d * (1 - sa) + s * d: The final pixel is the result of multiplying the source pixel\n  by the target pixel."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_MULTIPLY: ArkUI_BlendMode = 25;
#[doc = " The resultant image is created with the luminance and saturation of the source image and the hue of the target\n  image."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_HUE: ArkUI_BlendMode = 26;
#[doc = " The resultant image is created with the luminance and hue of the target image and the saturation of the source\n  image."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_SATURATION: ArkUI_BlendMode = 27;
#[doc = " The resultant image is created with the saturation and hue of the source image and the luminance of the target\n  image."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_COLOR: ArkUI_BlendMode = 28;
#[doc = " The resultant image is created with the saturation and hue of the target image and the luminance of the source\n  image."]
pub const ArkUI_BlendMode_ARKUI_BLEND_MODE_LUMINOSITY: ArkUI_BlendMode = 29;
#[doc = " @brief Enumerates the blend modes.\n\n @since 12"]
pub type ArkUI_BlendMode = ::std::os::raw::c_uint;
#[doc = " Components are arranged from left to right."]
pub const ArkUI_Direction_ARKUI_DIRECTION_LTR: ArkUI_Direction = 0;
#[doc = " Components are arranged from right to left."]
pub const ArkUI_Direction_ARKUI_DIRECTION_RTL: ArkUI_Direction = 1;
#[doc = " The default layout direction is used."]
pub const ArkUI_Direction_ARKUI_DIRECTION_AUTO: ArkUI_Direction = 3;
#[doc = " @brief Enumerates the modes in which components are laid out along the main axis of the container.\n\n @since 12"]
pub type ArkUI_Direction = ::std::os::raw::c_uint;
#[doc = " The default configuration in the container is used."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_AUTO: ArkUI_ItemAlignment = 0;
#[doc = " The items in the container are aligned with the cross-start edge."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_START: ArkUI_ItemAlignment = 1;
#[doc = " The items in the container are centered along the cross axis."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_CENTER: ArkUI_ItemAlignment = 2;
#[doc = " The items in the container are aligned with the cross-end edge."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_END: ArkUI_ItemAlignment = 3;
#[doc = " The items in the container are stretched and padded along the cross axis."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_STRETCH: ArkUI_ItemAlignment = 4;
#[doc = " The items in the container are aligned in such a manner that their text baselines are aligned along the\n  cross axis."]
pub const ArkUI_ItemAlignment_ARKUI_ITEM_ALIGNMENT_BASELINE: ArkUI_ItemAlignment = 5;
#[doc = " @brief Enumerates the modes in which components are laid out along the cross axis of the container.\n\n @since 12"]
pub type ArkUI_ItemAlignment = ::std::os::raw::c_uint;
#[doc = " The foreground colors are the inverse of the component background colors."]
pub const ArkUI_ColorStrategy_ARKUI_COLOR_STRATEGY_INVERT: ArkUI_ColorStrategy = 0;
#[doc = " The shadow colors of the component are the average color obtained from the component background shadow area."]
pub const ArkUI_ColorStrategy_ARKUI_COLOR_STRATEGY_AVERAGE: ArkUI_ColorStrategy = 1;
#[doc = " The shadow colors of the component are the primary color obtained from the component background shadow area."]
pub const ArkUI_ColorStrategy_ARKUI_COLOR_STRATEGY_PRIMARY: ArkUI_ColorStrategy = 2;
#[doc = " @brief Enumerates the foreground colors.\n\n @since 12"]
pub type ArkUI_ColorStrategy = ::std::os::raw::c_uint;
#[doc = " The child components are aligned with the start edge of the main axis."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_START: ArkUI_FlexAlignment = 1;
#[doc = " The child components are aligned in the center of the main axis."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_CENTER: ArkUI_FlexAlignment = 2;
#[doc = " The child components are aligned with the end edge of the main axis."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_END: ArkUI_FlexAlignment = 3;
#[doc = " The child components are evenly distributed along the main axis. The space between any two adjacent components\n  is the same. The first component is aligned with the main-start, and the last component is aligned with\n  the main-end."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_SPACE_BETWEEN: ArkUI_FlexAlignment = 6;
#[doc = " The child components are evenly distributed along the main axis. The space between any two adjacent components\n  is the same. The space between the first component and main-start, and that between the last component and\n  cross-main are both half the size of the space between two adjacent components."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_SPACE_AROUND: ArkUI_FlexAlignment = 7;
#[doc = " The child components are evenly distributed along the main axis. The space between the first component\n  and main-start, the space between the last component and main-end, and the space between any two adjacent\n  components are the same."]
pub const ArkUI_FlexAlignment_ARKUI_FLEX_ALIGNMENT_SPACE_EVENLY: ArkUI_FlexAlignment = 8;
#[doc = " @brief Enumerates the vertical alignment modes.\n\n @since 12"]
pub type ArkUI_FlexAlignment = ::std::os::raw::c_uint;
#[doc = " The child components are arranged in the same direction as the main axis runs along the rows."]
pub const ArkUI_FlexDirection_ARKUI_FLEX_DIRECTION_ROW: ArkUI_FlexDirection = 0;
#[doc = " The child components are arranged in the same direction as the main axis runs down the columns."]
pub const ArkUI_FlexDirection_ARKUI_FLEX_DIRECTION_COLUMN: ArkUI_FlexDirection = 1;
#[doc = " The child components are arranged opposite to the <b>ROW</b> direction."]
pub const ArkUI_FlexDirection_ARKUI_FLEX_DIRECTION_ROW_REVERSE: ArkUI_FlexDirection = 2;
#[doc = " The child components are arranged opposite to the <b>COLUMN</b> direction."]
pub const ArkUI_FlexDirection_ARKUI_FLEX_DIRECTION_COLUMN_REVERSE: ArkUI_FlexDirection = 3;
#[doc = " @brief Enumerates the directions of the main axis in the flex container.\n\n @since 12"]
pub type ArkUI_FlexDirection = ::std::os::raw::c_uint;
#[doc = " The child components in the flex container are arranged in a single line, and they cannot overflow."]
pub const ArkUI_FlexWrap_ARKUI_FLEX_WRAP_NO_WRAP: ArkUI_FlexWrap = 0;
#[doc = " The child components in the flex container are arranged in multiple lines, and they may overflow."]
pub const ArkUI_FlexWrap_ARKUI_FLEX_WRAP_WRAP: ArkUI_FlexWrap = 1;
#[doc = " The child components in the flex container are reversely arranged in multiple lines, and they may overflow."]
pub const ArkUI_FlexWrap_ARKUI_FLEX_WRAP_WRAP_REVERSE: ArkUI_FlexWrap = 2;
#[doc = " @brief Defines whether the flex container has a single line or multiple lines.\n\n @since 12"]
pub type ArkUI_FlexWrap = ::std::os::raw::c_uint;
#[doc = " The component is visible."]
pub const ArkUI_Visibility_ARKUI_VISIBILITY_VISIBLE: ArkUI_Visibility = 0;
#[doc = " The component is hidden, and a placeholder is used for it in the layout."]
pub const ArkUI_Visibility_ARKUI_VISIBILITY_HIDDEN: ArkUI_Visibility = 1;
#[doc = " The component is hidden. It is not involved in the layout, and no placeholder is used for it."]
pub const ArkUI_Visibility_ARKUI_VISIBILITY_NONE: ArkUI_Visibility = 2;
#[doc = " @brief Enumerates the visibility values.\n\n @since 12"]
pub type ArkUI_Visibility = ::std::os::raw::c_uint;
#[doc = " Left aligned."]
pub const ArkUI_CalendarAlignment_ARKUI_CALENDAR_ALIGNMENT_START: ArkUI_CalendarAlignment = 0;
#[doc = " Center aligned."]
pub const ArkUI_CalendarAlignment_ARKUI_CALENDAR_ALIGNMENT_CENTER: ArkUI_CalendarAlignment = 1;
#[doc = " Right aligned."]
pub const ArkUI_CalendarAlignment_ARKUI_CALENDAR_ALIGNMENT_END: ArkUI_CalendarAlignment = 2;
#[doc = " @brief Enumerates the alignment modes between the calendar picker and the entry component.\n\n @since 12"]
pub type ArkUI_CalendarAlignment = ::std::os::raw::c_uint;
#[doc = " Rectangle."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_RECTANGLE: ArkUI_MaskType = 0;
#[doc = " Circle."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_CIRCLE: ArkUI_MaskType = 1;
#[doc = " Ellipse."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_ELLIPSE: ArkUI_MaskType = 2;
#[doc = " Path."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_PATH: ArkUI_MaskType = 3;
#[doc = " Progress indicator."]
pub const ArkUI_MaskType_ARKUI_MASK_TYPE_PROGRESS: ArkUI_MaskType = 4;
#[doc = " @brief Enumerates the mask types.\n\n @since 12"]
pub type ArkUI_MaskType = ::std::os::raw::c_uint;
#[doc = " Rectangle."]
pub const ArkUI_ClipType_ARKUI_CLIP_TYPE_RECTANGLE: ArkUI_ClipType = 0;
#[doc = " Circle."]
pub const ArkUI_ClipType_ARKUI_CLIP_TYPE_CIRCLE: ArkUI_ClipType = 1;
#[doc = " Ellipse."]
pub const ArkUI_ClipType_ARKUI_CLIP_TYPE_ELLIPSE: ArkUI_ClipType = 2;
#[doc = " Path."]
pub const ArkUI_ClipType_ARKUI_CLIP_TYPE_PATH: ArkUI_ClipType = 3;
#[doc = " @brief Enumerates the clipping region types.\n\n @since 12"]
pub type ArkUI_ClipType = ::std::os::raw::c_uint;
#[doc = " @brief Defines the gradient color stop structure.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ColorStop {
    #[doc = " Color array."]
    pub colors: *const u32,
    #[doc = " Position array."]
    pub stops: *mut f32,
    #[doc = " Length array."]
    pub size: ::std::os::raw::c_int,
}
#[doc = " Rectangle."]
pub const ArkUI_ShapeType_ARKUI_SHAPE_TYPE_RECTANGLE: ArkUI_ShapeType = 0;
#[doc = " Circle."]
pub const ArkUI_ShapeType_ARKUI_SHAPE_TYPE_CIRCLE: ArkUI_ShapeType = 1;
#[doc = " Ellipse."]
pub const ArkUI_ShapeType_ARKUI_SHAPE_TYPE_ELLIPSE: ArkUI_ShapeType = 2;
#[doc = " Path."]
pub const ArkUI_ShapeType_ARKUI_SHAPE_TYPE_PATH: ArkUI_ShapeType = 3;
#[doc = " @brief Enumerates the custom shapes.\n\n @since 12"]
pub type ArkUI_ShapeType = ::std::os::raw::c_uint;
#[doc = " From right to left."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_LEFT:
    ArkUI_LinearGradientDirection = 0;
#[doc = " From bottom to top."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_TOP:
    ArkUI_LinearGradientDirection = 1;
#[doc = " From left to right."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_RIGHT:
    ArkUI_LinearGradientDirection = 2;
#[doc = " From top to bottom."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_BOTTOM:
    ArkUI_LinearGradientDirection = 3;
#[doc = " From lower right to upper left."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_LEFT_TOP:
    ArkUI_LinearGradientDirection = 4;
#[doc = " From upper right to lower left."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_LEFT_BOTTOM:
    ArkUI_LinearGradientDirection = 5;
#[doc = " From lower left to upper right."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_RIGHT_TOP:
    ArkUI_LinearGradientDirection = 6;
#[doc = " From upper left to lower right."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_RIGHT_BOTTOM:
    ArkUI_LinearGradientDirection = 7;
#[doc = " No gradient."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_NONE:
    ArkUI_LinearGradientDirection = 8;
#[doc = " Custom direction."]
pub const ArkUI_LinearGradientDirection_ARKUI_LINEAR_GRADIENT_DIRECTION_CUSTOM:
    ArkUI_LinearGradientDirection = 9;
#[doc = " @brief Enumerates the gradient directions.\n\n @since 12"]
pub type ArkUI_LinearGradientDirection = ::std::os::raw::c_uint;
#[doc = " Word breaks can occur between any two characters for Chinese, Japanese, and Korean (CJK) text, but can occur\n  only at a space character for non-CJK text (such as English)."]
pub const ArkUI_WordBreak_ARKUI_WORD_BREAK_NORMAL: ArkUI_WordBreak = 0;
#[doc = " Word breaks can occur between any two characters for non-CJK text. CJK text behavior is the same as for\n  <b>NORMAL</b>."]
pub const ArkUI_WordBreak_ARKUI_WORD_BREAK_BREAK_ALL: ArkUI_WordBreak = 1;
#[doc = " This option has the same effect as <b>BREAK_ALL</b> for non-CJK text, except that if it preferentially wraps\n  lines at appropriate characters (for example, spaces) whenever possible.\nCJK text behavior is the same as for <b>NORMAL</b>."]
pub const ArkUI_WordBreak_ARKUI_WORD_BREAK_BREAK_WORD: ArkUI_WordBreak = 2;
#[doc = " @brief Enumerates the word break rules.\n\n @since 12"]
pub type ArkUI_WordBreak = ::std::os::raw::c_uint;
#[doc = " An ellipsis is used at the start of the line of text."]
pub const ArkUI_EllipsisMode_ARKUI_ELLIPSIS_MODE_START: ArkUI_EllipsisMode = 0;
#[doc = " An ellipsis is used at the center of the line of text."]
pub const ArkUI_EllipsisMode_ARKUI_ELLIPSIS_MODE_CENTER: ArkUI_EllipsisMode = 1;
#[doc = " An ellipsis is used at the end of the line of text."]
pub const ArkUI_EllipsisMode_ARKUI_ELLIPSIS_MODE_END: ArkUI_EllipsisMode = 2;
#[doc = " @brief Enumerates the ellipsis positions.\n\n @since 12"]
pub type ArkUI_EllipsisMode = ::std::os::raw::c_uint;
#[doc = " Render image pixels as they are in the original source image."]
pub const ArkUI_ImageRenderMode_ARKUI_IMAGE_RENDER_MODE_ORIGINAL: ArkUI_ImageRenderMode = 0;
#[doc = " Render image pixels to create a monochrome template image."]
pub const ArkUI_ImageRenderMode_ARKUI_IMAGE_RENDER_MODE_TEMPLATE: ArkUI_ImageRenderMode = 1;
#[doc = " @brief Enumerates the image rendering modes.\n\n @since 12"]
pub type ArkUI_ImageRenderMode = ::std::os::raw::c_uint;
#[doc = " Top edge of the window."]
pub const ArkUI_TransitionEdge_ARKUI_TRANSITION_EDGE_TOP: ArkUI_TransitionEdge = 0;
#[doc = " Bottom edge of the window."]
pub const ArkUI_TransitionEdge_ARKUI_TRANSITION_EDGE_BOTTOM: ArkUI_TransitionEdge = 1;
#[doc = " Left edge of the window."]
pub const ArkUI_TransitionEdge_ARKUI_TRANSITION_EDGE_START: ArkUI_TransitionEdge = 2;
#[doc = " Right edge of the window."]
pub const ArkUI_TransitionEdge_ARKUI_TRANSITION_EDGE_END: ArkUI_TransitionEdge = 3;
#[doc = " @brief Enumerates the slide-in and slide-out positions of the component from the screen edge during transition.\n\n @since 12"]
pub type ArkUI_TransitionEdge = ::std::os::raw::c_uint;
#[doc = " The content of the view is blended in sequence on the target image."]
pub const ArkUI_BlendApplyType_BLEND_APPLY_TYPE_FAST: ArkUI_BlendApplyType = 0;
#[doc = " The content of the component and its child components are drawn on the offscreen canvas, and then blended with\n  the existing content on the canvas."]
pub const ArkUI_BlendApplyType_BLEND_APPLY_TYPE_OFFSCREEN: ArkUI_BlendApplyType = 1;
#[doc = " @brief Defines how the specified blend mode is applied.\n\n @since 12"]
pub type ArkUI_BlendApplyType = ::std::os::raw::c_uint;
#[doc = " @brief Defines a mask area.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Rect {
    #[doc = " X coordinate of the mask area."]
    pub x: f32,
    #[doc = " Y coordinate of the mask area."]
    pub y: f32,
    #[doc = " Width of the mask area."]
    pub width: f32,
    #[doc = " Height of the mask area."]
    pub height: f32,
}
#[doc = " @brief Describes the width and height of a component.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_IntSize {
    #[doc = " Width, in px."]
    pub width: i32,
    #[doc = " Height, in px."]
    pub height: i32,
}
#[doc = " @brief Describes the position of a component.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_IntOffset {
    #[doc = " Horizontal coordinate, in px."]
    pub x: i32,
    #[doc = " Vertical coordinate, in px."]
    pub y: i32,
}
#[doc = " The callback is invoked when the entire animation is removed once it has finished."]
pub const ArkUI_FinishCallbackType_ARKUI_FINISH_CALLBACK_REMOVED: ArkUI_FinishCallbackType = 0;
#[doc = " The callback is invoked when the animation logically enters the falling state, though it may still be in its\n long tail state."]
pub const ArkUI_FinishCallbackType_ARKUI_FINISH_CALLBACK_LOGICALLY: ArkUI_FinishCallbackType = 1;
#[doc = " @brief Enumerates the animation onFinish callback types.\n\n @since 12"]
pub type ArkUI_FinishCallbackType = ::std::os::raw::c_uint;
#[doc = " The list items are packed toward the start edge of the list container along the cross axis."]
pub const ArkUI_ListItemAlignment_ARKUI_LIST_ITEM_ALIGNMENT_START: ArkUI_ListItemAlignment = 0;
#[doc = " The list items are centered in the list container along the cross axis."]
pub const ArkUI_ListItemAlignment_ARKUI_LIST_ITEM_ALIGNMENT_CENTER: ArkUI_ListItemAlignment = 1;
#[doc = " The list items are packed toward the end edge of the list container along the cross axis."]
pub const ArkUI_ListItemAlignment_ARKUI_LIST_ITEM_ALIGNMENT_END: ArkUI_ListItemAlignment = 2;
#[doc = " @brief Enumerates the alignment modes of items along the cross axis.\n\n @since 12"]
pub type ArkUI_ListItemAlignment = ::std::os::raw::c_uint;
#[doc = " The barrier is the leftmost of all its referencedIds."]
pub const ArkUI_BarrierDirection_ARKUI_BARRIER_DIRECTION_START: ArkUI_BarrierDirection = 0;
#[doc = " The barrier is on the rightmost side of all its referencedIds."]
pub const ArkUI_BarrierDirection_ARKUI_BARRIER_DIRECTION_END: ArkUI_BarrierDirection = 1;
#[doc = " The barrier is at the top of all its referencedIds."]
pub const ArkUI_BarrierDirection_ARKUI_BARRIER_DIRECTION_TOP: ArkUI_BarrierDirection = 2;
#[doc = " The barrier is at the bottom of all its referencedIds."]
pub const ArkUI_BarrierDirection_ARKUI_BARRIER_DIRECTION_BOTTOM: ArkUI_BarrierDirection = 3;
#[doc = " @brief defines the direction of the barrier line.\n\n @since 12"]
pub type ArkUI_BarrierDirection = ::std::os::raw::c_uint;
#[doc = " Components are evenly distributed among constraint anchor points."]
pub const ArkUI_RelativeLayoutChainStyle_ARKUI_RELATIVE_LAYOUT_CHAIN_STYLE_SPREAD:
    ArkUI_RelativeLayoutChainStyle = 0;
#[doc = " Except for the first and last two sub-components,\n other components are evenly distributed between the constraint anchor points."]
pub const ArkUI_RelativeLayoutChainStyle_ARKUI_RELATIVE_LAYOUT_CHAIN_STYLE_SPREAD_INSIDE:
    ArkUI_RelativeLayoutChainStyle = 1;
#[doc = " No gaps in subcomponents within the chain."]
pub const ArkUI_RelativeLayoutChainStyle_ARKUI_RELATIVE_LAYOUT_CHAIN_STYLE_PACKED:
    ArkUI_RelativeLayoutChainStyle = 2;
#[doc = " @brief defines the style of the chain.\n\n @since 12"]
pub type ArkUI_RelativeLayoutChainStyle = ::std::os::raw::c_uint;
#[doc = " @brief Describes the margins of a component.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Margin {
    #[doc = " Top margin, in vp."]
    pub top: f32,
    #[doc = " Right margin, in vp."]
    pub right: f32,
    #[doc = " Bottom margin, in vp."]
    pub bottom: f32,
    #[doc = " Left margin, in vp."]
    pub left: f32,
}
#[doc = " Default, which is fp for fonts and vp for non-fonts."]
pub const ArkUI_LengthMetricUnit_ARKUI_LENGTH_METRIC_UNIT_DEFAULT: ArkUI_LengthMetricUnit = -1;
#[doc = " px."]
pub const ArkUI_LengthMetricUnit_ARKUI_LENGTH_METRIC_UNIT_PX: ArkUI_LengthMetricUnit = 0;
#[doc = " vp."]
pub const ArkUI_LengthMetricUnit_ARKUI_LENGTH_METRIC_UNIT_VP: ArkUI_LengthMetricUnit = 1;
#[doc = " fp."]
pub const ArkUI_LengthMetricUnit_ARKUI_LENGTH_METRIC_UNIT_FP: ArkUI_LengthMetricUnit = 2;
#[doc = " @brief Enumerates the component units.\n\n @since 12"]
pub type ArkUI_LengthMetricUnit = ::std::os::raw::c_int;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always centered with the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_CENTER: ArkUI_RenderFit = 0;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always aligned with the top center of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_TOP: ArkUI_RenderFit = 1;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always aligned with the bottom center of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_BOTTOM: ArkUI_RenderFit = 2;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always aligned to the left of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_LEFT: ArkUI_RenderFit = 3;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always right-aligned with the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RIGHT: ArkUI_RenderFit = 4;
#[doc = " Maintains the content size of the animation's final state,\n and the content is always aligned with the top left corner of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_TOP_LEFT: ArkUI_RenderFit = 5;
#[doc = " Keep the content size of the animation final state,\n and the content is always aligned with the upper right corner of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_TOP_RIGHT: ArkUI_RenderFit = 6;
#[doc = " Keep the content size of the animation final state,\n and the content always aligns with the lower-left corner of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_BOTTOM_LEFT: ArkUI_RenderFit = 7;
#[doc = " Keep the content size of the animation final state,\nand the content always aligns with the lower-right corner of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_BOTTOM_RIGHT: ArkUI_RenderFit = 8;
#[doc = " The aspect ratio of the animation's final state content is not considered,\nand the content is always scaled to the size of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_FILL: ArkUI_RenderFit = 9;
#[doc = " Reduce or enlarge the aspect ratio of the animation final state content,\n so that the content is fully displayed in the component,\n and keep the center aligned with the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_CONTAIN: ArkUI_RenderFit = 10;
#[doc = " Keep the aspect ratio of the animation final state content to reduce or enlarge,\n so that the content is fully displayed in the component.\n When there is left over in the broad direction of the component,\n the content is aligned to the left of the component,\n and when there is left over in the high direction of the component,\n the content is aligned to the top of the component."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_CONTAIN_TOP_LEFT: ArkUI_RenderFit = 11;
#[doc = " Keep the aspect ratio of the animation final state content to reduce or enlarge,\n so that the content is fully displayed in the component.\n When there is left in the wide direction of the component,\n the content is aligned with the component on the right.\n When there is left in the high direction of the component,\n the content is aligned with the component on the bottom."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_CONTAIN_BOTTOM_RIGHT: ArkUI_RenderFit = 12;
#[doc = " Keep the aspect ratio of the animation final state content reduced or enlarged,\n so that both sides of the content are greater than or equal to both sides of the component,\n and keep the center aligned with the component to display the middle part of the content."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_COVER: ArkUI_RenderFit = 13;
#[doc = " Keep the aspect ratio of the final content of the animation reduced or enlarged\n so that both sides of the content are exactly greater than or equal to both sides of the component.\n When the content width is left, the content is aligned to the left of the component,\n and the left portion of the content is displayed. When the content is left in the high direction,\n the content and the component remain top aligned, showing the top side of the content."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_COVER_TOP_LEFT: ArkUI_RenderFit = 14;
#[doc = " Keep the aspect ratio of the final content of the animation reduced or enlarged so\n that both sides of the content are exactly greater than or equal to both sides of the component.\n When the content width is left, the content and the component remain right aligned,\n and the right part of the content is displayed. When the content is left in the high direction,\n the content and the component remain aligned at the bottom,\n and the bottom part of the content is displayed."]
pub const ArkUI_RenderFit_ARKUI_RENDER_FIT_RESIZE_COVER_BOTTOM_RIGHT: ArkUI_RenderFit = 15;
#[doc = " @brief Enumerates the render fit.\n\n @since 12"]
pub type ArkUI_RenderFit = ::std::os::raw::c_uint;
#[doc = " Normal button (without rounded corners by default)."]
pub const ArkUI_ButtonType_ARKUI_BUTTON_TYPE_NORMAL: ArkUI_ButtonType = 0;
#[doc = " Capsule-type button (the round corner is half of the height by default)."]
pub const ArkUI_ButtonType_ARKUI_BUTTON_TYPE_CAPSULE: ArkUI_ButtonType = 1;
#[doc = " Circle button."]
pub const ArkUI_ButtonType_ARKUI_BUTTON_TYPE_CIRCLE: ArkUI_ButtonType = 2;
#[doc = " @brief Enumerates the button types.\n\n @since 12"]
pub type ArkUI_ButtonType = ::std::os::raw::c_uint;
#[doc = " Username. Password Vault, when enabled, can automatically save and fill in usernames."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_USER_NAME:
    ArkUI_TextInputContentType = 0;
#[doc = " Password. Password Vault, when enabled, can automatically save and fill in passwords."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PASSWORD:
    ArkUI_TextInputContentType = 1;
#[doc = " New password. Password Vault, when enabled, can automatically generate a new password."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_NEW_PASSWORD:
    ArkUI_TextInputContentType = 2;
#[doc = " Full street address. The scenario-based autofill feature, when enabled, can automatically save and fill in full\n  street addresses."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_FULL_STREET_ADDRESS:
    ArkUI_TextInputContentType = 3;
#[doc = " House number. The scenario-based autofill feature, when enabled, can automatically save and fill in house\n  numbers."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_HOUSE_NUMBER:
    ArkUI_TextInputContentType = 4;
#[doc = " District and county. The scenario-based autofill feature, when enabled, can automatically save and fill in\n  districts and counties."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_DISTRICT_ADDRESS:
    ArkUI_TextInputContentType = 5;
#[doc = " City. The scenario-based autofill feature, when enabled, can automatically save and fill in cities."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_CITY_ADDRESS:
    ArkUI_TextInputContentType = 6;
#[doc = " Province. The scenario-based autofill feature, when enabled, can automatically save and fill in provinces."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PROVINCE_ADDRESS:
    ArkUI_TextInputContentType = 7;
#[doc = " Country. The scenario-based autofill feature, when enabled, can automatically save and fill in countries."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_COUNTRY_ADDRESS:
    ArkUI_TextInputContentType = 8;
#[doc = " Full name. The scenario-based autofill feature, when enabled, can automatically save and fill in full names."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PERSON_FULL_NAME:
    ArkUI_TextInputContentType = 9;
#[doc = " Last name. The scenario-based autofill feature, when enabled, can automatically save and fill in last names."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PERSON_LAST_NAME:
    ArkUI_TextInputContentType = 10;
#[doc = " First name. The scenario-based autofill feature, when enabled, can automatically save and fill in first names."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PERSON_FIRST_NAME:
    ArkUI_TextInputContentType = 11;
#[doc = " Phone number. The scenario-based autofill feature, when enabled, can automatically save and fill in phone\n  numbers."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PHONE_NUMBER:
    ArkUI_TextInputContentType = 12;
#[doc = " Country code. The scenario-based autofill feature, when enabled, can automatically save and fill in country\n  codes."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_PHONE_COUNTRY_CODE:
    ArkUI_TextInputContentType = 13;
#[doc = " Phone number with country code. The scenario-based autofill feature, when enabled, can automatically save and\n  fill in phone numbers with country codes."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_FULL_PHONE_NUMBER:
    ArkUI_TextInputContentType = 14;
#[doc = " Email address. The scenario-based autofill feature, when enabled, can automatically save and fill in email\n  addresses."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_EMAIL_ADDRESS:
    ArkUI_TextInputContentType = 15;
#[doc = " Bank card number. The scenario-based autofill feature, when enabled, can automatically save and fill in bank\n  card numbers."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_BANK_CARD_NUMBER:
    ArkUI_TextInputContentType = 16;
#[doc = " ID card number. The scenario-based autofill feature, when enabled, can automatically save and fill in ID card\n  numbers."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_ID_CARD_NUMBER:
    ArkUI_TextInputContentType = 17;
#[doc = " Nickname. The scenario-based autofill feature, when enabled, can automatically save and fill in nicknames."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_NICKNAME:
    ArkUI_TextInputContentType = 18;
#[doc = " Address information without street address. The scenario-based autofill feature, when enabled, can automatically\n  save and fill in address information without street addresses."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_DETAIL_INFO_WITHOUT_STREET:
    ArkUI_TextInputContentType = 19;
#[doc = " Standard address. The scenario-based autofill feature, when enabled, can automatically save and fill in standard\n  addresses."]
pub const ArkUI_TextInputContentType_ARKUI_TEXTINPUT_CONTENT_TYPE_FORMAT_ADDRESS:
    ArkUI_TextInputContentType = 20;
#[doc = " @brief Enumerates the autofill types.\n\n @since 12"]
pub type ArkUI_TextInputContentType = ::std::os::raw::c_uint;
#[doc = " Default style. The caret width is fixed at 1.5 vp, and the caret height is subject to the background height and\n  font size of the selected text."]
pub const ArkUI_TextInputStyle_ARKUI_TEXTINPUT_STYLE_DEFAULT: ArkUI_TextInputStyle = 0;
#[doc = " Inline input style. The background height of the selected text is the same as the height of the text box."]
pub const ArkUI_TextInputStyle_ARKUI_TEXTINPUT_STYLE_INLINE: ArkUI_TextInputStyle = 1;
#[doc = " @brief Defines the text input style.\n\n @since 12"]
pub type ArkUI_TextInputStyle = ::std::os::raw::c_uint;
#[doc = " Default appearance mode, won't adopt immersive styles.\n @since 15"]
pub const ArkUI_KeyboardAppearance_ARKUI_KEYBOARD_APPEARANCE_NONE_IMMERSIVE:
    ArkUI_KeyboardAppearance = 0;
#[doc = " Immersive mode.\n @since 15"]
pub const ArkUI_KeyboardAppearance_ARKUI_KEYBOARD_APPEARANCE_IMMERSIVE: ArkUI_KeyboardAppearance =
    1;
#[doc = " Light immersive style.\n @since 15"]
pub const ArkUI_KeyboardAppearance_ARKUI_KEYBOARD_APPEARANCE_LIGHT_IMMERSIVE:
    ArkUI_KeyboardAppearance = 2;
#[doc = " Dark immersive style.\n @since 15"]
pub const ArkUI_KeyboardAppearance_ARKUI_KEYBOARD_APPEARANCE_DARK_IMMERSIVE:
    ArkUI_KeyboardAppearance = 3;
#[doc = " @brief Defines the keyboard style of input box\n\n @since 15"]
pub type ArkUI_KeyboardAppearance = ::std::os::raw::c_uint;
#[doc = " Phone Number."]
pub const ArkUI_TextDataDetectorType_ARKUI_TEXT_DATA_DETECTOR_TYPE_PHONE_NUMBER:
    ArkUI_TextDataDetectorType = 0;
#[doc = " Link."]
pub const ArkUI_TextDataDetectorType_ARKUI_TEXT_DATA_DETECTOR_TYPE_URL: ArkUI_TextDataDetectorType =
    1;
#[doc = " Mailbox."]
pub const ArkUI_TextDataDetectorType_ARKUI_TEXT_DATA_DETECTOR_TYPE_EMAIL:
    ArkUI_TextDataDetectorType = 2;
#[doc = " Address."]
pub const ArkUI_TextDataDetectorType_ARKUI_TEXT_DATA_DETECTOR_TYPE_ADDRESS:
    ArkUI_TextDataDetectorType = 3;
#[doc = " @brief Defines the entity type for text recognition.\n\n @since 12"]
pub type ArkUI_TextDataDetectorType = ::std::os::raw::c_uint;
#[doc = " dot type."]
pub const ArkUI_SwiperIndicatorType_ARKUI_SWIPER_INDICATOR_TYPE_DOT: ArkUI_SwiperIndicatorType = 0;
#[doc = " digit type."]
pub const ArkUI_SwiperIndicatorType_ARKUI_SWIPER_INDICATOR_TYPE_DIGIT: ArkUI_SwiperIndicatorType =
    1;
#[doc = " @brief Define the navigation indicator type of the swiper.\n\n @since 12"]
pub type ArkUI_SwiperIndicatorType = ::std::os::raw::c_uint;
#[doc = " In the folded state, when the ListItem slides in the opposite direction to the main axis,\n the operation item is hidden."]
pub const ArkUI_ListItemSwipeActionState_ARKUI_LIST_ITEM_SWIPE_ACTION_STATE_COLLAPSED:
    ArkUI_ListItemSwipeActionState = 0;
#[doc = " In the folded state, when the ListItem slides in the opposite direction to the spindle,\n the operation item is displayed."]
pub const ArkUI_ListItemSwipeActionState_ARKUI_LIST_ITEM_SWIPE_ACTION_STATE_EXPANDED:
    ArkUI_ListItemSwipeActionState = 1;
#[doc = " Long distance state, the state of deleting a ListItem after it enters the long distance deletion area."]
pub const ArkUI_ListItemSwipeActionState_ARKUI_LIST_ITEM_SWIPE_ACTION_STATE_ACTIONING:
    ArkUI_ListItemSwipeActionState = 2;
#[doc = " @brief Define the pattern of element arrangement in the main axis direction of the Swiper component.\n\n @since 12"]
pub type ArkUI_ListItemSwipeActionState = ::std::os::raw::c_uint;
#[doc = " The ListItem can continue to be scratched after the distance exceeds the size of the scratched component."]
pub const ArkUI_ListItemSwipeEdgeEffect_ARKUI_LIST_ITEM_SWIPE_EDGE_EFFECT_SPRING:
    ArkUI_ListItemSwipeEdgeEffect = 0;
#[doc = " The sliding distance of the ListItem cannot exceed the size of the scratched component."]
pub const ArkUI_ListItemSwipeEdgeEffect_ARKUI_LIST_ITEM_SWIPE_EDGE_EFFECT_NONE:
    ArkUI_ListItemSwipeEdgeEffect = 1;
#[doc = " @brief Define the explicit and implicit mode of the SwipeAction method for the Listitem component.\n\n @since 12"]
pub type ArkUI_ListItemSwipeEdgeEffect = ::std::os::raw::c_uint;
#[doc = " @error No errors."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NO_ERROR: ArkUI_ErrorCode = 0;
#[doc = " @error Parameter error."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_PARAM_INVALID: ArkUI_ErrorCode = 401;
#[doc = " @error Internal error occurs, such as failure occurs because of the internal environment error,\n or operation failed because of the internal execution failed.\n @since 15"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_INTERNAL_ERROR: ArkUI_ErrorCode = 100001;
#[doc = " @error The component does not support specific properties or events."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED: ArkUI_ErrorCode =
    106102;
#[doc = " @error The corresponding operation does not support nodes created by ArkTS."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_ARKTS_NODE_NOT_SUPPORTED: ArkUI_ErrorCode = 106103;
#[doc = " @error The lazy loading adapter is not bound to the component."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_ADAPTER_NOT_BOUND: ArkUI_ErrorCode = 106104;
#[doc = " @error The adapter already exists."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_ADAPTER_EXIST: ArkUI_ErrorCode = 106105;
#[doc = " @error The corresponding node already has a child node and cannot add an adapter."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_CHILD_NODE_EXIST: ArkUI_ErrorCode = 106106;
#[doc = " The parameter length in the parameter event exceeds the limit."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INDEX_OUT_OF_RANGE: ArkUI_ErrorCode =
    106107;
#[doc = " The data does not exist in the component event."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INVALID: ArkUI_ErrorCode = 106108;
#[doc = " The component event does not support return values."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_EVENT_NO_RETURN: ArkUI_ErrorCode = 106109;
#[doc = " The index value is invalid."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_INDEX_INVALID: ArkUI_ErrorCode = 106200;
#[doc = "  Failed to query route navigation information."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_GET_INFO_FAILED: ArkUI_ErrorCode = 106201;
#[doc = " The buffer size is not large enough."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR: ArkUI_ErrorCode = 106202;
#[doc = " @error The node is not on main tree.\n @since 15"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NODE_NOT_ON_MAIN_TREE: ArkUI_ErrorCode = 106203;
#[doc = " @error The node requesting focus is not focusable.\n @since 15"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_FOCUS_NON_FOCUSABLE: ArkUI_ErrorCode = 150001;
#[doc = " @error The node requesting focus has unfocusable ancestor.\n @since 15"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_FOCUS_NON_FOCUSABLE_ANCESTOR: ArkUI_ErrorCode = 150002;
#[doc = " @error The node requesting focus does not exists.\n @since 15"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_FOCUS_NON_EXISTENT: ArkUI_ErrorCode = 150003;
#[doc = " @error The snapshot taking is timeout.\n @since 15"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_COMPONENT_SNAPSHOT_TIMEOUT: ArkUI_ErrorCode = 160002;
#[doc = " The component is not a scroll container."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NON_SCROLLABLE_CONTAINER: ArkUI_ErrorCode = 180001;
#[doc = " The buffer is not large enough."]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_BUFFER_SIZE_NOT_ENOUGH: ArkUI_ErrorCode = 180002;
#[doc = " @error The event is not a clone event.\n @since 15"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_NOT_CLONED_POINTER_EVENT: ArkUI_ErrorCode = 180003;
#[doc = " @error The component status is abnormal.\n @since 15"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_POST_CLONED_COMPONENT_STATUS_ABNORMAL: ArkUI_ErrorCode =
    180004;
#[doc = " @error No component hit to respond to the event.\n @since 15"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_POST_CLONED_NO_COMPONENT_HIT_TO_RESPOND_TO_THE_EVENT:
    ArkUI_ErrorCode = 180005;
#[doc = " @error invalid styled string.\n @since 14"]
pub const ArkUI_ErrorCode_ARKUI_ERROR_CODE_INVALID_STYLED_STRING: ArkUI_ErrorCode = 180101;
#[doc = " @brief Define error code enumeration values.\n\n @since 12"]
pub type ArkUI_ErrorCode = ::std::os::raw::c_uint;
#[doc = " The animation is in the initial state."]
pub const ArkUI_AnimationStatus_ARKUI_ANIMATION_STATUS_INITIAL: ArkUI_AnimationStatus = 0;
#[doc = " The animation is being played."]
pub const ArkUI_AnimationStatus_ARKUI_ANIMATION_STATUS_RUNNING: ArkUI_AnimationStatus = 1;
#[doc = " The animation is paused."]
pub const ArkUI_AnimationStatus_ARKUI_ANIMATION_STATUS_PAUSED: ArkUI_AnimationStatus = 2;
#[doc = " The animation is stopped."]
pub const ArkUI_AnimationStatus_ARKUI_ANIMATION_STATUS_STOPPED: ArkUI_AnimationStatus = 3;
#[doc = " @brief Defines the playback status for the image animator.\n\n @since 12"]
pub type ArkUI_AnimationStatus = ::std::os::raw::c_uint;
#[doc = " Before execution, the animation does not apply any styles to the target component.\n After execution, the animation restores the target component to its default state."]
pub const ArkUI_AnimationFillMode_ARKUI_ANIMATION_FILL_MODE_NONE: ArkUI_AnimationFillMode = 0;
#[doc = " The target component retains the state set by the last keyframe encountered\n during execution of the animation."]
pub const ArkUI_AnimationFillMode_ARKUI_ANIMATION_FILL_MODE_FORWARDS: ArkUI_AnimationFillMode = 1;
#[doc = " The animation applies the values defined in the first relevant keyframe once it is applied to\n the target component, and retains the values during the period set by delay."]
pub const ArkUI_AnimationFillMode_ARKUI_ANIMATION_FILL_MODE_BACKWARDS: ArkUI_AnimationFillMode = 2;
#[doc = " The animation follows the rules for both Forwards and Backwards,\n extending the animation attributes in both directions."]
pub const ArkUI_AnimationFillMode_ARKUI_ANIMATION_FILL_MODE_BOTH: ArkUI_AnimationFillMode = 3;
#[doc = " @brief Defines the status before and after execution of the animation in the current playback direction.\n\n @since 12"]
pub type ArkUI_AnimationFillMode = ::std::os::raw::c_uint;
#[doc = " The Checkbox unchecked."]
pub const ArkUI_AccessibilityCheckedState_ARKUI_ACCESSIBILITY_UNCHECKED:
    ArkUI_AccessibilityCheckedState = 0;
#[doc = " The Checkbox checked."]
pub const ArkUI_AccessibilityCheckedState_ARKUI_ACCESSIBILITY_CHECKED:
    ArkUI_AccessibilityCheckedState = 1;
#[doc = " @brief Defines the state type for the accessibility checkbox.\n\n @since 12"]
pub type ArkUI_AccessibilityCheckedState = ::std::os::raw::c_uint;
#[doc = " The animation plays in forward loop mode."]
pub const ArkUI_AnimationDirection_ARKUI_ANIMATION_DIRECTION_NORMAL: ArkUI_AnimationDirection = 0;
#[doc = " The animation plays in reverse loop mode."]
pub const ArkUI_AnimationDirection_ARKUI_ANIMATION_DIRECTION_REVERSE: ArkUI_AnimationDirection = 1;
#[doc = " The animation plays in alternating loop mode. When the animation is played for an odd number of times, the\n  playback is in forward direction. When the animation is played for an even number of times, the playback is in\n  reverse direction."]
pub const ArkUI_AnimationDirection_ARKUI_ANIMATION_DIRECTION_ALTERNATE: ArkUI_AnimationDirection =
    2;
#[doc = " The animation plays in reverse alternating loop mode. When the animation is played for an odd number of times,\n  the playback is in reverse direction. When the animation is played for an even number of times, the playback is\n  in forward direction."]
pub const ArkUI_AnimationDirection_ARKUI_ANIMATION_DIRECTION_ALTERNATE_REVERSE:
    ArkUI_AnimationDirection = 3;
#[doc = "/**\n @brief Enumerates the animation playback modes.\n\n @since 12"]
pub type ArkUI_AnimationDirection = ::std::os::raw::c_uint;
#[doc = " Finger drag."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_DRAG: ArkUI_ScrollSource = 0;
#[doc = " Inertial roll after finger drag."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_FLING: ArkUI_ScrollSource = 1;
#[doc = " Execute the EdgeEffect.Spring edge effect when crossing the boundary."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_EDGE_EFFECT: ArkUI_ScrollSource = 2;
#[doc = " Other user input other than dragging, such as mouse wheel, keyboard events, etc."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_OTHER_USER_INPUT: ArkUI_ScrollSource = 3;
#[doc = " Drag the scroll bar."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_SCROLL_BAR: ArkUI_ScrollSource = 4;
#[doc = " Inertia scrolling after dragging the scroll bar."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_SCROLL_BAR_FLING: ArkUI_ScrollSource = 5;
#[doc = " The scroll controller causes unanimated scrolling."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_SCROLLER: ArkUI_ScrollSource = 6;
#[doc = " The scroll controller causes the scroll to drive the painting."]
pub const ArkUI_ScrollSource_ARKUI_SCROLL_SOURCE_ANIMATION: ArkUI_ScrollSource = 7;
#[doc = " @brief Define the rolling source enumeration value.\n\n @since 12"]
pub type ArkUI_ScrollSource = ::std::os::raw::c_uint;
#[doc = " click action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_CLICK:
    ArkUI_AccessibilityActionType = 1;
#[doc = " long click action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_LONG_CLICK:
    ArkUI_AccessibilityActionType = 2;
#[doc = " cut action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_CUT:
    ArkUI_AccessibilityActionType = 4;
#[doc = " copy action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_COPY:
    ArkUI_AccessibilityActionType = 8;
#[doc = " paste action."]
pub const ArkUI_AccessibilityActionType_ARKUI_ACCESSIBILITY_ACTION_PASTE:
    ArkUI_AccessibilityActionType = 16;
#[doc = " @brief Define accessible action types.\n\n @since 12"]
pub type ArkUI_AccessibilityActionType = ::std::os::raw::c_uint;
#[doc = " @brief Defines the translation options for component transition.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TranslationOptions {
    #[doc = " Translation distance along the x-axis."]
    pub x: f32,
    #[doc = " Translation distance along the y-axis."]
    pub y: f32,
    #[doc = " Translation distance along the z-axis."]
    pub z: f32,
}
#[doc = " @brief Defines the scaling options for component transition.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ScaleOptions {
    #[doc = " Scale ratio along the x-axis."]
    pub x: f32,
    #[doc = " Scale ratio along the y-axis."]
    pub y: f32,
    #[doc = " Scale factor along the z-axis (not effective for the current 2D graphics)."]
    pub z: f32,
    #[doc = " X coordinate of the center point."]
    pub centerX: f32,
    #[doc = " Y coordinate of the center point."]
    pub centerY: f32,
}
#[doc = " @brief Defines the rotation options for component transition.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_RotationOptions {
    #[doc = " X-component of the rotation vector."]
    pub x: f32,
    #[doc = " Y-component of the rotation vector."]
    pub y: f32,
    #[doc = " Z-component of the rotation vector."]
    pub z: f32,
    #[doc = " Rotation angle."]
    pub angle: f32,
    #[doc = " X coordinate of the center point."]
    pub centerX: f32,
    #[doc = " Y coordinate of the center point."]
    pub centerY: f32,
    #[doc = " Z-axis anchor, that is, the z-component of the 3D rotation center point."]
    pub centerZ: f32,
    #[doc = " Distance from the user to the z=0 plane."]
    pub perspective: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CustomSpanMeasureInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CustomSpanMetrics {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_CustomSpanDrawInfo {
    _unused: [u8; 0],
}
#[doc = " The NavDestination show."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_SHOW: ArkUI_NavDestinationState =
    0;
#[doc = " The NavDestination hide."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_HIDE: ArkUI_NavDestinationState =
    1;
#[doc = " The NavDestination is mounted to the component tree."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_APPEAR:
    ArkUI_NavDestinationState = 2;
#[doc = " The NavDestination removed from the component tree."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_DISAPPEAR:
    ArkUI_NavDestinationState = 3;
#[doc = " Before the NavDestination show."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_WILL_SHOW:
    ArkUI_NavDestinationState = 4;
#[doc = " Before the NavDestination hide."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_WILL_HIDE:
    ArkUI_NavDestinationState = 5;
#[doc = " Before the NavDestination mount to the component tree."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_WILL_APPEAR:
    ArkUI_NavDestinationState = 6;
#[doc = " Before the NavDestination removed from the component tree."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_WILL_DISAPPEAR:
    ArkUI_NavDestinationState = 7;
#[doc = " The NavDestination returns from the component."]
pub const ArkUI_NavDestinationState_ARKUI_NAV_DESTINATION_STATE_ON_BACK_PRESS:
    ArkUI_NavDestinationState = 100;
#[doc = " @brief Defines the state of the NavDestination component.\n\n @since 12"]
pub type ArkUI_NavDestinationState = ::std::os::raw::c_uint;
#[doc = " The Router Page is about to be created."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ABOUT_TO_APPEAR: ArkUI_RouterPageState = 0;
#[doc = " The Router Page is about to be destroyed."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ABOUT_TO_DISAPPEAR: ArkUI_RouterPageState =
    1;
#[doc = " The Router Page show."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ON_SHOW: ArkUI_RouterPageState = 2;
#[doc = " The Router Page hide."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ON_HIDE: ArkUI_RouterPageState = 3;
#[doc = " The Router Page returns."]
pub const ArkUI_RouterPageState_ARKUI_ROUTER_PAGE_STATE_ON_BACK_PRESS: ArkUI_RouterPageState = 4;
#[doc = " @brief Define the state of Router Page.\n\n @since 12"]
pub type ArkUI_RouterPageState = ::std::os::raw::c_uint;
#[doc = " The default security zone includes the status bar and navigation bar."]
pub const ArkUI_SafeAreaType_ARKUI_SAFE_AREA_TYPE_SYSTEM: ArkUI_SafeAreaType = 1;
#[doc = " Non-secure areas of the device, such as bangs or hole holes."]
pub const ArkUI_SafeAreaType_ARKUI_SAFE_AREA_TYPE_CUTOUT: ArkUI_SafeAreaType = 2;
#[doc = " Soft keyboard area."]
pub const ArkUI_SafeAreaType_ARKUI_SAFE_AREA_TYPE_KEYBOARD: ArkUI_SafeAreaType = 4;
#[doc = " @brief defines the enumerated value of the extended security zone.\n\n @since 12"]
pub type ArkUI_SafeAreaType = ::std::os::raw::c_uint;
#[doc = " Outside the area of the <b>ListItemGroup</b> component."]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_GROUP_AREA_OUTSIDE: ArkUI_ListItemGroupArea = 0;
#[doc = " Area when the <b>ListItemGroup</b> component does not have the header, footer, or list item."]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_SWIPE_AREA_NONE: ArkUI_ListItemGroupArea = 1;
#[doc = " List item area of the <b>ListItemGroup</b> component."]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_SWIPE_AREA_ITEM: ArkUI_ListItemGroupArea = 2;
#[doc = " Header area of the <b>ListItemGroup</b> component."]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_SWIPE_AREA_HEADER: ArkUI_ListItemGroupArea = 3;
#[doc = " Footer area of the <b>ListItemGroup</b> component."]
pub const ArkUI_ListItemGroupArea_ARKUI_LIST_ITEM_SWIPE_AREA_FOOTER: ArkUI_ListItemGroupArea = 4;
#[doc = " @brief Define an enum for the areas of the <b>ListItemGroup</b> component.\n\n @since 15"]
pub type ArkUI_ListItemGroupArea = ::std::os::raw::c_uint;
#[doc = " Upper area."]
pub const ArkUI_SafeAreaEdge_ARKUI_SAFE_AREA_EDGE_TOP: ArkUI_SafeAreaEdge = 1;
#[doc = " Lower area."]
pub const ArkUI_SafeAreaEdge_ARKUI_SAFE_AREA_EDGE_BOTTOM: ArkUI_SafeAreaEdge = 2;
#[doc = " Front area."]
pub const ArkUI_SafeAreaEdge_ARKUI_SAFE_AREA_EDGE_START: ArkUI_SafeAreaEdge = 4;
#[doc = " Tail area."]
pub const ArkUI_SafeAreaEdge_ARKUI_SAFE_AREA_EDGE_END: ArkUI_SafeAreaEdge = 8;
#[doc = " @brief defines the enumerated value of the direction of the extended security zone.\n\n @since 12"]
pub type ArkUI_SafeAreaEdge = ::std::os::raw::c_uint;
#[doc = " Defines avoid keyboard when keyboard shows."]
pub const ArkUI_KeyboardAvoidMode_ARKUI_KEYBOARD_AVOID_MODE_DEFAULT: ArkUI_KeyboardAvoidMode = 0;
#[doc = " Defines not avoid keyboard when keyboard shows."]
pub const ArkUI_KeyboardAvoidMode_ARKUI_KEYBOARD_AVOID_MODE_NONE: ArkUI_KeyboardAvoidMode = 1;
#[doc = " @brief defines the enumerated value of the customDialog's keyboard avoid mode.\n\n @since 15"]
pub type ArkUI_KeyboardAvoidMode = ::std::os::raw::c_uint;
#[doc = " Layout top half screen when the phone in hover mode."]
pub const ArkUI_HoverModeAreaType_ARKUI_HOVER_MODE_AREA_TYPE_TOP: ArkUI_HoverModeAreaType = 0;
#[doc = " Layout bottom half screen when the phone in hover mode."]
pub const ArkUI_HoverModeAreaType_ARKUI_HOVER_MODE_AREA_TYPE_BOTTOM: ArkUI_HoverModeAreaType = 1;
#[doc = " @brief defines the enumerated value of area in hover mode.\n\n @since 15"]
pub type ArkUI_HoverModeAreaType = ::std::os::raw::c_uint;
#[doc = " Not expand."]
pub const ArkUI_ExpandMode_ARKUI_NOT_EXPAND: ArkUI_ExpandMode = 0;
#[doc = " Expand."]
pub const ArkUI_ExpandMode_ARKUI_EXPAND: ArkUI_ExpandMode = 1;
#[doc = " Lazy expand. Expand the children of node if needed."]
pub const ArkUI_ExpandMode_ARKUI_LAZY_EXPAND: ArkUI_ExpandMode = 2;
#[doc = " @brief Enumerates the expand modes.\n\n @since 15"]
pub type ArkUI_ExpandMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_SystemFontStyleEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_SnapshotOptions {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates a size constraint.\n\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_Create() -> *mut ArkUI_LayoutConstraint;
}
extern "C" {
    #[doc = " @brief Creates a deep copy of a size constraint.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the pointer to the new size constraint.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_Copy(
        Constraint: *const ArkUI_LayoutConstraint,
    ) -> *mut ArkUI_LayoutConstraint;
}
extern "C" {
    #[doc = " @brief Destroys the pointer to a size constraint.\n\n @param Constraint Indicates the pointer to the size constraint.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_Dispose(
        Constraint: *mut ArkUI_LayoutConstraint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the maximum width for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the maximum width.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetMaxWidth(Constraint: *const ArkUI_LayoutConstraint) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the minimum width for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the minimum width.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetMinWidth(Constraint: *const ArkUI_LayoutConstraint) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the maximum height for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the maximum height.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetMaxHeight(Constraint: *const ArkUI_LayoutConstraint)
        -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the minimum height for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the minimum height.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetMinHeight(Constraint: *const ArkUI_LayoutConstraint)
        -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the width percentage reference for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the width percentage reference.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetPercentReferenceWidth(
        Constraint: *const ArkUI_LayoutConstraint,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the height percentage reference for a size constraint, in px.\n\n @param Constraint Indicates the pointer to the size constraint.\n @return Returns the height percentage reference.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_GetPercentReferenceHeight(
        Constraint: *const ArkUI_LayoutConstraint,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the maximum width.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the maximum width, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetMaxWidth(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the minimum width.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the minimum width, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetMinWidth(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the maximum height.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the maximum height, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetMaxHeight(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the minimum height.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the minimum height, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetMinHeight(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the width percentage reference.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the width percentage reference, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetPercentReferenceWidth(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the height percentage reference.\n\n @param Constraint Indicates the pointer to the size constraint.\n @param value Indicates the height percentage reference, in px.\n @since 12"]
    pub fn OH_ArkUI_LayoutConstraint_SetPercentReferenceHeight(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the pointer to a canvas for drawing, which can be converted into the <b>OH_Drawing_Canvas</b> pointer\n in the <b>Drawing</b> module.\n\n @param context Indicates the pointer to the drawing context.\n @return Returns the pointer to the canvas for drawing.\n @since 12"]
    pub fn OH_ArkUI_DrawContext_GetCanvas(
        context: *mut ArkUI_DrawContext,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the size of a drawing area.\n\n @param context Indicates the pointer to the drawing context.\n @return Returns the size of the drawing area.\n @since 12"]
    pub fn OH_ArkUI_DrawContext_GetSize(context: *mut ArkUI_DrawContext) -> ArkUI_IntSize;
}
extern "C" {
    #[doc = " @brief Creates water flow section configuration.\n\n @return Returns the water flow section configuration.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_Create() -> *mut ArkUI_WaterFlowSectionOption;
}
extern "C" {
    #[doc = " @brief Destroys the pointer to a water flow section configuration.\n\n @param option Indicates the pointer to a water flow section configuration.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_Dispose(option: *mut ArkUI_WaterFlowSectionOption);
}
extern "C" {
    #[doc = " @brief Sets the FlowItem block configuration information array length.\n\n @param option FlowItem Indicates the packet configuration.\n @param size Array Length.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetSize(
        option: *mut ArkUI_WaterFlowSectionOption,
        size: i32,
    );
}
extern "C" {
    #[doc = " @brief Gets the FlowItem grouping configuration information array length.\n\n @param option FlowItem Indicates the packet configuration.\n @return Array size. If -1 is returned, the return fails.\n         The possible cause of the failure is that the option parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetSize(
        option: *mut ArkUI_WaterFlowSectionOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the number of items in a water flow section.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param itemCount Indicates the number of items in the water flow section.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetItemCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        itemCount: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the number of items in the water flow section that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the number of items in the water flow section.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetItemCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief The FlowItem grouping configuration information getsthe spindle size of\n the specified Item based on flowItemIndex.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param callback Gets the spindle size of the specified Item based on index.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_RegisterGetItemMainSizeCallbackByIndex(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        callback: ::std::option::Option<unsafe extern "C" fn(itemIndex: i32) -> f32>,
    );
}
extern "C" {
    #[doc = " @brief The FlowItem grouping configuration information getsthe spindle size of\n the specified Item based on flowItemIndex.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param userData FlowItem Custom data.\n @param callback Gets the spindle size of the specified Item based on index.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_RegisterGetItemMainSizeCallbackByIndexWithUserData(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(itemIndex: i32, userData: *mut ::std::os::raw::c_void) -> f32,
        >,
    );
}
extern "C" {
    #[doc = " @brief Sets the number of columns (in a vertical layout) or rows (in a horizontal layout) of a water flow.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param crossCount Indicates the number of columns or rows, depending on the layout direction.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetCrossCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        crossCount: i32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the number of columns (in a vertical layout) or rows (in a horizontal layout) in the water flow section\n that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the number of columns or rows.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetCrossCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the gap between columns in the specified water flow section.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param columnGap Indicates the gap between columns to set.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetColumnGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        columnGap: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the gap between columns in the water flow section that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the gap between columns.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetColumnGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the gap between rows in the specified water flow section.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param rowGap Indicates the gap between rows to set.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetRowGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        rowGap: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the gap between rows in the water flow section that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the gap between rows.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetRowGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the margins for the specified water flow section.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @param marginTop Indicates the top margin of the water flow section.\n @param marginRight Indicates the right margin of the water flow section.\n @param marginBottom Indicates the bottom margin of the water flow section.\n @param marginLeft Indicates the left margin of the water flow section.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_SetMargin(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        marginTop: f32,
        marginRight: f32,
        marginBottom: f32,
        marginLeft: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the margins of the water flow section that matches the specified index.\n\n @param option Indicates the pointer to a water flow section configuration.\n @param index Indicates the index of the target water flow section.\n @return Returns the margins.\n @since 12"]
    pub fn OH_ArkUI_WaterFlowSectionOption_GetMargin(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> ArkUI_Margin;
}
extern "C" {
    #[doc = " @brief Creates a navigation indicator.\n\n @param type Indicates the type of the indicator.\n @return Returns the pointer to the new indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_Create(
        type_: ArkUI_SwiperIndicatorType,
    ) -> *mut ArkUI_SwiperIndicator;
}
extern "C" {
    #[doc = " @brief Destroys the pointer to the indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_Dispose(indicator: *mut ArkUI_SwiperIndicator);
}
extern "C" {
    #[doc = " @brief Sets the distance between the navigation point and the start of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the distance between the navigation point and the start of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetStartPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the distance between the navigation point and the start of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the distance between the navigation point and the start of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetStartPosition(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the distance between the navigation point and the top of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the distance between the navigation point and the top of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetTopPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the distance between the navigation point and the top of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the distance between the navigation point and the top of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetTopPosition(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the distance between the navigation point and the right of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the distance between the navigation point and the right of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetEndPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the distance between the navigation point and the end of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the distance between the navigation point and the end of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetEndPosition(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the distance between the navigation point and the bottom of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the distance between the navigation point and the bottom of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetBottomPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the distance between the navigation point and the bottom of the swiper.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the distance between the navigation point and the bottom of the swiper.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetBottomPosition(indicator: *mut ArkUI_SwiperIndicator)
        -> f32;
}
extern "C" {
    #[doc = " @brief Sets the width of the dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the width of the dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetItemWidth(indicator: *mut ArkUI_SwiperIndicator, value: f32);
}
extern "C" {
    #[doc = " @brief Obtains the width of the dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the width of the dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetItemWidth(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the height of the dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the height of the dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetItemHeight(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief  Obtains the height of the dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the height of the dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetItemHeight(indicator: *mut ArkUI_SwiperIndicator) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the width of the selected dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the width of the selected dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetSelectedItemWidth(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief  Obtains the width of the selected dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the width of the selected dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetSelectedItemWidth(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the height of the selected dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param value Indicates the height of the selected dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetSelectedItemHeight(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief  Obtains the height of the selected dot for the dot indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the height of the selected dot for the dot indicator.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetSelectedItemHeight(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets whether to display the mask style of the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param mask Whether to display the mask style. True means to display.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetMask(indicator: *mut ArkUI_SwiperIndicator, mask: i32);
}
extern "C" {
    #[doc = " @brief Obtains whether to display the mask style of the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns whether to display the mask style. True means to display.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetMask(indicator: *mut ArkUI_SwiperIndicator) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the color of the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param color the color of the dot navigation indicator, in 0xARGB format.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetColor(indicator: *mut ArkUI_SwiperIndicator, color: u32);
}
extern "C" {
    #[doc = " @brief Obtains the color of the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the color of the dot navigation indicator, in 0xARGB format.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetColor(indicator: *mut ArkUI_SwiperIndicator) -> u32;
}
extern "C" {
    #[doc = " @brief Sets the color of the selected dot for the navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param color the color of the selected dot, in 0xARGB format.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetSelectedColor(
        indicator: *mut ArkUI_SwiperIndicator,
        selectedColor: u32,
    );
}
extern "C" {
    #[doc = " @brief Obtains the color of the selected dot for the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the color of the selected dot, in 0xARGB format.\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetSelectedColor(indicator: *mut ArkUI_SwiperIndicator) -> u32;
}
extern "C" {
    #[doc = " @brief Sets the number of maxDisplayCount for the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @param maxDisplayCount the maxDisplayCount of the navigation dot, span is 6-9.\n @return {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} indicator is null or maxDisplayCount less then 6 or\n         maxDisplayCount more then 9\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_SetMaxDisplayCount(
        indicator: *mut ArkUI_SwiperIndicator,
        maxDisplayCount: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of maxDisplayCount for the dot navigation indicator.\n\n @param indicator Indicates the pointer to the indicator.\n @return Returns the number of the maxDisplayCount, span is 6-9.\n         0 - indicator is null\n @since 12"]
    pub fn OH_ArkUI_SwiperIndicator_GetMaxDisplayCount(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Create auxiliary line information in the RelativeContaine container.\n\n @param size The number of auxiliary lines.\n @return auxiliary line information.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_Create(size: i32) -> *mut ArkUI_GuidelineOption;
}
extern "C" {
    #[doc = " @brief Destroy auxiliary line information.\n\n @param guideline auxiliary line information.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_Dispose(guideline: *mut ArkUI_GuidelineOption);
}
extern "C" {
    #[doc = " @brief Set the Id of the auxiliary line.\n\n @param guideline auxiliary line information.\n @param value id, must be unique and cannot have the same name as the component in the container.\n @param index auxiliary line index value.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_SetId(
        guideline: *mut ArkUI_GuidelineOption,
        value: *const ::std::os::raw::c_char,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Set the direction of the auxiliary line.\n\n @param guideline auxiliary line information.\n @param value direction.\n @param index auxiliary line index value.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_SetDirection(
        guideline: *mut ArkUI_GuidelineOption,
        value: ArkUI_Axis,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Set the distance from the left or top of the container.\n\n @param guideline auxiliary line information.\n @param value The distance from the left or top of the container.\n @param index auxiliary line index value.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_SetPositionStart(
        guideline: *mut ArkUI_GuidelineOption,
        value: f32,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Set the distance from the right or bottom of the container.\n\n @param guideline auxiliary line information.\n @param value The distance from the right side or bottom of the container.\n @param index auxiliary line index value.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_SetPositionEnd(
        guideline: *mut ArkUI_GuidelineOption,
        value: f32,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the Id of the auxiliary line.\n\n @param guideline auxiliary line information.\n @param index auxiliary line index value.\n @return Id.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_GetId(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the direction of the auxiliary line.\n\n @param guideline auxiliary line information.\n @param index auxiliary line index value.\n @return direction.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_GetDirection(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> ArkUI_Axis;
}
extern "C" {
    #[doc = " @brief Get the distance from the left or top of the container.\n\n @param guideline auxiliary line information.\n @param index auxiliary line index value.\n @return The distance from the left or top of the container.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_GetPositionStart(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Get the distance from the right side or bottom of the container.\n\n @param guideline auxiliary line information.\n @param index auxiliary line index value.\n @return The distance from the right side or bottom of the container.\n @since 12"]
    pub fn OH_ArkUI_GuidelineOption_GetPositionEnd(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief creates barrier information within the RelativeContaine container.\n\n @param size Number of barriers.\n @return barrier information.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_Create(size: i32) -> *mut ArkUI_BarrierOption;
}
extern "C" {
    #[doc = " @brief Destroy barrier information.\n\n @param barrierStyle barrier information.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_Dispose(barrierStyle: *mut ArkUI_BarrierOption);
}
extern "C" {
    #[doc = " @brief Set the Id of the barrier.\n\n @param barrierStyle barrier information.\n @param value id, must be unique and cannot have the same name as the component in the container.\n @param index Barrier index value.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_SetId(
        barrierStyle: *mut ArkUI_BarrierOption,
        value: *const ::std::os::raw::c_char,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Set the direction of the barrier.\n\n @param barrierStyle barrier information.\n @param value direction.\n @param index Barrier index value.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_SetDirection(
        barrierStyle: *mut ArkUI_BarrierOption,
        value: ArkUI_BarrierDirection,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Sets the dependent component of the barrier.\n\n @param barrierStyle barrier information.\n @param value The ID of the dependent component.\n @param index Barrier index value.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_SetReferencedId(
        barrierStyle: *mut ArkUI_BarrierOption,
        value: *const ::std::os::raw::c_char,
        index: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the Id of the barrier.\n\n @param barrierStyle auxiliary line information.\n @param index auxiliary line index value.\n @return The Id of the barrier.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_GetId(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the direction of the barrier.\n\n @param barrierStyle auxiliary line information.\n @param index auxiliary line index value.\n @return The direction of the barrier.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_GetDirection(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
    ) -> ArkUI_BarrierDirection;
}
extern "C" {
    #[doc = " @brief Get the dependent components of the barrier.\n\n @param barrierStyle auxiliary line information.\n @param index auxiliary line index value.\n @param referencedIndex dependent component Id index value.\n @return The barrier's dependent components.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_GetReferencedId(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
        referencedIndex: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the number of dependent components of the barrier.\n\n @param barrierStyle auxiliary line information.\n @param index auxiliary line index value.\n @return The number of dependent components of the barrier.\n @since 12"]
    pub fn OH_ArkUI_BarrierOption_GetReferencedIdSize(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief creates alignment rule information for subcomponents in relative containers.\n\n @return Alignment rule information.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_Create() -> *mut ArkUI_AlignmentRuleOption;
}
extern "C" {
    #[doc = " @brief Destroys the alignment rule information of subcomponents in relative containers.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_Dispose(option: *mut ArkUI_AlignmentRuleOption);
}
extern "C" {
    #[doc = " @brief Set the start alignment parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param value Alignment relative to the anchor component.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetStart(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_HorizontalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the end alignment parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param value Alignment relative to the anchor component.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetEnd(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_HorizontalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the parameters for horizontal center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param value Alignment relative to anchor component\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetCenterHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_HorizontalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the parameters for top alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param value Alignment relative to anchor component\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetTop(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_VerticalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the bottom alignment parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param value Alignment relative to anchor component\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetBottom(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_VerticalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Set the parameters for vertical center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param id The id value of the anchor component.\n @param value Alignment relative to the anchor component.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetCenterVertical(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::std::os::raw::c_char,
        alignment: ArkUI_VerticalAlignment,
    );
}
extern "C" {
    #[doc = " @brief Sets the horizontal offset parameter of the component under the anchor point constraint.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param horizontal bias value in the horizontal direction.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetBiasHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
        horizontal: f32,
    );
}
extern "C" {
    #[doc = " @brief Set the vertical offset parameter of the component under the anchor point constraint.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @param horizontal bias value in the vertical direction.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_SetBiasVertical(
        option: *mut ArkUI_AlignmentRuleOption,
        vertical: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the Id of the start-aligned parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The id value of the anchor component.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetStartId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the alignment of the start-aligned parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the parameters.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetStartAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_HorizontalAlignment;
}
extern "C" {
    #[doc = " @brief Get the end alignment parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return End-aligned parameter id.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetEndId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the end alignment parameter.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the end-aligned parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetEndAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_HorizontalAlignment;
}
extern "C" {
    #[doc = " @brief Gets the parameters of horizontal center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The id of the parameter of horizontal center alignment.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterIdHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the parameters of horizontal center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the horizontally centered alignment parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterAlignmentHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_HorizontalAlignment;
}
extern "C" {
    #[doc = " @brief Get the top-aligned parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return Top aligned parameter id.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetTopId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the top-aligned parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the top-aligned parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetTopAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_VerticalAlignment;
}
extern "C" {
    #[doc = " @brief Get the bottom alignment parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The id of the bottom-aligned parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetBottomId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the bottom alignment parameters.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the bottom-aligned parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetBottomAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_VerticalAlignment;
}
extern "C" {
    #[doc = " @brief Gets the parameters of vertical center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The id of the vertical center alignment parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterIdVertical(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the parameters of vertical center alignment.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The alignment of the vertical center alignment parameter.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterAlignmentVertical(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_VerticalAlignment;
}
extern "C" {
    #[doc = " @brief Get the bias value in the horizontal direction.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return The bias value in the horizontal direction.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetBiasHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Get the bias value in the vertical direction.\n\n @param option Alignment rule information of subcomponents in the relative container.\n @return bias value in vertical direction.\n @since 12"]
    pub fn OH_ArkUI_AlignmentRuleOption_GetBiasVertical(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Create a configuration item for the ListitemSwipeActionItem interface settings.\n\n @return List Item SwipeActionItem configuration item instance. If the object returns a null pointer,\n         it indicates creation failure, and the reason for the failure may be that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_Create() -> *mut ArkUI_ListItemSwipeActionItem;
}
extern "C" {
    #[doc = " @brief Destroy the ListitemSwipeActionItem instance.\n\n @param option List Item SwipeActionItem instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_Dispose(item: *mut ArkUI_ListItemSwipeActionItem);
}
extern "C" {
    #[doc = " @brief Set the layout content of ListItem SwipeActionItem.\n\n @param option List Item SwipeActionItem instance.\n @param builder Layout information.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetContent(
        item: *mut ArkUI_ListItemSwipeActionItem,
        node: ArkUI_NodeHandle,
    );
}
extern "C" {
    #[doc = " @brief Set the threshold for long-distance sliding deletion distance of components.\n\n @param option List Item SwipeActionItem instance.\n @param distance Component long-distance sliding deletion distance threshold.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetActionAreaDistance(
        item: *mut ArkUI_ListItemSwipeActionItem,
        distance: f32,
    );
}
extern "C" {
    #[doc = " @brief Obtain the threshold for long-distance sliding deletion distance of components.\n\n @param option List Item SwipeActionItem instance.\n @return Component long-distance sliding deletion distance threshold. If -1.0f is returned, the return fails.\n         The possible cause of the failure is that the item parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_GetActionAreaDistance(
        item: *mut ArkUI_ListItemSwipeActionItem,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Set the event to be called when a sliding entry enters the deletion area.\n\n @param option List Item SwipeActionItem instance.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnEnterActionArea(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when a sliding entry enters the deletion area.\n\n @param option List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnEnterActionAreaWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set the event to be called when a component enters the long-range deletion area and deletes a ListItem.\n\n @param option List Item SwipeActionItem instance.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnAction(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when a component enters the long-range deletion area and deletes a ListItem.\n\n @param option List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnActionWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set the event to be called when a sliding entry exits the deletion area.\n\n @param option List Item SwipeActionItem instance.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnExitActionArea(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when a sliding entry exits the deletion area.\n\n @param option List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnExitActionAreaWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when the sliding state of a list item changes.\n\n @param option List Item SwipeActionItem instance.\n @param callback Callback Events.\n        swipeActionState The changed state.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnStateChange(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::std::option::Option<
            unsafe extern "C" fn(swipeActionState: ArkUI_ListItemSwipeActionState),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when the sliding state of a list item changes.\n\n @param option List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n        swipeActionState The changed state.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnStateChangeWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                swipeActionState: ArkUI_ListItemSwipeActionState,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    #[doc = " @brief Create a configuration item for the ListitemSwipeActionOption interface settings.\n\n @return List Item SwipeActionOption configuration item instance.If the object returns a null pointer,\n         it indicates a creation failure, and the reason for the failure may be that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_Create() -> *mut ArkUI_ListItemSwipeActionOption;
}
extern "C" {
    #[doc = " @brief Destroy the ListitemSwipeActionOption instance.\n\n @param option List Item SwipeActionOption instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_Dispose(option: *mut ArkUI_ListItemSwipeActionOption);
}
extern "C" {
    #[doc = " @brief Set the layout content on the left (vertical layout) or top (horizontal layout)\n of the ListItem SwipeActionItem.\n\n @param option List Item SwipeActionItem instance.\n @param builder Layout information.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetStart(
        option: *mut ArkUI_ListItemSwipeActionOption,
        item: *mut ArkUI_ListItemSwipeActionItem,
    );
}
extern "C" {
    #[doc = " @brief Set the layout content on the right (vertical layout) or bottom (horizontal layout)\n of the ListItem SwipeActionItem.\n\n @param option List Item SwipeActionItem instance.\n @param builder Layout information.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetEnd(
        option: *mut ArkUI_ListItemSwipeActionOption,
        item: *mut ArkUI_ListItemSwipeActionItem,
    );
}
extern "C" {
    #[doc = " @brief Set the sliding effect.\n\n @param option List Item SwipeActionItem instance.\n @param edgeEffect Sliding effect.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetEdgeEffect(
        option: *mut ArkUI_ListItemSwipeActionOption,
        edgeEffect: ArkUI_ListItemSwipeEdgeEffect,
    );
}
extern "C" {
    #[doc = " @brief Get the sliding effect.\n\n @param option List Item SwipeActionItem instance.\n @return Sliding effect. The default return value is 0. If -1 is returned, the return fails.\n         The possible cause of the failure is that the option parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_GetEdgeEffect(
        option: *mut ArkUI_ListItemSwipeActionOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief The event called when the sliding operation offset changes.\n\n @param option List Item SwipeActionItem instance.\n @param callback Callback Events.\n        offset Slide offset.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetOnOffsetChange(
        option: *mut ArkUI_ListItemSwipeActionOption,
        callback: ::std::option::Option<unsafe extern "C" fn(offset: f32)>,
    );
}
extern "C" {
    #[doc = " @brief Set the event triggered when the sliding operation offset changes.\n\n @param option List Item SwipeActionItem instance.\n @param userData User defined data.\n @param callback Callback Events.\n        offset Slide offset.\n @since 12"]
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetOnOffsetChangeWithUserData(
        option: *mut ArkUI_ListItemSwipeActionOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(offset: f32, userData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Create configuration items for the ListChildrenMainSize interface settings.\n\n @return ListChildrenMainSize configuration item instance.If the object returns a null pointer,\n         it indicates a creation failure, and the reason for the failure may be that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Create() -> *mut ArkUI_ListChildrenMainSize;
}
extern "C" {
    #[doc = " @brief Destroy the ListChildrenMainSize instance.\n\n @param option The ListChildrenMainSize instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Dispose(option: *mut ArkUI_ListChildrenMainSize);
}
extern "C" {
    #[doc = " @brief Set the default size of ChildrenMainSizeOption for the List component.\n\n @param option ListChildrenMainSize instance.\n @param defaultMainSize The default size of the ListItem under the List, measured in vp.\n @return 0 represents success. If defaultMainSize is less than 0 or option is a null pointer, return 401.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_SetDefaultMainSize(
        option: *mut ArkUI_ListChildrenMainSize,
        defaultMainSize: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the default size of ChildrenMainSizeOption for the List component.\n\n @param option ListChildrenMainSize instance.\n @return The default size of the ListItem under the List is 0, measured in vp.\n         When the option is a null pointer, it returns -1.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_GetDefaultMainSize(
        option: *mut ArkUI_ListChildrenMainSize,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Reset the array size of ChildrenMainSizeOption for the List component.\n\n @param option ListChildrenMainSize instance.\n @param totalSize Array size.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Resize(
        option: *mut ArkUI_ListChildrenMainSize,
        totalSize: i32,
    );
}
extern "C" {
    #[doc = " @brief Resize the ChildrenMainSizeOption array operation on the List component.\n\n @param option ListChildrenMainSize instance.\n @param index To modify the starting position of the MainSize array.\n @param deleteCount The number of MainSize arrays to be deleted starting from index.\n @param addCount The number of MainSize arrays to be added starting from index.\n @return 0 represents success. If the function parameter is abnormal, return 401.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Splice(
        option: *mut ArkUI_ListChildrenMainSize,
        index: i32,
        deleteCount: i32,
        addCount: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Update the value of the ChildrenMainSizeOption array in the List component.\n\n @param option ListChildrenMainSize instance.\n @param index To modify the starting position of the MainSize array.\n @param mainSize The actual modified value.\n @return 0 represents success. If the function parameter is abnormal, return 401.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_UpdateSize(
        option: *mut ArkUI_ListChildrenMainSize,
        index: i32,
        mainSize: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the value of the ChildrenMainSizeOption array for the List component.\n\n @param option ListChildrenMainSize instance.\n @param index The index position of the value to be obtained.\n @return The value of the specific position of the array. If the function parameter is abnormal, return -1.\n @since 12"]
    pub fn OH_ArkUI_ListChildrenMainSizeOption_GetMainSize(
        option: *mut ArkUI_ListChildrenMainSize,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Creates measurement information for this custom span.\n\n @return Returns a <b>CustomSpanMeasureInfo</b> instance.\n <br> If the result returns nullptr, there may be out of memory.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMeasureInfo_Create() -> *mut ArkUI_CustomSpanMeasureInfo;
}
extern "C" {
    #[doc = " @brief Disposes of measurement information of this custom span.\n\n @param info The CustomSpanMeasureInfo instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMeasureInfo_Dispose(info: *mut ArkUI_CustomSpanMeasureInfo);
}
extern "C" {
    #[doc = " @brief Obtains the font size of a custom span.\n\n @param info Indicates the pointer to the measurement information of a custom span.\n @return Returns the font size. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMeasureInfo_GetFontSize(
        info: *mut ArkUI_CustomSpanMeasureInfo,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Creates measurement metrics for this custom span.\n\n @return Returns a <b>CustomSpanMetrics</b> instance.\n <br> If the result returns nullptr, there may be out of memory.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMetrics_Create() -> *mut ArkUI_CustomSpanMetrics;
}
extern "C" {
    #[doc = " @brief Disposes of measurement metrics of this custom span.\n\n @param info The CustomSpanMetrics instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMetrics_Dispose(metrics: *mut ArkUI_CustomSpanMetrics);
}
extern "C" {
    #[doc = " @brief Sets the width for a custom span.\n\n @param metrics Indicates the pointer to a <b>CustomSpanMetrics</b> instance.\n @param width Indicates the width, in px. The width should be greater than 0.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMetrics_SetWidth(
        metrics: *mut ArkUI_CustomSpanMetrics,
        width: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the height for a custom span.\n\n @param metrics Indicates the pointer to a <b>CustomSpanMetrics</b> instance.\n @param width Indicates the height, in px. The width should be greater than 0.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanMetrics_SetHeight(
        metrics: *mut ArkUI_CustomSpanMetrics,
        height: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Creates drawing information for this custom span.\n\n @return Returns a <b>CustomSpanDrawInfo</b> instance.\n <br> If the result returns nullptr, there may be out of memory.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_Create() -> *mut ArkUI_CustomSpanDrawInfo;
}
extern "C" {
    #[doc = " @brief Disposes of drawing information for this custom span.\n\n @param info The CustomSpanDrawInfo instance to be destroyed.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_Dispose(info: *mut ArkUI_CustomSpanDrawInfo);
}
extern "C" {
    #[doc = " @brief Obtains the x-axis offset of the custom span relative to the mounted component.\n\n @param info Indicates the pointer to the drawing information of a custom span.\n @return Returns the x-axis offset. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetXOffset(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the top margin of the custom span relative to the mounted component.\n\n @param info Indicates the pointer to the drawing information of a custom span.\n @return Returns the top margin. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetLineTop(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the bottom margin of the custom span relative to the mounted component.\n\n @param info Indicates the pointer to the drawing information of a custom span.\n @return Returns the bottom margin. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetLineBottom(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the baseline offset of the custom span relative to the mounted component.\n\n @param info Indicates the pointer to the drawing information of a custom span.\n @return Returns the baseline offset. If a parameter error occurs, <b>0.0f</b> is returned.\n <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetBaseline(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
}
extern "C" {
    #[doc = " @brief Create a image frame from the image path.\n @param src Indicates the image path.\n @return Returns the pointer to the image frame object.\n If a null pointer is returned, the object fails to be created. The possible cause is that\n the src parameter is abnormal, for example, the pointer is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_CreateFromString(
        src: *mut ::std::os::raw::c_char,
    ) -> *mut ArkUI_ImageAnimatorFrameInfo;
}
extern "C" {
    #[doc = " @brief Create a image frame from the drawable descriptor.\n\n @param drawable Indicates the pointer to the drawable descriptor.\n @return Returns the pointer to the image frame object.\n If a null pointer is returned, the object fails to be created. The possible cause is that\n the drawable parameter is abnormal, for example, the pointer is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_CreateFromDrawableDescriptor(
        drawable: *mut ArkUI_DrawableDescriptor,
    ) -> *mut ArkUI_ImageAnimatorFrameInfo;
}
extern "C" {
    #[doc = " @brief Destroy the pointer to the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_Dispose(imageInfo: *mut ArkUI_ImageAnimatorFrameInfo);
}
extern "C" {
    #[doc = " @brief Set the width of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param width Indicates the width of the image frame, and the unit is PX.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetWidth(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        width: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the width of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Return the width of the image frame, and the unit is PX. Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetWidth(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the height of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param height Indicates the height of the image frame, and the unit is PX.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetHeight(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        height: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the height of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Return the height of the image frame, and the unit is PX. Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetHeight(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the vertical coordinate of the image relative to the upper left corner of the widget.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param top Indicates the vertical coordinate of the image relative to the upper left corner of the widget,\n and the unit is PX.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetTop(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        top: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the vertical coordinate of the image relative to the upper left corner of the widget.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Returns the vertical coordinate of the image relative to the upper left corner of the widget,\n and the unit is PX. Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetTop(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the horizontal coordinate of the image relative to the upper left corner of the widget.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param left Indicates the horizontal coordinate of the image relative to the upper left corner of the widget,\n and the unit is PX.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetLeft(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        left: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the horizontal coordinate of the image relative to the upper left corner of the widget.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Returns the horizontal coordinate of the image relative to the upper left corner of the widget,\n and the unit is PX. Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetLeft(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the playback duration of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @param duration Indicates the playback duration of each image frame, and the unit is milliseconds.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetDuration(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        duration: i32,
    );
}
extern "C" {
    #[doc = " @brief Get the playback duration of the image frame.\n\n @param imageInfo Indicates the pointer to the image frame.\n @return Returns the playback duration of the image frame, and the unit is milliseconds.\n Return 0 when the imageInfo is null.\n @since 12"]
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetDuration(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Create accessibility state.\n\n @return Returns the pointer to the accessibility state object.\n If a null pointer is returned, the object fails to be created. The possible cause is that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_Create() -> *mut ArkUI_AccessibilityState;
}
extern "C" {
    #[doc = " @brief Dispose accessibility state.\n\n @param state accessibility state object.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_Dispose(state: *mut ArkUI_AccessibilityState);
}
extern "C" {
    #[doc = " @brief Set accessibility state disabled.\n\n @param state accessibility state object.\n @param isDisabled accessibility state disabled, Value 1 indicates disabled and 0 indicates enbled.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_SetDisabled(
        state: *mut ArkUI_AccessibilityState,
        isDisabled: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility state disabled.\n\n @param state accessibility state object.\n @return accessibility state disabled, Value 1 indicates disabled and 0 indicates enbled. The default value is 0.\n         If the function parameter is abnormal, return the default value.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_IsDisabled(state: *mut ArkUI_AccessibilityState) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility state selected.\n\n @param state accessibility state object.\n @param isSelected accessibility state selected, Value 1 indicates selected, and 0 indicates not selected.\n        The default value is 0.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_SetSelected(
        state: *mut ArkUI_AccessibilityState,
        isSelected: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility state selected.\n\n @param state accessibility state object.\n @return accessibility state selected, Value 1 indicates selected, and 0 indicates not selected.\n         The default value is 0.\n         If the function parameter is abnormal, return the default value.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_IsSelected(state: *mut ArkUI_AccessibilityState) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility checked state.\n\n @param state accessibility state object.\n @param checkedState checked state, and uses the {@link ArkUI_AccessibilityCheckedState} enumeration value,\n        The default value is ARKUI_ACCESSIBILITY_UNCHECKED.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_SetCheckedState(
        state: *mut ArkUI_AccessibilityState,
        checkedState: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility checked state.\n\n @param state accessibility state object.\n @return checked state, and uses the {@link ArkUI_AccessibilityCheckedState} enumeration value,\n         The default value is ARKUI_ACCESSIBILITY_UNCHECKED.\n         If the function parameter is abnormal, return the default value.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityState_GetCheckedState(state: *mut ArkUI_AccessibilityState)
        -> i32;
}
extern "C" {
    #[doc = " @brief Create accessibility value.\n\n @return Returns the pointer to the accessibility state object.\n If a null pointer is returned, the object fails to be created. The possible cause is that the address space is full.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_Create() -> *mut ArkUI_AccessibilityValue;
}
extern "C" {
    #[doc = " @brief Dispose accessibility value.\n\n @param value accessibility value object.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_Dispose(value: *mut ArkUI_AccessibilityValue);
}
extern "C" {
    #[doc = " @brief Set accessibility minimum value.\n\n @param value accessibility value object.\n @param min minimum value based on range components, The default value is -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_SetMin(value: *mut ArkUI_AccessibilityValue, min: i32);
}
extern "C" {
    #[doc = " @brief Get accessibility minimum value.\n\n @param value accessibility value object.\n @return minimum value based on range components, The default value is -1.\n         If the function parameter is abnormal, return -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_GetMin(value: *mut ArkUI_AccessibilityValue) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility minimum value.\n\n @param value accessibility value object.\n @param max maximum value based on range components, The default value is -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_SetMax(value: *mut ArkUI_AccessibilityValue, max: i32);
}
extern "C" {
    #[doc = " @brief Get accessibility minimum value.\n\n @param value accessibility value object.\n @return maximum value based on range components, The default value is -1.\n         If the function parameter is abnormal, return -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_GetMax(value: *mut ArkUI_AccessibilityValue) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility current value.\n\n @param value accessibility value object.\n @param current value based on range components, The default value is -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_SetCurrent(
        value: *mut ArkUI_AccessibilityValue,
        current: i32,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility current value.\n\n @param value accessibility value object.\n @return current value based on range components, The default value is -1.\n         If the function parameter is abnormal, return -1.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_GetCurrent(value: *mut ArkUI_AccessibilityValue) -> i32;
}
extern "C" {
    #[doc = " @brief Set accessibility text value.\n\n @param value accessibility value object.\n @param text The textual description information of the component, which defaults to an empty string.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_SetText(
        value: *mut ArkUI_AccessibilityValue,
        text: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Get accessibility text value.\n\n @param value accessibility value object.\n @return The textual description information of the component, which defaults to an empty string;\n         If the function parameter is abnormal, return null.\n @since 12"]
    pub fn OH_ArkUI_AccessibilityValue_GetText(
        value: *mut ArkUI_AccessibilityValue,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Destroy the instance of Customs Property.\n\n @param handle The instance of Customs Property to be destroyed.\n @since 14"]
    pub fn OH_ArkUI_CustomProperty_Destroy(handle: *mut ArkUI_CustomProperty);
}
extern "C" {
    #[doc = " @brief Get custom attribute value information.\n\n @param handle Custom attribute object pointer.\n @return Customize the value information within the attribute structure.\n @since 14"]
    pub fn OH_ArkUI_CustomProperty_GetStringValue(
        handle: *mut ArkUI_CustomProperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get window name from HostWindowInfo.\n\n @param info HostWindowInfo object pointer.\n @return Window name in HostWindowInfo.\n @since 15"]
    pub fn OH_ArkUI_HostWindowInfo_GetName(
        info: *mut ArkUI_HostWindowInfo,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Destroy the instance of HostWindowInfo.\n\n @param info Instance of HostWindowInfo to be destroyed.\n @since 15"]
    pub fn OH_ArkUI_HostWindowInfo_Destroy(info: *mut ArkUI_HostWindowInfo);
}
extern "C" {
    #[doc = " @brief Destroy ActiveChildenInfo instance.\n\n @param handle ActiveChild instance to be destroyed.\n @since 14"]
    pub fn OH_ArkUI_ActiveChildrenInfo_Destroy(handle: *mut ArkUI_ActiveChildrenInfo);
}
extern "C" {
    #[doc = " @brief Retrieve the child nodes of ActiveChildenInfo with the structure index.\n\n @param handle The ActiveChildenInfo instance for obtaining information.\n @param index The index of child nodes.\n @return The child node pointer corresponding to the index. Return nullptr in case of exception.\n @since 14"]
    pub fn OH_ArkUI_ActiveChildrenInfo_GetNodeByIndex(
        handle: *mut ArkUI_ActiveChildrenInfo,
        index: i32,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Retrieve the number of nodes within the structure of ActiveChildenInfo.\n\n @param handle The ActiveChildenInfo instance for obtaining information.\n @return Number of child nodes. Default value: 0.\n @since 14"]
    pub fn OH_ArkUI_ActiveChildrenInfo_GetCount(handle: *mut ArkUI_ActiveChildrenInfo) -> i32;
}
extern "C" {
    #[doc = " @brief Create linear progress indicator style information.\n\n @return Returns a <b>ProgressLinearStyleOption</b> instance.\n <br> If the result returns nullptr, there may be out of memory.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_Create() -> *mut ArkUI_ProgressLinearStyleOption;
}
extern "C" {
    #[doc = " @brief Destroy linear progress indicator style information.\n\n @param option Linear progress indicator style information.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_Destroy(option: *mut ArkUI_ProgressLinearStyleOption);
}
extern "C" {
    #[doc = " @brief Set whether the scan effect is enabled.\n\n @param option Linear progress indicator style information.\n @param enabled Whether to enable the scan effect. Default value: false.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_SetScanEffectEnabled(
        option: *mut ArkUI_ProgressLinearStyleOption,
        enabled: bool,
    );
}
extern "C" {
    #[doc = " @brief Set whether smoothing effect is enabled.\n\n @param option Linear progress indicator style information.\n @param enabled Whether to enable the smooth effect. When this effect is enabled, the progress change to\n the set value takes place gradually. Otherwise, it takes place immediately. Default value: true.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_SetSmoothEffectEnabled(
        option: *mut ArkUI_ProgressLinearStyleOption,
        enabled: bool,
    );
}
extern "C" {
    #[doc = " @brief Set linear progress indicator stroke width.\n\n @param option Linear progress indicator style information.\n @param strokeWidth Stroke width of the progress indicator. It cannot be set in percentage.\n Default value: 4.0vp.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_SetStrokeWidth(
        option: *mut ArkUI_ProgressLinearStyleOption,
        strokeWidth: f32,
    );
}
extern "C" {
    #[doc = " @brief Set linear progress indicator stroke radius.\n\n @param option Linear progress indicator style information.\n @param strokeRadius Rounded corner radius of the progress indicator. Value range: [0, strokeWidth/2].\n Default value: strokeWidth/2.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_SetStrokeRadius(
        option: *mut ArkUI_ProgressLinearStyleOption,
        strokeRadius: f32,
    );
}
extern "C" {
    #[doc = " @brief Get whether scan effect is enable.\n\n @param option Linear progress indicator style information.\n @return Whether to enable the scan effect.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_GetScanEffectEnabled(
        option: *mut ArkUI_ProgressLinearStyleOption,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get whether smoothing effect is enabled.\n\n @param option Linear progress indicator style information.\n @return Whether to enable the smooth effect.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_GetSmoothEffectEnabled(
        option: *mut ArkUI_ProgressLinearStyleOption,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get linear progress indicator stroke width.\n\n @param option Linear progress indicator style information.\n @return Stroke width of the progress indicator.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_GetStrokeWidth(
        option: *mut ArkUI_ProgressLinearStyleOption,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Get linear progress indicator stroke radius.\n\n @param option Linear progress indicator style information.\n @return Rounded corner radius of the progress indicator.\n @since 15"]
    pub fn OH_ArkUI_ProgressLinearStyleOption_GetStrokeRadius(
        option: *mut ArkUI_ProgressLinearStyleOption,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Creates an option for taking snapshot, the returned value must be released through\n        {@link OH_ArkUI_DestroySnapshotOptions} when it's not used anymore.\n\n @return Returns the pointer to the created snapshot options object.If the object returns a null pointer,\n         it indicates a creation failure, and the reason for the failure may be that the address space is full.\n @since 15"]
    pub fn OH_ArkUI_CreateSnapshotOptions() -> *mut ArkUI_SnapshotOptions;
}
extern "C" {
    #[doc = " @brief Dispose a snapshot option object.\n\n @param snapshotOptions Indicates the pointer to the snapshot option.\n @since 15"]
    pub fn OH_ArkUI_DestroySnapshotOptions(snapshotOptions: *mut ArkUI_SnapshotOptions);
}
extern "C" {
    #[doc = " @brief Config the snapshot option with scale.\n\n @param snapshotOptions Indicates the pointer to the snapshot option.\n @param scale Indicates the scale property to take the snapshot.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_SnapshotOptions_SetScale(
        snapshotOptions: *mut ArkUI_SnapshotOptions,
        scale: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Create a cross-language option instance.\n\n @return Returns a cross-language option instance. If the result is a null pointer, it may be out of memory.\n @since 15"]
    pub fn OH_ArkUI_CrossLanguageOption_Create() -> *mut ArkUI_CrossLanguageOption;
}
extern "C" {
    #[doc = " @brief Destroy the cross-language option instance.\n\n @param option The cross-language option instance.\n @since 15"]
    pub fn OH_ArkUI_CrossLanguageOption_Destroy(option: *mut ArkUI_CrossLanguageOption);
}
extern "C" {
    #[doc = " @brief Enable the attribute setting in the cross-language option.\n\n @param option The cross-language option.\n @param enabled The attribute setting in the cross-language option.\n Default value: false.\n @since 15"]
    pub fn OH_ArkUI_CrossLanguageOption_SetAttributeSettingStatus(
        option: *mut ArkUI_CrossLanguageOption,
        enabled: bool,
    );
}
extern "C" {
    #[doc = " @brief Get the attribute setting enable of the cross-language option.\n\n @param option The cross-language option.\n @return The attribute setting enable of the cross-language option.\n @since 15"]
    pub fn OH_ArkUI_CrossLanguageOption_GetAttributeSettingStatus(
        option: *mut ArkUI_CrossLanguageOption,
    ) -> bool;
}
#[doc = " @brief Defines the region of the image source to decode.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_Region {
    #[doc = " X coordinate of the start point, in pixels."]
    pub x: u32,
    #[doc = " Y coordinate of the start point, in pixels."]
    pub y: u32,
    #[doc = " Width of the region, in pixels."]
    pub width: u32,
    #[doc = " Height of the region, in pixels."]
    pub height: u32,
}
#[doc = " @brief Defines the region of the image source to decode.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_String {
    #[doc = " data for string type"]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = " data lenth for string type"]
    pub size: usize,
}
#[doc = " @brief Define a PictureMetadata struct type, used for picture metadata.\n\n @since 13"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PictureMetadata {
    _unused: [u8; 0],
}
#[doc = " operation success"]
pub const Image_ErrorCode_IMAGE_SUCCESS: Image_ErrorCode = 0;
#[doc = " invalid parameter"]
pub const Image_ErrorCode_IMAGE_BAD_PARAMETER: Image_ErrorCode = 401;
#[doc = " unsupported mime type"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_MIME_TYPE: Image_ErrorCode = 7600101;
#[doc = " unknown mime type"]
pub const Image_ErrorCode_IMAGE_UNKNOWN_MIME_TYPE: Image_ErrorCode = 7600102;
#[doc = " too large data or image"]
pub const Image_ErrorCode_IMAGE_TOO_LARGE: Image_ErrorCode = 7600103;
#[doc = " @error DMA memory does not exist"]
pub const Image_ErrorCode_IMAGE_DMA_NOT_EXIST: Image_ErrorCode = 7600173;
#[doc = " @error DMA operation failed"]
pub const Image_ErrorCode_IMAGE_DMA_OPERATION_FAILED: Image_ErrorCode = 7600174;
#[doc = " unsupported operations"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_OPERATION: Image_ErrorCode = 7600201;
#[doc = " unsupported metadata"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_METADATA: Image_ErrorCode = 7600202;
#[doc = " unsupported conversion"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_CONVERSION: Image_ErrorCode = 7600203;
#[doc = " invalid region"]
pub const Image_ErrorCode_IMAGE_INVALID_REGION: Image_ErrorCode = 7600204;
#[doc = "  @error unsupported memory format\n  @since 13"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_MEMORY_FORMAT: Image_ErrorCode = 7600205;
#[doc = " failed to allocate memory"]
pub const Image_ErrorCode_IMAGE_ALLOC_FAILED: Image_ErrorCode = 7600301;
#[doc = " memory copy failed"]
pub const Image_ErrorCode_IMAGE_COPY_FAILED: Image_ErrorCode = 7600302;
#[doc = " @error memory lock or unlock failed\n @since 15"]
pub const Image_ErrorCode_IMAGE_LOCK_UNLOCK_FAILED: Image_ErrorCode = 7600303;
#[doc = " unknown error"]
pub const Image_ErrorCode_IMAGE_UNKNOWN_ERROR: Image_ErrorCode = 7600901;
#[doc = " decode data source exception"]
pub const Image_ErrorCode_IMAGE_BAD_SOURCE: Image_ErrorCode = 7700101;
#[doc = " @error unsupported mime type\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_MIME_TYPE: Image_ErrorCode = 7700102;
#[doc = " @error image to large\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_TOO_LARGE: Image_ErrorCode = 7700103;
#[doc = " @error unsupported allocator type, e.g., use share memory to decode a HDR image as only\n DMA supported hdr metadata.\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_ALLOCATOR_TYPE: Image_ErrorCode = 7700201;
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_OPTIONS: Image_ErrorCode = 7700203;
#[doc = " decode failed"]
pub const Image_ErrorCode_IMAGE_DECODE_FAILED: Image_ErrorCode = 7700301;
#[doc = " @error memory allocation failed\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_ALLOC_FAILED: Image_ErrorCode = 7700302;
#[doc = " encode failed"]
pub const Image_ErrorCode_IMAGE_ENCODE_FAILED: Image_ErrorCode = 7800301;
#[doc = " @brief Enumerates the return values that may be used by the interface.\n\n @since 12"]
pub type Image_ErrorCode = ::std::os::raw::c_uint;
pub const Image_MetadataType_EXIF_METADATA: Image_MetadataType = 1;
pub const Image_MetadataType_FRAGMENT_METADATA: Image_MetadataType = 2;
#[doc = " @brief Define the metadata type.\n\n @since 13"]
pub type Image_MetadataType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Creates a <b>PictureMetadata</b> object.\n\n @param metadataType The type of metadata.\n @param metadata The PictureMetadata pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n @since 13"]
    pub fn OH_PictureMetadata_Create(
        metadataType: Image_MetadataType,
        metadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the property of picture metadata.\n\n @param metadata The PictureMetadata pointer will be operated.\n @param key The property's key.\n @param value The property's value.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    pub fn OH_PictureMetadata_GetProperty(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set picture metadata property.\n\n @param metadata The PictureMetadata pointer will be operated.\n @param key The property's key.\n @param value The property's value.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    pub fn OH_PictureMetadata_SetProperty(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases this PictureMetadata object.\n\n @param metadata The PictureMetadata pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n @since 13"]
    pub fn OH_PictureMetadata_Release(metadata: *mut OH_PictureMetadata) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains a clone of metadata.\n\n @param oldMetadata The PictureMetadata pointer will be operated.\n @param newMetadata The PictureMetadata pointer will be cloned.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n         {@link IMAGE_ALLOC_FAILED} memory alloc failed.\n         {@link IMAGE_COPY_FAILED} memory copy failed.\n @since 13"]
    pub fn OH_PictureMetadata_Clone(
        oldMetadata: *mut OH_PictureMetadata,
        newMetadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
#[doc = " @brief Define a native buffer type, used for retrieving a native buffer.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_NativeBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_NativeColorSpaceManager {
    _unused: [u8; 0],
}
#[doc = " Nearest-neighbor interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_NONE:
    OH_PixelmapNative_AntiAliasingLevel = 0;
#[doc = " Bilinear interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_LOW:
    OH_PixelmapNative_AntiAliasingLevel = 1;
#[doc = " Bilinear interpolation algorithm with mipmap linear filtering"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_MEDIUM:
    OH_PixelmapNative_AntiAliasingLevel = 2;
#[doc = " Cubic interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_HIGH:
    OH_PixelmapNative_AntiAliasingLevel = 3;
#[doc = " @brief Defines the anti-aliasing level.\n\n @since 12"]
pub type OH_PixelmapNative_AntiAliasingLevel = ::std::os::raw::c_uint;
#[doc = " Indicate the types of metadata that image needs to use."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_METADATA_TYPE: OH_Pixelmap_HdrMetadataKey = 0;
#[doc = " Static metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_STATIC_METADATA: OH_Pixelmap_HdrMetadataKey = 1;
#[doc = " Dynamic metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_DYNAMIC_METADATA: OH_Pixelmap_HdrMetadataKey = 2;
#[doc = " Gainmap metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_GAINMAP_METADATA: OH_Pixelmap_HdrMetadataKey = 3;
#[doc = " @brief Enumerates the HDR metadata types that need to be stored in Pixelmap.\n\n @since 12"]
pub type OH_Pixelmap_HdrMetadataKey = ::std::os::raw::c_uint;
#[doc = " No metadata."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_NONE: OH_Pixelmap_HdrMetadataType = 0;
#[doc = " Indicates that metadata will be used for the base image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_BASE: OH_Pixelmap_HdrMetadataType = 1;
#[doc = " Indicates that metadata will be used for the gainmap image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_GAINMAP: OH_Pixelmap_HdrMetadataType = 2;
#[doc = " Indicates that metadata will be used for the alternate image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_ALTERNATE: OH_Pixelmap_HdrMetadataType = 3;
#[doc = " @brief Value for HDR_METADATA_TYPE.\n\n @since 12"]
pub type OH_Pixelmap_HdrMetadataType = ::std::os::raw::c_uint;
#[doc = " @brief Value for HDR_STATIC_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrStaticMetadata {
    #[doc = " The X-coordinate of the primary colors. The length of the array is three. Store in the order of r, g, b."]
    pub displayPrimariesX: [f32; 3usize],
    #[doc = " The Y-coordinate of the primary colors. The length of the array is three. Store in the order of r, g, b."]
    pub displayPrimariesY: [f32; 3usize],
    #[doc = " The X-coordinate of the white point value."]
    pub whitePointX: f32,
    #[doc = " The Y-coordinate of the white point value."]
    pub whitePointY: f32,
    #[doc = " Max luminance."]
    pub maxLuminance: f32,
    #[doc = " Min luminance."]
    pub minLuminance: f32,
    #[doc = " Maximum brightness of displayed content."]
    pub maxContentLightLevel: f32,
    #[doc = " Maximum average brightness of displayed content."]
    pub maxFrameAverageLightLevel: f32,
}
#[doc = " @brief Value for HDR_DYNAMIC_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrDynamicMetadata {
    #[doc = " The value of dynamic metadata."]
    pub data: *mut u8,
    #[doc = " The length of dynamic metadata."]
    pub length: u32,
}
#[doc = " @brief Value for HDR_GAINMAP_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrGainmapMetadata {
    #[doc = " The version used by the writer."]
    pub writerVersion: u16,
    #[doc = " The minimum version a parser needs to understand."]
    pub miniVersion: u16,
    #[doc = " The number of gain map channels, with a value of 1 or 3."]
    pub gainmapChannelNum: u8,
    #[doc = " Indicate whether to use the color space of the base image."]
    pub useBaseColorFlag: bool,
    #[doc = " The baseline hdr headroom."]
    pub baseHeadroom: f32,
    #[doc = " The alternate hdr headroom."]
    pub alternateHeadroom: f32,
    #[doc = " The per-component max gain map values."]
    pub gainmapMax: [f32; 3usize],
    #[doc = " The per-component min gain map values."]
    pub gainmapMin: [f32; 3usize],
    #[doc = " The per-component gamma values."]
    pub gamma: [f32; 3usize],
    #[doc = " The per-component baseline offset."]
    pub baselineOffset: [f32; 3usize],
    #[doc = " The per-component alternate offset."]
    pub alternateOffset: [f32; 3usize],
}
#[doc = " @brief Value for HDR_METADATA_KEY. Corresponding relationship with HDR_METADATA_KEY.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrMetadataValue {
    #[doc = " The value corresponding to the HDR_METADATA_TYPE key"]
    pub type_: OH_Pixelmap_HdrMetadataType,
    #[doc = " The value corresponding to the HDR_STATIC_METADATA key"]
    pub staticMetadata: OH_Pixelmap_HdrStaticMetadata,
    #[doc = " The value corresponding to the HDR_DYNAMIC_METADATA key"]
    pub dynamicMetadata: OH_Pixelmap_HdrDynamicMetadata,
    #[doc = " The value corresponding to the HDR_GAINMAP_METADATA key"]
    pub gainmapMetadata: OH_Pixelmap_HdrGainmapMetadata,
}
#[doc = " @brief Defines the options used for creating a pixel map.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_InitializationOptions {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create a for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_Create(
        options: *mut *mut OH_Pixelmap_InitializationOptions,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get width number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param width the number of image width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetWidth(
        options: *mut OH_Pixelmap_InitializationOptions,
        width: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set width number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param width the number of image width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetWidth(
        options: *mut OH_Pixelmap_InitializationOptions,
        width: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get height number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param height the number of image height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetHeight(
        options: *mut OH_Pixelmap_InitializationOptions,
        height: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set height number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param height the number of image height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetHeight(
        options: *mut OH_Pixelmap_InitializationOptions,
        height: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelFormat: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param srcpixelFormat the number of image srcpixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetSrcPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        srcpixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param srcpixelFormat the number of image srcpixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetSrcPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        srcpixelFormat: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get rowStride for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param rowStride the rowStride of image buffer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if rowStride is null.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe options is released.\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetRowStride(
        options: *mut OH_Pixelmap_InitializationOptions,
        rowStride: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set rowStride number for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param rowStride the rowStride of image buffer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if rowStride does not match width.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe options is released.\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetRowStride(
        options: *mut OH_Pixelmap_InitializationOptions,
        rowStride: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get alphaType number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param alphaType the number of image alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetAlphaType(
        options: *mut OH_Pixelmap_InitializationOptions,
        alphaType: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set alphaType number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param alphaType the number of image alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetAlphaType(
        options: *mut OH_Pixelmap_InitializationOptions,
        alphaType: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief delete InitializationOtions pointer.\n\n @param options The InitializationOtions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_Release(
        options: *mut OH_Pixelmap_InitializationOptions,
    ) -> Image_ErrorCode;
}
#[doc = " @brief Defines the pixel map information.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_ImageInfo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create imageinfo struct  .\n\n @param info The imageinfo pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_Create(info: *mut *mut OH_Pixelmap_ImageInfo) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get width number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param width The number of imageinfo width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetWidth(
        info: *mut OH_Pixelmap_ImageInfo,
        width: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get height number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param height The number of imageinfo height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetHeight(
        info: *mut OH_Pixelmap_ImageInfo,
        height: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get rowStride number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param rowStride The number of imageinfo rowStride.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetRowStride(
        info: *mut OH_Pixelmap_ImageInfo,
        rowStride: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param pixelFormat The number of imageinfo pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetPixelFormat(
        info: *mut OH_Pixelmap_ImageInfo,
        pixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get alphaType number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param alphaType The number of imageinfo alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetAlphaType(
        info: *mut OH_Pixelmap_ImageInfo,
        alphaType: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get isHdr boolean for imageinfo struct.\n\n @param info The imageinfo pointer will be operated. Pointer connot be null.\n @param isHdr Whether the image has a high dynamic range.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetDynamicRange(
        info: *mut OH_Pixelmap_ImageInfo,
        isHdr: *mut bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Delete imageinfo struct pointer.\n\n @param info The imageinfo pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_Release(info: *mut OH_Pixelmap_ImageInfo) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a <b>PixelMap</b> object.\n\n @param data Color buffer in BGRA_8888 format.\n @param dataLength Color buffer size in BGRA_8888 format.\n @param options IPixel properties, including the alpha type, size, pixel format, and editable.\n @param pixelmap Pixelmap pointer for created.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_CreatePixelmap(
        data: *mut u8,
        dataLength: usize,
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert a native <b>PixelMap</b> object to <b>PixelMap</b> napi object.\n\n @param env Indicates the NAPI environment pointer.\n @param pixelmapNative Indicates a pointer to the <b>PixelMap</b> object created at the native layer.\n @param pixelmapNapi the <b>PixelMap</b> pointer will be converted.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} pixelmapNative is nullptr\n @since 12"]
    pub fn OH_PixelmapNative_ConvertPixelmapNativeToNapi(
        env: napi_env,
        pixelmapNative: *mut OH_PixelmapNative,
        pixelmapNapi: *mut napi_value,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert a <b>PixelMap</b> napi object to native <b>PixelMap</b> object.\n\n @param env Indicates the NAPI environment pointer.\n @param pixelmapNapi Indicates napi <b>PixelMap</b> object.\n @param pixelmapNative Indicates native <b>PixelMap</b> pointer to created.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} pixelmapNative is nullptr, or pixelmapNapi is not a PixelMap\n @since 12"]
    pub fn OH_PixelmapNative_ConvertPixelmapNativeFromNapi(
        env: napi_env,
        pixelmapNapi: napi_value,
        pixelmapNative: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Reads data of this pixel map to an Buffer. If this pixel map is created in the BGRA_8888 format,\n the data read is the same as the original data.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param destination Buffer to which the image pixel map data will be written.\n @param bufferSize Buffer size to which the image pixel map data will be written.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_ReadPixels(
        pixelmap: *mut OH_PixelmapNative,
        destination: *mut u8,
        bufferSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Reads image data in an Buffer and writes the data to a Pixelmap object.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param source Buffer from which the image data will be read.\n @param bufferSize Buffer size from which the image data will be read.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_WritePixels(
        pixelmap: *mut OH_PixelmapNative,
        source: *mut u8,
        bufferSize: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get argb pixel buffer from pixelmap.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param destination Buffer to which the image pixel map data will be written.\n @param bufferSize Buffer size to which the image pixel map data will be written.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, destination and bufferSize are incorrect.\n         {@link IMAGE_UNSUPPORTED_CONVERSION} If format does not support conversion to argb or conversion failed.\n         {@link IMAGE_ALLOC_FAILED} If device has no memory.\n         {@link IMAGE_COPY_FAILED} If memory copy failed.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_GetArgbPixels(
        pixelmap: *mut OH_PixelmapNative,
        destination: *mut u8,
        bufferSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert {@link OH_PixelmapNative} to standard dynamic range.\n\n @param pixelmap The Pixelmap pointer will be operated. Pointer connot be null.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n returns {@link Image_ErrorCode} IMAGE_UNSUPPORTED_OPERATION - Unsupported operation.Pixelmap can't be converted.\n @since 12"]
    pub fn OH_PixelmapNative_ToSdr(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains pixel map information of this image.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param imageInfo Indicates the pointer to the image information.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_GetImageInfo(
        pixelmap: *mut OH_PixelmapNative,
        imageInfo: *mut OH_Pixelmap_ImageInfo,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets an opacity rate for this image pixel map.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param rate Opacity rate to set. The value ranges from 0 to 1.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Opacity(
        pixelmap: *mut OH_PixelmapNative,
        rate: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Scales this image based on the input width and height.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Scale(
        pixelmap: *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Scales this image based on the input width and height with anti-aliasing.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @param level The anti-aliasing algorithm to be used.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, x and y are incorrect.\n returns {@link Image_ErrorCode} IMAGE_TOO_LARGE - if image is too large.\n returns {@link Image_ErrorCode} IMAGE_ALLOC_FAILED - if device has no memory.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe source pixelmap is released.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_ScaleWithAntiAliasing(
        pixelmap: *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
        level: OH_PixelmapNative_AntiAliasingLevel,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Translates this image based on the input coordinates.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param x The distance to be translate in the X direction.\n @param y The distance to be translate in the Y direction.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Translate(
        pixelmap: *mut OH_PixelmapNative,
        x: f32,
        y: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Rotates this image based on the input angle.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param angle Angle to rotate.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Rotate(
        pixelmap: *mut OH_PixelmapNative,
        angle: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Flips this image horizontally or vertically, or both.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param shouldFilpHorizontally Whether to flip the image horizontally.\n @param shouldFilpVertically Whether to flip the image vertically.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Flip(
        pixelmap: *mut OH_PixelmapNative,
        shouldFilpHorizontally: bool,
        shouldFilpVertically: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Crops this image based on the input size.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param region Area size, read according to area.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Crop(
        pixelmap: *mut OH_PixelmapNative,
        region: *mut Image_Region,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases an <b>OH_Pixelmap</b> object.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Release(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Converting images to alpha format\n\n @param srcpixelmap The source pixel map pointer will be operated.\n @param dstpixelmap The destination pixel map pointer will be operated.\n @param isPremul Whether it is pre-multiplied, true for prediction, false for non-pre-multiplied.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_ConvertAlphaFormat(
        srcpixelmap: *mut OH_PixelmapNative,
        dstpixelmap: *mut OH_PixelmapNative,
        isPremul: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Create a empty <b>PixelMap</b> object.\n\n @param options IPixel properties, including the alpha type, size, pixel format, and editable.\n @param pixelmap Pixelmap pointer for created.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_CreateEmptyPixelmap(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get metadata.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param key Type of metadata.\n @param value Value of metadata.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, key and value are incorrect.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory does not exist.\n returns {@link Image_ErrorCode} IMAGE_COPY_FAILED - if memory copy failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_GetMetadata(
        pixelmap: *mut OH_PixelmapNative,
        key: OH_Pixelmap_HdrMetadataKey,
        value: *mut *mut OH_Pixelmap_HdrMetadataValue,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set metadata.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param key Type of metadata.\n @param value Value of metadata.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, key and value are incorrect.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory does not exist.\n returns {@link Image_ErrorCode} IMAGE_COPY_FAILED - if memory copy failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_SetMetadata(
        pixelmap: *mut OH_PixelmapNative,
        key: OH_Pixelmap_HdrMetadataKey,
        value: *mut OH_Pixelmap_HdrMetadataValue,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the native buffer from the PixelMap.\n\n @param pixelmap The PixelMap to get the native buffer from.\n @param nativeBuffer The native buffer to retrieve.\n @return Returns {@link Image_ErrorCode} IMAGE_RESULT_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, pixelmap or nativeBuffer is null.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory dose not exist.\n returns {@link Image_ErrorCode} IMAGE_DMA_OPERATION_FAILED - if operations related to DMA memory has failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_GetNativeBuffer(
        pixelmap: *mut OH_PixelmapNative,
        nativeBuffer: *mut *mut OH_NativeBuffer,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the native colorspace from the PixelMap.\n\n @param pixelmap The native pixelmap to get the native colorspace from.\n @param colorSpaceNative The native colorspace to retrieve.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} The param of pixelmap or colorSpaceNative is nullptr or invalid.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_GetColorSpaceNative(
        pixelmap: *mut OH_PixelmapNative,
        colorSpaceNative: *mut *mut OH_NativeColorSpaceManager,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set the native colorspace for the PixelMap.\n\n @param pixelmap The native pixelmap to set the native colorspace for.\n @param colorSpaceNative The native colorspace to set.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} The param of pixelmap or colorSpaceNative is nullptr or invalid.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_SetColorSpaceNative(
        pixelmap: *mut OH_PixelmapNative,
        colorSpaceNative: *mut OH_NativeColorSpaceManager,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelmap memory name.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param name The pointer of name that needs to be set.\n @param size The size of name size that needs to be set.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, name and size are incorrect.\n         {@link IMAGE_UNSUPPORTED_MEMORY_FORMAT} If memory format is unsupported.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_SetMemoryName(
        pixelmap: *mut OH_PixelmapNative,
        name: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the memory address of a PixelMap and locks the memory.\n        When the memory is locked, any operation that modifies or releases the PixelMap will fail and return\n        {@link IMAGE_BAD_PARAMETER}.\n\n @param pixelmap The PixelMap pointer to be operated.\n @param addr The double pointer to the memory address of the PixelMap.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap or addr are invalid.\n         {@link IMAGE_LOCK_UNLOCK_FAILED} If memory failed to be locked.\n @see OH_PixelmapNative\n @since 15"]
    pub fn OH_PixelmapNative_AccessPixels(
        pixelmap: *mut OH_PixelmapNative,
        addr: *mut *mut ::std::os::raw::c_void,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Unlocks the memory of the PixelMap data.\n        This function is used with {@link OH_PixelmapNative_AccessPixels} in pairs.\n\n @param pixelmap The PixelMap pointer to be operated.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap is invalid.\n         {@link IMAGE_LOCK_UNLOCK_FAILED} If memory failed to be unlocked.\n @see OH_PixelmapNative\n @since 15"]
    pub fn OH_PixelmapNative_UnaccessPixels(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsPlainText {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsHyperlink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsHtml {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsAppItem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsFileUri {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsPixelMap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsContentForm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdsArrayBuffer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsPlainText}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsPlainText}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_Create() -> *mut OH_UdsPlainText;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsPlainText} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_Destroy(pThis: *mut OH_UdsPlainText);
}
extern "C" {
    #[doc = " @brief Get type id from the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_GetType(pThis: *mut OH_UdsPlainText) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get content from the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_GetContent(pThis: *mut OH_UdsPlainText)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get abstract from the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsPlainText\n @since 12"]
    pub fn OH_UdsPlainText_GetAbstract(
        pThis: *mut OH_UdsPlainText,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set content to the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @param content Represents a new content string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsPlainText Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsPlainText_SetContent(
        pThis: *mut OH_UdsPlainText,
        content: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set abstract to the {@link OH_UdsPlainText}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @param abstract Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsPlainText Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsPlainText_SetAbstract(
        pThis: *mut OH_UdsPlainText,
        abstract_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsHyperlink}.\n\n @return If the operation is successful, a pointer to the instance of {@link OH_UdsHyperlink}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_Create() -> *mut OH_UdsHyperlink;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsHyperlink} instance.\n\n @param pThis Represents a pointer to an  instance of {@link OH_UdsHyperlink}.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_Destroy(pThis: *mut OH_UdsHyperlink);
}
extern "C" {
    #[doc = " @brief Get type from the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_GetType(pThis: *mut OH_UdsHyperlink) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get url from the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_GetUrl(pThis: *mut OH_UdsHyperlink) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get description from the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHyperlink\n @since 12"]
    pub fn OH_UdsHyperlink_GetDescription(
        pThis: *mut OH_UdsHyperlink,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set url to the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @param url Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsHyperlink Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsHyperlink_SetUrl(
        pThis: *mut OH_UdsHyperlink,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set description to the {@link OH_UdsHyperlink}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @param description Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsHyperlink Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsHyperlink_SetDescription(
        pThis: *mut OH_UdsHyperlink,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsHtml}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsHtml}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_Create() -> *mut OH_UdsHtml;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsHtml} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_Destroy(pThis: *mut OH_UdsHtml);
}
extern "C" {
    #[doc = " @brief Get html from the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_GetType(pThis: *mut OH_UdsHtml) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get content from the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_GetContent(pThis: *mut OH_UdsHtml) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get plain content from the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsHtml\n @since 12"]
    pub fn OH_UdsHtml_GetPlainContent(pThis: *mut OH_UdsHtml) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set content to the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @param content Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsHtml Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsHtml_SetContent(
        pThis: *mut OH_UdsHtml,
        content: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set plain content to the {@link OH_UdsHtml}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsHtml}.\n @param plainContent Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsHtml Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsHtml_SetPlainContent(
        pThis: *mut OH_UdsHtml,
        plainContent: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsAppItem}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsAppItem}\n structure is returned. sIf the operation is failed, nullptr is returned.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_Create() -> *mut OH_UdsAppItem;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsAppItem} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_Destroy(pThis: *mut OH_UdsAppItem);
}
extern "C" {
    #[doc = " @brief Get type from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetType(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get app id from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetId(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get app name from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetName(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get app icon id from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetIconId(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get app label id from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetLabelId(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get bundle name from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetBundleName(pThis: *mut OH_UdsAppItem) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get ability name from the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance {@link OH_UdsAppItem}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsAppItem\n @since 12"]
    pub fn OH_UdsAppItem_GetAbilityName(pThis: *mut OH_UdsAppItem)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set application id to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param appId Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetId(
        pThis: *mut OH_UdsAppItem,
        appId: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set application name to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param appName Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetName(
        pThis: *mut OH_UdsAppItem,
        appName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set application icon id to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param appIconId Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetIconId(
        pThis: *mut OH_UdsAppItem,
        appIconId: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set application label id to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param appLabelId Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetLabelId(
        pThis: *mut OH_UdsAppItem,
        appLabelId: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set bundle name to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param bundleName Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetBundleName(
        pThis: *mut OH_UdsAppItem,
        bundleName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set ability name to the {@link OH_UdsAppItem}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @param abilityName Represents a new string value.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsAppItem Udmf_ErrCode\n @since 12"]
    pub fn OH_UdsAppItem_SetAbilityName(
        pThis: *mut OH_UdsAppItem,
        abilityName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsFileUri}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsFileUri}\n structure is returned. If the memory is not enough, nullptr is returned.\n @see OH_UdsFileUri\n @since 13"]
    pub fn OH_UdsFileUri_Create() -> *mut OH_UdsFileUri;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsFileUri} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @see OH_UdsFileUri\n @since 13"]
    pub fn OH_UdsFileUri_Destroy(pThis: *mut OH_UdsFileUri);
}
extern "C" {
    #[doc = " @brief Get type id from the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsFileUri\n @since 13"]
    pub fn OH_UdsFileUri_GetType(pThis: *mut OH_UdsFileUri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get file uri from the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsFileUri\n @since 13"]
    pub fn OH_UdsFileUri_GetFileUri(pThis: *mut OH_UdsFileUri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get file type from the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsFileUri\n @since 13"]
    pub fn OH_UdsFileUri_GetFileType(pThis: *mut OH_UdsFileUri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set file uri to the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @param fileUri Represents a new file uri string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsFileUri Udmf_ErrCode\n @since 13"]
    pub fn OH_UdsFileUri_SetFileUri(
        pThis: *mut OH_UdsFileUri,
        fileUri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set file type to the {@link OH_UdsFileUri}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @param fileType Represents a new file type string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsFileUri Udmf_ErrCode\n @since 13"]
    pub fn OH_UdsFileUri_SetFileType(
        pThis: *mut OH_UdsFileUri,
        fileType: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsPixelMap}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsPixelMap}\n structure is returned. If the memory is not enough, nullptr is returned.\n @see OH_UdsPixelMap\n @since 13"]
    pub fn OH_UdsPixelMap_Create() -> *mut OH_UdsPixelMap;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsPixelMap} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @see OH_UdsPixelMap\n @since 13"]
    pub fn OH_UdsPixelMap_Destroy(pThis: *mut OH_UdsPixelMap);
}
extern "C" {
    #[doc = " @brief Get type id from the {@link OH_UdsPixelMap}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsPixelMap\n @since 13"]
    pub fn OH_UdsPixelMap_GetType(pThis: *mut OH_UdsPixelMap) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get pixel map from the {@link OH_UdsPixelMap}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @param pixelmapNative Represents output params of {@link OH_PixelmapNative}.\n @see OH_UdsPixelMap\n @since 13"]
    pub fn OH_UdsPixelMap_GetPixelMap(
        pThis: *mut OH_UdsPixelMap,
        pixelmapNative: *mut OH_PixelmapNative,
    );
}
extern "C" {
    #[doc = " @brief Set pixel map to the {@link OH_UdsPixelMap}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @param pixelmapNative Represents a new {@link OH_PixelmapNative}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsPixelMap Udmf_ErrCode\n @since 13"]
    pub fn OH_UdsPixelMap_SetPixelMap(
        pThis: *mut OH_UdsPixelMap,
        pixelmapNative: *mut OH_PixelmapNative,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsArrayBuffer}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsArrayBuffer}\n structure is returned. If the memory is not enough, nullptr is returned.\n @see OH_UdsArrayBuffer\n @since 13"]
    pub fn OH_UdsArrayBuffer_Create() -> *mut OH_UdsArrayBuffer;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsArrayBuffer} instance.\n\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsArrayBuffer Udmf_ErrCode\n @since 13"]
    pub fn OH_UdsArrayBuffer_Destroy(buffer: *mut OH_UdsArrayBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set array buffer data to the {@link OH_UdsArrayBuffer}.\n\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @param data Represents the array buffer data.\n @param len Represents the length of data param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsArrayBuffer Udmf_ErrCode\n @since 13"]
    pub fn OH_UdsArrayBuffer_SetData(
        buffer: *mut OH_UdsArrayBuffer,
        data: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get array buffer data from the {@link OH_UdsArrayBuffer}.\n\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @param data Represents a pointer to array buffer data that is a output param.\n @param len Represents the array buffer data length that is a output param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsArrayBuffer Udmf_ErrCode\n @since 13"]
    pub fn OH_UdsArrayBuffer_GetData(
        buffer: *mut OH_UdsArrayBuffer,
        data: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdsContentForm}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdsContentForm}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdsContentForm\n @since 14"]
    pub fn OH_UdsContentForm_Create() -> *mut OH_UdsContentForm;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdsContentForm} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @see OH_UdsContentForm\n @since 14"]
    pub fn OH_UdsContentForm_Destroy(pThis: *mut OH_UdsContentForm);
}
extern "C" {
    #[doc = " @brief Get type id from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    pub fn OH_UdsContentForm_GetType(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get thumb data from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param thumbData Represents a pointer to thumb data that is a output param.\n @param len Represents the thumb data length that is a output param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    pub fn OH_UdsContentForm_GetThumbData(
        pThis: *mut OH_UdsContentForm,
        thumbData: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get description from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    pub fn OH_UdsContentForm_GetDescription(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get title from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    pub fn OH_UdsContentForm_GetTitle(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get thumb data from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param appIcon Represents a pointer to app icon that is a output param.\n @param len Represents the app icon length that is a output param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    pub fn OH_UdsContentForm_GetAppIcon(
        pThis: *mut OH_UdsContentForm,
        appIcon: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get app name from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    pub fn OH_UdsContentForm_GetAppName(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get link url from the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns a pointer of the value string when input args normally, otherwise return nullptr.\n @see OH_UdsContentForm\n @since 14"]
    pub fn OH_UdsContentForm_GetLinkUri(
        pThis: *mut OH_UdsContentForm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set thumb data to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param thumbData Represents the thumb data.\n @param len Represents the length of thumb data param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    pub fn OH_UdsContentForm_SetThumbData(
        pThis: *mut OH_UdsContentForm,
        thumbData: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set description to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param description Represents a description string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    pub fn OH_UdsContentForm_SetDescription(
        pThis: *mut OH_UdsContentForm,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set title to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param title Represents a title string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    pub fn OH_UdsContentForm_SetTitle(
        pThis: *mut OH_UdsContentForm,
        title: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set thumb data to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param appIcon Represents the app icon.\n @param len Represents the length of app icon param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    pub fn OH_UdsContentForm_SetAppIcon(
        pThis: *mut OH_UdsContentForm,
        appIcon: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set app name to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param appName Represents a app name string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    pub fn OH_UdsContentForm_SetAppName(
        pThis: *mut OH_UdsContentForm,
        appName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set link uri to the {@link OH_UdsContentForm}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @param linkUri Represents a link uri string.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdsContentForm Udmf_ErrCode\n @since 14"]
    pub fn OH_UdsContentForm_SetLinkUri(
        pThis: *mut OH_UdsContentForm,
        linkUri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief The intention is drag."]
pub const Udmf_Intention_UDMF_INTENTION_DRAG: Udmf_Intention = 0;
#[doc = " @brief The intention is pasteboard."]
pub const Udmf_Intention_UDMF_INTENTION_PASTEBOARD: Udmf_Intention = 1;
#[doc = " @brief Describe the intention type of the udmf.\n\n @since 12"]
pub type Udmf_Intention = ::std::os::raw::c_uint;
#[doc = " @brief Invalid share option."]
pub const Udmf_ShareOption_SHARE_OPTIONS_INVALID: Udmf_ShareOption = 0;
#[doc = " @brief Allowed to be used in the same application on this device."]
pub const Udmf_ShareOption_SHARE_OPTIONS_IN_APP: Udmf_ShareOption = 1;
#[doc = " @brief Allowed to be used in the cross application on this device."]
pub const Udmf_ShareOption_SHARE_OPTIONS_CROSS_APP: Udmf_ShareOption = 2;
#[doc = " @brief Describe intra-device usage range type enumeration.\n\n @since 12"]
pub type Udmf_ShareOption = ::std::os::raw::c_uint;
#[doc = " @brief Overwrite when dest uri has file with same name."]
pub const Udmf_FileConflictOptions_UDMF_OVERWRITE: Udmf_FileConflictOptions = 0;
#[doc = " @brief Skip when dest uri has file with same name."]
pub const Udmf_FileConflictOptions_UDMF_SKIP: Udmf_FileConflictOptions = 1;
#[doc = " @brief Describe the types of file conflict options when getting data from the udmf.\n\n @since 15"]
pub type Udmf_FileConflictOptions = ::std::os::raw::c_uint;
#[doc = " @brief Getting data without system default progress indicator."]
pub const Udmf_ProgressIndicator_UDMF_NONE: Udmf_ProgressIndicator = 0;
#[doc = " @brief Getting data with system default progress indicator."]
pub const Udmf_ProgressIndicator_UDMF_DEFAULT: Udmf_ProgressIndicator = 1;
#[doc = " @brief Describe the types of progress indicator when getting data from the udmf.\n\n @since 15"]
pub type Udmf_ProgressIndicator = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfRecord {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfRecordProvider {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfProperty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Udmf_ProgressInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_UdmfGetDataParams {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the callback function used to return the progress information and data.\n\n @param progressInfo The progress information notified to Application.\n @param data Represents the unified data.\n @since 15"]
pub type OH_Udmf_DataProgressListener = ::std::option::Option<
    unsafe extern "C" fn(progressInfo: *mut OH_Udmf_ProgressInfo, data: *mut OH_UdmfData),
>;
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfData}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfData}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfData.\n @since 12"]
    pub fn OH_UdmfData_Create() -> *mut OH_UdmfData;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdmfData} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @see OH_UdmfData.\n @since 12"]
    pub fn OH_UdmfData_Destroy(pThis: *mut OH_UdmfData);
}
extern "C" {
    #[doc = " @brief Add one {OH_UdmfRecord} record to the {@link OH_UdmfData} data.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @param record Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfData Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfData_AddRecord(
        pThis: *mut OH_UdmfData,
        record: *mut OH_UdmfRecord,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check whether the type exists in the {@link OH_UdmfData} data.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @param type Represents a string pointer of the type.\n @return Returns the status of finding type.\n         {@code false} is not existed.\n         {@code true} is existed.\n @see OH_UdmfData.\n @since 12"]
    pub fn OH_UdmfData_HasType(
        pThis: *mut OH_UdmfData,
        type_: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get all types in the {@link OH_UdmfData} data.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @param count Represents the types count that is a output param.\n @return Returns string array that in {@link OH_UdmfData} when input parameters valid,\n otherwise return nullptr.\n @see OH_UdmfData.\n @since 12"]
    pub fn OH_UdmfData_GetTypes(
        pThis: *mut OH_UdmfData,
        count: *mut ::std::os::raw::c_uint,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get all records in the {@link OH_UdmfData} data.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfData}.\n @param count Represents the records count that is a output param.\n @return Returns {@link OH_UdmfRecord} pointer array when input parameters valid, otherwise return nullptr.\n @see OH_UdmfData OH_UdmfRecord.\n @since 12"]
    pub fn OH_UdmfData_GetRecords(
        pThis: *mut OH_UdmfData,
        count: *mut ::std::os::raw::c_uint,
    ) -> *mut *mut OH_UdmfRecord;
}
#[doc = " @brief Defines the callback function used free the context.\n @param context Pointer to the context which is to be free.\n @since 13"]
pub type UdmfData_Finalize =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " @brief Creates an {@link OH_UdmfRecordProvider} instance.\n\n @return Returns the pointer to the {@link OH_UdmfRecordProvider} instance created if the operation is successful.\n Returns nullptr if the memory is not enough.\n @see OH_UdmfRecordProvider.\n @since 13"]
    pub fn OH_UdmfRecordProvider_Create() -> *mut OH_UdmfRecordProvider;
}
extern "C" {
    #[doc = " @brief Destroy an {@link OH_UdmfRecordProvider} instance.\n\n @param provider Pointer to the {@link OH_UdmfRecordProvider} instance to destroy.\n @return Returns the status code of the execution. For details, see {@link Udmf_ErrCode}.\n         Returns {@link UDMF_E_OK} if the operation is successful.\n         Returns {@link UDMF_E_INVALID_PARAM} if invalid args are detected.\n @see OH_UdmfRecordProvider Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfRecordProvider_Destroy(
        provider: *mut OH_UdmfRecordProvider,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief Defines a callback function used to obtain data by type.\n\n @param context Pointer to the context set by {@link OH_UdmfRecordProvider_SetData}.\n @param type Pointer to the type of data to obtain. For details, see {@link udmf_meta.h}.\n @return Returns the data content.\n @since 13"]
pub type OH_UdmfRecordProvider_GetData = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        type_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[doc = " @brief Sets a callback function to obtain data.\n\n @param provider Pointer to the {@link OH_UdmfRecordProvider} instance.\n @param context Pointer to the context set, which is the first parameter in OH_UdmfRecordProvider_GetData.\n @param callback Callback to set. For details, see {@link OH_UdmfRecordProvider_GetData}.\n @param finalize Optional callback that can free context when destroy provider.\n         For details, see {@link UdmfData_Finalize}.\n @return Returns the status code of the execution. For details, see {@link Udmf_ErrCode}.\n         Returns {@link UDMF_E_OK} if the operation is successful.\n         Returns {@link UDMF_E_INVALID_PARAM} if invalid args are detected.\n @see OH_UdmfRecordProvider OH_UdmfRecordProvider_GetData UdmfData_Finalize Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfRecordProvider_SetData(
        provider: *mut OH_UdmfRecordProvider,
        context: *mut ::std::os::raw::c_void,
        callback: OH_UdmfRecordProvider_GetData,
        finalize: UdmfData_Finalize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfRecord}, it's relate with UDS data.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfRecord}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfRecord.\n @since 12"]
    pub fn OH_UdmfRecord_Create() -> *mut OH_UdmfRecord;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to an instance of {@link OH_UdmfRecord}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @see OH_UdmfRecord.\n @since 12"]
    pub fn OH_UdmfRecord_Destroy(pThis: *mut OH_UdmfRecord);
}
extern "C" {
    #[doc = " @brief Add one custom data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param typeId Represents record type, reference udmf_meta.h.\n @param entry Represents custom data.\n @param count Represents the size of data param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddGeneralEntry(
        pThis: *mut OH_UdmfRecord,
        typeId: *const ::std::os::raw::c_char,
        entry: *mut ::std::os::raw::c_uchar,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsPlainText} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param plainText Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsPlainText Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddPlainText(
        pThis: *mut OH_UdmfRecord,
        plainText: *mut OH_UdsPlainText,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsHyperlink} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param hyperlink Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsHyperlink Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddHyperlink(
        pThis: *mut OH_UdmfRecord,
        hyperlink: *mut OH_UdsHyperlink,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsHtml} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param html Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsHtml Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddHtml(
        pThis: *mut OH_UdmfRecord,
        html: *mut OH_UdsHtml,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsAppItem} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param appItem Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsAppItem Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_AddAppItem(
        pThis: *mut OH_UdmfRecord,
        appItem: *mut OH_UdsAppItem,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsFileUri} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param fileUri Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsFileUri Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfRecord_AddFileUri(
        pThis: *mut OH_UdmfRecord,
        fileUri: *mut OH_UdsFileUri,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {OH_UdsPixelMap} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param pixelMap Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsPixelMap Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfRecord_AddPixelMap(
        pThis: *mut OH_UdmfRecord,
        pixelMap: *mut OH_UdsPixelMap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {@link OH_UdsArrayBuffer} data to the {@link OH_UdmfRecord} record.\n\n @param record Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param type Represents record type, reference udmf_meta.h.\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsArrayBuffer Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfRecord_AddArrayBuffer(
        record: *mut OH_UdmfRecord,
        type_: *const ::std::os::raw::c_char,
        buffer: *mut OH_UdsArrayBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add one {@link OH_UdsContentForm} data to the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param contentForm Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsContentForm Udmf_ErrCode.\n @since 14"]
    pub fn OH_UdmfRecord_AddContentForm(
        pThis: *mut OH_UdmfRecord,
        contentForm: *mut OH_UdsContentForm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get all types in the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param count Represents the types count that is a output param.\n @return Returns string array that in {@link OH_UdmfRecord} when input parameters valid,\n otherwise return nullptr.\n @see OH_UdmfRecord.\n @since 12"]
    pub fn OH_UdmfRecord_GetTypes(
        pThis: *mut OH_UdmfRecord,
        count: *mut ::std::os::raw::c_uint,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get one entry data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param typeId Represents record type, reference udmf_meta.h.\n @param entry Represents a pointer to entry data that is a output param.\n @param count Represents the entry data length that is a output param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetGeneralEntry(
        pThis: *mut OH_UdmfRecord,
        typeId: *const ::std::os::raw::c_char,
        entry: *mut *mut ::std::os::raw::c_uchar,
        count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsPlainText} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param plainText Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord OH_UdsPlainText Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetPlainText(
        pThis: *mut OH_UdmfRecord,
        plainText: *mut OH_UdsPlainText,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsHyperlink} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param hyperlink Represents a pointer to an instance of {@link OH_UdsHyperlink}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord OH_UdsHyperlink Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetHyperlink(
        pThis: *mut OH_UdmfRecord,
        hyperlink: *mut OH_UdsHyperlink,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsHtml} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param html Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord OH_UdsHtml Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetHtml(
        pThis: *mut OH_UdmfRecord,
        html: *mut OH_UdsHtml,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsAppItem} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param appItem Represents a pointer to an instance of {@link OH_UdsAppItem}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfRecord OH_UdsAppItem Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfRecord_GetAppItem(
        pThis: *mut OH_UdmfRecord,
        appItem: *mut OH_UdsAppItem,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsFileUri} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param fileUri Represents a pointer to an instance of {@link OH_UdsFileUri}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsFileUri Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfRecord_GetFileUri(
        pThis: *mut OH_UdmfRecord,
        fileUri: *mut OH_UdsFileUri,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {OH_UdsPixelMap} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param pixelMap Represents a pointer to an instance of {@link OH_UdsPixelMap}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsPixelMap Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfRecord_GetPixelMap(
        pThis: *mut OH_UdmfRecord,
        pixelMap: *mut OH_UdsPixelMap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the data provider of the types.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param types Represents a pointer to a group of data types;\n @param count Represents the number of data types;\n @param provider Represents a pointer an instance of {@link OH_UdmfRecordProvider}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdmfRecordProvider Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfRecord_SetProvider(
        pThis: *mut OH_UdmfRecord,
        types: *const *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        provider: *mut OH_UdmfRecordProvider,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {@link OH_UdsArrayBuffer} data from the {@link OH_UdmfRecord} record.\n\n @param record Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param type Represents record type, reference udmf_meta.h.\n @param buffer Represents a pointer to an instance of {@link OH_UdsArrayBuffer}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsArrayBuffer Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfRecord_GetArrayBuffer(
        record: *mut OH_UdmfRecord,
        type_: *const ::std::os::raw::c_char,
        buffer: *mut OH_UdsArrayBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {@link OH_UdsContentForm} data from the {@link OH_UdmfRecord} record.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfRecord}.\n @param contentForm Represents a pointer to an instance of {@link OH_UdsContentForm}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfRecord OH_UdsContentForm Udmf_ErrCode.\n @since 14"]
    pub fn OH_UdmfRecord_GetContentForm(
        pThis: *mut OH_UdmfRecord,
        contentForm: *mut OH_UdsContentForm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get primary {@link OH_UdsPlainText} data from the {@link OH_UdmfData}.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @param plainText Represents a pointer to an instance of {@link OH_UdsPlainText}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfData OH_UdsPlainText Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfData_GetPrimaryPlainText(
        data: *mut OH_UdmfData,
        plainText: *mut OH_UdsPlainText,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get one {@link OH_UdsHtml} data from the {@link OH_UdmfData}.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @param html Represents a pointer to an instance of {@link OH_UdsHtml}.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfData OH_UdsHtml Udmf_ErrCode.\n @since 13"]
    pub fn OH_UdmfData_GetPrimaryHtml(
        data: *mut OH_UdmfData,
        html: *mut OH_UdsHtml,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the count of {@link OH_UdmfRecord} in the {@link OH_UdmfData}.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @return Returns the count of {@link OH_UdmfRecord}\n @see OH_UdmfData.\n @since 13"]
    pub fn OH_UdmfData_GetRecordCount(data: *mut OH_UdmfData) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the record of the specified index from the {@link OH_UdmfData}.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @param index Represents the index of {@link OH_UdmfRecord} in the {@link OH_UdmfData}.\n @return Returns {@link OH_UdmfRecord} pointer when input parameters valid, otherwise return nullptr.\n @see OH_UdmfData.\n @since 13"]
    pub fn OH_UdmfData_GetRecord(
        data: *mut OH_UdmfData,
        index: ::std::os::raw::c_uint,
    ) -> *mut OH_UdmfRecord;
}
extern "C" {
    #[doc = " @brief Checks whether the UDMF data is from a local device.\n\n @param data Represents a pointer to an instance of {@link OH_UdmfData}.\n @return Returns a boolean value, which indicates whether the UDMF data is from a local device.\n         The value {@code true} means the data is from a local device.\n         The value {@code false} means the opposite.\n @see OH_UdmfData.\n @since 13"]
    pub fn OH_UdmfData_IsLocal(data: *mut OH_UdmfData) -> bool;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfProperty}\n from a {@link OH_UdmfData} data.\n\n @param unifiedData Represents a pointer to an instance of {@link OH_UdmfData}.\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfProperty}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfData OH_UdmfProperty.\n @since 12"]
    pub fn OH_UdmfProperty_Create(unifiedData: *mut OH_UdmfData) -> *mut OH_UdmfProperty;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to the {@link OH_UdmfProperty} instance.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @see OH_UdmfProperty.\n @since 12"]
    pub fn OH_UdmfProperty_Destroy(pThis: *mut OH_UdmfProperty);
}
extern "C" {
    #[doc = " @brief Get tag value from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @return Returns a pointer of the tag value string when input parameters valid, otherwise return nullptr.\n @see OH_UdmfProperty.\n @since 12"]
    pub fn OH_UdmfProperty_GetTag(pThis: *mut OH_UdmfProperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get timestamp value from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @return Returns timestamp value.\n @see OH_UdmfProperty\n @since 12"]
    pub fn OH_UdmfProperty_GetTimestamp(pThis: *mut OH_UdmfProperty) -> i64;
}
extern "C" {
    #[doc = " @brief Get share option value from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @return Returns {@link Udmf_ShareOption} value.\n @see OH_UdmfProperty Udmf_ShareOption\n @since 12"]
    pub fn OH_UdmfProperty_GetShareOption(pThis: *mut OH_UdmfProperty) -> Udmf_ShareOption;
}
extern "C" {
    #[doc = " @brief Get integer value by key from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param key Represents key-value pair's key\n @param defaultValue Represents when get value failure.\n @return Returns value associated with the key in successfully, otherwise return defaultValue.\n @see OH_UdmfProperty.\n @since 12"]
    pub fn OH_UdmfProperty_GetExtrasIntParam(
        pThis: *mut OH_UdmfProperty,
        key: *const ::std::os::raw::c_char,
        defaultValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get tag value from the {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param key Represents key-value pair's key.\n @return Returns a pointer of the key value string when input parameters valid, otherwise return nullptr.\n @see OH_UdmfProperty\n @since 12"]
    pub fn OH_UdmfProperty_GetExtrasStringParam(
        pThis: *mut OH_UdmfProperty,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set tag value to {@link OH_UdmfProperty} .\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param tag Represents new tag param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfProperty Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfProperty_SetTag(
        pThis: *mut OH_UdmfProperty,
        tag: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set Udmf_ShareOption value to {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param option Represents new {@link Udmf_ShareOption} param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfProperty Udmf_ShareOption Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfProperty_SetShareOption(
        pThis: *mut OH_UdmfProperty,
        option: Udmf_ShareOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set extras param to {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param key Represents extras param's key value.\n @param param Represents value of k-v pairs.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfProperty Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfProperty_SetExtrasIntParam(
        pThis: *mut OH_UdmfProperty,
        key: *const ::std::os::raw::c_char,
        param: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set extras param to {@link OH_UdmfProperty}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfProperty}.\n @param key Represents extras param's key value.\n @param param Represents value of k-v pairs.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n @see OH_UdmfProperty Udmf_ErrCode.\n @since 12"]
    pub fn OH_UdmfProperty_SetExtrasStringParam(
        pThis: *mut OH_UdmfProperty,
        key: *const ::std::os::raw::c_char,
        param: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get {@link OH_UdmfData} data from udmf database.\n\n @param key Represents database store's key value.\n @param intention Represents data type {@link Udmf_Intention}\n @param unifiedData Represents output params of {@link OH_UdmfData};\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfProperty Udmf_Intention Udmf_ErrCode.\n @since 12"]
    pub fn OH_Udmf_GetUnifiedData(
        key: *const ::std::os::raw::c_char,
        intention: Udmf_Intention,
        unifiedData: *mut OH_UdmfData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set {@link OH_UdmfData} data to database.\n\n @param intention Represents data type {@link Udmf_Intention}.\n @param unifiedData Represents a pointer to an instance of {@link OH_UdmfData}.\n @param key Represents return value after set data to database successfully,\n it's memory size not less than {@link UDMF_KEY_BUFFER_LEN}.\n @param keyLen Represents size of key param.\n @return Returns the status code of the execution. See {@link Udmf_ErrCode}.\n         {@link UDMF_E_OK} success.\n         {@link UDMF_E_INVALID_PARAM} The error code for common invalid args.\n         {@link UDMF_ERR} Internal data error.\n @see OH_UdmfProperty Udmf_Intention Udmf_ErrCode.\n @since 12"]
    pub fn OH_Udmf_SetUnifiedData(
        intention: Udmf_Intention,
        unifiedData: *mut OH_UdmfData,
        key: *mut ::std::os::raw::c_char,
        keyLen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets the progress from the {@OH_Udmf_ProgressInfo}.\n\n @param progressInfo Represents a pointer to an instance of {@link OH_Udmf_ProgressInfo}.\n @return Returns the progress.\n @see OH_Udmf_ProgressInfo\n @since 15"]
    pub fn OH_UdmfProgressInfo_GetProgress(
        progressInfo: *mut OH_Udmf_ProgressInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets the status from the {@OH_Udmf_ProgressInfo}.\n\n @param progressInfo Represents a pointer to an instance of {@link OH_Udmf_ProgressInfo}.\n @return Returns the status code. See {@link Udmf_ListenerStatus}.\n @see OH_Udmf_ProgressInfo Udmf_ListenerStatus\n @since 15"]
    pub fn OH_UdmfProgressInfo_GetStatus(
        progressInfo: *mut OH_Udmf_ProgressInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creation a pointer to the instance of the {@link OH_UdmfGetDataParams}.\n\n @return If the operation is successful, a pointer to the instance of the {@link OH_UdmfGetDataParams}\n structure is returned. If the operation is failed, nullptr is returned.\n @see OH_UdmfGetDataParams\n @since 15"]
    pub fn OH_UdmfGetDataParams_Create() -> *mut OH_UdmfGetDataParams;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to an instance of {@link OH_UdmfGetDataParams}.\n\n @param pThis Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @see OH_UdmfGetDataParams\n @since 15"]
    pub fn OH_UdmfGetDataParams_Destroy(pThis: *mut OH_UdmfGetDataParams);
}
extern "C" {
    #[doc = " @brief Sets the destination uri to the {@OH_UdmfGetDataParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @param destUri Pointer to a destination uri.\n @see OH_UdmfGetDataParams\n @since 15"]
    pub fn OH_UdmfGetDataParams_SetDestUri(
        params: *mut OH_UdmfGetDataParams,
        destUri: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets the file conflict options to the {@OH_UdmfGetDataParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @param options Represents to the file conflict options.\n @see OH_UdmfGetDataParams Udmf_FileConflictOptions\n @since 15"]
    pub fn OH_UdmfGetDataParams_SetFileConflictOptions(
        params: *mut OH_UdmfGetDataParams,
        options: Udmf_FileConflictOptions,
    );
}
extern "C" {
    #[doc = " @brief Sets the progress indicator to the {@OH_UdmfGetDataParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @param progressIndicator Represents to the progress indicator.\n @see OH_UdmfGetDataParams Udmf_ProgressIndicator\n @since 15"]
    pub fn OH_UdmfGetDataParams_SetProgressIndicator(
        params: *mut OH_UdmfGetDataParams,
        progressIndicator: Udmf_ProgressIndicator,
    );
}
extern "C" {
    #[doc = " @brief Sets the progress indicator to the {@OH_UdmfGetDataParams}.\n\n @param params Represents a pointer to an instance of {@link OH_UdmfGetDataParams}.\n @param dataProgressListener Represents to the data progress listener.\n @see OH_UdmfGetDataParams OH_Udmf_DataProgressListener\n @since 15"]
    pub fn OH_UdmfGetDataParams_SetDataProgressListener(
        params: *mut OH_UdmfGetDataParams,
        dataProgressListener: OH_Udmf_DataProgressListener,
    );
}
#[doc = " The drag and drop operation succeeded."]
pub const ArkUI_DragResult_ARKUI_DRAG_RESULT_SUCCESSFUL: ArkUI_DragResult = 0;
#[doc = " The drag and drop operation failed."]
pub const ArkUI_DragResult_ARKUI_DRAG_RESULT_FAILED: ArkUI_DragResult = 1;
#[doc = " The drag and drop operation was canceled."]
pub const ArkUI_DragResult_ARKUI_DRAG_RESULT_CANCELED: ArkUI_DragResult = 2;
#[doc = " @brief Defines an enum for drag results, which are set by the data receiver and transferred by the system to the\n        drag source so that the drag source is aware of the data processing result of the receiver.\n\n @since 12"]
pub type ArkUI_DragResult = ::std::os::raw::c_uint;
#[doc = " Copy."]
pub const ArkUI_DropOperation_ARKUI_DROP_OPERATION_COPY: ArkUI_DropOperation = 0;
#[doc = " Cut."]
pub const ArkUI_DropOperation_ARKUI_DROP_OPERATION_MOVE: ArkUI_DropOperation = 1;
#[doc = " @brief Defines an enum for data processing modes used when data is dropped, which affects the display of the badge.\n\n @since 12"]
pub type ArkUI_DropOperation = ::std::os::raw::c_uint;
#[doc = " Unknown."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_UNKNOWN: ArkUI_PreDragStatus = -1;
#[doc = " A drag gesture is being detected."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_ACTION_DETECTING: ArkUI_PreDragStatus = 0;
#[doc = " The component is ready to be dragged."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_READY_TO_TRIGGER_DRAG: ArkUI_PreDragStatus = 1;
#[doc = " A lift animation is started."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_PREVIEW_LIFT_STARTED: ArkUI_PreDragStatus = 2;
#[doc = " A lift animation is finished."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_PREVIEW_LIFT_FINISHED: ArkUI_PreDragStatus = 3;
#[doc = " A drop animation is started."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_PREVIEW_LANDING_STARTED: ArkUI_PreDragStatus =
    4;
#[doc = " A drop animation is finished."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_PREVIEW_LANDING_FINISHED: ArkUI_PreDragStatus =
    5;
#[doc = " A drop animation is terminated."]
pub const ArkUI_PreDragStatus_ARKUI_PRE_DRAG_STATUS_CANCELED_BEFORE_DRAG: ArkUI_PreDragStatus = 6;
#[doc = " @brief Defines an enum for interaction states prior to a drop and drop operation.\n\n @since 12"]
pub type ArkUI_PreDragStatus = ::std::os::raw::c_int;
#[doc = " The system automatically changes the position of the dragged point based on the scenario and\n scales the drag preview based on set rules."]
pub const ArkUI_DragPreviewScaleMode_ARKUI_DRAG_PREVIEW_SCALE_AUTO: ArkUI_DragPreviewScaleMode = 0;
#[doc = " The system does not scale the drag preview."]
pub const ArkUI_DragPreviewScaleMode_ARKUI_DRAG_PREVIEW_SCALE_DISABLED: ArkUI_DragPreviewScaleMode =
    1;
#[doc = " @brief Defines an enum for drag preview scale modes.\n\n @since 12"]
pub type ArkUI_DragPreviewScaleMode = ::std::os::raw::c_uint;
#[doc = " Unknown."]
pub const ArkUI_DragStatus_ARKUI_DRAG_STATUS_UNKNOWN: ArkUI_DragStatus = -1;
#[doc = " Started."]
pub const ArkUI_DragStatus_ARKUI_DRAG_STATUS_STARTED: ArkUI_DragStatus = 0;
#[doc = " Ended."]
pub const ArkUI_DragStatus_ARKUI_DRAG_STATUS_ENDED: ArkUI_DragStatus = 1;
#[doc = " @brief Defines an enum for drag states.\n\n @since 12"]
pub type ArkUI_DragStatus = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DragEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DragPreviewOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DragAction {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DragAndDropInfo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Obtains a <b>ArkUI_DragEvent</b> object from the specified <b>ArkUI_NodeEvent</b> object.\n\n @param nodeEvent Indicates the pointer to an <b>ArkUI_NodeEvent</b> object.\n @return Returns the pointer to an <b>ArkUI_DragEvent</b> object.\n         Returns <b>null</b> if the parameter passed in is invalid or is not a drag-related event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetDragEvent(nodeEvent: *mut ArkUI_NodeEvent)
        -> *mut ArkUI_DragEvent;
}
extern "C" {
    #[doc = " @brief Obtains the interaction state prior to a drop and drop operation.\n\n @param nodeEvent Indicates the pointer to an <b>ArkUI_NodeEvent</b> object.\n @return Returns the interaction state prior to the drop and drop operation.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetPreDragStatus(
        nodeEvent: *mut ArkUI_NodeEvent,
    ) -> ArkUI_PreDragStatus;
}
extern "C" {
    #[doc = " @brief Sets whether to disable the default drop animation.\n The default drop animation is enabled by default and can be disabled to apply a custom drop animation.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param disable Indicates whether to disable the default drop animation.\n The value <b>true</b> means to disable the default drop animation, and <b>false</b> means the opposite.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_DisableDefaultDropAnimation(
        event: *mut ArkUI_DragEvent,
        disable: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the data processing mode.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param dropOperation Indicates the data processing mode.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_SetSuggestedDropOperation(
        event: *mut ArkUI_DragEvent,
        dropOperation: ArkUI_DropOperation,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the result for a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param result Indicates the drag result.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_SetDragResult(
        event: *mut ArkUI_DragEvent,
        result: ArkUI_DragResult,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set drag data for a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param data Indicates the drag data.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_SetData(event: *mut ArkUI_DragEvent, data: *mut OH_UdmfData) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the default drag data from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param data Indicates the pointer to an <b>OH_UdmfData</b> object. The application needs to create a pointer\n             for receiving data by using the {@link OH_UdmfData_Create} method.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetUdmfData(
        event: *mut ArkUI_DragEvent,
        data: *mut OH_UdmfData,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of drag data types from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param count Indicates the number of drag data types returned.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetDataTypeCount(event: *mut ArkUI_DragEvent, count: *mut i32)
        -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the list of drag data types from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param eventTypeArray Indicates the list of the drag data types. You need to create a string array first.\n @param length Indicates the total length of the list array. It must be greater than or equal to the number obtained\n        by using {@link OH_ArkUI_DragEvent_GetDataTypeCount}.\n @param maxStrLen Indicates the max string length of drag data types.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} if the giving buffer is not enough for string copy.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetDataTypes(
        event: *mut ArkUI_DragEvent,
        eventTypeArray: *mut *mut ::std::os::raw::c_char,
        length: i32,
        maxStrLen: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the drag result from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param result Indicates the drag result returned.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetDragResult(
        event: *mut ArkUI_DragEvent,
        result: *mut ArkUI_DragResult,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the drop operation from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param operation Indicates the drop operation which the data receiver set.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n                 Possible causes: 1. The given parameters are null or the given event is not a valid DragEvent.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetDropOperation(
        event: *mut ArkUI_DragEvent,
        operation: *mut ArkUI_DropOperation,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of the touch point for a drag preview from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the X coordinate of the touch point, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetPreviewTouchPointX(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of the touch point for a drag preview from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the Y coordinate of the touch point, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetPreviewTouchPointY(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the width of a drag preview from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the width of the drag preview, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetPreviewRectWidth(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the height of a drag preview from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the height of the drag preview, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetPreviewRectHeight(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of the touch point relative to the window from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the X coordinate of the touch point relative to the window, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetTouchPointXToWindow(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of the touch point relative to the window from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the Y coordinate of the touch point relative to the window, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetTouchPointYToWindow(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of the touch point relative to the current display from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the X coordinate of the touch point relative to the current display, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetTouchPointXToDisplay(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of the touch point relative to the current display from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the Y coordinate of the touch point relative to the current display, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetTouchPointYToDisplay(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the dragging velocity along the x-axis.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the dragging velocity along the x-axis, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetVelocityX(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the dragging velocity along the y-axis.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the dragging velocity along the y-axis, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetVelocityY(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the dragging velocity along the main axis.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @return Returns the dragging velocity along the main axis, in px.\n         Returns the default value <b>0</b> if the input parameter is invalid.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetVelocity(event: *mut ArkUI_DragEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the pressed status of modifier keys from a drag event.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param keys Indicates the returned combination of modifier keys that are currently pressed.\n             The application can determine the pressed modifier keys through bitwise operations.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragEvent_GetModifierKeyStates(
        event: *mut ArkUI_DragEvent,
        keys: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Request to start the data sync process with the sync option.\n\n @param event Indicates the pointer to an <b>ArkUI_DragEvent</b> object.\n @param options Indicates the pointer to an <b>OH_UdmfGetDataParams</b> object.\n @param key Represents return value after set data to database successfully, it should be not\n            less than {@link UDMF_KEY_BUFFER_LEN}.\n @param keyLen Represents the length of key string.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_DRAG_DATA_SYNC_FAILED} if the data sync is not allowed or failed.\n @since 15"]
    pub fn OH_ArkUI_DragEvent_StartDataLoading(
        event: *mut ArkUI_DragEvent,
        options: *mut OH_UdmfGetDataParams,
        key: *mut ::std::os::raw::c_char,
        keyLen: ::std::os::raw::c_uint,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Cancel the data sync process.\n\n @param uiContext Indicates the pointer to a UI instance.\n @param key Represents the data key returned by {@link OH_ArkUI_DragEvent_StartDataLoading}.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_OPERATION_FAILED} if no any data sync is in progress.\n @since 15"]
    pub fn OH_ArkUI_CancelDataLoading(
        uiContext: ArkUI_ContextHandle,
        key: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to disable data prefetch process before the onDrop callback executing.\n        The system will retry to getting data until the max time limit (2.4s for now) reaches,\n        this's useful for the cross device draging operation, as the system helps to eliminate\n        the communication instability, but it's redundant for {@link OH_ArkUI_DragEvent_StartDataLoading}\n        method, as it will take care the data fetching with asynchronous mechanism, so must set this\n        field to true if using {@link OH_ArkUI_DragEvent_StartDataLoading} in onDrop to avoid the data is\n        fetched before onDrop executing unexpectedly.\n\n @param node Indicates the pointer to a component node.\n @param disabled Indicates whether to disable the data pre-fetch process, true for disable, false for not.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_DisableDropDataPrefetchOnNode(node: ArkUI_NodeHandle, disabled: bool) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable strict reporting on drag events.\n        This feature is disabled by default, and you are advised to enable it.\n        If this feature is disabled, the parent component is not notified when an item in it is dragged over its child\n        component. If this feature is enabled, the component is notified of the dragged item's leaving, and the chil\n        component to which the dragged item is dropped is notified of the item's entering. This configuration is\n        related to a specific UI instance. You can pass in a specific component node on the current UI instance\n        for association.\n\n @param node Indicates the pointer to a component node.\n @param enabled Indicates whether to enable strict reporting on drag events.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetDragEventStrictReportWithNode(node: ArkUI_NodeHandle, enabled: bool) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable strict reporting on drag events.\n        This feature is disabled by default, and you are advised to enable it.\n        If this feature is disabled, the parent component is not notified when an item in it is dragged over its child\n        component. If this feature is enabled, the component is notified of the dragged item's leaving, and the child\n        component to which the dragged item is dropped is notified of the item's entering. This configuration is\n        related to a specific UI instance. You can pass in a specific UI instance for association.\n\n @param uiContext Indicates the pointer to a UI instance.\n @param enabled Indicates whether to enable strict reporting on drag events.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetDragEventStrictReportWithContext(
        uiContext: ArkUI_ContextHandle,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the types of data that can be dropped to the specified component. This API resets the settings configured\n        through {@link OH_ArkUI_DisallowNodeAnyDropDataTypes} and {@link OH_ArkUI_AllowNodeAllDropDataTypes}.\n\n @param node Indicates the pointer to a component node.\n @param typesArray Indicates the array of types of data that can be dropped.\n @param count Indicates length of an array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetNodeAllowedDropDataTypes(
        node: ArkUI_NodeHandle,
        typesArray: *mut *const ::std::os::raw::c_char,
        count: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Configures the specified component to disallow any data types. This API resets the settings configured through\n        {@link OH_ArkUI_SetNodeAllowedDropDataTypes}.\n\n @param node Indicates the pointer to a component node.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DisallowNodeAnyDropDataTypes(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Configures the specified component to allow any data types. This API resets the settings configured through\n        {@link OH_ArkUI_SetNodeAllowedDropDataTypes}.\n\n @param node Indicates the pointer to a component node.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AllowNodeAllDropDataTypes(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether the specified component is draggable.\n\n @param node Indicates the pointer to a component node.\n @param bool Indicates whether the component is draggable.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetNodeDraggable(node: ArkUI_NodeHandle, enabled: bool) -> i32;
}
extern "C" {
    #[doc = " @brief Sets a custom drag preview for the specified component.\n\n @param node Indicates the pointer to a component node.\n @param preview Indicates the custom drag preview, which is a pixel map.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetNodeDragPreview(
        node: ArkUI_NodeHandle,
        preview: *mut OH_PixelmapNative,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Creates an <b>ArkUI_DragPreviewOption</b> object.\n\n @return Returns the created <b>ArkUI_DragPreviewOption</b> object.\n @since 12"]
    pub fn OH_ArkUI_CreateDragPreviewOption() -> *mut ArkUI_DragPreviewOption;
}
extern "C" {
    #[doc = " @brief Disposes of a <b>ArkUI_DragPreviewOption</b> object.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_Dispose(option: *mut ArkUI_DragPreviewOption);
}
extern "C" {
    #[doc = " @brief Sets the scale mode for an <b>ArkUI_DragPreviewOption</b> object.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param scaleMode Indicates the scale mode.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetScaleMode(
        option: *mut ArkUI_DragPreviewOption,
        scaleMode: ArkUI_DragPreviewScaleMode,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the shadow effect for an <b>ArkUI_DragPreviewOption</b> object.\n        The shadow effect is enabled by default.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param enabled Indicates whether to enable the shadow effect.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetDefaultShadowEnabled(
        option: *mut ArkUI_DragPreviewOption,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the rounded corner effect for an <b>ArkUI_DragPreviewOption</b> object.\n        The rounded corner effect is enabled by default.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param enabled Indicates whether to enable the rounded corner effect.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetDefaultRadiusEnabled(
        option: *mut ArkUI_DragPreviewOption,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the badge for an <b>ArkUI_DragPreviewOption</b> object.\n        If this feature is enabled, a badge that contains the number of dragged items is displayed.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param enabled Indicates whether to enable badge.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetNumberBadgeEnabled(
        option: *mut ArkUI_DragPreviewOption,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the count on the badge.\n        The settings will overwrite the value in the <b>SetDragPreviewNumberBadgeEnabled</b> API.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param forcedNumber Indicates the count on the badge.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetBadgeNumber(
        option: *mut ArkUI_DragPreviewOption,
        forcedNumber: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable the default animation on a click or touch, it's not used in drag action.\n\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @param enabled Indicates whether to enable the default animation on a click or touch.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragPreviewOption_SetDefaultAnimationBeforeLiftingEnabled(
        option: *mut ArkUI_DragPreviewOption,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets an <b>ArkUI_DragPreviewOption</b> object for the specified component.\n\n @param node Indicates the pointer to a component node.\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_SetNodeDragPreviewOption(
        node: ArkUI_NodeHandle,
        option: *mut ArkUI_DragPreviewOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Creates a drag action object for a UI instance based on the specified component node of the current\n        UI instance.\n\n @param node Indicates the pointer to a component node.\n @return Returns the pointer to the created drag action object; returns null if the operation fails.\n @since 12"]
    pub fn OH_ArkUI_CreateDragActionWithNode(node: ArkUI_NodeHandle) -> *mut ArkUI_DragAction;
}
extern "C" {
    #[doc = " @brief Creates a drag action object for the specified UI instance.\n\n @param uiContext Indicates the pointer to a UI instance.\n @return Returns the pointer to the created drag action object; returns null if the operation fails.\n @since 12"]
    pub fn OH_ArkUI_CreateDragActionWithContext(
        uiContext: ArkUI_ContextHandle,
    ) -> *mut ArkUI_DragAction;
}
extern "C" {
    #[doc = " @brief Disposes of a drag action object.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @since 12"]
    pub fn OH_ArkUI_DragAction_Dispose(dragAction: *mut ArkUI_DragAction);
}
extern "C" {
    #[doc = " @brief Sets the pointer ID. If only one finger is operating on the screen, the pointer ID is 0.\n        In general cases, you can set the pointer ID to 0.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param pointer Indicates the pointer ID. The value ranges from 0 to 9.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetPointerId(dragAction: *mut ArkUI_DragAction, pointer: i32)
        -> i32;
}
extern "C" {
    #[doc = " @brief Sets the drag previews for a drag action.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param pixelmapArray Indicates the array of the drag previews to set, which must be pixel maps.\n @param size Indicates the size of the drag preview array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetPixelMaps(
        dragAction: *mut ArkUI_DragAction,
        pixelmapArray: *mut *mut OH_PixelmapNative,
        size: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the touch point relative to the upper left corner of the first drag preview (pixel map).\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param x Indicates the X coordinate of the touch point.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetTouchPointX(dragAction: *mut ArkUI_DragAction, x: f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the touch point relative to the upper left corner of the first drag preview (pixel map).\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param y Indicates the Y coordinate of the touch point.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetTouchPointY(dragAction: *mut ArkUI_DragAction, y: f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the drag data.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param data Indicates the drag data.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetData(
        dragAction: *mut ArkUI_DragAction,
        data: *mut OH_UdmfData,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets an <b>ArkUI_DragPreviewOption</b> object for the specified drag action object.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param option Indicates the pointer to an <b>ArkUI_DragPreviewOption</b> object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_SetDragPreviewOption(
        dragAction: *mut ArkUI_DragAction,
        option: *mut ArkUI_DragPreviewOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a drag status listener.\n        This listener can be used to check whether the data is successfully  received and processed.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @param userData Indicates the custom user data.\n @param listener\n Indicates the listener to register. When the callback is invoked, the system returns a pointer to the drag status\n object. The pointer is destroyed after the callback is complete and the application should not hold it anymore.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAction_RegisterStatusListener(
        dragAction: *mut ArkUI_DragAction,
        userData: *mut ::std::os::raw::c_void,
        listener: ::std::option::Option<
            unsafe extern "C" fn(
                dragAndDropInfo: *mut ArkUI_DragAndDropInfo,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregisters a drag status listener.\n\n @param dragAction Indicates the pointer to the target drag action object.\n @since 12"]
    pub fn OH_ArkUI_DragAction_UnregisterStatusListener(dragAction: *mut ArkUI_DragAction);
}
extern "C" {
    #[doc = " @brief Obtains the drag status of a drag action.\n\n @param dragAndDropInfo Indicates the drag and drop information returned by the drag status listener.\n @return Returns an <b>ArkUI_DragStatus</b> object; returns <b>ArkUI_DRAG_STATUS_UNKNOWN</b> if an error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAndDropInfo_GetDragStatus(
        dragAndDropInfo: *mut ArkUI_DragAndDropInfo,
    ) -> ArkUI_DragStatus;
}
extern "C" {
    #[doc = " @brief Obtains a drag event based on the specified drag and drop information.\n        The drag event can then be used to obtain the drag result and the drag behavior, please note\n        other info is not included in such a drag event.\n\n @param dragAndDropInfo Indicates the drag and drop information returned by the drag status listener.\n @return Returns an <b>ArkUI_DragEvent</b> object; returns null if an error occurs.\n @since 12"]
    pub fn OH_ArkUI_DragAndDropInfo_GetDragEvent(
        dragAndDropInfo: *mut ArkUI_DragAndDropInfo,
    ) -> *mut ArkUI_DragEvent;
}
extern "C" {
    #[doc = " @brief Initiates a drag action through the specified drag action object.\n\n @param dragAction Indicates a drag action object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_StartDrag(dragAction: *mut ArkUI_DragAction) -> i32;
}
#[doc = " @brief Defines the expected frame rate range of the animation.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ExpectedFrameRateRange {
    #[doc = " Expected minimum frame rate."]
    pub min: u32,
    #[doc = " Expected maximum frame rate."]
    pub max: u32,
    #[doc = " Expected optimal frame rate."]
    pub expected: u32,
}
#[doc = " @brief Defines the callback type for when the animation playback is complete.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimateCompleteCallback {
    #[doc = " Type of the <b>onFinish</b> callback."]
    pub type_: ArkUI_FinishCallbackType,
    #[doc = " Callback invoked when the animation playback is complete."]
    pub callback:
        ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
    #[doc = " Custom type."]
    pub userData: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimateOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Curve {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to an interpolation curve.\n\n @since 12"]
pub type ArkUI_CurveHandle = *mut ArkUI_Curve;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_KeyframeAnimateOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimatorOption {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_Animator {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the pointer to an animator object.\n\n @since 12"]
pub type ArkUI_AnimatorHandle = *mut ArkUI_Animator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimatorEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AnimatorOnFrameEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TransitionEffect {
    _unused: [u8; 0],
}
#[doc = " @brief Implements the native animation APIs provided by ArkUI.\n\n @version 1\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeAnimateAPI_1 {
    #[doc = " @brief Defines an explicit animation.\n\n @note Make sure the component attributes to be set in the event closure have been set before.\n\n @param context Indicates a <b>UIContext</b> instance.\n @param option Indicates the pointer to an animation configuration.\n @param update Indicates the animation closure. The system automatically inserts a transition animation for the\n state change caused by the closure.\n @param complete Indicates the callback to be invoked when the animation playback is complete.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub animateTo: ::std::option::Option<
        unsafe extern "C" fn(
            context: ArkUI_ContextHandle,
            option: *mut ArkUI_AnimateOption,
            update: *mut ArkUI_ContextCallback,
            complete: *mut ArkUI_AnimateCompleteCallback,
        ) -> i32,
    >,
    #[doc = " @brief Sets the keyframe animation.\n\n\n @param context Indicates a <b>UIContext</b> instance.\n @param option Indicates the keyframe animation parameters.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub keyframeAnimateTo: ::std::option::Option<
        unsafe extern "C" fn(
            context: ArkUI_ContextHandle,
            option: *mut ArkUI_KeyframeAnimateOption,
        ) -> i32,
    >,
    #[doc = " @brief Creates an animator object.\n\n @param context Indicates a <b>UIContext</b> instance.\n @param option Indicates the animator parameters.\n @return Returns the pointer to the animator object; returns <b>NULL</b> if a function parameter error occurs."]
    pub createAnimator: ::std::option::Option<
        unsafe extern "C" fn(
            context: ArkUI_ContextHandle,
            option: *mut ArkUI_AnimatorOption,
        ) -> ArkUI_AnimatorHandle,
    >,
    #[doc = " @brief Disposes of an animator object.\n\n @param animator Indicates the target animator object."]
    pub disposeAnimator:
        ::std::option::Option<unsafe extern "C" fn(animatorHandle: ArkUI_AnimatorHandle)>,
}
extern "C" {
    #[doc = " @brief Creates an animation configuration.\n\n @return Returns the pointer to the created animation configuration.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_Create() -> *mut ArkUI_AnimateOption;
}
extern "C" {
    #[doc = " @brief Disposes of an animation configuration.\n\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_Dispose(option: *mut ArkUI_AnimateOption);
}
extern "C" {
    #[doc = " @brief Obtains the animation duration, in milliseconds.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the duration.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetDuration(option: *mut ArkUI_AnimateOption) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the animation playback speed.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the animation playback speed.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetTempo(option: *mut ArkUI_AnimateOption) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the animation curve.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the animated curve.If Null is returned, it means option is an invalid value.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetCurve(
        option: *mut ArkUI_AnimateOption,
    ) -> ArkUI_AnimationCurve;
}
extern "C" {
    #[doc = " @brief Obtains the animation delay, in milliseconds.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the animation delay.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetDelay(option: *mut ArkUI_AnimateOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of times that an animation is played.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the number of times that the animation is played.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetIterations(option: *mut ArkUI_AnimateOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the animation playback mode.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the animation playback mode.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetPlayMode(
        option: *mut ArkUI_AnimateOption,
    ) -> ArkUI_AnimationPlayMode;
}
extern "C" {
    #[doc = " @brief Obtains the expected frame rate range of an animation.\n\n @param option Indicates the pointer to an animation configuration.\n @return Returns the expected frame rate range.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetExpectedFrameRateRange(
        option: *mut ArkUI_AnimateOption,
    ) -> *mut ArkUI_ExpectedFrameRateRange;
}
extern "C" {
    #[doc = " @brief Sets the animation duration.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the duration, in milliseconds.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetDuration(option: *mut ArkUI_AnimateOption, value: i32);
}
extern "C" {
    #[doc = " @brief Sets the animation playback speed.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the animation playback speed.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetTempo(option: *mut ArkUI_AnimateOption, value: f32);
}
extern "C" {
    #[doc = " @brief Sets the animation curve.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the animated curve. Default value：ARKUI_CURVE_LINEAR.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetCurve(
        option: *mut ArkUI_AnimateOption,
        value: ArkUI_AnimationCurve,
    );
}
extern "C" {
    #[doc = " @brief Sets the animation delay.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the animation delay.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetDelay(option: *mut ArkUI_AnimateOption, value: i32);
}
extern "C" {
    #[doc = " @brief Sets the number of times that an animation is played.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the number of times that the animation is played.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetIterations(option: *mut ArkUI_AnimateOption, value: i32);
}
extern "C" {
    #[doc = " @brief Sets the animation playback mode.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the animation playback mode.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetPlayMode(
        option: *mut ArkUI_AnimateOption,
        value: ArkUI_AnimationPlayMode,
    );
}
extern "C" {
    #[doc = " @brief Sets the expected frame rate range of an animation.\n\n @param option Indicates the pointer to an animation configuration.\n @param value Indicates the expected frame rate range.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetExpectedFrameRateRange(
        option: *mut ArkUI_AnimateOption,
        value: *mut ArkUI_ExpectedFrameRateRange,
    );
}
extern "C" {
    #[doc = " @brief Sets the animation curve for the animation of an animator.\n\n @note This method is better than the value set by OH_ArkUI_AnimateOption_SetCurve.\n @param option Indicates the animator parameters.\n @param value Indicates the animation curve settings.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_SetICurve(
        option: *mut ArkUI_AnimateOption,
        value: ArkUI_CurveHandle,
    );
}
extern "C" {
    #[doc = " @brief Obtains the animation curve of the animation of an animator.\n\n @param option Indicates the animator parameters.\n @return Returns the animation curve of the specified animation.\n If Null is returned, it means option is an invalid value.\n @since 12"]
    pub fn OH_ArkUI_AnimateOption_GetICurve(option: *mut ArkUI_AnimateOption) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Obtains the keyframe animation parameters.\n\n @param size Indicates the number of keyframe animation states.\n @return Returns the keyframe animation parameter object; returns <b>NULL</b> if the value of <b>size</b> is less than\n 0.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_Create(size: i32) -> *mut ArkUI_KeyframeAnimateOption;
}
extern "C" {
    #[doc = " @brief Disposes of the keyframe animation parameter object.\n\n @param option Indicates the keyframe animation parameter object.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_Dispose(option: *mut ArkUI_KeyframeAnimateOption);
}
extern "C" {
    #[doc = " @brief Sets the overall delay of a keyframe animation, in milliseconds. By default, the keyframe animation is played\n without delay.\n\n @param option Indicates the keyframe animation parameters.\n @param value Indicates the delay, in milliseconds.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_SetDelay(
        option: *mut ArkUI_KeyframeAnimateOption,
        value: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the number of times that the keyframe animation is played. By default, the animation is played once.\n The value <b>-1</b> indicates that the animation is played for an unlimited number of times. The value <b>0</b>\n indicates that there is no animation.\n\n @param option Indicates the keyframe animation parameters.\n @param value Indicates the number of times that the animation is played.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_SetIterations(
        option: *mut ArkUI_KeyframeAnimateOption,
        value: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the keyframe animation playback is complete. This API is called after the\n keyframe animation has played for the specified number of times.\n\n @param option Indicates the keyframe animation parameters.\n @param userData Indicates the pointer to a custom object.\n @param onFinish Indicates the callback.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_RegisterOnFinishCallback(
        option: *mut ArkUI_KeyframeAnimateOption,
        userData: *mut ::std::os::raw::c_void,
        onFinish: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the duration of a keyframe animation, in milliseconds.\n\n @param option Indicates the keyframe animation parameters.\n @param value Indicates the duration to set, in milliseconds.\n @param index Indicates a state index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_SetDuration(
        option: *mut ArkUI_KeyframeAnimateOption,
        value: i32,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the animation curve for a specific keyframe in a keyframe animation.\n\n @note Because the <b>springMotion</b>, <b>responsiveSpringMotion</b>, and <b>interpolatingSpring</b> curves do not\n have effective duration settings, they are not supported.\n @param option Indicates the keyframe animation parameters.\n @param value Indicates the animation curve to set. Default value：EASE_IN_OUT.\n @param index Indicates a state index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_SetCurve(
        option: *mut ArkUI_KeyframeAnimateOption,
        value: ArkUI_CurveHandle,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the closure function of the state at the time of the keyframe, that is, the state to be reached at the\n time of the keyframe.\n\n @param option Indicates the keyframe animation parameters.\n @param event Indicates a closure function.\n @param userData Indicates the pointer to a custom object.\n @param index Indicates a state index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_RegisterOnEventCallback(
        option: *mut ArkUI_KeyframeAnimateOption,
        userData: *mut ::std::os::raw::c_void,
        event: ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the overall delay of a keyframe animation\n\n @param option Indicates the keyframe animation parameters.\n @return Returns the overall delay.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_GetDelay(option: *mut ArkUI_KeyframeAnimateOption)
        -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of times that a keyframe animation is played.\n\n @param option Indicates the keyframe animation parameters.\n @return Returns the number of times that the animation is played.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_GetIterations(
        option: *mut ArkUI_KeyframeAnimateOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the duration of a specific state in a keyframe animation.\n\n @param option Indicates the keyframe animation parameters.\n @param index Indicates a state index.\n @return Returns the duration. The unit is millisecond.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_GetDuration(
        option: *mut ArkUI_KeyframeAnimateOption,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the animation curve of a specific state in a keyframe animation.\n\n @param option Indicates the keyframe animation parameters.\n @param index Indicates a state index.\n @return Returns the animated curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_KeyframeAnimateOption_GetCurve(
        option: *mut ArkUI_KeyframeAnimateOption,
        index: i32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates an animator parameter object.\n\n @note When <b>keyframeSize</b> is greater than 0, the animation interpolation start point is 0, and the animation\n interpolation end point is 1; no setting is allowed.\n @param keyframeSize Indicates the number of keyframes.\n @return Returns the pointer to the animator parameter object.\n returns <b>NULL</b> if the value of <b>size</b> is less than 0.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_Create(keyframeSize: i32) -> *mut ArkUI_AnimatorOption;
}
extern "C" {
    #[doc = " @brief Disposes of an animator parameter object.\n\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_Dispose(option: *mut ArkUI_AnimatorOption);
}
extern "C" {
    #[doc = " @brief Sets the duration for thea nimation of an animator, in milliseconds.\n\n @param option Indicates the target animator parameter object.\n @param value Indicates the playback duration, in milliseconds.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetDuration(
        option: *mut ArkUI_AnimatorOption,
        value: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the delay for playing the animation of an animator, in milliseconds.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the delay to set, in milliseconds.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetDelay(option: *mut ArkUI_AnimatorOption, value: i32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the number of times that the animation of an animator is played. The value <b>0</b> means not to play the\n animation, and <b>-1</b> means to play the animation for an unlimited number of times.\n\n @note If this parameter is set to a negative value other than <b>-1</b>, the value is invalid. In this case, the\n animation is played once.\n @param option Indicates an animator parameter object.\n @param value Indicates the number of times that the animation is played.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetIterations(
        option: *mut ArkUI_AnimatorOption,
        value: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether the animation of an animator is restored to the initial state after being executed.\n\n @param option Indicates an animator parameter object.\n @param value Indicates whether to restore the animation to the initial state after the animation is executed.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetFill(
        option: *mut ArkUI_AnimatorOption,
        value: ArkUI_AnimationFillMode,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the playback direction for the animation of an animator.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the animation playback direction.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetDirection(
        option: *mut ArkUI_AnimatorOption,
        value: ArkUI_AnimationDirection,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the interpolation curve for the animation of an animator.\n\n @note <b>springCurve</b>, <b>springMotion</b>, <b>responsiveSpringMotion</b>, <b>interpolatingSpring</b>,\n and <b>customCurve</b> curves are not supported.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the target interpolation curve. Default value：ARKUI_CURVE_LINEAR.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetCurve(
        option: *mut ArkUI_AnimatorOption,
        value: ArkUI_CurveHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the interpolation start point for the animation of an animator.\n @note This API does not take effect when the animation is a keyframe animation.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the interpolation start point to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetBegin(option: *mut ArkUI_AnimatorOption, value: f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the interpolation end point for the animation of an animator.\n @note This API does not take effect when the animation is a keyframe animation.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the interpolation end point to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetEnd(option: *mut ArkUI_AnimatorOption, value: f32) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the expected frame rate range for the animation of an animator.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the expected frame rate range to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetExpectedFrameRateRange(
        option: *mut ArkUI_AnimatorOption,
        value: *mut ArkUI_ExpectedFrameRateRange,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the keyframe parameters for the animation of an animator.\n\n @param option Indicates an animator parameter object.\n @param time Indicates the keyframe time. Value range: [0,1].\n @param value Indicates the keyframe value.\n @param index Indicates the keyframe index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetKeyframe(
        option: *mut ArkUI_AnimatorOption,
        time: f32,
        value: f32,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the keyframe curve type for the animation of an animator.\n\n @note <b>springCurve</b>, <b>springMotion</b>, <b>responsiveSpringMotion</b>, <b>interpolatingSpring</b>,\n and <b>customCurve</b> curves are not supported.\n\n @param option Indicates an animator parameter object.\n @param value Indicates the target interpolation curve.\n @param index Indicates the keyframe index.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_SetKeyframeCurve(
        option: *mut ArkUI_AnimatorOption,
        value: ArkUI_CurveHandle,
        index: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the duration for playing an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the duration for playing the animation, in milliseconds.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetDuration(option: *mut ArkUI_AnimatorOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the delay for playing the animation of an animator.\n\n @param option Indicates the animator parameters.\n @return Returns the delay for playing the animation, in milliseconds.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetDelay(option: *mut ArkUI_AnimatorOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of times that an animation is played.\n\n @param option Animator animation parameter.\n @return Returns the number of times that the animation is played.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetIterations(option: *mut ArkUI_AnimatorOption) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether the animator animation is restored to the initial state after being executed.\n\n @param option Indicates the animator parameters.\n @return Returns whether the animator animation is restored to the initial state after being executed.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetFill(
        option: *mut ArkUI_AnimatorOption,
    ) -> ArkUI_AnimationFillMode;
}
extern "C" {
    #[doc = " @brief Obtains the playback direction of an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the animation playback direction.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetDirection(
        option: *mut ArkUI_AnimatorOption,
    ) -> ArkUI_AnimationDirection;
}
extern "C" {
    #[doc = " @brief Obtains the interpolation curve of the animation of an animator.\n\n @param option Indicates the animator parameters.\n @return Returns the interpolation curve of the animation.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetCurve(option: *mut ArkUI_AnimatorOption)
        -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Obtains the interpolation start point of an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the interpolation start point of the animation.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetBegin(option: *mut ArkUI_AnimatorOption) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the interpolation end point of an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the interpolation end point of the animation.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetEnd(option: *mut ArkUI_AnimatorOption) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the expected frame rate range of an animation.\n\n @param option Indicates the animator parameters.\n @return Returns the pointer to the expected frame rate range object.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetExpectedFrameRateRange(
        option: *mut ArkUI_AnimatorOption,
    ) -> *mut ArkUI_ExpectedFrameRateRange;
}
extern "C" {
    #[doc = " @brief Obtains the keyframe time of an animation.\n\n @param option Indicates an animator parameter object.\n @param index Indicates the keyframe index.\n @return Returns the keyframe time.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetKeyframeTime(
        option: *mut ArkUI_AnimatorOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the keyframe value of an animation.\n\n @param option Indicates an animator parameter object.\n @param index Indicates the keyframe index.\n @return Returns the keyframe value.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetKeyframeValue(
        option: *mut ArkUI_AnimatorOption,
        index: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the interpolation curve for a keyframe in the animation of an animator.\n\n @param option Indicates an animator parameter object.\n @param index Indicates the keyframe index.\n @return Returns the interpolation curve.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_GetKeyframeCurve(
        option: *mut ArkUI_AnimatorOption,
        index: i32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Obtains the custom object in an animation event object.\n\n @param event Indicates an animation event object.\n @return Returns the custom object.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorEvent_GetUserData(
        event: *mut ArkUI_AnimatorEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the custom object in an animation event object.\n\n @param event Indicates an animation event object.\n @return Returns the custom object.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOnFrameEvent_GetUserData(
        event: *mut ArkUI_AnimatorOnFrameEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the current progress in an animation event object.\n\n @param event Indicates an animation event object.\n @return Returns the animation progress.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOnFrameEvent_GetValue(event: *mut ArkUI_AnimatorOnFrameEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the animator receives a frame.\n\n @param option Indicates an animator parameter object.\n @param userData Indicates the custom parameter.\n @param callback Indicates the callback to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_RegisterOnFrameCallback(
        option: *mut ArkUI_AnimatorOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(event: *mut ArkUI_AnimatorOnFrameEvent),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the animation playback is complete.\n\n @param option Indicates an animator parameter object.\n @param userData Indicates the custom parameter.\n @param callback Indicates the callback to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_RegisterOnFinishCallback(
        option: *mut ArkUI_AnimatorOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_AnimatorEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the animation playback is canceled.\n\n @param option Indicates an animator parameter object.\n @param userData Indicates the custom parameter.\n @param callback Indicates the callback to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_RegisterOnCancelCallback(
        option: *mut ArkUI_AnimatorOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_AnimatorEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the callback invoked when the animation playback is repeated.\n\n @param option Indicates an animator parameter object.\n @param userData Indicates the custom parameter.\n @param callback Indicates the callback to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AnimatorOption_RegisterOnRepeatCallback(
        option: *mut ArkUI_AnimatorOption,
        userData: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_AnimatorEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Resets the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @param option Indicates the animator parameters.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_ResetAnimatorOption(
        animatorHandle: ArkUI_AnimatorHandle,
        option: *mut ArkUI_AnimatorOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Starts the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Play(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Ends the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Finish(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Pauses the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Pause(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Cancels the animation of an animator.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Cancel(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Plays the animation of an animator in reverse order.\n\n @param animatorHandle Indicates an animator object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_Animator_Reverse(animatorHandle: ArkUI_AnimatorHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Implements initialization for the interpolation curve, which is used to create an interpolation curve based on\n the input parameter.\n\n @param curve Indicates the curve type.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs."]
    pub fn OH_ArkUI_Curve_CreateCurveByType(curve: ArkUI_AnimationCurve) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a step curve.\n\n @param count Indicates the number of steps. The value must be a positive integer. Value range: [1, +∞).\n @param end Indicates whether jumping occurs when the interpolation ends.\n <b>true</b>: Jumping occurs when the interpolation ends. <b>false</b>: Jumping occurs when the interpolation starts.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs."]
    pub fn OH_ArkUI_Curve_CreateStepsCurve(count: i32, end: bool) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a cubic Bezier curve.\n\n\n @param x1 Indicates the X coordinate of the first point on the Bezier curve. Value range: [0, 1].\n A value less than 0 is handed as <b>0</b>. A value greater than 1 is handed as <b>1</b>.\n @param y1 Indicates the Y coordinate of the first point on the Bezier curve.\n @param x2 Indicates the X coordinate of the second point on the Bezier curve. Value range: [0, 1].\n A value less than 0 is handed as <b>0</b>. A value greater than 1 is handed as <b>1</b>.\n @param y2 Indicates the Y coordinate of the second point on the Bezier curve.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs."]
    pub fn OH_ArkUI_Curve_CreateCubicBezierCurve(
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a spring curve. The curve shape is subject to the spring parameters, and the animation duration is\n subject to the <b>duration</b> parameter in <b>animation</b> and <b>animateTo</b>.\n\n @param velocity Indicates the initial velocity of the spring. It is applied by external factors to the spring\n animation, designed to help ensure the smooth transition from the previous motion state. The velocity is the\n normalized velocity, and its value is equal to the actual velocity at the beginning of the animation divided by the\n  animation attribute change value.\n @param mass Indicates the mass, which influences the inertia in the spring system. The greater the mass, the greater\n the amplitude of the oscillation, and the slower the speed of restoring to the equilibrium position.\n @param stiffness Indicates the stiffness. It is the degree to which an object deforms by resisting the force applied.\n In an elastic system, the greater the stiffness, the stronger the ability to resist deformation, and the faster the\n speed of restoring to the equilibrium position.\n @param damping Indicates the damping. It is used to describe the oscillation and attenuation of the system after\n being disturbed. The larger the damping, the smaller the number of oscillations of elastic motion, and the smaller\n the oscillation amplitude.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs."]
    pub fn OH_ArkUI_Curve_CreateSpringCurve(
        velocity: f32,
        mass: f32,
        stiffness: f32,
        damping: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a spring animation curve. If multiple spring animations are applied to the same attribute of an\n  object, each animation replaces their predecessor and inherits the velocity.\n @note The animation duration is subject to the curve parameters, rather than the <b>duration</b> parameter in\n <b>animation</b> or <b>animateTo</b>.\n\n @param response Indicates the duration of one complete oscillation.\n @param dampingFraction Indicates the damping coefficient.\n > 0 and < 1: underdamped. In this case, the spring overshoots the equilibrium position.\n <b>1</b>: critically damped.\n > 1: overdamped. In this case, the spring approaches equilibrium gradually.\n @param overlapDuration Indicates the duration for animations to overlap. When animations overlap, the <b>response</b>\n values of these animations will\n transit smoothly over this duration if they are different.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs."]
    pub fn OH_ArkUI_Curve_CreateSpringMotion(
        response: f32,
        dampingFraction: f32,
        overlapDuration: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a responsive spring animation curve. It is a special case of <b>springMotion</b>, with the only\n difference in the default values. It can be used together with <b>springMotion</b>.\n @note The animation duration is subject to the curve parameters, rather than the <b>duration</b> parameter in\n <b>animation</b> or <b>animateTo</b>.\n\n @param response Indicates the duration of one complete oscillation.\n @param dampingFraction Indicates the damping coefficient.\n > 0 and < 1: underdamped. In this case, the spring overshoots the equilibrium position.\n <b>1</b>: critically damped.\n > 1: overdamped. In this case, the spring approaches equilibrium gradually.\n @param overlapDuration Indicates the duration for animations to overlap. When animations overlap, the\n <b>response</b> values of these animations will\n transit smoothly over this duration if they are different.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs."]
    pub fn OH_ArkUI_Curve_CreateResponsiveSpringMotion(
        response: f32,
        dampingFraction: f32,
        overlapDuration: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates an interpolating spring curve animated from 0 to 1. The actual animation value is calculated based on\n the curve.\n @note The animation duration is subject to the curve parameters, rather than the <b>duration</b> parameter in\n <b>animation</b> or <b>animateTo</b>.\n\n\n @param velocity Indicates the initial velocity of the spring. It is applied by external factors to the spring\n animation, esigned to help ensure the smooth transition from the previous motion state. The velocity is the\n normalized velocity, and its value is equal to the actual velocity\n at the beginning of the animation divided by the animation attribute change value.\n @param mass Indicates the mass, which influences the inertia in the spring system.\n The greater the mass, the greater the amplitude of the oscillation, and the slower the speed of restoring to the\n equilibrium position.\n @param stiffness Indicates the stiffness. It is the degree to which an object deforms by resisting the force applied.\n In an elastic system, the greater the stiffness, the stronger the ability to resist deformation, and the faster the\n speed of restoring to the equilibrium position.\n @param damping Indicates the damping. It is used to describe the oscillation and attenuation of the system after\n being disturbed. The larger the damping, the smaller the number of oscillations of elastic motion, and the smaller\n the oscillation amplitude.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs."]
    pub fn OH_ArkUI_Curve_CreateInterpolatingSpring(
        velocity: f32,
        mass: f32,
        stiffness: f32,
        damping: f32,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Creates a custom curve.\n\n @param userData Indicates the custom data.\n @param interpolate Indicates the custom interpolation callback. <b>fraction</b> indicates the input x value for\n interpolation when the animation starts; value range: [0,1].\n The return value is the y value of the curve; value range: [0,1].\n If <b>fraction</b> is <b>0</b>, the return value <b>0</b> corresponds to the animation start point; any other return\n value means that the animation jumps at the start point.\n If <b>fraction</b> is <b>1</b>, the return value <b>1</b> corresponds to the animation end point; any other return\n value means that the end value of the animation is not the value of the state variable,\n which will result in an effect of transition from that end value to the value of the state variable.\n @return Returns the pointer to the interpolation object of the curve.\n         Returns <b>NULL</b> if a parameter error occurs."]
    pub fn OH_ArkUI_Curve_CreateCustomCurve(
        userData: *mut ::std::os::raw::c_void,
        interpolate: ::std::option::Option<
            unsafe extern "C" fn(fraction: f32, userdata: *mut ::std::os::raw::c_void) -> f32,
        >,
    ) -> ArkUI_CurveHandle;
}
extern "C" {
    #[doc = " @brief Disposes of a custom curve.\n\n @param curve Indicates the pointer to the interpolation object of the curve."]
    pub fn OH_ArkUI_Curve_DisposeCurve(curveHandle: ArkUI_CurveHandle);
}
extern "C" {
    #[doc = " @brief Creates an opacity object for component transition.\n\n @note If the value specified is less than 0, the value <b>0</b> is used. If the value specified is greater than 1,\n the value <b>1</b> is used.\n @param opacity Indicates the opacity. Value range: [0, 1].\n @return Returns the created opacity object for component transition.\n @since 12"]
    pub fn OH_ArkUI_CreateOpacityTransitionEffect(opacity: f32) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates a translation object for component transition.\n\n @param translate Indicates the translation settings for component transition.\n @return Returns the translation object created for component transition.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateTranslationTransitionEffect(
        translate: *mut ArkUI_TranslationOptions,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates a scaling object for component transition.\n\n @param scale Indicates the scaling settings for component transition.\n @return Returns the scaling object created for component transition.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateScaleTransitionEffect(
        scale: *mut ArkUI_ScaleOptions,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates a rotation object for component transition.\n\n @param rotate Indicates the rotation settings for component transition.\n @return Returns the rotation object created for component transition.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateRotationTransitionEffect(
        rotate: *mut ArkUI_RotationOptions,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates a movement object for component transition.\n\n @param edge Indicates the movement type.\n @return Returns the movement object created for component transition.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateMovementTransitionEffect(
        edge: ArkUI_TransitionEdge,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Creates an asymmetric transition effect.\n\n @note If the <b>asymmetric</b> function is not used for <b>TransitionEffect</b>, the transition effect takes effect\n for both appearance and disappearance of the component.\n @param appear Indicates the transition effect for appearance.\n @param disappear Indicates the transition effect for disappearance.\n @return Returns the asymmetric transition effect.\n         Returns <b>NULL</b> if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_CreateAsymmetricTransitionEffect(
        appear: *mut ArkUI_TransitionEffect,
        disappear: *mut ArkUI_TransitionEffect,
    ) -> *mut ArkUI_TransitionEffect;
}
extern "C" {
    #[doc = " @brief Disposes of a transition effect.\n\n @param effect Indicates the transition effect to dispose of.\n @since 12"]
    pub fn OH_ArkUI_TransitionEffect_Dispose(effect: *mut ArkUI_TransitionEffect);
}
extern "C" {
    #[doc = " @brief Sets a combination of transition effects.\n\n @param firstEffect Indicates the transition effect options.\n @param secondEffect Indicates the combination of transition effects.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_TransitionEffect_Combine(
        firstEffect: *mut ArkUI_TransitionEffect,
        secondEffect: *mut ArkUI_TransitionEffect,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets transition effect animation settings.\n\n @note If <b>combine</b> is used for combining transition effects, the animation settings of a transition effect are\n applicable to the one following it.\n @param effect Indicates the transition effect options.\n @param animation Indicates the animation settings.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_TransitionEffect_SetAnimation(
        effect: *mut ArkUI_TransitionEffect,
        animation: *mut ArkUI_AnimateOption,
    ) -> i32;
}
#[doc = " Touching the system-defined Back button or pressing the Esc key."]
pub const ArkUI_DismissReason_DIALOG_DISMISS_BACK_PRESS: ArkUI_DismissReason = 0;
#[doc = " Touching the mask."]
pub const ArkUI_DismissReason_DIALOG_DISMISS_TOUCH_OUTSIDE: ArkUI_DismissReason = 1;
#[doc = " Touching the Close button."]
pub const ArkUI_DismissReason_DIALOG_DISMISS_CLOSE_BUTTON: ArkUI_DismissReason = 2;
#[doc = " Sliding down."]
pub const ArkUI_DismissReason_DIALOG_DISMISS_SLIDE_DOWN: ArkUI_DismissReason = 3;
#[doc = " @brief Enumerates the actions for triggering closure of the dialog box.\n\n @since 12"]
pub type ArkUI_DismissReason = ::std::os::raw::c_uint;
#[doc = " overlay mode."]
pub const ArkUI_LevelMode_ARKUI_LEVEL_MODE_OVERLAY: ArkUI_LevelMode = 0;
#[doc = " embedded mode."]
pub const ArkUI_LevelMode_ARKUI_LEVEL_MODE_EMBEDDED: ArkUI_LevelMode = 1;
#[doc = " @brief Enumerates the level mode.\n\n @since 15"]
pub type ArkUI_LevelMode = ::std::os::raw::c_uint;
#[doc = " Mask covering the parent node area."]
pub const ArkUI_ImmersiveMode_ARKUI_IMMERSIVE_MODE_DEFAULT: ArkUI_ImmersiveMode = 0;
#[doc = " Mask extend safe area includes status bar and navigation bar."]
pub const ArkUI_ImmersiveMode_ARKUI_IMMERSIVE_MODE_EXTEND: ArkUI_ImmersiveMode = 1;
#[doc = " @brief Enumerates the immersive mode.\n\n @since 15"]
pub type ArkUI_ImmersiveMode = ::std::os::raw::c_uint;
#[doc = " @brief Invoked when the dialog box is closed.\n\n @since 12"]
pub type ArkUI_OnWillDismissEvent =
    ::std::option::Option<unsafe extern "C" fn(reason: i32) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_DialogDismissEvent {
    _unused: [u8; 0],
}
#[doc = " @brief Provides the custom dialog box APIs for the native side.\n\n @version 1\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeDialogAPI_1 {
    #[doc = " @brief Creates a custom dialog box and returns the pointer to the created dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @return Returns the pointer to the created custom dialog box; returns a null pointer if the creation fails."]
    pub create: ::std::option::Option<unsafe extern "C" fn() -> ArkUI_NativeDialogHandle>,
    #[doc = " @brief Destroys a custom dialog box.\n\n @param handle Indicates the pointer to the custom dialog box controller."]
    pub dispose: ::std::option::Option<unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle)>,
    #[doc = " @brief Attaches the content of a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param content Indicates the pointer to the root node of the custom dialog box content.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setContent: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, content: ArkUI_NodeHandle) -> i32,
    >,
    #[doc = " @brief Detaches the content of a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub removeContent:
        ::std::option::Option<unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle) -> i32>,
    #[doc = " @brief Sets the alignment mode for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param alignment Indicates the alignment mode. The parameter type is {@link ArkUI_Alignment}.\n @param offsetX Indicates the horizontal offset of the custom dialog box. The value is a floating point number.\n @param offsetY Indicates the vertical offset of the custom dialog box. The value is a floating point number.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setContentAlignment: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            alignment: i32,
            offsetX: f32,
            offsetY: f32,
        ) -> i32,
    >,
    #[doc = " @brief Resets the alignment mode of a custom dialog box to its default settings.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub resetContentAlignment:
        ::std::option::Option<unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle) -> i32>,
    #[doc = " @brief Sets the modal mode for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param isModal Specifies whether the custom dialog box is a modal, which has a mask applied. The value\n <b>true</b> means that the custom dialog box is a modal, and <b>false</b> means the opposite.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setModalMode: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, isModal: bool) -> i32,
    >,
    #[doc = " @brief Specifies whether to allow users to touch the mask to dismiss the custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param autoCancel Specifies whether to allow users to touch the mask to dismiss the dialog box.\n The value <b>true</b> means to allow users to do so, and <b>false</b> means the opposite.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setAutoCancel: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, autoCancel: bool) -> i32,
    >,
    #[doc = " @brief Sets the mask for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param maskColor Indicates the mask color, in 0xARGB format.\n @param maskRect Indicates the pointer to the mask area. Events outside the mask area are transparently\n transmitted, and events within the mask area are not. The parameter type is {@link ArkUI_Rect}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setMask: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            maskColor: u32,
            maskRect: *const ArkUI_Rect,
        ) -> i32,
    >,
    #[doc = " @brief Sets the background color for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param backgroundColor Indicates the background color of the custom dialog box, in 0xARGB format.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setBackgroundColor: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, backgroundColor: u32) -> i32,
    >,
    #[doc = " @brief Sets the background corner radius for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param topLeft Indicates the radius of the upper left corner of the custom dialog box background.\n @param topRight Indicates the radius of the upper right corner of the custom dialog box background.\n @param bottomLeft Indicates the radius of the lower left corner of the custom dialog box background.\n @param bottomRight Indicates the radius of the lower right corner of the custom dialog box background.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setCornerRadius: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            topLeft: f32,
            topRight: f32,
            bottomLeft: f32,
            bottomRight: f32,
        ) -> i32,
    >,
    #[doc = " @brief Sets the number of grid columns occupied by a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param gridCount Indicates the number of grid columns occupied by the dialog box. The default value is subject to\n the window size, and the maximum value is the maximum number of columns supported by the system.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setGridColumnCount: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, gridCount: i32) -> i32,
    >,
    #[doc = " @brief Specifies whether to use a custom style for the custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param enableCustomStyle Specifies whether to use a custom style for the dialog box.\n <b>true</b>: The dialog box automatically adapts its width to the child components; the rounded corner is 0;\n the background color is transparent.\n <b>false</b>: The dialog box automatically adapts its width to the grid system and its height to the child\n components; the rounded corner is 24 vp.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub enableCustomStyle: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, enableCustomStyle: bool) -> i32,
    >,
    #[doc = " @brief Specifies whether to use a custom animation for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param enableCustomAnimation Specifies whether to use a custom animation. The value <b>true</b> means to use a\n custom animation, and <b>false</b> means to use the default animation.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub enableCustomAnimation: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, enableCustomAnimation: bool) -> i32,
    >,
    #[doc = " @brief Registers a callback for a custom dialog box so that the user can decide whether to close the dialog box\n after they touch the Back button or press the Esc key.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param eventHandler Indicates the callback to register. The parameter type is {@link ArkUI_OnWillDismissEvent}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub registerOnWillDismiss: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            eventHandler: ArkUI_OnWillDismissEvent,
        ) -> i32,
    >,
    #[doc = " @brief Shows a custom dialog box.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param showInSubWindow Specifies whether to show the dialog box in a sub-window.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub show: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, showInSubWindow: bool) -> i32,
    >,
    #[doc = " @brief Closes a custom dialog box. If the dialog box has been closed, this API does not take effect.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub close: ::std::option::Option<unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle) -> i32>,
    #[doc = " @brief Registers a listener for the dismiss event of the custom dialog box.\n\n @param handle Indicates the pointer to the custom dialog box controller.\n @param userData Indicates the pointer to the custom data.\n @param callback Indicates the callback for the dismiss event of the custom dialog box.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub registerOnWillDismissWithUserData: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            userData: *mut ::std::os::raw::c_void,
            callback: ::std::option::Option<
                unsafe extern "C" fn(event: *mut ArkUI_DialogDismissEvent),
            >,
        ) -> i32,
    >,
}
#[doc = " @brief Provides the custom dialog box APIs for the native side.\n\n @version 2\n @since 15"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeDialogAPI_2 {
    #[doc = " @brief Provides the custom dialog box APIs for the native side. The API scope is {@link ArkUI_NativeDialogAPI_1}\n\n @since 15"]
    pub nativeDialogAPI1: ArkUI_NativeDialogAPI_1,
    #[doc = " @brief Defines the distance between the customDialog and system keyboard.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param distance distance, in vp.\n @param unit  Indicates the unit, which is an enumerated value of {@link ArkUI_LengthMetricUnit}\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_CAPI_INIT_ERROR} if the CAPI init error.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub setKeyboardAvoidDistance: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            distance: f32,
            unit: ArkUI_LengthMetricUnit,
        ) -> i32,
    >,
    #[doc = " @brief Sets the level mode for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param levelMode Indicates the level mode. The parameter type is {@link ArkUI_LevelMode}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub setLevelMode: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, levelMode: ArkUI_LevelMode) -> i32,
    >,
    #[doc = " @brief Sets the level uniqueId for a custom dialog box.\n\n @note This method must be called before the <b>setLevelMode</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param uniqueId Indicates the uniquedId of any nodes in router or navigation pages.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub setLevelUniqueId: ::std::option::Option<
        unsafe extern "C" fn(handle: ArkUI_NativeDialogHandle, uniqueId: i32) -> i32,
    >,
    #[doc = " @brief Sets the immersive mode for a custom dialog box.\n\n @note This method must be called before the <b>show</b> method.\n @param handle Indicates the pointer to the custom dialog box controller.\n @param immersiveMode Indicates the immersive mode. The parameter type is {@link ArkUI_ImmersiveMode}.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub setImmersiveMode: ::std::option::Option<
        unsafe extern "C" fn(
            handle: ArkUI_NativeDialogHandle,
            immersiveMode: ArkUI_ImmersiveMode,
        ) -> i32,
    >,
}
extern "C" {
    #[doc = " @brief Sets whether to block the system behavior of dismissing a dialog box.\n\n @param event Indicates the pointer to a dialog box dismiss event object.\n @param shouldBlockDismiss Indicates whether to block the system behavior of dismissing the dialog box. The value\n                           <b>true</b> means to block the system behavior, and <b>false</b> means the opposite.\n @since 12"]
    pub fn OH_ArkUI_DialogDismissEvent_SetShouldBlockDismiss(
        event: *mut ArkUI_DialogDismissEvent,
        shouldBlockDismiss: bool,
    );
}
extern "C" {
    #[doc = " @brief Obtains the pointer to user data in a dialog box dismiss event object.\n\n @param event Indicates the pointer to a dialog box dismiss event object.\n\n @return Returns the pointer to user data.\n @since 12"]
    pub fn OH_ArkUI_DialogDismissEvent_GetUserData(
        event: *mut ArkUI_DialogDismissEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the c from a dialog box dismiss event object.\n\n @param event Indicates the pointer to a dialog box dismiss event object.\n\n @return Returns the dismissal reason. Returns <b>-1</b> if an exception occurs.\n         {@link DIALOG_DISMISS_BACK_PRESS}: touching the Back button, swiping left or right on the screen, or\n                                            pressing the Esc key.\n         {@link DIALOG_DISMISS_TOUCH_OUTSIDE}: touching the mask.\n         {@link DIALOG_DISMISS_CLOSE_BUTTON}: touching the Close button.\n         {@link DIALOG_DISMISS_SLIDE_DOWN}: sliding down.\n @since 12"]
    pub fn OH_ArkUI_DialogDismissEvent_GetDismissReason(
        event: *mut ArkUI_DialogDismissEvent,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_UIInputEvent {
    _unused: [u8; 0],
}
pub const ArkUI_UIInputEvent_Type_ARKUI_UIINPUTEVENT_TYPE_UNKNOWN: ArkUI_UIInputEvent_Type = 0;
pub const ArkUI_UIInputEvent_Type_ARKUI_UIINPUTEVENT_TYPE_TOUCH: ArkUI_UIInputEvent_Type = 1;
pub const ArkUI_UIInputEvent_Type_ARKUI_UIINPUTEVENT_TYPE_AXIS: ArkUI_UIInputEvent_Type = 2;
#[doc = " Mouse event."]
pub const ArkUI_UIInputEvent_Type_ARKUI_UIINPUTEVENT_TYPE_MOUSE: ArkUI_UIInputEvent_Type = 3;
#[doc = " @brief Enumerates the UI input event types.\n\n @since 12"]
pub type ArkUI_UIInputEvent_Type = ::std::os::raw::c_uint;
#[doc = " Both the node and its child node respond to the hit test of a touch event, but its sibling node is blocked from\n  the hit test."]
pub const HitTestMode_HTM_DEFAULT: HitTestMode = 0;
#[doc = " The node responds to the hit test of a touch event, but its child node and sibling node are blocked from the hit\n  test."]
pub const HitTestMode_HTM_BLOCK: HitTestMode = 1;
#[doc = " Both the node and its child node respond to the hit test of a touch event, and its sibling node is also\n  considered during the hit test."]
pub const HitTestMode_HTM_TRANSPARENT: HitTestMode = 2;
#[doc = " The node does not respond to the hit test of a touch event, but its child node and sibling node are considered\n  during the hit test."]
pub const HitTestMode_HTM_NONE: HitTestMode = 3;
#[doc = " @brief Enumerates the hit test modes.\n\n @since 12"]
pub type HitTestMode = ::std::os::raw::c_uint;
#[doc = " Ctrl."]
pub const ArkUI_ModifierKeyName_ARKUI_MODIFIER_KEY_CTRL: ArkUI_ModifierKeyName = 1;
#[doc = " Shift."]
pub const ArkUI_ModifierKeyName_ARKUI_MODIFIER_KEY_SHIFT: ArkUI_ModifierKeyName = 2;
#[doc = " Alt."]
pub const ArkUI_ModifierKeyName_ARKUI_MODIFIER_KEY_ALT: ArkUI_ModifierKeyName = 4;
#[doc = " Fn."]
pub const ArkUI_ModifierKeyName_ARKUI_MODIFIER_KEY_FN: ArkUI_ModifierKeyName = 8;
#[doc = " @brief Defines an enum for modifier keys.\n\n @since 12"]
pub type ArkUI_ModifierKeyName = ::std::os::raw::c_uint;
#[doc = " Unknown."]
pub const ArkUI_InteractionHand_ARKUI_EVENT_HAND_NONE: ArkUI_InteractionHand = 0;
#[doc = " Left hand."]
pub const ArkUI_InteractionHand_ARKUI_EVENT_HAND_LEFT: ArkUI_InteractionHand = 1;
#[doc = " Right hand."]
pub const ArkUI_InteractionHand_ARKUI_EVENT_HAND_RIGHT: ArkUI_InteractionHand = 2;
#[doc = " @brief Defines whether the touch event is from the left or right hand.\n\n @since 15"]
pub type ArkUI_InteractionHand = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Obtains the type of this UI input event.\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the type of the current UI input event; returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetType(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the action type of this UI input event.\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the action type of the current UI input event; returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetAction(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the source type of this UI input event.\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the source type of the current UI input event.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetSourceType(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the tool type of this UI input event.\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the tool type of the current UI input event.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetToolType(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the time when this UI input event occurs.\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the time when the UI input event occurs; returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_UIInputEvent_GetEventTime(event: *const ArkUI_UIInputEvent) -> i64;
}
extern "C" {
    #[doc = " @brief Obtains the number of touch points from a directional input event (such as a touch event, mouse event,\n or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the number of touch points for the directional input event.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetPointerCount(event: *const ArkUI_UIInputEvent) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of a touch point from a directional input event (such as a touch event, mouse event,\n or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the ID of the corresponding touch point.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetPointerId(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of the touch pointer that triggers the current touch event.\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_GetChangedPointerId(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the upper left corner of the current component from a directional\n input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the directional input event.\n @return Returns the X coordinate relative to the upper left corner of the current component;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific touch point relative to the upper left corner of the current component\n from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the X coordinate relative to the upper left corner of the current component;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetXByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the upper left corner of the current component from a directional\n input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the Y coordinate relative to the upper left corner of the current component;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point relative to the upper left corner of the current component\n from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the Y coordinate relative to the upper left corner of the current component;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetYByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the upper left corner of the current application window from a\n directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the X coordinate relative to the upper left corner of the current application window;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetWindowX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific touch point relative to the upper left corner of the current\n application window from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the X coordinate relative to the upper left corner of the current application window;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetWindowXByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the upper left corner of the current application window from a\n directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the Y coordinate relative to the upper left corner of the current application window;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetWindowY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point relative to the upper left corner of the current\n application window from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the Y coordinate relative to the upper left corner of the current application window;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetWindowYByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate relative to the upper left corner of the current screen from a directional input\n event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the X coordinate relative to the upper left corner of the current screen;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetDisplayX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific touch point relative to the upper left corner of the current screen\n from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the X coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetDisplayXByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate relative to the upper left corner of the current screen from a directional input\n event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the Y coordinate relative to the upper left corner of the current screen;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetDisplayY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point relative to the upper left corner of the current screen\n from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the Y coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetDisplayYByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the pressure applied to the touchscreen from a directional input event (for example, a touch event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the pressure applied to the touchscreen; returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetPressure(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle relative to the YZ plane from a directional input event (for example, a touch event).\n The value range is [-90, 90]. A positive value indicates a rightward tilt.\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the angle relative to the YZ plane.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetTiltX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle relative to the XZ plane from a directional input event (for example, a touch event).\n The value range is [-90, 90]. A positive value indicates a downward tilt.\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the angle relative to the XZ plane.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetTiltY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the width of the touch area from a directional input event (for example, a touch event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the width of the touch area.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetTouchAreaWidth(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the height of the touch area from a directional input event (for example, a touch event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @return Returns the height of the touch area.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetTouchAreaHeight(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains whether the current touch event is from the left or right hand.\n\n @param event Pointer to the current UI input event.\n @param hand Whether the touch point is from the left or right hand.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_GetInteractionHand(
        event: *const ArkUI_UIInputEvent,
        hand: *mut ArkUI_InteractionHand,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether the current touch event is from the left or right hand.\n\n @param event Pointer to the current UI input event.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\n @param hand Whether the touch point is from the left or right hand.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_GetInteractionHandByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: i32,
        hand: *mut ArkUI_InteractionHand,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the number of historical events from a directional input event (such as a touch event, mouse event,\n or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the number of historical events.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistorySize(event: *const ArkUI_UIInputEvent) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the occurrence time of a historical event from a directional input event (such as a touch event,\n mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the time when the UI input event occurs; returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryEventTime(
        event: *const ArkUI_UIInputEvent,
        historyIndex: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Obtains the number of touch points in a specific historical event from a directional input event (such as\n a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the number of touch points in the specified historical event\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryPointerCount(
        event: *const ArkUI_UIInputEvent,
        historyIndex: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of a touch point in a specific historical event from a directional input event (such as\n a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the ID of the corresponding touch point in the specified historical event.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryPointerId(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current component from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the X coordinate relative to the upper left corner of the current component;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current component from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the Y coordinate relative to the upper left corner of the current component;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current application window from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the X coordinate relative to the upper left corner of the current application window;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryWindowX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current application window from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the Y coordinate relative to the upper left corner of the current application window;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryWindowY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current screen from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the X coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryDisplayX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of a specific touch point in a historical event relative to the upper left corner\n of the current screen from a directional input event (such as a touch event, mouse event, or axis event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the Y coordinate relative to the upper left corner of the current screen;\n returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryDisplayY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the pressure applied to the touchscreen in a specific historical event from a directional input event\n (for example, a touch event)..\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the pressure applied to the touchscreen; returns <b>0.0f</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryPressure(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle relative to the YZ plane in a specific historical event from a directional input event\n (for example, a touch event). The value range is [-90, 90]. A positive value indicates a rightward tilt.\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the angle relative to the YZ plane.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryTiltX(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle relative to the XZ plane in a specific historical event from a directional input event\n (for example, a touch event). The value range is [-90, 90]. A positive value indicates a downward tilt.\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the angle relative to the XZ plane.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryTiltY(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the width of the touch area in a specific historical event from a directional input event\n (for example, a touch event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the width of the touch area.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryTouchAreaWidth(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the height of the touch area in a specific historical event from a directional input event\n (for example, a touch event).\n\n @param event Indicates the pointer to the current UI input event.\n @param pointerIndex Indicates the index of the target touch point in the multi-touch data list.\n @param historyIndex Indicates the index of the target historical event.\n @return Returns the height of the touch area.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_GetHistoryTouchAreaHeight(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
        historyIndex: u32,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the value of the vertical scroll axis for this axis event.\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the value of the vertical scroll axis of the current axis event;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AxisEvent_GetVerticalAxisValue(event: *const ArkUI_UIInputEvent) -> f64;
}
extern "C" {
    #[doc = " @brief Obtains the value of the horizontal scroll axis for this axis event.\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the value of the horizontal scroll axis of the current axis event;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AxisEvent_GetHorizontalAxisValue(event: *const ArkUI_UIInputEvent) -> f64;
}
extern "C" {
    #[doc = " @brief Obtains the scale value of the pinch axis for this axis event.\n\n @param event Indicates the pointer to the UI input event.\n @return Returns the scale value of the pinch axis of the current axis event;\n returns <b>0</b> if any parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_AxisEvent_GetPinchAxisScaleValue(event: *const ArkUI_UIInputEvent) -> f64;
}
extern "C" {
    #[doc = " @brief Obtains the action type of the current axis event.\n\n @param event Indicates the pointer to the current UI input event.\n @return Returns the action type of the current axis event.\n @since 15"]
    pub fn OH_ArkUI_AxisEvent_GetAxisAction(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Sets how the component behaves during hit testing.\n\n @param event Indicates the pointer to the current UI input event.\n @param mode Indicates how the component behaves during hit testing. The parameter type is {@link HitTestMode}.\n @return Returns the status code of the execution.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_SetInterceptHitTestMode(
        event: *const ArkUI_UIInputEvent,
        mode: HitTestMode,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the value of the button type for mouse events.\n\n @param event Represents a pointer to the current UI input event.\n @return Return to the mouse button type, where <b>1</b> is the left button, <b>2</b> is the right button,\n <b>3</b> is the middle button, <b>4</b> is the back button, and <b>5</b> is the forward button.\n @since 12"]
    pub fn OH_ArkUI_MouseEvent_GetMouseButton(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Get the value of the mouse action type for mouse events.\n\n @param event Represents a pointer to the current UI input event.\n @return Returns the type of mouse action, where <b>1</b> represents button pressed,\n <b>2</b> represents button released, and <b>3</b> represents mouse movement.\n @since 12"]
    pub fn OH_ArkUI_MouseEvent_GetMouseAction(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to prevent event bubbling.\n\n @param event Indicates the pointer to the current UI input event.\n @param stopPropagation Indicates whether the event is prevented from bubbling.\n @return Returns the status code of the execution. If 0 is returned, the setting is successful.\n         If 401 is returned, the execution fails.\n         The possible cause of the failure is that the event parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_PointerEvent_SetStopPropagation(
        event: *const ArkUI_UIInputEvent,
        stopPropagation: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of device that triggers UI input event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the device ID.\n @since 14"]
    pub fn OH_ArkUI_UIInputEvent_GetDeviceId(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the pressed status of modifier keys from UI input event.\n The following modifier keys are supported: Ctrl, Alt, Shift, Fn. However, the <b>Fn</b> key on external keyboards\n is not supported.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param pressedKeyCodes Array of all keys that are pressed. You need to allocate the memory space.\n @param length Length of the passed pressedKeyCodes array (when used as an input parameter);\n               number of the keys pressed (when used as an output parameter).\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} if the giving buffer is not enough.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 14"]
    pub fn OH_ArkUI_UIInputEvent_GetPressedKeys(
        event: *const ArkUI_UIInputEvent,
        pressedKeyCodes: *mut i32,
        length: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the axis value of a focus axis event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param axis Axis type of the focus axis event.\n @return Returns the axis value of the focus axis event; returns <b>0.0</b> if any parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_FocusAxisEvent_GetAxisValue(event: *const ArkUI_UIInputEvent, axis: i32)
        -> f64;
}
extern "C" {
    #[doc = " @brief Sets whether to prevent a focus axis event from bubbling up.\n\n @param event Indicates the pointer to the current UI input event.\n @param stopPropagation Indicates whether to stop event propagation.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_FocusAxisEvent_SetStopPropagation(
        event: *const ArkUI_UIInputEvent,
        stopPropagation: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the press time of a specific touch point.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\n @return Returns the press time of the specific touch point; returns <b>0</b> if any parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_GetPressedTimeByIndex(
        event: *const ArkUI_UIInputEvent,
        pointerIndex: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Obtains the x-axis offset of the mouse pointer position relative to the position in the previously reported\n mouse event. This value may be less than the difference between the two reported X coordinates when the mouse pointer\n is near the screen edge.\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the x-axis offset of the mouse pointer position relative to the position in the previously reported\n mouse event; returns <b>0.0f</b> if any parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_MouseEvent_GetRawDeltaX(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the y-axis offset of the mouse pointer position relative to the position in the previously reported\n mouse event. This value may be less than the difference between the two reported Y coordinates when the mouse pointer\n is near the screen edge.\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the y-axis offset of the mouse pointer position relative to the position in the previously reported\n mouse event; returns <b>0.0f</b> if any parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_MouseEvent_GetRawDeltaY(event: *const ArkUI_UIInputEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the pressed buttons from a mouse event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param pressedButtons Array of the pressed buttons. An int array must be created beforehand to store the pressed\n                       buttons.\n @param length Length of the passed pressedButtons array (when used as an input parameter);\n               number of the buttons pressed (when used as an output parameter).\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} if the given buffer size is insufficient.\n @since 15"]
    pub fn OH_ArkUI_MouseEvent_GetPressedButtons(
        event: *const ArkUI_UIInputEvent,
        pressedButtons: *mut i32,
        length: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of the screen where the UI input event occurs.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the screen ID; returns <b>0</b> if any parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_UIInputEvent_GetTargetDisplayId(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Creates a cloned event pointer based on an event pointer.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param clonedEvent Pointer to the cloned <b>ArkUI_UIInputEvent</b> object.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_CreateClonedEvent(
        event: *const ArkUI_UIInputEvent,
        clonedEvent: *mut *mut ArkUI_UIInputEvent,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Destroys a cloned event pointer.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NON_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_DestroyClonedEvent(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the X and Y coordinates of a cloned event relative to the upper left corner of the current component.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param x X coordinate of the event relative to the upper left corner of the current component.\n @param y Y coordinate of the event relative to the upper left corner of the current component.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NON_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventLocalPosition(
        event: *const ArkUI_UIInputEvent,
        x: f32,
        y: f32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the X and Y coordinates of a specific contact point of a cloned event relative to the upper left corner\n of the current component.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param x X coordinate of the event relative to the upper left corner of the current component.\n @param y Y coordinate of the event relative to the upper left corner of the current component.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NON_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventLocalPositionByIndex(
        event: *const ArkUI_UIInputEvent,
        x: f32,
        y: f32,
        pointerIndex: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the action type of a cloned event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param actionType Action type of the cloned event.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NON_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventActionType(
        event: *const ArkUI_UIInputEvent,
        actionType: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the touch point ID of a cloned pointer event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param fingerId ID of the touch point that triggers the event.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NON_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventChangedFingerId(
        event: *const ArkUI_UIInputEvent,
        fingerId: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the touch point ID of a specific contact point of a cloned event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param fingerId Touch point ID of the specific contact point.\n @param pointerIndex Index of the target touch point in the multi-touch data list.\n @return Returns the result code.\n          Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n          Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n          Returns {@link ARKUI_ERROR_CODE_NON_CLONED_POINTER_EVENT} if the input event pointer is not a\n          cloned event pointer.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_SetClonedEventFingerIdByIndex(
        event: *const ArkUI_UIInputEvent,
        fingerId: i32,
        pointerIndex: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Posts a cloned event to a specific node.\n\n @param node Target node.\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NON_CLONED_POINTER_EVENT} if the input event pointer is not a\n         cloned event pointer.\n         Returns {@link ARKUI_ERROR_CODE_POST_CLONED_COMPONENT_STATUS_ABNORMAL}\n         if the component status abnormal.\n         Returns {@link ARKUI_ERROR_CODE_POST_CLONED_NO_COMPONENT_HIT_TO_RESPOND_TO_THE_EVENT}\n         if no component hit to response to the event.\n @since 15"]
    pub fn OH_ArkUI_PointerEvent_PostClonedEvent(
        node: ArkUI_NodeHandle,
        event: *const ArkUI_UIInputEvent,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GestureRecognizer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GestureInterruptInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GestureEvent {
    _unused: [u8; 0],
}
#[doc = " Triggered."]
pub const ArkUI_GestureEventActionType_GESTURE_EVENT_ACTION_ACCEPT: ArkUI_GestureEventActionType =
    1;
#[doc = " Updated."]
pub const ArkUI_GestureEventActionType_GESTURE_EVENT_ACTION_UPDATE: ArkUI_GestureEventActionType =
    2;
#[doc = " Ended."]
pub const ArkUI_GestureEventActionType_GESTURE_EVENT_ACTION_END: ArkUI_GestureEventActionType = 4;
#[doc = " Canceled."]
pub const ArkUI_GestureEventActionType_GESTURE_EVENT_ACTION_CANCEL: ArkUI_GestureEventActionType =
    8;
#[doc = " @brief Enumerates gesture event types.\n\n @since 12"]
pub type ArkUI_GestureEventActionType = ::std::os::raw::c_uint;
#[doc = " @brief Defines a set of gesture event types.\n\n Example: ArkUI_GestureEventActionTypeMask actions = GESTURE_EVENT_ACTION_ACCEPT | GESTURE_EVENT_ACTION_UPDATE;\\n\n\n @since 12"]
pub type ArkUI_GestureEventActionTypeMask = u32;
#[doc = " Normal."]
pub const ArkUI_GesturePriority_NORMAL: ArkUI_GesturePriority = 0;
#[doc = " High-priority."]
pub const ArkUI_GesturePriority_PRIORITY: ArkUI_GesturePriority = 1;
#[doc = " Parallel."]
pub const ArkUI_GesturePriority_PARALLEL: ArkUI_GesturePriority = 2;
#[doc = " @brief Enumerates gesture event modes.\n\n @since 12"]
pub type ArkUI_GesturePriority = ::std::os::raw::c_uint;
pub const ArkUI_GroupGestureMode_SEQUENTIAL_GROUP: ArkUI_GroupGestureMode = 0;
#[doc = " Parallel recognition. Registered gestures are recognized concurrently until all gestures are recognized.\n The recognition result of each gesture does not affect each other."]
pub const ArkUI_GroupGestureMode_PARALLEL_GROUP: ArkUI_GroupGestureMode = 1;
#[doc = " Exclusive recognition. Registered gestures are identified concurrently.\n If one gesture is successfully recognized, gesture recognition ends."]
pub const ArkUI_GroupGestureMode_EXCLUSIVE_GROUP: ArkUI_GroupGestureMode = 2;
#[doc = " @brief Enumerates gesture group modes.\n\n @since 12"]
pub type ArkUI_GroupGestureMode = ::std::os::raw::c_uint;
#[doc = " All directions."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_ALL: ArkUI_GestureDirection = 15;
#[doc = " Horizontal direction."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_HORIZONTAL: ArkUI_GestureDirection = 3;
#[doc = " Vertical direction."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_VERTICAL: ArkUI_GestureDirection = 12;
#[doc = " Leftward."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_LEFT: ArkUI_GestureDirection = 1;
#[doc = " Rightward."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_RIGHT: ArkUI_GestureDirection = 2;
#[doc = " Upward."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_UP: ArkUI_GestureDirection = 4;
#[doc = " Downward."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_DOWN: ArkUI_GestureDirection = 8;
#[doc = " None."]
pub const ArkUI_GestureDirection_GESTURE_DIRECTION_NONE: ArkUI_GestureDirection = 0;
#[doc = " @brief Enumerates gesture directions.\n\n @since 12"]
pub type ArkUI_GestureDirection = ::std::os::raw::c_uint;
#[doc = " @brief Defines a set of gesture directions.\n\n Example: ArkUI_GestureDirectionMask directions = GESTURE_DIRECTION_LEFT | GESTURE_DIRECTION_RIGHT \\n\n This example indicates that the leftward and rightward directions are supported. \\n\n\n @since 12"]
pub type ArkUI_GestureDirectionMask = u32;
#[doc = " The gestures of child components are enabled and recognized based on the default gesture recognition sequence."]
pub const ArkUI_GestureMask_NORMAL_GESTURE_MASK: ArkUI_GestureMask = 0;
#[doc = " The gestures of child components are disabled, including the built-in gestures."]
pub const ArkUI_GestureMask_IGNORE_INTERNAL_GESTURE_MASK: ArkUI_GestureMask = 1;
#[doc = " @brief Enumerates gesture masking modes.\n\n @since 12"]
pub type ArkUI_GestureMask = ::std::os::raw::c_uint;
#[doc = " Tap."]
pub const ArkUI_GestureRecognizerType_TAP_GESTURE: ArkUI_GestureRecognizerType = 0;
#[doc = " Long press."]
pub const ArkUI_GestureRecognizerType_LONG_PRESS_GESTURE: ArkUI_GestureRecognizerType = 1;
#[doc = " Pan."]
pub const ArkUI_GestureRecognizerType_PAN_GESTURE: ArkUI_GestureRecognizerType = 2;
#[doc = " Pinch."]
pub const ArkUI_GestureRecognizerType_PINCH_GESTURE: ArkUI_GestureRecognizerType = 3;
#[doc = " Rotate."]
pub const ArkUI_GestureRecognizerType_ROTATION_GESTURE: ArkUI_GestureRecognizerType = 4;
#[doc = " Swipe."]
pub const ArkUI_GestureRecognizerType_SWIPE_GESTURE: ArkUI_GestureRecognizerType = 5;
#[doc = " A group of gestures."]
pub const ArkUI_GestureRecognizerType_GROUP_GESTURE: ArkUI_GestureRecognizerType = 6;
#[doc = " @brief Enumerates gesture types.\n\n @since 12"]
pub type ArkUI_GestureRecognizerType = ::std::os::raw::c_uint;
#[doc = " The gesture recognition process continues."]
pub const ArkUI_GestureInterruptResult_GESTURE_INTERRUPT_RESULT_CONTINUE:
    ArkUI_GestureInterruptResult = 0;
#[doc = " The gesture recognition process is paused."]
pub const ArkUI_GestureInterruptResult_GESTURE_INTERRUPT_RESULT_REJECT:
    ArkUI_GestureInterruptResult = 1;
#[doc = " @brief Enumerates gesture interruption results.\n\n @since 12"]
pub type ArkUI_GestureInterruptResult = ::std::os::raw::c_uint;
#[doc = " Ready."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_READY:
    ArkUI_GestureRecognizerState = 0;
#[doc = " Detecting."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_DETECTING:
    ArkUI_GestureRecognizerState = 1;
#[doc = " Pending."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_PENDING:
    ArkUI_GestureRecognizerState = 2;
#[doc = " Blocked."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_BLOCKED:
    ArkUI_GestureRecognizerState = 3;
#[doc = " Successful."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_SUCCESSFUL:
    ArkUI_GestureRecognizerState = 4;
#[doc = " Failed."]
pub const ArkUI_GestureRecognizerState_ARKUI_GESTURE_RECOGNIZER_STATE_FAILED:
    ArkUI_GestureRecognizerState = 5;
#[doc = " @brief Enumerates the gesture recognizer states.\n\n @since 12"]
pub type ArkUI_GestureRecognizerState = ::std::os::raw::c_uint;
#[doc = " @brief Defines the gesture recognizer handle.\n\n @since 12"]
pub type ArkUI_GestureRecognizerHandle = *mut ArkUI_GestureRecognizer;
#[doc = " @brief Defines the gesture recognizer handle array.\n\n @since 12"]
pub type ArkUI_GestureRecognizerHandleArray = *mut ArkUI_GestureRecognizerHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_GestureEventTargetInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_ParallelInnerGestureEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TouchRecognizer {
    _unused: [u8; 0],
}
#[doc = " @brief Defines a touch recognizer handle.\n\n @since 15"]
pub type ArkUI_TouchRecognizerHandle = *mut ArkUI_TouchRecognizer;
#[doc = " @brief Defines an array of touch recognizer handle.\n\n @since 15"]
pub type ArkUI_TouchRecognizerHandleArray = *mut ArkUI_TouchRecognizerHandle;
#[doc = " @brief Defines a callback function for notifying gesture recognizer destruction.\n @since 12"]
pub type ArkUI_GestureRecognizerDisposeNotifyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        recognizer: *mut ArkUI_GestureRecognizer,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Checks whether a gesture is a built-in gesture of the component.\n\n @param event Indicates the pointer to the gesture interruption information.\n @return Returns <b>true</b> if the gesture is a built-in gesture; returns <b>false</b> otherwise.\n\n @since 12"]
    pub fn OH_ArkUI_GestureInterruptInfo_GetSystemFlag(
        event: *const ArkUI_GestureInterruptInfo,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains the pointer to interrupted gesture recognizer.\n\n @param event Indicates the pointer to the gesture interruption information.\n @return Returns the pointer to interrupted gesture recognizer.\n @since 12"]
    pub fn OH_ArkUI_GestureInterruptInfo_GetRecognizer(
        event: *const ArkUI_GestureInterruptInfo,
    ) -> *mut ArkUI_GestureRecognizer;
}
extern "C" {
    #[doc = " @brief Obtains the pointer to the interrupted gesture event.\n\n @param event Indicates the pointer to the gesture interruption information.\n @return Returns the pointer to the interrupted gesture event.\n @since 12"]
    pub fn OH_ArkUI_GestureInterruptInfo_GetGestureEvent(
        event: *const ArkUI_GestureInterruptInfo,
    ) -> *mut ArkUI_GestureEvent;
}
extern "C" {
    #[doc = " @brief Obtains the type of the system gesture to trigger.\n\n @param event Indicates the pointer to the gesture interruption information.\n @return Returns the type of the system gesture to trigger. If the gesture to trigger is not a system gesture,\n         <b>-1</b> is returned.\n @since 12"]
    pub fn OH_ArkUI_GestureInterruptInfo_GetSystemRecognizerType(
        event: *const ArkUI_GestureInterruptInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the touch recognizer handles from the gesture interrupt info.\n\n @param info Indicates the pointer to a gesture interrupt info.\n @param recognizers Indicates the pointer to an array of touch recognizer handles.\n @param size Indicates the size of recognizers.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 15"]
    pub fn OH_ArkUI_GestureInterruptInfo_GetTouchRecognizers(
        info: *const ArkUI_GestureInterruptInfo,
        recognizers: *mut ArkUI_TouchRecognizerHandleArray,
        size: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get component object of the specific touch recognizer.\n\n @param recognizer Indicates the pointer to the TouchRecognizer.\n @return Get component object of the specific touch recognizer.\n @since 15"]
    pub fn OH_ArkUI_TouchRecognizer_GetNodeHandle(
        recognizer: ArkUI_TouchRecognizerHandle,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Send touch-cancel event to the touch recognizer in a gesture interruption callback.\n\n @param recognizer Indicates the touch recognizer handle.\n @param info Indicates the pointer to a gesture interrupt info.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 15"]
    pub fn OH_ArkUI_TouchRecognizer_CancelTouch(
        recognizer: ArkUI_TouchRecognizerHandle,
        info: *mut ArkUI_GestureInterruptInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the gesture event type.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the gesture event type.\n @since 12"]
    pub fn OH_ArkUI_GestureEvent_GetActionType(
        event: *const ArkUI_GestureEvent,
    ) -> ArkUI_GestureEventActionType;
}
extern "C" {
    #[doc = " @brief Obtains gesture input.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the pointer to the input event of the gesture event.\n @since 12"]
    pub fn OH_ArkUI_GestureEvent_GetRawInputEvent(
        event: *const ArkUI_GestureEvent,
    ) -> *const ArkUI_UIInputEvent;
}
extern "C" {
    #[doc = " @brief Obtains the number of times that a long press gesture is triggered periodically.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the number of times that the long press gesture is triggered periodically.\n @since 12"]
    pub fn OH_ArkUI_LongPress_GetRepeatCount(event: *const ArkUI_GestureEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the velocity of a pan gesture along the main axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the velocity of the pan gesture along the main axis, in px/s.\n         The value is the square root of the sum of the squares of the velocity on the x-axis and y-axis.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetVelocity(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the velocity of a pan gesture along the x-axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the velocity of the pan gesture along the x-axis, in px/s.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetVelocityX(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the velocity of a pan gesture along the y-axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the velocity of the pan gesture along the y-axis, in px/s.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetVelocityY(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the relative offset of a pan gesture along the x-axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the relative offset of the gesture along the x-axis, in px.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetOffsetX(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the relative offset of a pan gesture along the y-axis.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the relative offset of the gesture along the y-axis, in px.\n @since 12"]
    pub fn OH_ArkUI_PanGesture_GetOffsetY(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle information of the swipe gesture.\n\n After a swipe gesture is recognized, a line connecting the two fingers is identified as the initial line.\n As the fingers swipe, the line between the fingers rotates. \\n\n Based on the coordinates of the initial line's and current line's end points, the arc tangent function is used to\n calculate the respective included angle of the points relative to the horizontal direction \\n\n by using the following formula: Rotation angle = arctan2(cy2-cy1,cx2-cx1) - arctan2(y2-y1,x2-x1). \\n\n The initial line is used as the coordinate system. Values from 0 to 180 degrees represent clockwise rotation,\n while values from –180 to 0 degrees represent counterclockwise rotation. \\n\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the angle of the swipe gesture, which is the result obtained based on the aforementioned formula.\n @since 12"]
    pub fn OH_ArkUI_SwipeGesture_GetAngle(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the average velocity of all fingers used in the swipe gesture.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the average velocity of all fingers used in the swipe gesture, in px/s.\n @since 12"]
    pub fn OH_ArkUI_SwipeGesture_GetVelocity(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the angle information of a rotation gesture.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the rotation angle.\n @since 12"]
    pub fn OH_ArkUI_RotationGesture_GetAngle(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the scale ratio of a pinch gesture.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the scale ratio.\n @since 12"]
    pub fn OH_ArkUI_PinchGesture_GetScale(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the X coordinate of the center of the pinch gesture, in vp,\n relative to the upper left corner of the current component.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the X coordinate of the center of the pinch gesture, in vp,\n relative to the upper left corner of the current component.\n @since 12"]
    pub fn OH_ArkUI_PinchGesture_GetCenterX(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Obtains the Y coordinate of the center of the pinch gesture, in vp,\n relative to the upper left corner of the current component.\n\n @param event Indicates the pointer to the gesture event.\n @return Returns the Y coordinate of the center of the pinch gesture, in vp,\n relative to the upper left corner of the current component.\n @since 12"]
    pub fn OH_ArkUI_PinchGesture_GetCenterY(event: *const ArkUI_GestureEvent) -> f32;
}
extern "C" {
    #[doc = " @brief Get the ARKUI component bound to the gesture.\n\n @param event gesture event.\n @return ARKUI component bound to the gesture.If Null is returned, it means event is an invalid value.\n @since 12"]
    pub fn OH_ArkUI_GestureEvent_GetNode(event: *const ArkUI_GestureEvent) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Obtains information about a gesture response chain.\n\n @param event Indicates the pointer to the gesture interruption information.\n @param responseChain Indicates the pointer to an array of gesture recognizers on the response chain.\n @param count Indicates the pointer to the number of gesture recognizers on the response chain.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_GetResponseRecognizersFromInterruptInfo(
        event: *const ArkUI_GestureInterruptInfo,
        responseChain: *mut ArkUI_GestureRecognizerHandleArray,
        count: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the enabled state of a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param enabled Indicates the enabled state.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_SetGestureRecognizerEnabled(
        recognizer: *mut ArkUI_GestureRecognizer,
        enabled: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets whether to enable strict finger count checking. If this feature is enabled and the actual number of touch\n        fingers does not match the set number, the gesture recognition fails.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param limitFingerCount Indicates whether to enable strict finger count checking.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_SetGestureRecognizerLimitFingerCount(
        recognizer: *mut ArkUI_GestureRecognizer,
        limitFingerCount: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the enabled state of a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @return Returns <b>true</b> if the gesture recognizer is enabled.\n         Returns <b>false</b> if the gesture recognizer is disabled.\n @since 12"]
    pub fn OH_ArkUI_GetGestureRecognizerEnabled(recognizer: *mut ArkUI_GestureRecognizer) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains the state of a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param state Indicates the pointer to the state of the gesture recognizer.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_GetGestureRecognizerState(
        recognizer: *mut ArkUI_GestureRecognizer,
        state: *mut ArkUI_GestureRecognizerState,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the information about a gesture event target.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param info Indicates the information about a gesture event target.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_GetGestureEventTargetInfo(
        recognizer: *mut ArkUI_GestureRecognizer,
        info: *mut *mut ArkUI_GestureEventTargetInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether this scroll container is scrolled to the top.\n\n @param info Indicates the information about a gesture event target.\n @param ret Indicates whether the scroll container is scrolled to the top.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_NON_SCROLLABLE_CONTAINER} if the component is not a scroll container.\n @since 12"]
    pub fn OH_ArkUI_GestureEventTargetInfo_IsScrollBegin(
        info: *mut ArkUI_GestureEventTargetInfo,
        ret: *mut bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether this scroll container is scrolled to the bottom.\n\n @param info Indicates the information about a gesture event target.\n @param ret Indicates whether the scroll container is scrolled to the bottom.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_NON_SCROLLABLE_CONTAINER} if the component is not a scroll container.\n @since 12"]
    pub fn OH_ArkUI_GestureEventTargetInfo_IsScrollEnd(
        info: *mut ArkUI_GestureEventTargetInfo,
        ret: *mut bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the direction of a pan gesture.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param directionMask Indicates the pan direction.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_GetPanGestureDirectionMask(
        recognizer: *mut ArkUI_GestureRecognizer,
        directionMask: *mut ArkUI_GestureDirectionMask,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether a gesture is a built-in gesture.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @return Returns <b>true</b> if the gesture is a built-in gesture; returns <b>false</b> otherwise.\n @since 12"]
    pub fn OH_ArkUI_IsBuiltInGesture(recognizer: *mut ArkUI_GestureRecognizer) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains the tag of a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param buffer Indicates the buffer.\n @param bufferSize Indicates the buffer size.\n @param result Indicates the length of the string to be written to the buffer.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_NOT_ENOUGH} if the buffer is not large enough.\n @since 12"]
    pub fn OH_ArkUI_GetGestureTag(
        recognizer: *mut ArkUI_GestureRecognizer,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        result: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the ID of the component linked to a gesture recognizer.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param nodeId Indicates the component ID.\n @param size Indicates the buffer size.\n @param result Indicates the length of the string to be written to the buffer.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n         Returns {@link ARKUI_ERROR_CODE_BUFFER_SIZE_NOT_ENOUGH} if the buffer is not large enough.\n @since 12"]
    pub fn OH_ArkUI_GetGestureBindNodeId(
        recognizer: *mut ArkUI_GestureRecognizer,
        nodeId: *mut ::std::os::raw::c_char,
        size: i32,
        result: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains whether a gesture recognizer is valid.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @return Returns <b>true</b> if the gesture recognizer is valid.\n         Returns <b>false</b> if the gesture recognizer is invalid.\n @since 12"]
    pub fn OH_ArkUI_IsGestureRecognizerValid(recognizer: *mut ArkUI_GestureRecognizer) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains custom data in the parallel internal gesture event.\n\n @param event Indicates the pointer to a parallel internal gesture event.\n @return Returns the pointer to custom data.\n @since 12"]
    pub fn OH_ArkUI_ParallelInnerGestureEvent_GetUserData(
        event: *mut ArkUI_ParallelInnerGestureEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the current gesture recognizer in a parallel internal gesture event.\n\n @param event Indicates the pointer to a parallel internal gesture event.\n @return Returns the pointer to the current gesture recognizer.\n @since 12"]
    pub fn OH_ArkUI_ParallelInnerGestureEvent_GetCurrentRecognizer(
        event: *mut ArkUI_ParallelInnerGestureEvent,
    ) -> *mut ArkUI_GestureRecognizer;
}
extern "C" {
    #[doc = " @brief Obtains the conflicting gesture recognizers in a parallel internal gesture event.\n\n @param event Indicates the pointer to a parallel internal gesture event.\n @param array Indicates the pointer to the array of conflicting gesture recognizers.\n @param size Indicates the size of the array of conflicting gesture recognizers.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_ParallelInnerGestureEvent_GetConflictRecognizers(
        event: *mut ArkUI_ParallelInnerGestureEvent,
        array: *mut ArkUI_GestureRecognizerHandleArray,
        size: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets a callback function for notifying gesture recognizer destruction.\n\n @param recognizer Indicates the pointer to a gesture recognizer.\n @param callback Indicates the callback function for notifying gesture recognizer destruction.\n @param userData Indicates the custom data.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs.\n @since 12"]
    pub fn OH_ArkUI_SetArkUIGestureRecognizerDisposeNotify(
        recognizer: *mut ArkUI_GestureRecognizer,
        callback: ArkUI_GestureRecognizerDisposeNotifyCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> i32;
}
#[doc = " @brief Defines the gesture APIs.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeGestureAPI_1 {
    #[doc = " The struct version is 1."]
    pub version: i32,
    #[doc = " @brief Creates a tap gesture.\n\n        1. This API is used to trigger a tap gesture with one, two, or more taps. \\n\n        2. If multi-tap is configured, the timeout interval between a lift and the next tap is 300 ms. \\n\n        3. If the distance between the last tapped position and the current tapped position exceeds 60 vp,\n           gesture recognition fails. \\n\n        4. If the value is greater than 1, the tap gesture will fail to be recognized when the number of fingers\n           touching the screen within 300 ms of the first finger touch is less than the required number, \\n\n           or when the number of fingers lifted from the screen within 300 ms of the first finger's being lifted\n           is less than the required number. \\n\n        5. When the number of fingers touching the screen exceeds the set value, the gesture can be recognized. \\n\n\n @param countNum Indicates the number of consecutive taps. If the value is less than 1 or is not set,\n        the default value <b>1</b> is used.\n @param fingersNum Indicates the number of fingers required to trigger a tap. The value ranges\n        from 1 to 10. If the value is less than 1 or is not set, the default value <b>1</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createTapGesture: ::std::option::Option<
        unsafe extern "C" fn(countNum: i32, fingersNum: i32) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a long press gesture.\n\n        1. This API is used to trigger a long press gesture, which requires one or more fingers with a minimum\n           The value ranges 500 ms hold-down time. \\n\n        2. In components that support drag actions by default, such as <b><Text></b>, <b><TextInput></b>,\n           <b><TextArea></b>, <b><Hyperlink></b>, <b><Image></b>, and <b>RichEditor></b>, the long press gesture \\n\n           may conflict with the drag action. If this occurs, they are handled as follows: \\n\n           If the minimum duration of the long press gesture is less than 500 ms, the long press gesture receives\n           a higher response priority than the drag action. \\n\n           If the minimum duration of the long press gesture is greater than or equal to 500 ms,\n           the drag action receives a higher response priority than the long press gesture. \\n\n        3. If a finger moves more than 15 px after being pressed, the gesture recognition fails. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a long press gesture.\n        The value ranges from 1 to 10.\n @param repeatResult Indicates whether to continuously trigger the event callback.\n @param durationNum Indicates the minimum hold-down time, in ms.\n        If the value is less than or equal to 0, the default value <b>500</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createLongPressGesture: ::std::option::Option<
        unsafe extern "C" fn(
            fingersNum: i32,
            repeatResult: bool,
            durationNum: i32,
        ) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a pan gesture.\n\n        1. This API is used to trigger a pan gesture when the movement distance of a finger on the screen exceeds\n           the minimum value. \\n\n        2. If a pan gesture and a tab swipe occur at the same time, set <b>distanceNum</b> to <b>1</b>\n           so that the gesture can be more easily recognized. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a pan gesture. The value ranges from 1 to 10.\n        If the value is less than 1 or is not set, the default value <b>1</b> is used.\n @param directions Indicates the pan direction. The value supports the AND (&amp;) and OR (\\|) operations.\n @param distanceNum Indicates the minimum pan distance to trigger the gesture, in vp. If this parameter is\n        set to a value less than or equal to 0, the default value <b>5</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createPanGesture: ::std::option::Option<
        unsafe extern "C" fn(
            fingersNum: i32,
            directions: ArkUI_GestureDirectionMask,
            distanceNum: f64,
        ) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a pinch gesture.\n\n        1. This API is used to trigger a pinch gesture, which requires two to five fingers with a minimum 5 vp\n           distance between the fingers. \\n\n        2. While more fingers than the minimum number can be pressed to trigger the gesture, only the first\n           fingers of the minimum number participate in gesture calculation. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a pinch. The value ranges from 2 to 5.\n        Default value: <b>2</b>\n @param distanceNum Indicates the minimum recognition distance, in px. If this parameter is set to a value less\n        than or equal to 0, the default value <b>5</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createPinchGesture: ::std::option::Option<
        unsafe extern "C" fn(fingersNum: i32, distanceNum: f64) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a rotation gesture.\n\n        1. This API is used to trigger a rotation gesture, which requires two to five fingers with a\n           minimum 1-degree rotation angle. \\n\n        2. While more fingers than the minimum number can be pressed to trigger the gesture, only the first\n           two fingers participate in gesture calculation. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a rotation. The value ranges from 2 to 5.\n        Default value: <b>2</b>\n @param angleNum Indicates the minimum degree that can trigger the rotation gesture. Default value: <b>1</b>\n        If this parameter is set to a value less than or equal to 0 or greater than 360,\n        the default value <b>1</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createRotationGesture: ::std::option::Option<
        unsafe extern "C" fn(fingersNum: i32, angleNum: f64) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a swipe gesture.\n\n        This API is used to implement a swipe gesture, which can be recognized when the swipe speed is 100\n        vp/s or higher. \\n\n\n @param fingersNum Indicates the minimum number of fingers to trigger a swipe gesture.\n        The value ranges from 1 to 10.\n @param directions Indicates the swipe direction.\n @param speedNum Indicates the minimum speed of the swipe gesture, in px/s.\n        If this parameter is set to a value less than or equal to 0, the default value <b>100</b> is used.\n @return Returns the pointer to the created gesture."]
    pub createSwipeGesture: ::std::option::Option<
        unsafe extern "C" fn(
            fingersNum: i32,
            directions: ArkUI_GestureDirectionMask,
            speedNum: f64,
        ) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Creates a gesture group.\n\n @param gestureMode Indicates the gesture group mode.\n @return Returns the pointer to the created gesture group."]
    pub createGroupGesture: ::std::option::Option<
        unsafe extern "C" fn(gestureMode: ArkUI_GroupGestureMode) -> *mut ArkUI_GestureRecognizer,
    >,
    #[doc = " @brief Disposes a gesture to release resources.\n\n @param recognizer Indicates the pointer to the gesture to dispose."]
    pub dispose:
        ::std::option::Option<unsafe extern "C" fn(recognizer: *mut ArkUI_GestureRecognizer)>,
    #[doc = " @brief Adds a gesture to a gesture group.\n\n @param group Indicates the pointer to the gesture group.\n @param child Indicates the gesture to be added to the gesture group.\n @return Returns <b>0</b> if success.\n         Returns <b>401</b> if a parameter exception occurs. Returns 401 if a parameter exception occurs."]
    pub addChildGesture: ::std::option::Option<
        unsafe extern "C" fn(
            group: *mut ArkUI_GestureRecognizer,
            child: *mut ArkUI_GestureRecognizer,
        ) -> i32,
    >,
    #[doc = " @brief Removes a gesture to a gesture group.\n\n @param group Indicates the pointer to the gesture group.\n @param child Indicates the gesture to be removed to the gesture group.\n @return Returns <b>0</b> if success.\n         Returns <b>401</b> if a parameter exception occurs."]
    pub removeChildGesture: ::std::option::Option<
        unsafe extern "C" fn(
            group: *mut ArkUI_GestureRecognizer,
            child: *mut ArkUI_GestureRecognizer,
        ) -> i32,
    >,
    #[doc = " @brief Registers a callback for gestures.\n\n @param recognizer Indicates the pointer to the gesture recognizer.\n @param actionTypeMask Indicates the set of gesture event types. Multiple callbacks can be registered at once,\n        with the callback event types distinguished in the callbacks.\n        Example: actionTypeMask = GESTURE_EVENT_ACTION_ACCEPT | GESTURE_EVENT_ACTION_UPDATE;\n @param extraParams Indicates the context passed in the <b>targetReceiver</b> callback.\n @param targetReceiver Indicates the callback to register for processing the gesture event types.\n        <b>event</b> indicates the gesture callback data.\n @return Returns <b>0</b> if success.\n         Returns <b>401</b> if a parameter exception occurs."]
    pub setGestureEventTarget: ::std::option::Option<
        unsafe extern "C" fn(
            recognizer: *mut ArkUI_GestureRecognizer,
            actionTypeMask: ArkUI_GestureEventActionTypeMask,
            extraParams: *mut ::std::os::raw::c_void,
            targetReceiver: ::std::option::Option<
                unsafe extern "C" fn(
                    event: *mut ArkUI_GestureEvent,
                    extraParams: *mut ::std::os::raw::c_void,
                ),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Adds a gesture to a UI component.\n\n @param node Indicates the UI component to which you want to add the gesture.\n @param recognizer Indicates the gesture to be added to the UI component.\n @param mode Indicates the gesture event mode. Available options are <b>NORMAL_GESTURE</b>,\n        <b>PARALLEL_GESTURE</b>, and <b>PRIORITY_GESTURE</b>.\n @param mask Indicates the gesture masking mode.\n @return Returns <b>0</b> if success.\n         Returns <b>401</b> if a parameter exception occurs."]
    pub addGestureToNode: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            recognizer: *mut ArkUI_GestureRecognizer,
            mode: ArkUI_GesturePriority,
            mask: ArkUI_GestureMask,
        ) -> i32,
    >,
    #[doc = " @brief Removes a gesture from a node.\n\n @param node Indicates the node from which you want to remove the gesture.\n @param recognizer Indicates the gesture to be removed.\n @return Returns <b>0</b> if success.\n Returns <b>401</b> if a parameter exception occurs."]
    pub removeGestureFromNode: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            recognizer: *mut ArkUI_GestureRecognizer,
        ) -> i32,
    >,
    #[doc = " @brief Sets a gesture interruption callback for a node.\n\n @param node Indicates the node for which you want to set a gesture interruption callback.\n @param interrupter Indicates the gesture interruption callback to set.\n        <b>info</b> indicates the gesture interruption data. If <b>interrupter</b> returns\n        <b>GESTURE_INTERRUPT_RESULT_CONTINUE</b>, the gesture recognition process continues. If it returns\n        <b>GESTURE_INTERRUPT_RESULT_REJECT</b>, the gesture recognition process is paused.\n @return Returns <b>0</b> if success.\n Returns <b>401</b> if a parameter exception occurs."]
    pub setGestureInterrupterToNode: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            interrupter: ::std::option::Option<
                unsafe extern "C" fn(
                    info: *mut ArkUI_GestureInterruptInfo,
                ) -> ArkUI_GestureInterruptResult,
            >,
        ) -> i32,
    >,
    #[doc = " @brief Obtains the type of a gesture.\n\n @param recognizer Indicates the pointer to the gesture.\n @return Returns the gesture type."]
    pub getGestureType: ::std::option::Option<
        unsafe extern "C" fn(
            recognizer: *mut ArkUI_GestureRecognizer,
        ) -> ArkUI_GestureRecognizerType,
    >,
    #[doc = " @brief Sets the callback function for a parallel internal gesture event.\n\n @param node Indicates the ArkUI node for which the callback of a parallel internal gesture event is to be set.\n @param userData Indicates the custom data.\n @param parallelInnerGesture Indicates the parallel internal gesture event. <b>event</b> returns the data of the\n        parallel internal gesture event; <b>parallelInnerGesture</b> returns the pointer to the gesture recognizer\n        that requires parallel recognition.\n @return Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if success.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter exception occurs."]
    pub setInnerGestureParallelTo: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            userData: *mut ::std::os::raw::c_void,
            parallelInnerGesture: ::std::option::Option<
                unsafe extern "C" fn(
                    event: *mut ArkUI_ParallelInnerGestureEvent,
                ) -> *mut ArkUI_GestureRecognizer,
            >,
        ) -> i32,
    >,
    #[doc = " @brief Creates a tap gesture that is subject to distance restrictions.\n\n        1. This API is used to trigger a tap gesture with one, two, or more taps. \\n\n        2. If multi-tap is configured, the timeout interval between a lift and the next tap is 300 ms. \\n\n        3. If the distance between the last tapped position and the current tapped position exceeds 60 vp,\n           gesture recognition fails. \\n\n        4. If the value is greater than 1, the tap gesture will fail to be recognized when the number of fingers\n           touching the screen within 300 ms of the first finger touch is less than the required number,\n           or when the number of fingers lifted from the screen within 300 ms of the first finger's being lifted\n           is less than the required number. \\n\n        5. When the number of fingers touching the screen exceeds the set value, the gesture can be recognized. \\n\n        6. If the finger moves beyond the preset distance limit, gesture recognition fails. \\n\n\n @param countNum Indicates the number of consecutive taps. If the value is less than 1 or is not set, the default\n        value <b>1</b> is used.\n @param fingersNum Indicates the number of fingers required to trigger a tap. The value ranges from 1 to 10.\n        If the value is less than 1 or is not set, the default value <b>1</b> is used.\n @param distanceThreshold Indicates the allowed moving distance of a finger.\n        If the value is less than 0 or is not set, it will be converted to the default value of infinity.\n @return Returns the pointer to the created gesture."]
    pub createTapGestureWithDistanceThreshold: ::std::option::Option<
        unsafe extern "C" fn(
            countNum: i32,
            fingersNum: i32,
            distanceThreshold: f64,
        ) -> *mut ArkUI_GestureRecognizer,
    >,
}
#[doc = " API related to UI components. For details, see the struct definition in <arkui/native_node.h>."]
pub const ArkUI_NativeAPIVariantKind_ARKUI_NATIVE_NODE: ArkUI_NativeAPIVariantKind = 0;
#[doc = " API related to dialog boxes. For details, see the struct definition in <arkui/native_dialog.h>."]
pub const ArkUI_NativeAPIVariantKind_ARKUI_NATIVE_DIALOG: ArkUI_NativeAPIVariantKind = 1;
#[doc = " API related to gestures. For details, see the struct definition in <arkui/native_gesture.h>."]
pub const ArkUI_NativeAPIVariantKind_ARKUI_NATIVE_GESTURE: ArkUI_NativeAPIVariantKind = 2;
#[doc = " API related to animations. For details, see the struct definition in <arkui/native_animate.h>."]
pub const ArkUI_NativeAPIVariantKind_ARKUI_NATIVE_ANIMATE: ArkUI_NativeAPIVariantKind = 3;
#[doc = " @brief Defines the native API types.\n\n @since 12"]
pub type ArkUI_NativeAPIVariantKind = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Obtains the native API set of a specified type.\n\n @param type Indicates the type of the native API set provided by ArkUI, for example, <b>ARKUI_NATIVE_NODE</b>\n and <b>ARKUI_NATIVE_GESTURE</b>.\n @param sturctName Indicates the name of a native struct defined in the corresponding header file, for example,\n <b>ArkUI_NativeNodeAPI_1</b> in <arkui/native_node.h>.\n @return Returns the pointer to the abstract native API, which can be used after being converted into a specific type.\n @code {.cpp}\n #include<arkui/native_interface.h>\n #include<arkui/native_node.h>\n #include<arkui/native_gesture.h>\n\n auto* anyNativeAPI = OH_ArkUI_QueryModuleInterfaceByName(ARKUI_NATIVE_NODE, \"ArkUI_NativeNodeAPI_1\");\n if (anyNativeAPI) {\n     auto nativeNodeApi = reinterpret_cast<ArkUI_NativeNodeAPI_1*>(anyNativeAPI);\n }\n auto anyGestureAPI = OH_ArkUI_QueryModuleInterface(ARKUI_NATIVE_GESTURE, \"ArkUI_NativeGestureAPI_1\");\n if (anyNativeAPI) {\n     auto basicGestureApi = reinterpret_cast<ArkUI_NativeGestureAPI_1*>(anyGestureAPI);\n }\n @endcode\n\n @since 12"]
    pub fn OH_ArkUI_QueryModuleInterfaceByName(
        type_: ArkUI_NativeAPIVariantKind,
        structName: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Unknown (or unrecognized) key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_UNKNOWN: ArkUI_KeyCode = -1;
#[doc = " Function (Fn) key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_FN: ArkUI_KeyCode = 0;
#[doc = " Volume Up key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_VOLUME_UP: ArkUI_KeyCode = 16;
#[doc = " Volume Down key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_VOLUME_DOWN: ArkUI_KeyCode = 17;
#[doc = " Power key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_POWER: ArkUI_KeyCode = 18;
#[doc = " Shutter key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_CAMERA: ArkUI_KeyCode = 19;
#[doc = " Speaker Mute key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_VOLUME_MUTE: ArkUI_KeyCode = 22;
#[doc = " Mute key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MUTE: ArkUI_KeyCode = 23;
#[doc = " Brightness Up key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BRIGHTNESS_UP: ArkUI_KeyCode = 40;
#[doc = " Brightness Down key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BRIGHTNESS_DOWN: ArkUI_KeyCode = 41;
#[doc = " Key 0"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_0: ArkUI_KeyCode = 2000;
#[doc = " Key 1"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_1: ArkUI_KeyCode = 2001;
#[doc = " Key 2"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_2: ArkUI_KeyCode = 2002;
#[doc = " Key 3"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_3: ArkUI_KeyCode = 2003;
#[doc = " Key 4"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_4: ArkUI_KeyCode = 2004;
#[doc = " Key 5"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_5: ArkUI_KeyCode = 2005;
#[doc = " Key 6"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_6: ArkUI_KeyCode = 2006;
#[doc = " Key 7"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_7: ArkUI_KeyCode = 2007;
#[doc = " Key 8"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_8: ArkUI_KeyCode = 2008;
#[doc = " Key 9"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_9: ArkUI_KeyCode = 2009;
#[doc = " Key +"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_STAR: ArkUI_KeyCode = 2010;
#[doc = " Key #"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_POUND: ArkUI_KeyCode = 2011;
#[doc = " Up key on D-pad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_UP: ArkUI_KeyCode = 2012;
#[doc = " Down key on D-pad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_DOWN: ArkUI_KeyCode = 2013;
#[doc = " Left key on D-pad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_LEFT: ArkUI_KeyCode = 2014;
#[doc = " Right key on D-pad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_RIGHT: ArkUI_KeyCode = 2015;
#[doc = " OK key on D-pad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DPAD_CENTER: ArkUI_KeyCode = 2016;
#[doc = " Key A"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_A: ArkUI_KeyCode = 2017;
#[doc = " Key B"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_B: ArkUI_KeyCode = 2018;
#[doc = " Key C"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_C: ArkUI_KeyCode = 2019;
#[doc = " Key D"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_D: ArkUI_KeyCode = 2020;
#[doc = " Key E"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_E: ArkUI_KeyCode = 2021;
#[doc = " Key F"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F: ArkUI_KeyCode = 2022;
#[doc = " Key G"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_G: ArkUI_KeyCode = 2023;
#[doc = " Key H"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_H: ArkUI_KeyCode = 2024;
#[doc = " Key I"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_I: ArkUI_KeyCode = 2025;
#[doc = " Key J"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_J: ArkUI_KeyCode = 2026;
#[doc = " Key K"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_K: ArkUI_KeyCode = 2027;
#[doc = " Key L"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_L: ArkUI_KeyCode = 2028;
#[doc = " Key M"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_M: ArkUI_KeyCode = 2029;
#[doc = " Key N"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_N: ArkUI_KeyCode = 2030;
#[doc = " Key O"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_O: ArkUI_KeyCode = 2031;
#[doc = " Key P"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_P: ArkUI_KeyCode = 2032;
#[doc = " Key R"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_Q: ArkUI_KeyCode = 2033;
#[doc = " Key R"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_R: ArkUI_KeyCode = 2034;
#[doc = " Key S"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_S: ArkUI_KeyCode = 2035;
#[doc = " Key T"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_T: ArkUI_KeyCode = 2036;
#[doc = " Key U"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_U: ArkUI_KeyCode = 2037;
#[doc = " Key V"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_V: ArkUI_KeyCode = 2038;
#[doc = " Key W"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_W: ArkUI_KeyCode = 2039;
#[doc = " Key X"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_X: ArkUI_KeyCode = 2040;
#[doc = " Key Y"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_Y: ArkUI_KeyCode = 2041;
#[doc = " Key Z"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_Z: ArkUI_KeyCode = 2042;
#[doc = " Key #"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_COMMA: ArkUI_KeyCode = 2043;
#[doc = " Key #"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_PERIOD: ArkUI_KeyCode = 2044;
#[doc = " Left Alt key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ALT_LEFT: ArkUI_KeyCode = 2045;
#[doc = " Right Alt key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ALT_RIGHT: ArkUI_KeyCode = 2046;
#[doc = " Left Shift key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SHIFT_LEFT: ArkUI_KeyCode = 2047;
#[doc = " Right Shift key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SHIFT_RIGHT: ArkUI_KeyCode = 2048;
#[doc = " Tab key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_TAB: ArkUI_KeyCode = 2049;
#[doc = " Space key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SPACE: ArkUI_KeyCode = 2050;
#[doc = " Symbol key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SYM: ArkUI_KeyCode = 2051;
#[doc = " Explorer key, used to start the explorer application"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_EXPLORER: ArkUI_KeyCode = 2052;
#[doc = " Email key, used to start the email application"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ENVELOPE: ArkUI_KeyCode = 2053;
#[doc = " Enter key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ENTER: ArkUI_KeyCode = 2054;
#[doc = " Backspace key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_DEL: ArkUI_KeyCode = 2055;
#[doc = " Key `"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_GRAVE: ArkUI_KeyCode = 2056;
#[doc = " Key -"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MINUS: ArkUI_KeyCode = 2057;
#[doc = " Key ="]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_EQUALS: ArkUI_KeyCode = 2058;
#[doc = " Key ["]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_LEFT_BRACKET: ArkUI_KeyCode = 2059;
#[doc = " Key ]"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_RIGHT_BRACKET: ArkUI_KeyCode = 2060;
#[doc = " Key \\\\"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BACKSLASH: ArkUI_KeyCode = 2061;
#[doc = " Key ;"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SEMICOLON: ArkUI_KeyCode = 2062;
#[doc = " Key '"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_APOSTROPHE: ArkUI_KeyCode = 2063;
#[doc = " Key /"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SLASH: ArkUI_KeyCode = 2064;
#[doc = " Key @"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_AT: ArkUI_KeyCode = 2065;
#[doc = " Key +"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_PLUS: ArkUI_KeyCode = 2066;
#[doc = " Menu key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MENU: ArkUI_KeyCode = 2067;
#[doc = " Page Up key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_PAGE_UP: ArkUI_KeyCode = 2068;
#[doc = " Page Down key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_PAGE_DOWN: ArkUI_KeyCode = 2069;
#[doc = " ESC key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_ESCAPE: ArkUI_KeyCode = 2070;
#[doc = " Delete key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_FORWARD_DEL: ArkUI_KeyCode = 2071;
#[doc = " Left Ctrl key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_CTRL_LEFT: ArkUI_KeyCode = 2072;
#[doc = " Right Ctrl key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_CTRL_RIGHT: ArkUI_KeyCode = 2073;
#[doc = " Caps Lock key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_CAPS_LOCK: ArkUI_KeyCode = 2074;
#[doc = " Scroll Lock key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SCROLL_LOCK: ArkUI_KeyCode = 2075;
#[doc = " Left Meta key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_META_LEFT: ArkUI_KeyCode = 2076;
#[doc = " Right Meta key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_META_RIGHT: ArkUI_KeyCode = 2077;
#[doc = " Function key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_FUNCTION: ArkUI_KeyCode = 2078;
#[doc = " System Request/Print Screen key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_SYSRQ: ArkUI_KeyCode = 2079;
#[doc = " Break/Pause key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BREAK: ArkUI_KeyCode = 2080;
#[doc = " Move to Home key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MOVE_HOME: ArkUI_KeyCode = 2081;
#[doc = " Move to End key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MOVE_END: ArkUI_KeyCode = 2082;
#[doc = " Insert key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_INSERT: ArkUI_KeyCode = 2083;
#[doc = " Forward key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_FORWARD: ArkUI_KeyCode = 2084;
#[doc = " Play key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_PLAY: ArkUI_KeyCode = 2085;
#[doc = " Pause key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_PAUSE: ArkUI_KeyCode = 2086;
#[doc = " Close key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_CLOSE: ArkUI_KeyCode = 2087;
#[doc = " Eject key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_EJECT: ArkUI_KeyCode = 2088;
#[doc = " Record key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_MEDIA_RECORD: ArkUI_KeyCode = 2089;
#[doc = " F1 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F1: ArkUI_KeyCode = 2090;
#[doc = " F2 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F2: ArkUI_KeyCode = 2091;
#[doc = " F3 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F3: ArkUI_KeyCode = 2092;
#[doc = " F4 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F4: ArkUI_KeyCode = 2093;
#[doc = " F5 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F5: ArkUI_KeyCode = 2094;
#[doc = " F6 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F6: ArkUI_KeyCode = 2095;
#[doc = " F7 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F7: ArkUI_KeyCode = 2096;
#[doc = " F8 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F8: ArkUI_KeyCode = 2097;
#[doc = " F9 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F9: ArkUI_KeyCode = 2098;
#[doc = " F10 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F10: ArkUI_KeyCode = 2099;
#[doc = " F11 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F11: ArkUI_KeyCode = 2100;
#[doc = " F12 key"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_F12: ArkUI_KeyCode = 2101;
#[doc = " Number Lock key on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUM_LOCK: ArkUI_KeyCode = 2102;
#[doc = " Key 0 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_0: ArkUI_KeyCode = 2103;
#[doc = " Key 1 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_1: ArkUI_KeyCode = 2104;
#[doc = " Key 2 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_2: ArkUI_KeyCode = 2105;
#[doc = " Key 3 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_3: ArkUI_KeyCode = 2106;
#[doc = " Key 4 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_4: ArkUI_KeyCode = 2107;
#[doc = " Key 5 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_5: ArkUI_KeyCode = 2108;
#[doc = " Key 6 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_6: ArkUI_KeyCode = 2109;
#[doc = " Key 7 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_7: ArkUI_KeyCode = 2110;
#[doc = " Key 8 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_8: ArkUI_KeyCode = 2111;
#[doc = " Key 9 on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_9: ArkUI_KeyCode = 2112;
#[doc = " Key / on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_DIVIDE: ArkUI_KeyCode = 2113;
#[doc = " Key ) on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_MULTIPLY: ArkUI_KeyCode = 2114;
#[doc = " Key - on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_SUBTRACT: ArkUI_KeyCode = 2115;
#[doc = " Key + on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_ADD: ArkUI_KeyCode = 2116;
#[doc = " Key . on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_DOT: ArkUI_KeyCode = 2117;
#[doc = " Key , on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_COMMA: ArkUI_KeyCode = 2118;
#[doc = " Enter key on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_ENTER: ArkUI_KeyCode = 2119;
#[doc = " Key = on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_EQUALS: ArkUI_KeyCode = 2120;
#[doc = " Key ( on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_LEFT_PAREN: ArkUI_KeyCode = 2121;
#[doc = " Key ) on numeric keypad"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_NUMPAD_RIGHT_PAREN: ArkUI_KeyCode = 2122;
#[doc = " Joystick key A\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_A: ArkUI_KeyCode = 2301;
#[doc = " Joystick key B\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_B: ArkUI_KeyCode = 2302;
#[doc = " Joystick key X\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_X: ArkUI_KeyCode = 2304;
#[doc = " Joystick key Y\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_Y: ArkUI_KeyCode = 2305;
#[doc = " Joystick key L1\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_L1: ArkUI_KeyCode = 2307;
#[doc = " Joystick key R1\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_R1: ArkUI_KeyCode = 2308;
#[doc = " Joystick key L2\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_L2: ArkUI_KeyCode = 2309;
#[doc = " Joystick key R2\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_R2: ArkUI_KeyCode = 2310;
#[doc = " Joystick key Select\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_SELECT: ArkUI_KeyCode = 2311;
#[doc = " Joystick key Start\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_START: ArkUI_KeyCode = 2312;
#[doc = " Joystick key Mode\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_MODE: ArkUI_KeyCode = 2313;
#[doc = " Joystick key THUMBL\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_THUMBL: ArkUI_KeyCode = 2314;
#[doc = " Joystick key THUMBR\n @since 15"]
pub const ArkUI_KeyCode_ARKUI_KEYCODE_BUTTON_THUMBR: ArkUI_KeyCode = 2315;
#[doc = " @brief Defines an enum for the key codes in key events.\n\n @since 14"]
pub type ArkUI_KeyCode = ::std::os::raw::c_int;
#[doc = " Unknown type"]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_UNKNOWN: ArkUI_KeyEventType = -1;
#[doc = " Pressing of a key"]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_DOWN: ArkUI_KeyEventType = 0;
#[doc = " Release of a key"]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_UP: ArkUI_KeyEventType = 1;
#[doc = " Long press of a key"]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_LONG_PRESS: ArkUI_KeyEventType = 2;
#[doc = " Click of a key"]
pub const ArkUI_KeyEventType_ARKUI_KEY_EVENT_CLICK: ArkUI_KeyEventType = 3;
#[doc = " @brief Defines an enum for the key event types.\n\n @since 14"]
pub type ArkUI_KeyEventType = ::std::os::raw::c_int;
#[doc = " Unknown type"]
pub const ArkUI_KeySourceType_ARKUI_KEY_SOURCE_UNKNOWN: ArkUI_KeySourceType = 0;
#[doc = " Mouse"]
pub const ArkUI_KeySourceType_ARKUI_KEY_SOURCE_TYPE_MOUSE: ArkUI_KeySourceType = 1;
#[doc = " Keyboard"]
pub const ArkUI_KeySourceType_ARKUI_KEY_SOURCE_TYPE_KEYBOARD: ArkUI_KeySourceType = 4;
#[doc = " @brief Joystick.\n\n @since 15"]
pub const ArkUI_KeySourceType_ARKUI_KEY_SOURCE_TYPE_JOYSTICK: ArkUI_KeySourceType = 5;
#[doc = " @brief Defines an enum for the types of devices that trigger a key event.\n\n @since 14"]
pub type ArkUI_KeySourceType = ::std::os::raw::c_uint;
#[doc = " Unknown intention"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_UNKNOWN: ArkUI_KeyIntension = -1;
#[doc = "Upward"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_UP: ArkUI_KeyIntension = 1;
#[doc = " Downward"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_DOWN: ArkUI_KeyIntension = 2;
#[doc = " Leftward"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_LEFT: ArkUI_KeyIntension = 3;
#[doc = " Rightward"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_RIGHT: ArkUI_KeyIntension = 4;
#[doc = " Select"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_SELECT: ArkUI_KeyIntension = 5;
#[doc = " Escape"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_ESCAPE: ArkUI_KeyIntension = 6;
#[doc = " Back"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_BACK: ArkUI_KeyIntension = 7;
#[doc = " Forward"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_FORWARD: ArkUI_KeyIntension = 8;
#[doc = " Menu"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_MENU: ArkUI_KeyIntension = 9;
#[doc = " Home"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_HOME: ArkUI_KeyIntension = 10;
#[doc = " Page up"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_PAGE_UP: ArkUI_KeyIntension = 11;
#[doc = " Page down"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_PAGE_DOWN: ArkUI_KeyIntension = 12;
#[doc = " Zoom out"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_ZOOM_OUT: ArkUI_KeyIntension = 13;
#[doc = " Zoom in"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENSION_ZOOM_IN: ArkUI_KeyIntension = 14;
#[doc = " Play or pause"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_PLAY_PAUSE: ArkUI_KeyIntension = 100;
#[doc = " Fast-forward"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_FAST_FORWARD: ArkUI_KeyIntension = 101;
#[doc = " Fast playback"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_FAST_PLAYBACK: ArkUI_KeyIntension = 103;
#[doc = " Play next"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_NEXT: ArkUI_KeyIntension = 104;
#[doc = " Play previous"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_PREVIOUS: ArkUI_KeyIntension = 105;
#[doc = " Mute"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_MEDIA_MUTE: ArkUI_KeyIntension = 106;
#[doc = " Volume up"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_VOLUME_UP: ArkUI_KeyIntension = 107;
#[doc = " Volume down"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_VOLUME_DOWN: ArkUI_KeyIntension = 108;
#[doc = " Answer a call"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_CALL: ArkUI_KeyIntension = 200;
#[doc = " Camera"]
pub const ArkUI_KeyIntension_ARKUI_KEY_INTENTION_CAMERA: ArkUI_KeyIntension = 300;
#[doc = " @brief Defines an enum for key intentions.\n\n @since 14"]
pub type ArkUI_KeyIntension = ::std::os::raw::c_int;
extern "C" {
    #[doc = " @brief Obtains the type of a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the key event type.\n @since 14"]
    pub fn OH_ArkUI_KeyEvent_GetType(event: *const ArkUI_UIInputEvent) -> ArkUI_KeyEventType;
}
extern "C" {
    #[doc = " @brief Obtains the key code from a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the key code.\n @since 14"]
    pub fn OH_ArkUI_KeyEvent_GetKeyCode(event: *const ArkUI_UIInputEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the key value from a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the key value.\n @since 14"]
    pub fn OH_ArkUI_KeyEvent_GetKeyText(
        event: *const ArkUI_UIInputEvent,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Obtains the type of device that triggers a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the device type.\n @since 14"]
    pub fn OH_ArkUI_KeyEvent_GetKeySource(event: *const ArkUI_UIInputEvent) -> ArkUI_KeySourceType;
}
extern "C" {
    #[doc = " @brief Prevents a key event from bubbling up.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param stopPropagation Whether to stop event propagation.\n @since 14"]
    pub fn OH_ArkUI_KeyEvent_StopPropagation(
        event: *const ArkUI_UIInputEvent,
        stopPropagation: bool,
    );
}
extern "C" {
    #[doc = " @brief Obtains the intention code associated with a key event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the intention code associated with the key event.\n @since 14"]
    pub fn OH_ArkUI_KeyEvent_GetKeyIntensionCode(
        event: *const ArkUI_UIInputEvent,
    ) -> ArkUI_KeyIntension;
}
extern "C" {
    #[doc = " @brief Obtains the Unicode value associated with a key event.\n Non-space basic Latin characters in the 0x0021-0x007E range are supported. Characters with a value of 0 are not\n supported. In the case of key combination, this API returns the Unicode value of the key corresponding to the key\n event.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @return Returns the Unicode value.\n @since 14"]
    pub fn OH_ArkUI_KeyEvent_GetUnicode(event: *const ArkUI_UIInputEvent) -> u32;
}
extern "C" {
    #[doc = " @brief Sets whether a key event is consumed in the key event callback.\n\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @param isConsumed Whether the event is consumed.\n @since 14"]
    pub fn OH_ArkUI_KeyEvent_SetConsumed(event: *const ArkUI_UIInputEvent, isConsumed: bool);
}
extern "C" {
    #[doc = " @brief Dispatch key event to a specific component node.\n\n @param node Indicates the pointer to a component node.\n @param event Pointer to an <b>ArkUI_UIInputEvent</b> object.\n @since 15"]
    pub fn OH_ArkUI_KeyEvent_Dispatch(node: ArkUI_NodeHandle, event: *const ArkUI_UIInputEvent);
}
#[doc = " Custom node."]
pub const ArkUI_NodeType_ARKUI_NODE_CUSTOM: ArkUI_NodeType = 0;
#[doc = " Text."]
pub const ArkUI_NodeType_ARKUI_NODE_TEXT: ArkUI_NodeType = 1;
#[doc = " Text span."]
pub const ArkUI_NodeType_ARKUI_NODE_SPAN: ArkUI_NodeType = 2;
#[doc = " Image span."]
pub const ArkUI_NodeType_ARKUI_NODE_IMAGE_SPAN: ArkUI_NodeType = 3;
#[doc = " Image."]
pub const ArkUI_NodeType_ARKUI_NODE_IMAGE: ArkUI_NodeType = 4;
#[doc = " Toggle."]
pub const ArkUI_NodeType_ARKUI_NODE_TOGGLE: ArkUI_NodeType = 5;
#[doc = " Loading icon."]
pub const ArkUI_NodeType_ARKUI_NODE_LOADING_PROGRESS: ArkUI_NodeType = 6;
#[doc = " Single-line text input."]
pub const ArkUI_NodeType_ARKUI_NODE_TEXT_INPUT: ArkUI_NodeType = 7;
#[doc = " Multi-line text input."]
pub const ArkUI_NodeType_ARKUI_NODE_TEXT_AREA: ArkUI_NodeType = 8;
#[doc = " Button."]
pub const ArkUI_NodeType_ARKUI_NODE_BUTTON: ArkUI_NodeType = 9;
#[doc = " Progress indicator."]
pub const ArkUI_NodeType_ARKUI_NODE_PROGRESS: ArkUI_NodeType = 10;
#[doc = " Check box."]
pub const ArkUI_NodeType_ARKUI_NODE_CHECKBOX: ArkUI_NodeType = 11;
#[doc = " XComponent."]
pub const ArkUI_NodeType_ARKUI_NODE_XCOMPONENT: ArkUI_NodeType = 12;
#[doc = " Date picker."]
pub const ArkUI_NodeType_ARKUI_NODE_DATE_PICKER: ArkUI_NodeType = 13;
#[doc = " Time picker."]
pub const ArkUI_NodeType_ARKUI_NODE_TIME_PICKER: ArkUI_NodeType = 14;
#[doc = " Text picker."]
pub const ArkUI_NodeType_ARKUI_NODE_TEXT_PICKER: ArkUI_NodeType = 15;
#[doc = " Calendar picker."]
pub const ArkUI_NodeType_ARKUI_NODE_CALENDAR_PICKER: ArkUI_NodeType = 16;
#[doc = " Slider."]
pub const ArkUI_NodeType_ARKUI_NODE_SLIDER: ArkUI_NodeType = 17;
#[doc = " Radio"]
pub const ArkUI_NodeType_ARKUI_NODE_RADIO: ArkUI_NodeType = 18;
#[doc = " Image animator."]
pub const ArkUI_NodeType_ARKUI_NODE_IMAGE_ANIMATOR: ArkUI_NodeType = 19;
#[doc = " Check box group.\n  @since 15"]
pub const ArkUI_NodeType_ARKUI_NODE_CHECKBOX_GROUP: ArkUI_NodeType = 21;
#[doc = " Stack container."]
pub const ArkUI_NodeType_ARKUI_NODE_STACK: ArkUI_NodeType = 1000;
#[doc = " Swiper."]
pub const ArkUI_NodeType_ARKUI_NODE_SWIPER: ArkUI_NodeType = 1001;
#[doc = " Scrolling container."]
pub const ArkUI_NodeType_ARKUI_NODE_SCROLL: ArkUI_NodeType = 1002;
#[doc = " List."]
pub const ArkUI_NodeType_ARKUI_NODE_LIST: ArkUI_NodeType = 1003;
#[doc = " List item."]
pub const ArkUI_NodeType_ARKUI_NODE_LIST_ITEM: ArkUI_NodeType = 1004;
#[doc = " List item group."]
pub const ArkUI_NodeType_ARKUI_NODE_LIST_ITEM_GROUP: ArkUI_NodeType = 1005;
#[doc = " Column container."]
pub const ArkUI_NodeType_ARKUI_NODE_COLUMN: ArkUI_NodeType = 1006;
#[doc = " Row container."]
pub const ArkUI_NodeType_ARKUI_NODE_ROW: ArkUI_NodeType = 1007;
#[doc = " Flex container."]
pub const ArkUI_NodeType_ARKUI_NODE_FLEX: ArkUI_NodeType = 1008;
#[doc = " Refresh component."]
pub const ArkUI_NodeType_ARKUI_NODE_REFRESH: ArkUI_NodeType = 1009;
#[doc = " Water flow container."]
pub const ArkUI_NodeType_ARKUI_NODE_WATER_FLOW: ArkUI_NodeType = 1010;
#[doc = " Water flow item."]
pub const ArkUI_NodeType_ARKUI_NODE_FLOW_ITEM: ArkUI_NodeType = 1011;
#[doc = " Relative layout component."]
pub const ArkUI_NodeType_ARKUI_NODE_RELATIVE_CONTAINER: ArkUI_NodeType = 1012;
#[doc = " Grid."]
pub const ArkUI_NodeType_ARKUI_NODE_GRID: ArkUI_NodeType = 1013;
#[doc = " Grid item."]
pub const ArkUI_NodeType_ARKUI_NODE_GRID_ITEM: ArkUI_NodeType = 1014;
#[doc = " Custom span."]
pub const ArkUI_NodeType_ARKUI_NODE_CUSTOM_SPAN: ArkUI_NodeType = 1015;
#[doc = " @brief Enumerates ArkUI component types that can be created on the native side.\n\n @since 12"]
pub type ArkUI_NodeType = ::std::os::raw::c_uint;
#[doc = " @brief Defines the general input parameter structure of the {@link setAttribute} function.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_AttributeItem {
    #[doc = " Numeric array."]
    pub value: *const ArkUI_NumberValue,
    #[doc = " Size of the numeric array."]
    pub size: i32,
    #[doc = " String type."]
    pub string: *const ::std::os::raw::c_char,
    #[doc = " Object type."]
    pub object: *mut ::std::os::raw::c_void,
}
#[doc = " @brief Defines the width attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WIDTH: ArkUI_NodeAttributeType = 0;
#[doc = " @brief Defines the height attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: height, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: height, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_HEIGHT: ArkUI_NodeAttributeType = 1;
#[doc = " @brief Defines the background color attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: background color. The value is in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color. The value is in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_COLOR: ArkUI_NodeAttributeType = 2;
#[doc = " @brief Defines the background image attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: image address;\\n\n .value[0]?.i32: whether to repeat the image. Optional. The parameter type is {@link ArkUI_ImageRepeat}.\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n The default value is <b>ARKUI_IMAGE_REPEAT_NONE</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: image address;\\n\n .value[0].i32: whether to repeat the image. The parameter type is {@link ArkUI_ImageRepeat}.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_IMAGE: ArkUI_NodeAttributeType = 3;
#[doc = " @brief Defines the padding attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: Specify the same padding for the four directions. \\n\n .value[0].f32: padding, in vp.\\n\n 2: Specify different paddings for different directions. \\n\n .value[0].f32: top padding, in vp.\\n\n .value[1].f32: right padding, in vp.\\n\n .value[2].f32: bottom padding, in vp.\\n\n .value[3].f32: left padding, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: top padding, in vp.\\n\n .value[1].f32: right padding, in vp.\\n\n .value[2].f32: bottom padding, in vp.\\n\n .value[3].f32: left padding, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PADDING: ArkUI_NodeAttributeType = 4;
#[doc = " @brief Defines the component ID attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component ID.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component ID.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ID: ArkUI_NodeAttributeType = 5;
#[doc = " @brief Defines the interactivity attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The value <b>true</b> means that the component can interact with users, and <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means that the component can interact with users, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ENABLED: ArkUI_NodeAttributeType = 6;
#[doc = " @brief Defines the margin attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: Specify the same margin for the four directions. \\n\n .value[0].f32: margin, in vp.\\n\n 2: Specify different margins for different directions. \\n\n .value[0].f32: top margin, in vp.\\n\n .value[1].f32: right margin, in vp.\\n\n .value[2].f32: bottom margin, in vp.\\n\n .value[3].f32: left margin, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: top margin, in vp.\\n\n .value[1].f32: right margin, in vp.\\n\n .value[2].f32: bottom margin, in vp.\\n\n .value[3].f32: left margin, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MARGIN: ArkUI_NodeAttributeType = 7;
#[doc = " @brief Defines the translate attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: distance to translate along the x-axis, in vp. The default value is <b>0</b>.\\n\n .value[1].f32: distance to translate along the y-axis, in vp. The default value is <b>0</b>.\\n\n .value[2].f32: distance to translate along the z-axis, in vp. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: distance to translate along the x-axis, in vp.\\n\n .value[1].f32: distance to translate along the y-axis, in vp.\\n\n .value[2].f32: distance to translate along the z-axis, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSLATE: ArkUI_NodeAttributeType = 8;
#[doc = " @brief Defines the scale attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: scale factor along the x-axis. The default value is <b>1</b>.\\n\n .value[1].f32: scale factor along the y-axis. The default value is <b>1</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: scale factor along the x-axis.\\n\n .value[1].f32: scale factor along the y-axis. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCALE: ArkUI_NodeAttributeType = 9;
#[doc = " @brief Defines the rotate attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: X coordinate of the rotation axis vector. The default value is <b>0</b>.\\n\n .value[1].f32: Y coordinate of the rotation axis vector. The default value is <b>0</b>.\\n\n .value[2].f32: Z coordinate of the rotation axis vector. The default value is <b>0</b>.\\n\n .value[3].f32: rotation angle. The default value is <b>0</b>.\\n\n .value[4].f32: line of sight, that is, the distance from the viewpoint to the z=0 plane, in vp.\n The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the rotation axis vector.\\n\n .value[1].f32: Y coordinate of the rotation axis vector.\\n\n .value[2].f32: Z coordinate of the rotation axis vector.\\n\n .value[3].f32: rotation angle.\\n\n .value[4].f32: line of sight, that is, the distance from the viewpoint to the z=0 plane, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ROTATE: ArkUI_NodeAttributeType = 10;
#[doc = " @brief Sets the brightness attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: brightness value. The default value is <b>1.0</b>, and the recommended value range is [0, 2]. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: brightness value. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BRIGHTNESS: ArkUI_NodeAttributeType = 11;
#[doc = " @brief Sets the saturation attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].f32: saturation value. The default value is <b>1.0</b>, and the recommended value range is [0, 50). \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].f32: saturation value. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SATURATION: ArkUI_NodeAttributeType = 12;
#[doc = " @brief Sets the blur attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].f32: blur radius. A larger value indicates a higher blur degree. If the value is <b>0</b>,\n the component is not blurred. The unit is vp. The default value is <b>0.0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: blur radius. The larger the fuzzy radius, the more blurred the image. If the value is <b>0</b>,\n the image is not blurred. The unit is vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BLUR: ArkUI_NodeAttributeType = 13;
#[doc = " @brief Sets the gradient attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: start angle of the linear gradient. This attribute takes effect only when\n {@link ArkUI_LinearGradientDirection} is set to <b>ARKUI_LINEAR_GRADIENT_DIRECTION_CUSTOM</b>.\n A positive value indicates a clockwise rotation from the origin, (0, 0). The default value is <b>180</b>. \\n\n .value[1].i32: direction of the linear gradient. When it is set, the <b>angle</b> attribute does not take effect.\n The parameter type is {@link ArkUI_LinearGradientDirection}: \\n\n .value[2].i32: whether the colors are repeated. The default value is <b>false</b>. \\n\n .object: array of color stops, each of which consists of a color and its stop position.\n Invalid colors are automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].f32: start angle of the linear gradient. \\n\n .value[1].i32: direction of the linear gradient. It does not take effect when <b>angle</b> is set. \\n\n .value[2].i32: whether the colors are repeated. \\n\n .object: array of color stops, each of which consists of a color and its stop position.\n Invalid colors are automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LINEAR_GRADIENT: ArkUI_NodeAttributeType = 14;
#[doc = " @brief Sets the alignment attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode. The data type is {@link ArkUI_Alignment}.\n The default value is <b>ARKUI_ALIGNMENT_CENTER</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode. The data type is {@link ArkUI_Alignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ALIGNMENT: ArkUI_NodeAttributeType = 15;
#[doc = " @brief Defines the opacity attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: opacity value. The value ranges from 0 to 1. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: opacity value. The value ranges from 0 to 1. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OPACITY: ArkUI_NodeAttributeType = 16;
#[doc = " @brief Defines the border width attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].f32: width of the four borders. \\n\n 2: .value[0].f32: width of the top border. \\n\n .value[1].f32: width of the right border. \\n\n .value[2].f32: width of the bottom border. \\n\n .value[3].f32: width of the left border. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the top border. \\n\n .value[1].f32: width of the right border. \\n\n .value[2].f32: width of the bottom border. \\n\n .value[3].f32: width of the left border. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_WIDTH: ArkUI_NodeAttributeType = 17;
#[doc = " @brief Defines the border corner radius attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].f32: radius of the four corners. \\n\n 2: .value[0].f32: radius of the upper left corner. \\n\n .value[1].f32: radius of the upper right corner. \\n\n .value[2].f32: radius of the lower left corner. \\n\n .value[3].f32: radius of the lower right corner. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: radius of the upper left corner. \\n\n .value[1].f32: radius of the upper right corner. \\n\n .value[2].f32: radius of the lower left corner. \\n\n .value[3].f32: radius of the lower right corner. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_RADIUS: ArkUI_NodeAttributeType = 18;
#[doc = " @brief Defines the border color attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].u32: color of the four borders, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n 2: .value[0].u32: color of the top border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[1].u32: color of the right border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[2].u32: color of the lower border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[3].u32: color of the left border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the top border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[1].u32: color of the right border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[2].u32: color of the lower border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n .value[3].u32: color of the left border, in 0xARGB format, for example, <b>0xFFFF11FF</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_COLOR: ArkUI_NodeAttributeType = 19;
#[doc = " @brief Defines the border line style attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].i32: line style of the four borders. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n 2: .value[0].i32: line style of the top border. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n .value[1].i32: line style of the right border. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n .value[2].i32: line style of the bottom border. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n .value[3].i32: line style of the left border. The parameter type is {@link ArkUI_BorderStyle}.\n The default value is <b>ARKUI_BORDER_STYLE_SOLID</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: line style of the top border. \\n\n .value[1].i32: line style of the right border. \\n\n .value[2].i32: line style of the bottom border. \\n\n .value[3].i32: line style of the left border. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_STYLE: ArkUI_NodeAttributeType = 20;
#[doc = " @brief Defines the z-index attribute for the stack sequence.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: z-index value. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: z-index value. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_Z_INDEX: ArkUI_NodeAttributeType = 21;
#[doc = " @brief Defines the visibility attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show or hide the component. The parameter type is {@link ArkUI_Visibility}.\n The default value is <b>ARKUI_VISIBILITY_VISIBLE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to show or hide the component. The parameter type is {@link ArkUI_Visibility}.\n The default value is <b>ARKUI_VISIBILITY_VISIBLE</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_VISIBILITY: ArkUI_NodeAttributeType = 22;
#[doc = " @brief Defines the clipping and masking attribute, which can be set, reset, and obtained as required through\n APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to clip the component based on the parent container bounds.\n The value <b>1</b> means to clip the component, and <b>0</b> means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to clip the component based on the parent container bounds.\n The value <b>1</b> means to clip the component, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CLIP: ArkUI_NodeAttributeType = 23;
#[doc = " @brief Defines the clipping region on the component.\n This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute,\n which supports five types of shapes:\\n\n 1. Rectangle:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_RECTANGLE</b> for the rectangle shape.\\n\n .value[1].f32: width of the rectangle.\\n\n .value[2].f32: height of rectangle.\\n\n .value[3].f32: width of the rounded corner of the rectangle.\\n\n .value[4].f32: height of the rounded corner of the rectangle.\\n\n .value[5]?.f32: radius of the top left corner of the rectangular shape.\\n\n .value[6]?.f32: radius of the bottom left corner of the rectangular shape.\\n\n .value[7]?.f32: radius of the top right corner of the rectangular shape.\\n\n .value[8]?.f32: radius of the bottom right corner of the rectangular shape.\\n\n 2. Circle:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[1].f32: width of the circle.\\n\n .value[2].f32: height of the circle.\\n\n 3.Ellipse:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[1].f32: width of the ellipse.\\n\n .value[2].f32: height of the ellipse.\\n\n 4. Path:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_PATH</b> for the path shape.\\n\n .value[1].f32: width of the path.\\n\n .value[2].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n Format of the return value {@link ArkUI_AttributeItem}, which supports five types of shapes:\\n\n 1. Rectangle:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_RECTANGLE</b> for the rectangle shape.\\n\n .value[1].f32: width of the rectangle.\\n\n .value[2].f32: height of rectangle.\\n\n .value[3].f32: width of the rounded corner of the rectangle.\\n\n .value[4].f32: height of the rounded corner of the rectangle.\\n\n .value[5].f32: radius of the top left corner of the rectangular shape; \\n\n .value[6].f32: radius of the bottom left corner of the rectangular shape; \\n\n .value[7].f32: radius of the top right corner of the rectangular shape; \\n\n .value[8].f32: radius of the bottom right corner of the rectangular shape; \\n\n 2. Circle:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[1].f32: width of the circle.\\n\n .value[2].f32: height of the circle.\\n\n 3.Ellipse:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[1].f32: width of the ellipse.\\n\n .value[2].f32: height of the ellipse.\\n\n 4. Path:\\n\n .value[0].i32: type of shape. The parameter type is {@link ArkUI_ClipType}.\n The value is <b>ARKUI_CLIP_TYPE_PATH</b> for the path shape.\\n\n .value[1].f32: width of the path.\\n\n .value[2].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CLIP_SHAPE: ArkUI_NodeAttributeType = 24;
#[doc = " @brief Defines the transform attribute, which can be used to translate, rotate, and scale images.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0...15].f32: 16 floating-point numbers. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0...15].f32: 16 floating-point numbers. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSFORM: ArkUI_NodeAttributeType = 25;
#[doc = " @brief Defines the hit test behavior attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: hit test mode. The parameter type is {@link ArkUI_HitTestMode}.\n The default value is <b>ARKUI_HIT_TEST_MODE_DEFAULT</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: hit test mode. The parameter type is {@link ArkUI_HitTestMode}.\n The default value is <b>ARKUI_HIT_TEST_MODE_DEFAULT</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_HIT_TEST_BEHAVIOR: ArkUI_NodeAttributeType = 26;
#[doc = " @brief Defines the offset attribute, which specifies the offset of the component's upper left corner relative\n to the parent container's. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: X coordinate. \\n\n .value[1].f32: Y coordinate. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate. \\n\n .value[1].f32: Y coordinate. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_POSITION: ArkUI_NodeAttributeType = 27;
#[doc = " @brief Defines the shadow attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: shadow effect. The parameter type is {@link ArkUI_ShadowStyle}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: shadow effect. The parameter type is {@link ArkUI_ShadowStyle}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SHADOW: ArkUI_NodeAttributeType = 28;
#[doc = " @brief Defines the custom shadow effect. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: blur radius of the shadow, in vp.\\n\n .value[1]?.i32: whether to enable the coloring strategy. The value <b>1</b> means to enable the coloring\n strategy, and <b>0</b> (default value) means the opposite.\\n\n .value[2]?.f32: offset of the shadow along the x-axis, in px.\\n\n .value[3]?.f32: offset of the shadow along the y-axis, in px.\\n\n .value[4]?.i32: shadow type {@link ArkUI_ShadowType}. The default value is <b>ARKUI_SHADOW_TYPE_COLOR</b>.\\n\n .value[5]?.u32: shadow color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n .value[6]?.u32: whether to fill the shadow. The value <b>1</b> means to fill the shadow, and <b>0</b>\n means the opposite.\\n\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: blur radius of the shadow, in vp.\\n\n .value[1].i32: whether to enable the coloring strategy. \\n\n .value[2].f32: offset of the shadow along the x-axis, in px.\\n\n .value[3].f32: offset of the shadow along the y-axis, in px.\\n\n .value[4].i32: shadow type {@link ArkUI_ShadowType}. The default value is <b>ARKUI_SHADOW_TYPE_COLOR</b>.\\n\n .value[5].u32: shadow color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n .value[6].u32: whether to fill the shadow. The value <b>1</b> means to fill the shadow, and <b>0</b>\n means the opposite.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CUSTOM_SHADOW: ArkUI_NodeAttributeType = 29;
#[doc = " @brief Defines the background image width and height.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width of the image. The value range is [0, +∞), and the unit is vp. \\n\n .value[1].f32: height of the image. The value range is [0, +∞), and the unit is vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the image, in vp. \\n\n .value[1].f32: height of the image, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_IMAGE_SIZE: ArkUI_NodeAttributeType = 30;
#[doc = " @brief Defines the background image size.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: size of the background image. The value is an enum of {@link ArkUI_ImageSize}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: size of the background image. The value is an enum of {@link ArkUI_ImageSize}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_IMAGE_SIZE_WITH_STYLE: ArkUI_NodeAttributeType =
    31;
#[doc = " @brief Defines the background blur attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: blue type. The value is an enum of {@link ArkUI_BlurStyle}. \\n\n .value[1]?.i32: color mode. The value is an enum of {@link ArkUI_ColorMode}. \\n\n .value[2]?.i32: adaptive color mode. The value is an enum of {@link ArkUI_AdaptiveColor}. \\n\n .value[3]?.f32: blur degree. The value range is [0.0, 1.0]. \\n\n .value[4]?.f32: start boundary of grayscale blur. \\n\n .value[5]?.f32: end boundary of grayscale blur. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: blue type. The value is an enum of {@link ArkUI_BlurStyle}. \\n\n .value[1].i32: color mode. The value is an enum of {@link ArkUI_ColorMode}. \\n\n .value[2].i32: adaptive color mode. The value is an enum of {@link ArkUI_AdaptiveColor}. \\n\n .value[3].f32: blur degree. The value range is [0.0, 1.0]. \\n\n .value[4].f32: start boundary of grayscale blur. \\n\n .value[5].f32: end boundary of grayscale blur. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_BLUR_STYLE: ArkUI_NodeAttributeType = 32;
#[doc = " @brief Defines the transform center attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: X coordinate of the center point, in vp.\\n\n .value[1]?.f32: Y coordinate of the center point, in vp.\\n\n .value[2]?.f32: Z coordinate of the center point, in vp.\\n\n .value[3]?.f32 : X coordinate of the center point, expressed in a number that represents a percentage.\n For example, 0.2 indicates 20%. This attribute overwrites value[0].f32. The default value is <b>0.5f</b>. \\n\n .value[4]?.f32 : Y coordinate of the center point, expressed in a number that represents a percentage.\n For example, 0.2 indicates 20%. This attribute overwrites value[1].f32. The default value is <b>0.5f</b>. \\n\n .value[5]?.f32 : Z coordinate of the center point, expressed in a number that represents a percentage.\n For example, 0.2 indicates 20%. This attribute overwrites value[2].f32. The default value is <b>0.0f</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the center point, in vp.\\n\n .value[1].f32: Y coordinate of the center point, in vp.\\n\n .value[2].f32: Z coordinate of the center point, in vp.\\n\n Note: If the coordinate is expressed in a number that represents a percentage, the attribute obtaining API\n returns the calculated value in vp.\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSFORM_CENTER: ArkUI_NodeAttributeType = 33;
#[doc = " @brief Defines the transition opacity attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: opacity values of the start and end points.\\n\n .value[1].i32: animation duration, in milliseconds.\\n\n .value[2].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n\n .value[3]?.i32: animation delay duration, in milliseconds.\\n\n .value[4]?.i32: number of times that the animation is played.\\n\n .value[5]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}.\\n\n .value[6]?.f32: animation playback speed.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: opacity values of the start and end points.\\n\n .value[1].i32: animation duration, in milliseconds.\\n\n .value[2].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n\n .value[3].i32: animation delay duration, in milliseconds. \\n\n .value[4].i32: number of times that the animation is played. \\n\n .value[5].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[6].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OPACITY_TRANSITION: ArkUI_NodeAttributeType = 34;
#[doc = " @brief Defines the transition rotation attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: X-component of the rotation vector. \\n\n .value[1].f32: Y-component of the rotation vector. \\n\n .value[2].f32: Z-component of the rotation vector \\n\n .value[3].f32: angle. \\n\n .value[4].f32: line of sight. The default value is <b>0.0f</b>. \\n\n .value[5].i32: animation duration, in milliseconds. \\n\n .value[6].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n .value[7]?.i32: animation delay duration, in milliseconds. \\n\n .value[8]?.i32: number of times that the animation is played. \\n\n .value[9]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[10]?.f32: animation playback speed. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X-component of the rotation vector. \\n\n .value[1].f32: Y-component of the rotation vector. \\n\n .value[2].f32: Z-component of the rotation vector \\n\n .value[3].f32: angle. \\n\n .value[4].f32: line of sight. \\n\n .value[5].i32: animation duration, in milliseconds. \\n\n .value[6].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n .value[7].i32: animation delay duration, in milliseconds. \\n\n .value[8].i32: number of times that the animation is played. \\n\n .value[9].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[10].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ROTATE_TRANSITION: ArkUI_NodeAttributeType = 35;
#[doc = " @brief Defines the transition scaling attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: scale factor along the x-axis. \\n\n .value[1].f32: scale factor along the y-axis. \\n\n .value[2].f32: scale factor along the z-axis. \\n\n .value[3].i32: animation duration, in milliseconds. \\n\n .value[4].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n .value[5]?.i32: animation delay duration, in milliseconds. \\n\n .value[6]?.i32: number of times that the animation is played. \\n\n .value[7]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[8]?.f32: animation playback speed. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: scale factor along the x-axis. \\n\n .value[1].f32: scale factor along the y-axis. \\n\n .value[2].f32: scale factor along the z-axis. \\n\n .value[3].i32: animation duration, in milliseconds. \\n\n .value[4].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n .value[5].i32: animation delay duration, in milliseconds. \\n\n .value[6].i32: number of times that the animation is played. \\n\n .value[7].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[8].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCALE_TRANSITION: ArkUI_NodeAttributeType = 36;
#[doc = " @brief Defines the transition translation attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n value[0].f32: translation distance along the x-axis, in vp.\\n\n value[1].f32: translation distance along the y-axis, in vp.\\n\n value[2].f32: translation distance along the z-axis, in vp.\\n\n value[3].i32: animation duration, in milliseconds. \\n\n value[4].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n value[5]?.i32: animation delay duration, in milliseconds. \\n\n value[6]?.i32: number of times that the animation is played. \\n\n value[7]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n value[8]?.f32: animation playback speed. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].f32: translation distance along the x-axis, in vp.\\n\n value[1].f32: translation distance along the y-axis, in vp.\\n\n value[2].f32: translation distance along the z-axis, in vp.\\n\n value[3].i32: animation duration, in milliseconds. \\n\n value[4].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n \\n\n value[5].i32: animation delay duration, in milliseconds. \\n\n value[6].i32: number of times that the animation is played. \\n\n value[7].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n value[8].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSLATE_TRANSITION: ArkUI_NodeAttributeType = 37;
#[doc = " @brief Defines the slide-in and slide-out of the component from the screen edge during transition.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_TransitionEdge}. \\n\n .value[1].i32: animation duration, in milliseconds.\\n\n .value[2].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n\n .value[3]?.i32: animation delay duration, in milliseconds.\\n\n .value[4]?.i32: number of times that the animation is played.\\n\n .value[5]?.i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}.\\n\n .value[6]?.f32: animation playback speed.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_TransitionEdge}. \\n\n .value[1].i32: animation duration, in milliseconds.\\n\n .value[2].i32: animation curve type. The value is an enum of {@link ArkUI_AnimationCurve}.\\n\n .value[3].i32: animation delay duration, in milliseconds. \\n\n .value[4].i32: number of times that the animation is played. \\n\n .value[5].i32: animation playback mode. The value is an enum of {@link ArkUI_AnimationPlayMode}. \\n\n .value[6].f32: animation playback speed. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MOVE_TRANSITION: ArkUI_NodeAttributeType = 38;
#[doc = " @brief Defines the focus attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_FOCUSABLE: ArkUI_NodeAttributeType = 39;
#[doc = " @brief Defines the default focus attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_DEFAULT_FOCUS: ArkUI_NodeAttributeType = 40;
#[doc = " @brief Defines the touch target attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .data[0].f32: X coordinate of the touch point relative to the upper left corner of the component, in vp. \\n\n .data[1].f32: Y coordinate of the touch point relative to the upper left corner of the component, in vp. \\n\n .data[2].f32: width of the touch target, in %. \\n\n .data[3].f32: height of the touch target, in %. \\n\n .data[4...].f32: Multiple touch targets can be set. The sequence of the parameters is the same as the preceding.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .data[0].f32: X coordinate of the touch point relative to the upper left corner of the component, in vp. \\n\n .data[1].f32: Y coordinate of the touch point relative to the upper left corner of the component, in vp. \\n\n .data[2].f32: width of the touch target, in %. \\n\n .data[3].f32: height of the touch target, in %. \\n\n .data[4...].f32: Multiple touch targets can be set. The sequence of the parameters is the same as the preceding.\n"]
pub const ArkUI_NodeAttributeType_NODE_RESPONSE_REGION: ArkUI_NodeAttributeType = 41;
#[doc = " @brief Defines the overlay attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: mask text.\\n\n .value[0]?.i32: position of the overlay relative to the component. Optional.\n The parameter type is {@link ArkUI_Alignment}.\n The default value is <b>ARKUI_ALIGNMENT_TOP_START.</b> \\n\n .value[1]?.f32: offset of the overlay relative to the upper left corner of itself on the x-axis, in vp. Optional. \\n\n .value[2]?.f32: offset of the overlay relative to the upper left corner of itself on the y-axis, in vp. Optional.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: mask text.\\n\n .value[0].i32: position of the overlay relative to the component.\n The parameter type is {@link ArkUI_Alignment}.\n The default value is <b>ARKUI_ALIGNMENT_TOP_START.</b> \\n\n .value[1].f32: offset of the overlay relative to the upper left corner of itself on the x-axis, in vp. \\n\n .value[2].f32: offset of the overlay relative to the upper left corner of itself on the y-axis, in vp.\n"]
pub const ArkUI_NodeAttributeType_NODE_OVERLAY: ArkUI_NodeAttributeType = 42;
#[doc = " @brief Defines the sweep gradient effect.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: X coordinate of the sweep gradient center relative to the upper left corner of the component.\\n\n .value[1]?.f32: Y coordinate of the sweep gradient center relative to the upper left corner of the component.\\n\n .value[2]?.f32: start point of the sweep gradient. The default value is <b>0</b>. \\n\n .value[3]?.f32: end point of the sweep gradient. The default value is <b>0</b>. \\n\n .value[4]?.f32: rotation angle of the sweep gradient. The default value is <b>0</b>. \\n\n .value[5]?.i32: whether the colors are repeated. The value <b>1</b> means that the colors are repeated,\n and <b>0</b> means the opposite.\\n\n .object: array of color stops, each of which consists of a color and its stop position. Invalid colors are\n automatically skipped.\\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the sweep gradient center relative to the upper left corner of the component. \\n\n .value[1].f32: Y coordinate of the sweep gradient center relative to the upper left corner of the component. \\n\n .value[2].f32: start point of the sweep gradient. The default value is <b>0</b>. \\n\n .value[3].f32: end point of the sweep gradient. The default value is <b>0</b>. \\n\n .value[4].f32: rotation angle of the sweep gradient. The default value is <b>0</b>. \\n\n .value[5].i32: whether the colors are repeated. The value <b>1</b> means that the colors are repeated,\n and <b>0</b> means the opposite.\\n\n .object: array of color stops, each of which consists of a color and its stop position. Invalid colors are\n automatically skipped.\\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWEEP_GRADIENT: ArkUI_NodeAttributeType = 43;
#[doc = " @brief Defines the radial gradient effect.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0]?.f32: X coordinate of the radial gradient center relative to the upper left corner of the component. \\n\n .value[1]?.f32: Y coordinate of the radial gradient center relative to the upper left corner of the component. \\n\n .value[2]?.f32: radius of the radial gradient. The default value is <b>0</b>. \\n\n .value[3]?.i32: whether the colors are repeated. The value <b>1</b> means that the colors are repeated,\n and <b>0</b> means the opposite. \\n\n .object: array of color stops, each of which consists of a color and its stop position. Invalid colors are\n automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the radial gradient center relative to the upper left corner of the component. \\n\n .value[1].f32: Y coordinate of the radial gradient center relative to the upper left corner of the component. \\n\n .value[2].f32: radius of the radial gradient. The default value is <b>0</b>. \\n\n .value[3].i32: whether the colors are repeated. The value <b>1</b> means that the colors are repeated,\n and <b>0</b> means the opposite.\\n\n .object: array of color stops, each of which consists of a color and its stop position. Invalid colors are\n automatically skipped. \\n\n colors: colors of the color stops. \\n\n stops: stop positions of the color stops. \\n\n size: number of colors. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RADIAL_GRADIENT: ArkUI_NodeAttributeType = 44;
#[doc = " @brief Adds a mask of the specified shape to the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute, which supports five types of\n shapes:\\n\n 1. Rectangle:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_RECTANGLE</b> for the rectangle shape.\\n\n .value[4].f32: width of the rectangle.\\n\n .value[5].f32: height of the rectangle.\\n\n .value[6].f32: width of the rounded corner of the rectangle.\\n\n .value[7].f32: height of the rounded corner of the rectangle.\\n\n .value[8]?.f32: radius of the top left corner of the rectangular shape.\\n\n .value[9]?.f32: radius of the bottom left corner of the rectangular shape.\\n\n .value[10]?.f32: radius of the top right corner of the rectangular shape.\\n\n .value[11]?.f32: radius of the bottom right corner of the rectangular shape.\\n\n 2. Circle:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[4].f32: width of the circle.\\n\n .value[5].f32: height of the circle.\\n\n 3. Ellipse:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[4].f32: width of the ellipse.\\n\n .value[5].f32: height of the ellipse.\\n\n 4. Path:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_PATH</b> for the path shape.\\n\n .value[4].f32: width of the path.\\n\n .value[5].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n 5. Progress:\\n\n .value[0].i32: mask type. The parameter type is {@link ArkUI_MaskType}.\n The value is <b>ARKUI_MASK_TYPE_PROGRESS</b> for the progress shape.\\n\n .value[1].f32: current value of the progress indicator.\\n\n .value[2].f32: maximum value of the progress indicator.\\n\n .value[3].u32: color of the progress indicator, in 0xARGB format.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}, which supports five types of shapes:\\n\n 1. Rectangle:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type.\\n\n .value[4].f32: width of the rectangle.\\n\n .value[5].f32: height of the rectangle.\\n\n .value[6].f32: width of the rounded corner of the rectangle.\\n\n .value[7].f32: height of the rounded corner of the rectangle.\\n\n .value[8].f32: radius of the top left corner of the rectangular shape.\\n\n .value[9].f32: radius of the bottom left corner of the rectangular shape.\\n\n .value[10].f32: radius of the top right corner of the rectangular shape.\\n\n .value[11].f32: radius of the bottom right corner of the rectangular shape.\\n\n 2. Circle:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type.\\n\n .value[4].f32: width of the circle.\\n\n .value[5].f32: height of the circle.\\n\n 3. Ellipse:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type.\\n\n .value[4].f32: width of the ellipse.\\n\n .value[5].f32: height of the ellipse.\\n\n 4. Path:\\n\n .value[0].u32 fill color, in 0xARGB format. \\n\n .value[1].u32: stroke color, in 0xARGB format. \\n\n .value[2].f32: stroke width, in vp. \\n\n .value[3].i32: mask type.\\n\n .value[4].f32: width of the path.\\n\n .value[5].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n 5. Progress:\\n\n .value[0].i32: mask type.\\n\n .value[1].f32: current value of the progress indicator.\\n\n .value[2].f32: maximum value of the progress indicator.\\n\n .value[3].u32: color of the progress indicator.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MASK: ArkUI_NodeAttributeType = 45;
#[doc = " @brief Blends the component's background with the content of the component's child node.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: blend mode. The parameter type is {@link ArkUI_BlendMode}. The default value is\n <b>ARKUI_BLEND_MODE_NONE</b>. \\n\n .value[1].?i32: how the specified blend mode is applied. The parameter type is {@link ArkUI_BlendApplyType}.\n The default value is <b>ARKUI_BLEND_APPLY_TYPE_FAST</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: blend mode. The parameter type is {@link ArkUI_BlendMode}. The default value is\n <b>ARKUI_BLEND_MODE_NONE</b>. \\n\n .value[1].i32: how the specified blend mode is applied. The parameter type is {@link ArkUI_BlendApplyType}.\n The default value is <b>ARKUI_BLEND_APPLY_TYPE_FAST</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BLEND_MODE: ArkUI_NodeAttributeType = 46;
#[doc = " @brief Sets the direction of the main axis.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: direction of the main axis.\\n\n The parameter type is {@link ArkUI_Direction}. The default value is <b>ARKUI_DIRECTION_AUTO</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: direction of the main axis.\\n\n The parameter type is {@link ArkUI_Direction}. The default value is <b>ARKUI_DIRECTION_AUTO</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DIRECTION: ArkUI_NodeAttributeType = 47;
#[doc = " @brief Defines the size constraints.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum width, in vp.\\n\n .value[1].f32: maximum width, in vp.\\n\n .value[2].f32: minimum height, in vp.\\n\n .value[3].f32: maximum height, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum width, in vp.\\n\n .value[1].f32: maximum width, in vp.\\n\n .value[2].f32: minimum height, in vp.\\n\n .value[3].f32: maximum height, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CONSTRAINT_SIZE: ArkUI_NodeAttributeType = 48;
#[doc = " @brief Defines the grayscale effect.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: grayscale conversion ratio. The value ranges from 0 to 1.\n For example, 0.5 indicates a 50% grayscale conversion ratio. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: grayscale conversion ratio. The value ranges from 0 to 1.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRAY_SCALE: ArkUI_NodeAttributeType = 49;
#[doc = " @brief Inverts the image.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: image inversion ratio. The value ranges from 0 to 1.\n For example, 0.5 indicates a 50% image inversion ratio.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: image inversion ratio. The value ranges from 0 to 1.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_INVERT: ArkUI_NodeAttributeType = 50;
#[doc = " @brief Defines the sepia conversion ratio.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: sepia conversion ratio. The value ranges from 0 to 1.\n For example, 0.5 indicates that a 50% sepia conversion ratio.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: sepia conversion ratio. The value ranges from 0 to 1.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SEPIA: ArkUI_NodeAttributeType = 51;
#[doc = " @brief Defines the contrast attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: contrast. If the value is <b>1</b>, the source image is displayed.\n A larger value indicates a higher contrast. Value range: [0, 10).\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: contrast. Value range: [0, 10).\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CONTRAST: ArkUI_NodeAttributeType = 52;
#[doc = " @brief Defines the foreground color attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n 2: .value[0].i32: color enum {@link ArkUI_ColoringStrategy}.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FOREGROUND_COLOR: ArkUI_NodeAttributeType = 53;
#[doc = " @brief Defines the offset of the component's child relative to the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32 : offset along the x-axis, in vp. \\n\n .value[1].f32 : offset along the y-axis, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32 : offset along the x-axis, in vp. \\n\n .value[1].f32 : offset along the y-axis, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OFFSET: ArkUI_NodeAttributeType = 54;
#[doc = " @brief Sets the anchor for locating the component's child.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: X coordinate of the anchor, in vp.\\n\n .value[1].f32: Y coordinate of the anchor, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: X coordinate of the anchor, in vp.\\n\n .value[1].f32: Y coordinate of the anchor, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MARK_ANCHOR: ArkUI_NodeAttributeType = 55;
#[doc = " @brief Defines the position of the background image in the component, that is, the coordinates relative to\n the upper left corner of the component. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: position along the x-axis, in px. \\n\n .value[1].f32: position along the y-axis, in px. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: position along the x-axis, in px. \\n\n .value[1].f32: position along the y-axis, in px. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BACKGROUND_IMAGE_POSITION: ArkUI_NodeAttributeType = 56;
#[doc = " @brief Sets the alignment rules in the relative container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: Use the {@link ArkUI_AlignmentRuleOption} object as the component’s alignment rule. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: Use the {@link ArkUI_AlignmentRuleOption} object as the component’s alignment rule. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ALIGN_RULES: ArkUI_NodeAttributeType = 57;
#[doc = " @brief Sets the alignment mode of the child components along the cross axis of the parent container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode of the child components along the cross axis of the parent container.\\n\n The parameter type is {@link ArkUI_ItemAlignment}. The default value is <b>ARKUI_ITEM_ALIGNMENT_AUTO</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode of the child components along the cross axis of the parent container.\\n\n The parameter type is {@link ArkUI_ItemAlignment}. The default value is <b>ARKUI_ITEM_ALIGNMENT_AUTO</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ALIGN_SELF: ArkUI_NodeAttributeType = 58;
#[doc = " @brief Sets the percentage of the parent container's remaining space that is allocated to the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: percentage of the parent container's remaining space that is allocated to the component. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: percentage of the parent container's remaining space that is allocated to the component. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FLEX_GROW: ArkUI_NodeAttributeType = 59;
#[doc = " @brief Sets the percentage of the parent container's shrink size that is allocated to the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: percentage of the parent container's shrink size that is allocated to the component. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: percentage of the parent container's shrink size that is allocated to the component. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FLEX_SHRINK: ArkUI_NodeAttributeType = 60;
#[doc = " @brief Sets the base size of the component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: percentage of the parent container's remaining space that is allocated to the component. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: percentage of the parent container's remaining space that is allocated to the component. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FLEX_BASIS: ArkUI_NodeAttributeType = 61;
#[doc = " @brief Sets the accessibility group. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: Accessibility group. The value <b>1</b> means that the component and all its child components\n form an entire selectable component.\n In this case, the accessibility service will no longer be available for the content of its child components.\n The value is <b>1</b> or <b>0</b>.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: Accessibility group. The value <b>1</b> means that the component and all its child components\n form an entire selectable component.\n In this case, the accessibility service will no longer be available for the content of its child components.\n The value is <b>1</b> or <b>0</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_GROUP: ArkUI_NodeAttributeType = 62;
#[doc = " @brief Sets the accessibility text. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: accessibility text.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: accessibility text.\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_TEXT: ArkUI_NodeAttributeType = 63;
#[doc = " @brief Sets the accessibility service model. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: accessibility service model. The parameter type is {@link ArkUI_AccessibilityMode}.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: accessibility service model. The parameter type is {@link ArkUI_AccessibilityMode}.\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_MODE: ArkUI_NodeAttributeType = 64;
#[doc = " @brief Sets the accessibility description.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: accessibility description.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: accessibility description.\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_DESCRIPTION: ArkUI_NodeAttributeType = 65;
#[doc = " @brief Defines the focused state. This attribute can be set and obtained as required through APIs.\n @note Setting the parameter to <b>0</b> shifts focus from the currently focused component on the current level\n of the page to the root container.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_FOCUS_STATUS: ArkUI_NodeAttributeType = 66;
#[doc = " @brief Defines the aspect ratio attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: aspect ratio of the component, in width/height format. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: aspect ratio of the component, in width/height format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ASPECT_RATIO: ArkUI_NodeAttributeType = 67;
#[doc = " @brief Defines the weight of the component within its row, column, or flex container for proportional\n distribution of available space within the container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: weight of the component along the main axis. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: weight of the component along the main axis. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LAYOUT_WEIGHT: ArkUI_NodeAttributeType = 68;
#[doc = " @brief Sets the display priority for the component in the row, column, or flex  (single-line) container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: display priority of the component in the container. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: display priority of the component in the container. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DISPLAY_PRIORITY: ArkUI_NodeAttributeType = 69;
#[doc = " @brief Sets the thickness of an element's outline.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: thickness of the left outline. \\n\n .value[1].f32: thickness of the top outline. \\n\n .value[2].f32: thickness of the right outline. \\n\n .value[3].f32: thickness of the bottom outline. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: thickness of the left outline. \\n\n .value[1].f32: thickness of the top outline. \\n\n .value[2].f32: thickness of the right outline. \\n\n .value[3].f32: thickness of the bottom outline. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OUTLINE_WIDTH: ArkUI_NodeAttributeType = 70;
#[doc = " @brief Defines the width attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width, in percentage.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width, in percentage.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WIDTH_PERCENT: ArkUI_NodeAttributeType = 71;
#[doc = " @brief Defines the height attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: height, in percentage.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: height, in percentage.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_HEIGHT_PERCENT: ArkUI_NodeAttributeType = 72;
#[doc = " @brief Defines the padding attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: Specify the same padding for the four directions. \\n\n .value[0].f32: padding, in percentage.\\n\n 2: Specify different paddings for different directions. \\n\n .value[0].f32: top padding, in percentage.\\n\n .value[1].f32: right padding, in percentage.\\n\n .value[2].f32: bottom padding, in percentage.\\n\n .value[3].f32: left padding, in percentage.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: top padding, in percentage.\\n\n .value[1].f32: right padding, in percentage.\\n\n .value[2].f32: bottom padding, in percentage.\\n\n .value[3].f32: left padding, in percentage.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PADDING_PERCENT: ArkUI_NodeAttributeType = 73;
#[doc = " @brief Defines the margin attribute, which can be set, reset, and obtained as required through APIs.\n\n There are two formats of {@link ArkUI_AttributeItem} for setting the attribute value:\\n\n 1: Specify the same margin for the four directions. \\n\n .value[0].f32: margin, in percentage.\\n\n 2: Specify different margins for different directions. \\n\n .value[0].f32: top margin, in percentage.\\n\n .value[1].f32: right margin, in percentage.\\n\n .value[2].f32: bottom margin, in percentage.\\n\n .value[3].f32: left margin, in percentage.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: top margin, in percentage.\\n\n .value[1].f32: right margin, in percentage.\\n\n .value[2].f32: bottom margin, in percentage.\\n\n .value[3].f32: left margin, in percentage.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_MARGIN_PERCENT: ArkUI_NodeAttributeType = 74;
#[doc = " @brief The implicit shared element transition within the component supports attribute setting,\n attribute reset, and attribute acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .value[0]?.i32: The parameter type is 1 or 0. 2 components that share element bindings,\n Whether to continue to participate in the shared element animation when the appearance element is not deleted,\n the default is false, and the original position will remain unchanged if not involved. \\n\n .string is used to set the binding relationship. Set the id to \"\" to\n clear the binding relationship to avoid participating in sharing behavior. \\n\n The id can be changed and the binding relationship re-established.\n The same ID can only be bound to two components and they are in/out roles of different types.\n Multiple components cannot be bound to the same id. \\n\n\\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .value[0].i32: The parameter type is 1 or 0. 2 components that share element bindings,\n Whether to continue to participate in the shared element animation when the appearance element is not deleted,\n the default is not false, if not involved, the original position will remain unchanged. \\n\n .string is used to set the binding relationship. Set the id to \"\" to\n clear the binding relationship to avoid participating in sharing behavior. \\n\n The id can be changed and the binding relationship re-established.\n The same ID can only be bound to two components and they are in/out roles of different types.\n Multiple components cannot be bound to the same id. \\n"]
pub const ArkUI_NodeAttributeType_NODE_GEOMETRY_TRANSITION: ArkUI_NodeAttributeType = 75;
#[doc = " @brief specifies the parameters of the chain formed by this component as the chain head,\n and supports attribute setting, attribute reset and attribute acquisition interfaces.\n\n Only takes effect when the parent container is RelativeContainer\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .value[0].i32: The direction of the chain. Enum {@link ArkUI_Axis}. \\n\n .value[1].i32: Chain style. Enum {@link ArkUI_RelativeLayoutChainStyle}. \\n\n\\n\n .value[0].i32: The direction of the chain. Enum {@link ArkUI_Axis}. \\n\n .value[1].i32: Chain style. Enum {@link ArkUI_RelativeLayoutChainStyle}. \\n"]
pub const ArkUI_NodeAttributeType_NODE_RELATIVE_LAYOUT_CHAIN_MODE: ArkUI_NodeAttributeType = 76;
#[doc = " @brief Set the component content filling method in the process of width and height animation,\n support property setting, property reset, property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32 Content filling mode {@link ArkUI_RenderFit}.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32 Content filling mode {@link ArkUI_RenderFit}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RENDER_FIT: ArkUI_NodeAttributeType = 77;
#[doc = " @brief External stroke color properties, support property setting,\n property reset and property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].u32: Set the border color of the four sides uniformly, using 0xargb, such as 0xFFFF11FF. \\n\n 2: .value[0].u32: Set the top border color, represented by 0xargb, such as 0xFFFF11FF. \\n\n .value[1].u32: Set the right border color, represented by 0xargb, such as 0xFFFF11FF. \\n\n .value[2].u32: Set the lower side box color, denoted by 0xargb, such as 0xFFFF11FF. \\n\n .value[3].u32: Set the left border color, denoted by 0xargb, such as 0xFFFF11FF. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: Set the top border color, represented by 0xargb, such as 0xFFFF11FF. \\n\n .value[1].u32: Set the right border color, represented by 0xargb, such as 0xFFFF11FF. \\n\n .value[2].u32: Set the lower side box color, denoted by 0xargb, such as 0xFFFF11FF. \\n\n .value[3].u32: Set the left border color, denoted by 0xargb, such as 0xFFFF11FF. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_OUTLINE_COLOR: ArkUI_NodeAttributeType = 78;
#[doc = " @brief Set the height and width dimensions, support property setting,\n property reset and property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: Width value, unit is vp;\\n\n .value[1].f32: Height value, unit is vp;\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: Width value, unit is vp;\\n\n .value[1].f32: Height value, unit is vp;\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SIZE: ArkUI_NodeAttributeType = 79;
#[doc = " @brief Set whether the current component and child component are\n rendered off the screen first and then fused with the parent control,\n supporting property setting, property reset and property acquisition.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_RENDER_GROUP: ArkUI_NodeAttributeType = 80;
#[doc = " @brief Add color overlay effect to components, support property setting,\n property reset and property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: The color of the overlay is represented by 0xargb, such as 0xFFFF11FF. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: The color of the overlay is represented by 0xargb, such as 0xFFFF11FF. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_COLOR_BLEND: ArkUI_NodeAttributeType = 81;
#[doc = " @brief Provide content ambiguity capability for the current component,\n support property setting, property reset, property acquisition interface.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32 Represents the content blurring style, and uses the {@link ArkUI_BlurStyle} enumeration value.\\n\n .value[1]?.i32 Represents the dark and light mode used by the content blur effect,\\n\n with the {@link ArkUI_ThemeColorMode} enumeration value.\\n\n .value[2]?.i32 The color extraction mode used to represent the content blur effect takes\\n\n the {@link ArkUI_AdaptiveColor} enumeration value.\\n\n .value[3]?.f32: blur degree. The value range is [0.0, 1.0]. \\n\n .value[4]?.f32 It is a gray-level fuzzy parameter. The value range is [0,127].\\n\n .value[5]?.f32 It is a gray-level fuzzy parameter. The value range is [0,127].\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32 Represents the content blurring style, and uses the {@link ArkUI_BlurStyle} enumeration value.\\n\n .value[1].i32 Represents the dark and light mode used by the content blur effect,\\n\n with the {@link ArkUI_ThemeColorMode} enumeration value.\\n\n .value[2].i32 The color extraction mode used to represent the content blur effect takes\\n\n the {@link ArkUI_AdaptiveColor} enumeration value.\\n\n .value[3].f32: blur degree. The value range is [0.0, 1.0]. \\n\n .value[4].f32 It is a gray-level fuzzy parameter. The value range is [0,127].\\n\n .value[5].f32 It is a gray-level fuzzy parameter. The value range is [0,127].\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FOREGROUND_BLUR_STYLE: ArkUI_NodeAttributeType = 82;
#[doc = " @brief Defines layout rect attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: x position of the component.\n .value[1].i32: y position of the component.\n .value[2].i32: width of the component.\n .value[3].i32: height of the component.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: x position of the component.\n .value[1].i32: y position of the component.\n .value[2].i32: width of the component.\n .value[3].i32: height of the component.\n"]
pub const ArkUI_NodeAttributeType_NODE_LAYOUT_RECT: ArkUI_NodeAttributeType = 83;
#[doc = " @brief Whether the current component supports click-to-focus capability,\n which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_FOCUS_ON_TOUCH: ArkUI_NodeAttributeType = 84;
#[doc = " @brief Defines the border width attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].f32: width of the four borders, in percentage. \\n\n 2: .value[0].f32: width of the top border, in percentage. \\n\n .value[1].f32: width of the right border, in percentage. \\n\n .value[2].f32: width of the bottom border, in percentage. \\n\n .value[3].f32: width of the left border, in percentage. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the top border, in percentage. \\n\n .value[1].f32: width of the right border, in percentage. \\n\n .value[2].f32: width of the bottom border, in percentage. \\n\n .value[3].f32: width of the left border, in percentage. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_WIDTH_PERCENT: ArkUI_NodeAttributeType = 85;
#[doc = " @brief Defines the border corner radius attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n 1: .value[0].f32: radius of the four corners, in percentage. \\n\n 2: .value[0].f32: radius of the upper left corner, in percentage. \\n\n .value[1].f32: radius of the upper right corner, in percentage. \\n\n .value[2].f32: radius of the lower left corner, in percentage. \\n\n .value[3].f32: radius of the lower right corner, in percentage. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: radius of the upper left corner, in percentage. \\n\n .value[1].f32: radius of the upper right corner, in percentage. \\n\n .value[2].f32: radius of the lower left corner, in percentage. \\n\n .value[3].f32: radius of the lower right corner, in percentage. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BORDER_RADIUS_PERCENT: ArkUI_NodeAttributeType = 86;
#[doc = " @brief Accessible ID, which can be obtained as required through APIs.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32：Accessible ID。\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_ID: ArkUI_NodeAttributeType = 87;
#[doc = " @brief Define accessible actions, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32：accessible action types，and uses the {@link ArkUI_AccessibilityActionType} enumeration value.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32：accessible action types，and uses the {@link ArkUI_AccessibilityActionType} enumeration value.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_ACTIONS: ArkUI_NodeAttributeType = 88;
#[doc = " @brief Define accessible role, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32：accessible role type，and uses the {@link ArkUI_NodeType} enumeration value.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32：accessible role type，and uses the {@link ArkUI_NodeType} enumeration value.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_ROLE: ArkUI_NodeAttributeType = 89;
#[doc = " @brief Define accessible state, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object：the parameter type is {@link ArkUI_AccessibilityState}.\\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object：the parameter type is {@link ArkUI_AccessibilityState}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_STATE: ArkUI_NodeAttributeType = 90;
#[doc = " @brief Define accessible value, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object：the parameter type is {@link ArkUI_AccessibilityValue}.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object：the parameter type is {@link ArkUI_AccessibilityValue}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ACCESSIBILITY_VALUE: ArkUI_NodeAttributeType = 91;
#[doc = " @brief defines control components to extend their security zones,\n supporting property setting, property reset, and property fetching.\n\n Attribute setting method {@link ArkUI_AttributeItem} Parameter format: \\n\n .value[0]? .u32: Set of extended security zone enumerated values {@link ArkUI_SafeAreaType},\n For example, ARKUI_SAFE_AREA_TYPE_SYSTEM | ARKUI_SAFE_AREA_TYPE_CUTOUT; \\n\n .value[1]? .u32: set of directional enum values for extended security zones {@link ArkUI_SafeAreaEdge}; \\n\n For example: ARKUI_SAFE_AREA_EDGE_TOP | ARKUI_SAFE_AREA_EDGE_BOTTOM; \\n\n \\n\n Attribute fetch method return value {@link ArkUI_AttributeItem} format: \\n\n.value[0].u32: extends the security zone. \\n. \\n\n.value[1].u32: indicates the direction to extend the security zone. \\n. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_EXPAND_SAFE_AREA: ArkUI_NodeAttributeType = 92;
#[doc = " @brief Defines the visible area ratio (visible area/total area of the component) threshold for invoking the\n visible area change event of the component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[...].f32: threshold array. The value range is 0 to 1.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[...].f32: threshold array. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_VISIBLE_AREA_CHANGE_RATIO: ArkUI_NodeAttributeType = 93;
#[doc = " @brief Sets the transition effect when the component is inserted or deleted.\n This attribute can be set, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: transition effect. The parameter type is {@link ArkUI_TransitionEffect}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: transition effect. The parameter type is {@link ArkUI_TransitionEffect}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TRANSITION: ArkUI_NodeAttributeType = 94;
#[doc = " @brief Defines the component ID.\n This attribute can be obtained through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for obtaining the attribute:\\n\n .value[0].i32: component ID. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_UNIQUE_ID: ArkUI_NodeAttributeType = 95;
#[doc = " @brief Set the current component system focus box style.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].f32: The distance between the focus box and the edge of the component. \\n\n Positive numbers represent the outer side, negative numbers represent the inner side. \\n\n Percentage is not supported. \\n\n .value[1].f32: Focus box width. Negative numbers and percentages are not supported. \\n\n .value[2].u32: Focus box color. \\n\n \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FOCUS_BOX: ArkUI_NodeAttributeType = 96;
#[doc = " @brief Defines the moving distance limit for the component-bound tap gesture.\n This attribute can be set as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: allowed moving distance of a finger, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CLICK_DISTANCE: ArkUI_NodeAttributeType = 97;
#[doc = " @brief Sets whether the focus can be placed on this component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the focus can be placed on the current component. The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the focus can be placed on the current component. The parameter type is 1 or 0.\n\n @since 14"]
pub const ArkUI_NodeAttributeType_NODE_TAB_STOP: ArkUI_NodeAttributeType = 98;
#[doc = " @brief Defines the backdrop blur attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32：backdrop blur radius, in px. The value range is [0, +∞).\\n\n .value[1]?.f32：grayscale blur settings that control the brightness of the black color.\\n\n The value range is [0, 127].\\n\n .value[2]?.f32：grayscale blur settings that control the darkness of the white color.\\n\n The value range is [0, 127].\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32：backdrop blur radius, in px. The value range is [0, +∞).\\n\n .value[1].f32：grayscale blur settings that control the brightness of the black color.\\n\n The value range is [0, 127].\\n\n .value[2].f32：grayscale blur settings that control the darkness of the white color.\\n\n The value range is [0, 127].\\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_BACKDROP_BLUR: ArkUI_NodeAttributeType = 99;
#[doc = " @brief Defines the text content attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: text content.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: text content.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_CONTENT: ArkUI_NodeAttributeType = 1000;
#[doc = " @brief Defines the font color attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: font color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: font color value, in 0xARGB format.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_COLOR: ArkUI_NodeAttributeType = 1001;
#[doc = " @brief Defines the font size attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: font size, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: font size, in fp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_SIZE: ArkUI_NodeAttributeType = 1002;
#[doc = " @brief Defines the font style attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: font style {@link ArkUI_FontStyle}. The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: font style {@link ArkUI_FontStyle}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_STYLE: ArkUI_NodeAttributeType = 1003;
#[doc = " @brief Defines the font weight attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: font weight {@link ArkUI_FontWeight}. The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: font weight {@link ArkUI_FontWeight}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_WEIGHT: ArkUI_NodeAttributeType = 1004;
#[doc = " @brief Defines the text line height attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: line height, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: line height, in fp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LINE_HEIGHT: ArkUI_NodeAttributeType = 1005;
#[doc = " @brief Defines the text decoration style and color.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text decoration type {@link ArkUI_TextDecorationType}.\n The default value is <b>ARKUI_TEXT_DECORATION_TYPE_NONE</b>.\\n\n .value[1]?.u32: text decoration color, in 0xARGB format. For example, 0xFFFF0000 indicates red. Optional.\\n\n .value[2]?.i32: text decoration style {@link ArkUI_TextDecorationStyle}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text decoration type {@link ArkUI_TextDecorationType}.\\n\n .value[1].u32: text decoration color, in 0xARGB format. \\n\n .value[2].i32: text decoration style {@link ArkUI_TextDecorationStyle}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_DECORATION: ArkUI_NodeAttributeType = 1006;
#[doc = " @brief Defines the text case attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text case.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text case.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_CASE: ArkUI_NodeAttributeType = 1007;
#[doc = " @brief Defines the letter spacing attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: letter spacing, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: letter spacing, in fp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LETTER_SPACING: ArkUI_NodeAttributeType = 1008;
#[doc = " @brief Sets the maximum number of lines in the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: maximum number of lines in the text.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: maximum number of lines in the text.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_MAX_LINES: ArkUI_NodeAttributeType = 1009;
#[doc = " @brief Horizontal alignment mode of the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: horizontal alignment mode of the text. The value is an enum of {@link ArkUI_TextAlignment}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: horizontal alignment mode of the text. The value is an enum of {@link ArkUI_TextAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_ALIGN: ArkUI_NodeAttributeType = 1010;
#[doc = " @brief Defines the text overflow attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: display mode when the text is too long. {@ArkUI_TextOverflow}\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: display mode when the text is too long. {@ArkUI_TextOverflow}\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_OVERFLOW: ArkUI_NodeAttributeType = 1011;
#[doc = " @brief Defines the font family attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: fonts, separated by commas (,).\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: fonts, separated by commas (,).\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_FAMILY: ArkUI_NodeAttributeType = 1012;
#[doc = " @brief Defines the copy option attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: copy option {@link ArkUI_CopyOptions}. The default value is <b>ARKUI_COPY_OPTIONS_NONE</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: copy option {@link ArkUI_CopyOptions. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_COPY_OPTION: ArkUI_NodeAttributeType = 1013;
#[doc = " @brief Defines the text baseline offset attribute\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: baseline offset, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: baseline offset, in fp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_BASELINE_OFFSET: ArkUI_NodeAttributeType = 1014;
#[doc = " @brief Defines the text shadow attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: blur radius of the shadow, in vp.\\n\n .value[1].i32: shadow type {@link ArkUI_ShadowType}. The default value is <b>ARKUI_SHADOW_TYPE_COLOR</b>.\\n\n .value[2].u32: shadow color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n .value[3].f32: offset of the shadow along the x-axis, in vp.\\n\n .value[4].f32: offset of the shadow along the y-axis, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: blur radius of the shadow, in vp.\\n\n .value[1].i32: shadow type {@link ArkUI_ShadowType}.\\n\n .value[2].u32: shadow color, in 0xARGB format.\\n\n .value[3].f32: offset of the shadow along the x-axis, in vp.\\n\n .value[4].f32: offset of the shadow along the y-axis, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_TEXT_SHADOW: ArkUI_NodeAttributeType = 1015;
#[doc = " @brief Defines the minimum font size attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum font size, in fp.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum font size, in fp.\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_MIN_FONT_SIZE: ArkUI_NodeAttributeType = 1016;
#[doc = " @brief Defines the maximum font size attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: maximum font size, in fp.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: maximum font size, in fp.\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_MAX_FONT_SIZE: ArkUI_NodeAttributeType = 1017;
#[doc = " @brief Defines the text style attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string?: font family. Optional. Use commas (,) to separate multiple fonts. \\n\n .value[0].f32: font size, in fp. \\n\n .value[1]?.i32: font weight. Optional. The parameter type is {@link ArkUI_FontWeight}.\n The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>. \\n\n .value[2]?.i32: font style. Optional. The parameter type is {@link ArkUI_FontStyle}.\n The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: font family. Use commas (,) to separate multiple fonts. \\n\n .value[0].f32: font size, in fp. \\n\n .value[1].i32: font weight. The parameter type is {@link ArkUI_FontWeight}.\n The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>. \\n\n .value[2].i32: font style. The parameter type is {@link ArkUI_FontStyle}.\n The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_FONT: ArkUI_NodeAttributeType = 1018;
#[doc = " @brief Defines how the adaptive height is determined for the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: how the adaptive height is determined for the text.\n The parameter type is {@link ArkUI_TextHeightAdaptivePolicy}.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: how the adaptive height is determined for the text.\n The parameter type is {@link ArkUI_TextHeightAdaptivePolicy}\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_HEIGHT_ADAPTIVE_POLICY: ArkUI_NodeAttributeType = 1019;
#[doc = " @brief Defines the indentation of the first line.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: indentation of the first line. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: indentation of the first line. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INDENT: ArkUI_NodeAttributeType = 1020;
#[doc = " @brief Defines the line break rule. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_WordBreak}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_WordBreak}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_WORD_BREAK: ArkUI_NodeAttributeType = 1021;
#[doc = " @brief Defines the ellipsis position. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_EllipsisMode}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_EllipsisMode}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_ELLIPSIS_MODE: ArkUI_NodeAttributeType = 1022;
#[doc = " @brief Defines the text line spacing attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: line spacing, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: line spacing, in fp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_LINE_SPACING: ArkUI_NodeAttributeType = 1023;
#[doc = " @brief  Set the text feature effect and the NODE_FONT_FEATURE attribute,\n NODE_FONT_FEATURE is the advanced typesetting capability of OpenType\n Features such as ligatures and equal-width digits are generally used in customized fonts. \\n\n The capabilities need to be supported by the fonts, \\n\n Interfaces for setting, resetting, and obtaining attributes are supported. \\n\n Attribute setting method parameter {@Link ArkUI_AttributeItem} format: \\n\n .string: complies with the text feature format. The format is normal | \\n\n is in the format of [ | on | off],\\n.\n There can be multiple values separated by commas (,). \\n\n For example, the input format of a number with the same width is ss01 on. \\n\n \\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .string indicates the content of the text feature. Multiple text features are separated by commas (,). \\n"]
pub const ArkUI_NodeAttributeType_NODE_FONT_FEATURE: ArkUI_NodeAttributeType = 1024;
#[doc = " @brief Setting Enable Text Recognition.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32:Enable text recognition, default value false.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32：Enable Text Recognition\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_ENABLE_DATA_DETECTOR: ArkUI_NodeAttributeType = 1025;
#[doc = " @brief Set the text recognition configuration.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0...].i32: Array of entity types, parameter types{@link ArkUI_TextDataDetectorType}。\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0...].i32：Array of entity types, parameter types{@link ArkUI_TextDataDetectorType}。\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_ENABLE_DATA_DETECTOR_CONFIG: ArkUI_NodeAttributeType =
    1026;
#[doc = " @brief Defines the background color of the selected text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_SELECTED_BACKGROUND_COLOR: ArkUI_NodeAttributeType =
    1027;
#[doc = " @brief The text component uses a formatted string object to set text content properties,\n and supports property setting, property reset, and property acquisition interfaces.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object indicates ArkUI_StyledString formatted string data. The parameter type is {@link ArkUI_StyledString}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object indicates ArkUI_StyledString formatted string data. The parameter type is {@link ArkUI_StyledString}. \\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_CONTENT_WITH_STYLED_STRING: ArkUI_NodeAttributeType =
    1028;
#[doc = " @brief Sets whether to center text vertically in the text component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to center text vertically. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to center text vertically. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_HALF_LEADING: ArkUI_NodeAttributeType = 1029;
#[doc = " @brief Defines the font weight attribute, which can be set, reset, and obtained as required through APIs.\n The font weight specified by this API is not affected by any changes in the system font weight settings.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: font weight {@link ArkUI_FontWeight}. The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: font weight {@link ArkUI_FontWeight}.\\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_IMMUTABLE_FONT_WEIGHT: ArkUI_NodeAttributeType = 1030;
#[doc = " @brief Defines the text content attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: content of the text span. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: content of the text span. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SPAN_CONTENT: ArkUI_NodeAttributeType = 2000;
#[doc = " @brief Defines the text background style.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the text background, in 0xARGB format, for example, <b>0xFFFF0000</b> indicating red. \\n\n The second parameter indicates the rounded corners of the text background. Two setting modes are available: \\n\n 1: .value[1].f32: radius of the four corners, in vp. \\n\n 2: .value[1].f32: radius of the upper left corner, in vp. \\n\n .value[2].f32: radius of the upper right corner, in vp. \\n\n .value[3].f32: radius of the lower left corner, in vp. \\n\n .value[4].f32: radius of the lower right corner, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the text background, in 0xARGB format. \\n\n .value[1].f32: radius of the upper left corner, in vp. \\n\n .value[2].f32: radius of the upper right corner, in vp. \\n\n .value[3].f32: radius of the lower left corner, in vp. \\n\n .value[4].f32: radius of the lower right corner, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SPAN_TEXT_BACKGROUND_STYLE: ArkUI_NodeAttributeType = 2001;
#[doc = " @brief Defines the text baseline offset attribute\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: baseline offset, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: baseline offset, in fp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SPAN_BASELINE_OFFSET: ArkUI_NodeAttributeType = 2002;
#[doc = " @brief Defines the image source of the image span.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: image address of the image span.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: image address of the image span.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_SRC: ArkUI_NodeAttributeType = 3000;
#[doc = " @brief Defines the alignment mode of the image with the text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode of the image with the text.\n The value is an enum of {@link ArkUI_ImageSpanAlignment}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode of the image with the text.\n The value is an enum of {@link ArkUI_ImageSpanAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_VERTICAL_ALIGNMENT: ArkUI_NodeAttributeType =
    3001;
#[doc = " @brief Defines the placeholder image source.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_ALT: ArkUI_NodeAttributeType = 3002;
#[doc = " @brief Defines the baseline offset attribute of the <b>ImageSpan</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n A positive value means an upward offset, while a negative value means a downward offset.\n The default value is <b>0</b>, and the unit is fp. \\n\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: baseline offset, in fp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: baseline offset, in fp. \\n\n\n @since 13"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SPAN_BASELINE_OFFSET: ArkUI_NodeAttributeType = 3003;
#[doc = " @brief Defines the image source of the <Image> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: image source.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: image source.\\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_SRC: ArkUI_NodeAttributeType = 4000;
#[doc = " @brief Defines how the image is resized to fit its container.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: how the image is resized to fit its container. The value is an enum of {@link ArkUI_ObjectFit}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: how the image is resized to fit its container. The value is an enum of {@link ArkUI_ObjectFit}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_OBJECT_FIT: ArkUI_NodeAttributeType = 4001;
#[doc = " @brief Defines the interpolation effect of the image.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: interpolation effect of the image. The value is an enum of {@link ArkUI_ImageInterpolation}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: interpolation effect of the image. The value is an enum of {@link ArkUI_ImageInterpolation}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_INTERPOLATION: ArkUI_NodeAttributeType = 4002;
#[doc = " @brief Defines how the image is repeated.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: how the image is repeated. The value is an enum of {@link ArkUI_ImageRepeat}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: how the image is repeated. The value is an enum of {@link ArkUI_ImageRepeat}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_OBJECT_REPEAT: ArkUI_NodeAttributeType = 4003;
#[doc = " @brief Defines the color filter of the image.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32 to .value[19].f32: filter matrix array. \\n\n .size: 5 x 4 filter array size. \\n\n .object: the pointer to OH_Drawing_ColorFilter. Either .value or .object is set. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32 to .value[19].f32: filter matrix array. \\n\n .size: 5 x 4 filter array size. \\n\n .object: the pointer to OH_Drawing_ColorFilter. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_COLOR_FILTER: ArkUI_NodeAttributeType = 4004;
#[doc = " @brief Defines the auto resize attribute, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32 : whether to resize the image source. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32 : whether to resize the image source. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_AUTO_RESIZE: ArkUI_NodeAttributeType = 4005;
#[doc = " @brief Defines the placeholder image source.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}. Either .string or .object must be set.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: placeholder image source. \\n\n .object: The parameter type is {@link ArkUI_DrawableDescriptor}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ALT: ArkUI_NodeAttributeType = 4006;
#[doc = " @brief Defines whether the image is draggable.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the image is draggable. The value <b>true</b> means that the image is draggable. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the image is draggable. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_DRAGGABLE: ArkUI_NodeAttributeType = 4007;
#[doc = " @brief Defines the image rendering mode. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_ImageRenderMode}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_ImageRenderMode}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_RENDER_MODE: ArkUI_NodeAttributeType = 4008;
#[doc = " @brief Defines whether the image display size follows the image source size.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: wheter to follow, true means to follow.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: wheter to follow, true means to follow.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_FIT_ORIGINAL_SIZE: ArkUI_NodeAttributeType = 4009;
#[doc = " @brief Defines the fill color of the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: fill color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: fill color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_FILL_COLOR: ArkUI_NodeAttributeType = 4010;
#[doc = " @brief Sets the resizable image options.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width of the left edge. The unit is vp. \\n\n .value[1].f32: width of the top edge. The unit is vp. \\n\n .value[2].f32: width of the right edge. The unit is vp. \\n\n .value[3].f32: width of the bottom edge. The unit is vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the left edge. The unit is vp. \\n\n .value[1].f32: width of the top edge. The unit is vp. \\n\n .value[2].f32: width of the right edge. The unit is vp. \\n\n .value[3].f32: width of the bottom edge. The unit is vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_RESIZABLE: ArkUI_NodeAttributeType = 4011;
#[doc = " @brief Defines the color of the component when it is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: background color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TOGGLE_SELECTED_COLOR: ArkUI_NodeAttributeType = 5000;
#[doc = " @brief Defines the color of the circular slider for the component of the switch type.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the circular slider, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the circular slider, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TOGGLE_SWITCH_POINT_COLOR: ArkUI_NodeAttributeType = 5001;
#[doc = " @brief Defines the toggle switch value. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the toggle. The value <b>true</b> means to enable the toggle. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable the toggle. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TOGGLE_VALUE: ArkUI_NodeAttributeType = 5002;
#[doc = " @brief Defines the color of the component when it is deselected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n.value[0].u32: background color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TOGGLE_UNSELECTED_COLOR: ArkUI_NodeAttributeType = 5003;
#[doc = " @brief Defines the foreground color of the loading progress bar.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: foreground color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: foreground color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LOADING_PROGRESS_COLOR: ArkUI_NodeAttributeType = 6000;
#[doc = " @brief Defines whether to show the loading animation for the <LoadingProgress> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show the loading animation.\n The value <b>true</b> means to show the loading animation, and <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to show the loading animation, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LOADING_PROGRESS_ENABLE_LOADING: ArkUI_NodeAttributeType =
    6001;
#[doc = " @brief Defines the default placeholder text of the single-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default placeholder text. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default placeholder text. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_PLACEHOLDER: ArkUI_NodeAttributeType = 7000;
#[doc = " @brief Defines the default text content of the single-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default text content. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default text content. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_TEXT: ArkUI_NodeAttributeType = 7001;
#[doc = " @brief Defines the caret color attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: caret color, in 0xARGB format. For example, 0xFFFF0000 indicates red.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: caret color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CARET_COLOR: ArkUI_NodeAttributeType = 7002;
#[doc = " @brief Defines the caret style attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: caret width, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: caret width, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CARET_STYLE: ArkUI_NodeAttributeType = 7003;
#[doc = " @brief Defines the underline attribute of the single-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show an underline.\n The value <b>true</b> means to show an underline, and <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to show an underline, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SHOW_UNDERLINE: ArkUI_NodeAttributeType = 7004;
#[doc = " @brief Defines the maximum number of characters in the text input.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: maximum number of characters in the text input, without a unit. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: maximum number of characters in the text input. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_MAX_LENGTH: ArkUI_NodeAttributeType = 7005;
#[doc = " @brief Defines the type of the Enter key.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: type of the Enter key{@link ArkUI_EnterKeyType}. The default value is <b>ARKUI_ENTER_KEY_TYPE_DONE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type of the Enter key{@link ArkUI_EnterKeyType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENTER_KEY_TYPE: ArkUI_NodeAttributeType = 7006;
#[doc = " @brief Defines the placeholder text color.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_PLACEHOLDER_COLOR: ArkUI_NodeAttributeType = 7007;
#[doc = " @brief Defines the placeholder text font.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: font size, in fp. Optional. The default value is <b>16.0</b>.\\n\n .value[1]?.i32: font style {@link ArkUI_FontStyle}. Optional.\n The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>. \\n\n .value[2]?.i32: font weight {@link ArkUI_FontWeight}. Optional.\n The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>. \\n\n ?.string: font family. Multiple font families are separated by commas (,).\n Example: \"font weight; font family 1, font family 2\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: font size, in fp.\\n\n .value[1].i32: font style {@link ArkUI_FontStyle}.\\n\n .value[2].i32: font weight {@link ArkUI_FontWeight}.\\n\n .string: font family. Multiple font families are separated by commas (,). \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_PLACEHOLDER_FONT: ArkUI_NodeAttributeType = 7008;
#[doc = " @brief Defines whether to enable the input method when the component obtains focus.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the input method when the component obtains focus.\n The value <b>true</b> means to enable the input method, and <b>false</b> means the opposite.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to enable the input method when the component obtains focus,\n and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENABLE_KEYBOARD_ON_FOCUS:
    ArkUI_NodeAttributeType = 7009;
#[doc = " @brief Defines the text box type. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text box type {@link ArkUI_TextInputType}.\n The default value is <b>ARKUI_TEXTINPUT_TYPE_NORMAL</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text box type {@link ArkUI_TextInputType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_TYPE: ArkUI_NodeAttributeType = 7010;
#[doc = " @brief Defines the background color of the selected text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SELECTED_BACKGROUND_COLOR:
    ArkUI_NodeAttributeType = 7011;
#[doc = " @brief Defines whether to display the password icon at the end of the password text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to display the password icon at the end of the password text box.\n The value <b>true</b> means to display the password icon, and <b>false</b> means the opposite.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to display the password icon at the end of the password text box,\n and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SHOW_PASSWORD_ICON: ArkUI_NodeAttributeType =
    7012;
#[doc = " @brief Defines the editable state for the single-line text box.\n This attribute can be set as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: whether to remain in the editable state. The value\n <b>true</b> means to remain in the editable state, and <b>false</b> means to exit the editable state. \\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for obtaining the attribute:\n .value[0].i32: whether to remain in the editable state. The value <b>true</b> means to remain in the editable\n state, and <b>false</b> means to exit the editable state. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_EDITING: ArkUI_NodeAttributeType = 7013;
#[doc = " @brief Defines the style of the cancel button on the right of the single-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: button style {@link ArkUI_CancelButtonStyle}.\n The default value is <b>ARKUI_CANCELBUTTON_STYLE_INPUT</b>.\\n\n .value[1]?.f32: button icon size, in vp.\\n\n .value[2]?.u32: button icon color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n ?.string: button icon image source. The value is the local address of the image, for example, /pages/icon.png. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: button style {@link ArkUI_CancelButtonStyle}.\\n\n .value[1].f32: icon size, in vp.\\n\n .value[2].u32: button icon color, in 0xARGB format.\\n\n .string: button icon image source. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CANCEL_BUTTON: ArkUI_NodeAttributeType = 7014;
#[doc = " @brief Sets the text selection area, which will be highlighted.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: start position of the text selection. \\n\n .value[1].i32: end position of the text selection. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: start position of the text selection. \\n\n .value[1].i32: end position of the text selection. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_TEXT_SELECTION: ArkUI_NodeAttributeType = 7015;
#[doc = " @brief Sets the color of the text underline when it is enabled.\n\n The default underline color configured for the theme is <b>'0x33182431'</b>.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the underline applied to the text being typed in.\n The value is in 0xARGB format. \\n\n .value[1].u32: color of the underline applied to the text in the normal state.\n The value is in 0xARGB format. \\n\n .value[2].u32: color of the underline applied to the text when an error is detected.\n The value is in 0xARGB format. \\n\n .value[3].u32: color of the underline applied to the text when it is disabled.\n The value is in 0xARGB format. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the underline applied to the text being typed in. The value is in 0xARGB format. \\n\n .value[1].u32: color of the underline applied to the text in the normal state. The value is in 0xARGB format. \\n\n .value[2].u32: color of the underline applied to the text when an error is detected.\n The value is in 0xARGB format. \\n\n .value[3].u32: color of the underline applied to the text when it is disabled. The value is in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_UNDERLINE_COLOR: ArkUI_NodeAttributeType = 7016;
#[doc = " @brief Sets whether to enable autofill.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable autofill. The default value is <b>true</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable autofill. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENABLE_AUTO_FILL: ArkUI_NodeAttributeType = 7017;
#[doc = " @brief Sets the autofill type.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: autofill type. The parameter type is {@link ArkUI_TextInputContentType}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: autofill type. The parameter type is {@link ArkUI_TextInputContentType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CONTENT_TYPE: ArkUI_NodeAttributeType = 7018;
#[doc = " @brief Defines the rules for generating passwords. When autofill is used, these rules are transparently\n transmitted to Password Vault for generating a new password.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: rules for generating passwords. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: rules for generating passwords. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_PASSWORD_RULES: ArkUI_NodeAttributeType = 7019;
#[doc = " @brief Sets whether to select all text in the initial state. The inline mode is not supported.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to select all text in the initial state. The default value is b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to select all text in the initial state. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SELECT_ALL: ArkUI_NodeAttributeType = 7020;
#[doc = " @brief Sets the regular expression for input filtering.\n Only inputs that comply with the regular expression can be displayed.\n Other inputs are filtered out. The specified regular expression can match single characters,\n but not strings.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: regular expression. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: regular expression. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_INPUT_FILTER: ArkUI_NodeAttributeType = 7021;
#[doc = " @brief Sets the text box to the default style or inline input style.\n\n For the inline input style, only <b>InputType.Normal</b> is supported.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text input style. The parameter type is {@link ArkUI_TextInputStyle}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text input style. The parameter type is {@link ArkUI_TextInputStyle}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_STYLE: ArkUI_NodeAttributeType = 7022;
#[doc = " @brief Sets or obtains the caret position.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n In the case of setting the caret position:\n .value[0].i32: character count from the beginning of a string to the caret position. \\n\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n In the case of obtaining the caret position: If this API is called when the caret position is updated in the\n current frame, it will not take effect.\n .value[0].i32: index of the caret position. \\n\n .value[1].f32: X coordinate of the caret relative to the text box. \\n\n .value[2].f32: Y coordinate of the caret relative to the text box. \\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CARET_OFFSET: ArkUI_NodeAttributeType = 7023;
#[doc = " @brief Obtains the position of the edited text area relative to the component and its size.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: horizontal coordinate. \\n\n .value[1].f32: vertical coordinate. \\n\n .value[2].f32: content width. \\n\n .value[3].f32: content height. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CONTENT_RECT: ArkUI_NodeAttributeType = 7024;
#[doc = " @brief Obtains the number of lines of the edited text.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of lines of the edited text. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CONTENT_LINE_COUNT: ArkUI_NodeAttributeType =
    7025;
#[doc = " @brief Sets whether to hide the text selection menu when the text box is long-pressed, double-click, or\n right-clicked. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to hide the text selection menu when the text box is long-pressed, double-click, or\n right-clicked. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to hide the text selection menu when the text box is long-pressed, double-click, or\n right-clicked. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SELECTION_MENU_HIDDEN: ArkUI_NodeAttributeType =
    7026;
#[doc = " @brief Sets whether the text box loses focus after the Enter key is pressed to submit information.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the text box loses focus. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the text box loses focus. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_BLUR_ON_SUBMIT: ArkUI_NodeAttributeType = 7027;
#[doc = " @brief Set up a custom keyboard.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object：custom keyboard,The parameter type is{@Link ArkUI_NodeHandle}。\\n\n .value[0]?.i32：Sets whether the custom keyboard supports the avoidance feature, default value false.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object:custom keyboard,The parameter type is{@Link ArkUI_NodeHandle}。\\n\n .value[0].i32：Set whether the custom keyboard supports the avoidance function.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_CUSTOM_KEYBOARD: ArkUI_NodeAttributeType = 7028;
#[doc = " @brief Defines the line break rule. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is {@link ArkUI_WordBreak}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is {@link ArkUI_WordBreak}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_WORD_BREAK: ArkUI_NodeAttributeType = 7029;
#[doc = " @brief Sets whether the keyboard pops up when the input box gains focus.\n It supports property setting, property reset and property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format:\\n\n .value[0].i32: Whether to pop up the keyboard. \\n\n \\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .value[0].i32: Whether to pop up the keyboard. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_SHOW_KEYBOARD_ON_FOCUS: ArkUI_NodeAttributeType =
    7030;
#[doc = " @brief When this property is set, the height of the textInput component is calculated using this property.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: set the value of numberOfLines.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: the value of numberOfLines.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_NUMBER_OF_LINES: ArkUI_NodeAttributeType = 7031;
#[doc = " @brief Sets the letter spacing of the <b>TextInput</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: letter spacing. The default unit is fp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: letter spacing. The default unit is fp. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_LETTER_SPACING: ArkUI_NodeAttributeType = 7032;
#[doc = " @brief Sets whether to enable preview text for the <b>TextInput</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable preview tex. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable preview tex. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_ENABLE_PREVIEW_TEXT: ArkUI_NodeAttributeType =
    7033;
#[doc = " @brief Set the keyboard style of textInput\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32：keyboard style，the parameter type is {@link ArkUI_KeyboardAppearanceType}。\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}：\\n\n .value[0].i32：keyboard style，the parameter type is {@link ArkUI_KeyboardAppearanceType}。\\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_INPUT_KEYBOARD_APPEARANCE: ArkUI_NodeAttributeType =
    7035;
#[doc = " @brief Defines the default placeholder text for the multi-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default placeholder text. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default placeholder text. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_PLACEHOLDER: ArkUI_NodeAttributeType = 8000;
#[doc = " @brief Defines the default text content for the multi-line text box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default text content. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default text content. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_TEXT: ArkUI_NodeAttributeType = 8001;
#[doc = " @brief Defines the maximum number of characters in the text input.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: maximum number of characters in the text input. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: maximum number of characters in the text input. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_MAX_LENGTH: ArkUI_NodeAttributeType = 8002;
#[doc = " @brief Defines the placeholder text color.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_PLACEHOLDER_COLOR: ArkUI_NodeAttributeType = 8003;
#[doc = " @brief Defines the placeholder text font.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.f32: font size, in fp. Optional. The default value is <b>16.0</b>.\\n\n .value[1]?.i32: font style {@link ArkUI_FontStyle}. Optional. The default value is <b>ARKUI_FONT_STYLE_NORMAL</b>.\\n\n .value[2]?.i32: font weight {@link ArkUI_FontWeight}. Optional. The default value is <b>ARKUI_FONT_WEIGHT_NORMAL</b>.\\n\n ?.string: font family. Multiple font families are separated by commas (,). For example, \"font weight; font family 1, font family 2\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: font size, in fp.\\n\n .value[1].i32: font style {@link ArkUI_FontStyle}.\\n\n .value[2].i32: font weight {@link ArkUI_FontWeight}.\\n\n .string: font family. Multiple font families are separated by commas (,). \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_PLACEHOLDER_FONT: ArkUI_NodeAttributeType = 8004;
#[doc = " @brief Defines the caret color attribute.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: background color, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CARET_COLOR: ArkUI_NodeAttributeType = 8005;
#[doc = " @brief Defines the editable state for the multi-line text box.\n This attribute can be set as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to remain in the editable state. The value <b>true</b> means to remain in the\n editable state, and <b>false</b> means to exit the editable state.\\n \\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for obtaining the attribute:\n .value[0].i32: whether to remain in the editable state. The value <b>true</b> means to remain in the editable\n state, and <b>false</b> means to exit the editable state.\\n \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_EDITING: ArkUI_NodeAttributeType = 8006;
#[doc = " @brief Defines the text box type. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: text box type {@link ArkUI_TextAreaType}.\n The default value is <b>ARKUI_TEXTAREA_TYPE_NORMAL</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: text box type {@link ArkUI_TextAreaType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_TYPE: ArkUI_NodeAttributeType = 8007;
#[doc = " @brief Defines the counter settings. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show a character counter. The value <b>true</b> means to show a character counter. \\n\n .value[1]?.f32: threshold percentage for displaying the character counter. The character counter is displayed\n when the number of characters that have been entered is greater than the maximum number of characters multiplied\n by the threshold percentage value. The value range is 1 to 100. If the value is a decimal, it is rounded down. \\n\n .value[2]?.i32: whether to highlight the border when the number of entered characters reaches the maximum. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to show a character counter. \\n\n .value[1].f32: threshold percentage for displaying the character counter. The character counter is displayed\n when the number of characters that have been entered is greater than the maximum number of characters multiplied\n by the threshold percentage value. The value range is 1 to 100. \\n\n .value[2].i32: whether to highlight the border when the number of entered characters reaches the maximum.\n The default value is <b>true</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_SHOW_COUNTER: ArkUI_NodeAttributeType = 8008;
#[doc = " @brief Sets whether to hide the text selection menu when the text box is long-pressed, double-click,\n or right-clicked. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to hide the text selection menu when the text box is long-pressed, double-click,\n or right-clicked. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to hide the text selection menu when the text box is long-pressed, double-click,\n or right-clicked. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_SELECTION_MENU_HIDDEN: ArkUI_NodeAttributeType =
    8009;
#[doc = " @brief Sets whether the multi-line text box loses focus after the Enter key is pressed to submit information.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the text box loses focus. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the text box loses focus. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_BLUR_ON_SUBMIT: ArkUI_NodeAttributeType = 8010;
#[doc = " @brief Sets the regular expression for input filtering.\n Only inputs that comply with the regular expression can be displayed.\n Other inputs are filtered out. The specified regular expression can match single characters,\n but not strings.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: regular expression. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: regular expression. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_INPUT_FILTER: ArkUI_NodeAttributeType = 8011;
#[doc = " @brief Defines the background color of the selected text.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_SELECTED_BACKGROUND_COLOR:
    ArkUI_NodeAttributeType = 8012;
#[doc = " @brief Defines the type of the Enter key.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: type of the Enter key{@link ArkUI_EnterKeyType}. The default value is <b>ARKUI_ENTER_KEY_TYPE_DONE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type of the Enter key{@link ArkUI_EnterKeyType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_ENTER_KEY_TYPE: ArkUI_NodeAttributeType = 8013;
#[doc = " @brief Defines whether to enable the input method when the component obtains focus.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the input method when the component obtains focus.\n The value <b>true</b> means to enable the input method, and <b>false</b> means the opposite.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to enable the input method when the component obtains focus,\n and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_ENABLE_KEYBOARD_ON_FOCUS: ArkUI_NodeAttributeType =
    8014;
#[doc = " @brief Defines whether to enable the input method when the component obtains focus.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the input method when the component obtains focus.\n The value <b>true</b> means to enable the input method, and <b>false</b> means the opposite.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means to enable the input method when the component obtains focus,\n and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CARET_OFFSET: ArkUI_NodeAttributeType = 8015;
#[doc = " @brief Obtains the position of the edited text area relative to the component and its size.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: horizontal coordinate. \\n\n .value[1].f32: vertical coordinate. \\n\n .value[2].f32: content width. \\n\n .value[3].f32: content height. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CONTENT_RECT: ArkUI_NodeAttributeType = 8016;
#[doc = " @brief Obtains the number of lines of the edited text.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of lines of the edited text. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CONTENT_LINE_COUNT: ArkUI_NodeAttributeType = 8017;
#[doc = " @brief Sets the text selection area, which will be highlighted.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: start position of the text selection. \\n\n .value[1].i32: end position of the text selection. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: start position of the text selection. \\n\n .value[1].i32: end position of the text selection. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_TEXT_SELECTION: ArkUI_NodeAttributeType = 8018;
#[doc = " @brief Sets whether to enable autofill.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable autofill. The default value is <b>true</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable autofill. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_ENABLE_AUTO_FILL: ArkUI_NodeAttributeType = 8019;
#[doc = " @brief Sets the autofill type.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: autofill type. The parameter type is {@link ArkUI_TextInputContentType}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: autofill type. The parameter type is {@link ArkUI_TextInputContentType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_CONTENT_TYPE: ArkUI_NodeAttributeType = 8020;
#[doc = " @brief Sets whether the keyboard pops up when the input box gains focus.\n It supports property setting, property reset and property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format:\\n\n .value[0].i32: Whether to pop up the keyboard. \\n\n \\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .value[0].i32: Whether to pop up the keyboard. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_SHOW_KEYBOARD_ON_FOCUS: ArkUI_NodeAttributeType =
    8021;
#[doc = " @brief When this property is set, the height of the textArea component is calculated using this property.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: set the value of numberOfLines.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: Set the value of numberOfLines\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_NUMBER_OF_LINES: ArkUI_NodeAttributeType = 8022;
#[doc = " @brief Sets the letter spacing of the <b>TextArea</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: letter spacing. The default unit is fp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: letter spacing. The default unit is fp. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_LETTER_SPACING: ArkUI_NodeAttributeType = 8023;
#[doc = " @brief Sets whether to enable preview text for the <b>TextArea</b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable preview tex. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable preview tex. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_ENABLE_PREVIEW_TEXT: ArkUI_NodeAttributeType =
    8024;
#[doc = " @brief Set the keyboard style of textArea\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32：keyboard style，the parameter type is {@link ArkUI_KeyboardAppearanceType}。\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}：\\n\n .value[0].i32：keyboard style，the parameter type is {@link ArkUI_KeyboardAppearanceType}。\\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_AREA_KEYBOARD_APPEARANCE: ArkUI_NodeAttributeType =
    8026;
#[doc = " @brief Defines the button text content. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: default text content. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: default text content. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BUTTON_LABEL: ArkUI_NodeAttributeType = 9000;
#[doc = " @brief Sets the button type. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: button type. The parameter type is {@link ArkUI_ButtonType}.\n The default value is <b>ARKUI_BUTTON_TYPE_CAPSULE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: button type. The parameter type is {@link ArkUI_ButtonType}.\n The default value is <b>ARKUI_BUTTON_TYPE_CAPSULE</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_BUTTON_TYPE: ArkUI_NodeAttributeType = 9001;
#[doc = " @brief Defines the current value of the progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: current value of the progress indicator. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: current value of the progress indicator. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_VALUE: ArkUI_NodeAttributeType = 10000;
#[doc = " @brief Defines the total value of the progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: total value of the progress indicator. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: total value of the progress indicator. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_TOTAL: ArkUI_NodeAttributeType = 10001;
#[doc = " @brief Defines the color for the progress value on the progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color value, in 0xARGB format. For example, 0xFFFF0000 indicates red. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color value, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_COLOR: ArkUI_NodeAttributeType = 10002;
#[doc = " @brief Defines the type of the progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: type of the progress indicator {@link ArkUI_ProgressType}.\n The default value is <b>ARKUI_PROGRESS_TYPE_LINEAR</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type of the progress indicator {@link ArkUI_ProgressType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_TYPE: ArkUI_NodeAttributeType = 10003;
#[doc = " @brief Sets the style of the linear progress indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n If the progress indicator type is not linear, it will not take effect.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: Use the {@link ArkUI_ProgressLinearStyleOption} object to set the style. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: Use the {@link ArkUI_ProgressLinearStyleOption} object to get the style. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_PROGRESS_LINEAR_STYLE: ArkUI_NodeAttributeType = 10004;
#[doc = " @brief Defines whether the check box is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the check box is selected.\n The value <b>1</b> means that the check box is selected, and <b>0</b> means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means that the check box is selected, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_SELECT: ArkUI_NodeAttributeType = 11000;
#[doc = " @brief Defines the color of the check box when it is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the check box when it is selected, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the check box when it is selected, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_SELECT_COLOR: ArkUI_NodeAttributeType = 11001;
#[doc = " @brief Defines the border color of the check box when it is not selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_UNSELECT_COLOR: ArkUI_NodeAttributeType = 11002;
#[doc = " @brief Defines the internal icon style of the check box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\\n\n .value[1]?.f32: size of the internal mark, in vp. Optional.\\n\n .value[2]?.f32: stroke width of the internal mark, in vp. Optional. The default value is <b>2</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\\n\n .value[1].f32: size of the internal mark, in vp. \\n\n .value[2].f32: stroke width of the internal mark, in vp. The default value is <b>2</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_MARK: ArkUI_NodeAttributeType = 11003;
#[doc = " @brief Defines the shape of the check box.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: component shape. The parameter type is {@link ArkUI_CheckboxShape}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: component shape. The parameter type is {@link ArkUI_CheckboxShape}.\n"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_SHAPE: ArkUI_NodeAttributeType = 11004;
#[doc = " @brief Defines the name of the checkbox.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component name. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component name. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_NAME: ArkUI_NodeAttributeType = 11005;
#[doc = " @brief Defines the name of the checkbox.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component name. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component name. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP: ArkUI_NodeAttributeType = 11006;
#[doc = " @brief Defines the ID of the <b><XComponent></b> component.\n This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component ID. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component ID. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_XCOMPONENT_ID: ArkUI_NodeAttributeType = 12000;
#[doc = " @brief Defines the type of the <b><XComponent></b> component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: type {@link ArkUI_XComponentType}. The default value is <b>ARKUI_XCOMPONENT_TYPE_SURFACE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type {@link ArkUI_XComponentType}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_XCOMPONENT_TYPE: ArkUI_NodeAttributeType = 12001;
#[doc = " @brief Defines the width and height of the <b><XComponent></b> component.\n This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: width, in px. \\n\n .value[1].u32: height, in px. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: width, in px. \\n\n .value[1].u32: height, in px. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_XCOMPONENT_SURFACE_SIZE: ArkUI_NodeAttributeType = 12002;
#[doc = " @brief Defines whether to display the lunar calendar in the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to display the lunar calendar in the date picker. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to display the lunar calendar in the date picker.\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_LUNAR: ArkUI_NodeAttributeType = 13000;
#[doc = " @brief Defines the start date of the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: date. The default value is <b>\"1970-1-1\"</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: date. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_START: ArkUI_NodeAttributeType = 13001;
#[doc = " @brief Defines the end date of the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: date. The default value is <b>\"2100-12-31\"</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: date. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_END: ArkUI_NodeAttributeType = 13002;
#[doc = " @brief Defines the selected date of the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: date. The default value is <b>\"2024-01-22\"</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: date.\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_SELECTED: ArkUI_NodeAttributeType = 13003;
#[doc = " @brief Defines the font color, font size, and font weight for the top and bottom items in the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_DISAPPEAR_TEXT_STYLE: ArkUI_NodeAttributeType =
    13004;
#[doc = " @brief Defines the font color, font size, and font weight of all items except the top, bottom, and selected\n items in the date picker. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_TEXT_STYLE: ArkUI_NodeAttributeType = 13005;
#[doc = " @brief Defines the font color, font size, and font weight of the selected item in the date picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_DATE_PICKER_SELECTED_TEXT_STYLE: ArkUI_NodeAttributeType =
    13006;
#[doc = " @brief Defines the time of the selected item. in the timer picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: time. The default value is the current system time. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: time.\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_SELECTED: ArkUI_NodeAttributeType = 14000;
#[doc = " @brief Defines whether the display time is in 24-hour format.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the display time is in 24-hour format. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the display time is in 24-hour format.\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_USE_MILITARY_TIME: ArkUI_NodeAttributeType =
    14001;
#[doc = " @brief Defines the font color, font size, and font weight for the top and bottom items in the time picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_DISAPPEAR_TEXT_STYLE: ArkUI_NodeAttributeType =
    14002;
#[doc = " @brief Defines the font color, font size, and font weight of all items except the top, bottom, and selected items\n in the time picker. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_TEXT_STYLE: ArkUI_NodeAttributeType = 14003;
#[doc = " @brief Defines the font color, font size, and font weight of the selected item in the time picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TIME_PICKER_SELECTED_TEXT_STYLE: ArkUI_NodeAttributeType =
    14004;
#[doc = " @brief Defines the data selection range of the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: type of the text picker {@link ArkUI_TextPickerRangeType}.\n The default value is <b>ARKUI_TEXTPICKER_RANGETYPE_SINGLE</b>. \\n\n ?.string: string input, whose format varies by picker type.\\n\n 1: single-column picker. The input format is a group of strings separated by semicolons (;).\\n\n 2: multi-column picker. Multiple pairs of plain text strings are supported. The pairs are separated by\n semicolons (;), and strings within each pair are separated by commas (,). \\n\n ?.object: Object input, whose format varies by picker type.\\n\n 1: single-column picker with image support. The input structure is {@link ARKUI_TextPickerRangeContent}.\\n\n 2: multi-column interconnected picker. The input structure is {@link ARKUI_TextPickerCascadeRangeContent}.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: type of the text picker {@link ArkUI_TextPickerRangeType}.\\n\n ?.string: string output, whose format varies by picker type.\\n\n 1: single-column picker. The output format is a group of strings separated by semicolons (;).\\n\n 2: multi-column picker. Multiple pairs of plain text strings are supported. The pairs are separated by\n semicolons (;), and strings within each pair are separated by commas (,). \\n\n ?.string: Object output, whose format varies by picker type.\\n\n 1: single-column picker with image support. The output structure is {@link ARKUI_TextPickerRangeContent}.\\n\n 2: multi-column interconnected picker. The output structure is {@link ARKUI_TextPickerCascadeRangeContent}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_OPTION_RANGE: ArkUI_NodeAttributeType = 15000;
#[doc = " @brief Defines the index of the default selected item in the data selection range of the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: index. If there are multiple index values, add them one by one. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: index. If there are multiple index values, add them one by one.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_OPTION_SELECTED: ArkUI_NodeAttributeType = 15001;
#[doc = " @brief Defines the value of the default selected item in the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: value of the selected item. If there are multiple values, add them one by one and\n separate them with semicolons (;). \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: value of the selected item. If there are multiple values, add them one by one and\n separate them with semicolons (;).\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_OPTION_VALUE: ArkUI_NodeAttributeType = 15002;
#[doc = " @brief Defines the font color, font size, and font weight for the top and bottom items in the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_DISAPPEAR_TEXT_STYLE: ArkUI_NodeAttributeType =
    15003;
#[doc = " @brief Defines the font color, font size, and font weight for all items except the top, bottom, and selected\n items in the text picker. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_TEXT_STYLE: ArkUI_NodeAttributeType = 15004;
#[doc = " @brief Defines the font color, font size, and font weight for the selected item in the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: array of five parameters of the string type, separated by semicolons (;).\\n\n Parameter 1: font color, in #ARGB format.\\n\n Parameter 2: font size, in fp. The value is a number.\\n\n Parameter 3: font weight. Available options are (\"bold\", \"normal\", \"bolder\", \"lighter\", \"medium\", \"regular\").\\n.\n Parameter 4: fonts, separated by commas (,).\\n\n Parameter 5: font style. Available options are (\"normal\", \"italic\").\\n\n Example: \"#ff182431;14;normal;Arial,HarmonyOS Sans;normal\". \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_SELECTED_TEXT_STYLE: ArkUI_NodeAttributeType =
    15005;
#[doc = " @brief Defines the index of the default selected item in the data selection range of the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0...].i32: index of the default item in the data selection range.\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_SELECTED_INDEX: ArkUI_NodeAttributeType = 15006;
#[doc = " @brief Defines whether to support scroll looping for the text picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to support scroll looping. The value <b>true</b> means to support scroll looping, and\n <b>false</b> means the opposite.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].i32: The value <b>1</b> means to support scroll looping, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_CAN_LOOP: ArkUI_NodeAttributeType = 15007;
#[doc = " @brief Defines the height of each item in the picker. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: item height, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n value[0].f32: item height, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_TEXT_PICKER_DEFAULT_PICKER_ITEM_HEIGHT:
    ArkUI_NodeAttributeType = 15008;
#[doc = " @brief Defines the style of the background in the selected state of the calendar picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: style of the background in the selected state of the calendar picker.\n The value range is [0, +∞). If the value is <b>0</b>, the background is a rectangle with square corners.\nIf the value is in the 0–16 range, the background is a rectangle with rounded corners. If the value is equal to\n or greater than 16, the background is a circle. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: style of the background in the selected state of the calendar picker. The value range is [0, +∞).\n If the value is <b>0</b>, the background is a rectangle with square corners.\nIf the value is in the 0–16 range, the background is a rectangle with rounded corners. If the value is equal to or\n greater than 16, the background is a circle. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_HINT_RADIUS: ArkUI_NodeAttributeType = 16000;
#[doc = " @brief Defines the date of the selected item in the calendar picker.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: year of the selected date. \\n\n .value[1].u32: month of the selected date. \\n\n .value[2].u32: day of the selected date. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: year of the selected date. \\n\n .value[1].u32: month of the selected date. \\n\n .value[2].u32: day of the selected date. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_SELECTED_DATE: ArkUI_NodeAttributeType =
    16001;
#[doc = " @brief Defines how the calendar picker is aligned with the entry component.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode. The parameter type is {@link ArkUI_CalendarAlignment}. \\n\n .value[1]?.f32: offset of the picker relative to the entry component along the x-axis after alignment based on\n the specified alignment mode. \\n\n .value[2]?.f32: offset of the picker relative to the entry component along the y-axis after alignment based on\n the specified alignment mode. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode. The parameter type is {@link ArkUI_CalendarAlignment}. \\n\n .value[1]?.f32: offset of the picker relative to the entry component along the x-axis after alignment based on\n the specified alignment mode. \\n\n .value[2]?.f32: offset of the picker relative to the entry component along the y-axis after alignment based on\n the specified alignment mode. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_EDGE_ALIGNMENT: ArkUI_NodeAttributeType =
    16002;
#[doc = " @brief Defines the font color, font size, and font weight in the entry area of the calendar picker.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.u32: font color of the entry area. \\n\n .value[1]?.f32: font size of the entry area, in fp. \\n\n .value[2]?.i32: font weight of the entry area. The parameter type is {@link ArkUI_FontWeight}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: font color of the entry area. \\n\n .value[1].f32: font size of the entry area, in fp. \\n\n .value[2].i32: font weight of the entry area. The parameter type is {@link ArkUI_FontWeight}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_CALENDAR_PICKER_TEXT_STYLE: ArkUI_NodeAttributeType = 16003;
#[doc = " @brief Defines the color of the slider. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the slider, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the slider, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_BLOCK_COLOR: ArkUI_NodeAttributeType = 17000;
#[doc = " @brief Defines the background color of the slider. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: background color, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: background color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_TRACK_COLOR: ArkUI_NodeAttributeType = 17001;
#[doc = " @brief Defines the color of the selected part of the slider track. This attribute can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the selected part of the slider track, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the selected part of the slider track, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_SELECTED_COLOR: ArkUI_NodeAttributeType = 17002;
#[doc = " @brief Sets whether to display the stepping value. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to display the stepping value. The value <b>1</b> means to display the stepping value,\n and <b>0</b> (default value) means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to display the stepping value. The value <b>1</b> means to display the stepping value,\n and <b>0</b> (default value) means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_SHOW_STEPS: ArkUI_NodeAttributeType = 17003;
#[doc = " @brief Defines the slider shape, which can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: shape. The parameter type is {@link ArkUI_SliderBlockStyle}. \\n\n .string?: depending on the shape. Optional. \\n\n ARKUI_SLIDER_BLOCK_STYLE_IMAGE: image resource of the slider. Example: /pages/common/icon.png. \\n\n ARKUI_SLIDER_BLOCK_STYLE_SHAPE: custom shape of the slider. \\n\n There are five types:\\n\n 1. Rectangle:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_RECTANGLE</b> for the rectangle shape.\\n\n .value[2].f32: width of the rectangle.\\n\n .value[3].f32: height of the rectangle.\\n\n .value[4].f32: width of the rounded corner of the rectangle.\\n\n .value[5].f32: height of the rounded corner of the rectangle.\\n\n 2. Circle:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[2].f32: width of the circle.\\n\n .value[3].f32: height of the circle.\\n\n 3.Ellipse:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[2].f32: width of the ellipse.\\n\n .value[3].f32: height of the ellipse;\\n\n 4. Path:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_PATH</b> for the path shape.\\n\n .value[2].f32: width of the path.\\n\n .value[3].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: shape. The parameter type is {@link ArkUI_SliderBlockStyle}. \\n\n .string?: depending on the shape. Optional. \\n\n ARKUI_SLIDER_BLOCK_STYLE_IMAGE: image resource of the slider. Example: /pages/common/icon.png. \\n\n ARKUI_SLIDER_BLOCK_STYLE_SHAPE: custom shape of the slider. \\n\n There are five types:\\n\n 1. Rectangle:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_RECTANGLE</b> for the rectangle shape.\\n\n .value[2].f32: width of the rectangle.\\n\n .value[3].f32: height of the rectangle.\\n\n .value[4].f32: width of the rounded corner of the rectangle.\\n\n .value[5].f32: height of the rounded corner of the rectangle.\\n\n 2. Circle:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_CIRCLE</b> for the circle shape.\\n\n .value[2].f32: width of the circle.\\n\n .value[3].f32: height of the circle.\\n\n 3.Ellipse:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_ELLIPSE</b> for the ellipse shape.\\n\n .value[2].f32: width of the ellipse.\\n\n .value[3].f32: height of the ellipse;\\n\n 4. Path:\\n\n .value[1].i32: type of shape. The parameter type is {@link ArkUI_ShapeType}.\n The value is <b>ARKUI_SHAPE_TYPE_PATH</b> for the path shape.\\n\n .value[2].f32: width of the path.\\n\n .value[3].f32: height of the path.\\n\n .string: command for drawing the path.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_BLOCK_STYLE: ArkUI_NodeAttributeType = 17004;
#[doc = " @brief Defines the current value of the slider. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: current value. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: current value.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_VALUE: ArkUI_NodeAttributeType = 17005;
#[doc = " @brief Defines the minimum value of the slider. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum value. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum value.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_MIN_VALUE: ArkUI_NodeAttributeType = 17006;
#[doc = " @brief Defines the maximum value of the slider. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: maximum value. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: maximum value.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_MAX_VALUE: ArkUI_NodeAttributeType = 17007;
#[doc = " @brief Defines the step of the slider. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: step. The value range is [0.01, 100]. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: step. The value range is [0.01, 100].\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_STEP: ArkUI_NodeAttributeType = 17008;
#[doc = " @brief Defines whether the slider moves horizontally or vertically. This attribute can be set, reset, and\n obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the slider moves horizontally or vertically.\n The parameter type is {@link ArkUI_SliderDirection}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the slider moves horizontally or vertically.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_DIRECTION: ArkUI_NodeAttributeType = 17009;
#[doc = " @brief Defines whether the slider values are reversed. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the slider values are reversed. The value <b>1</b> means that the slider values are\n reversed, and <b>0</b> means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the slider values are reversed. The value <b>1</b> means that the slider values are\n reversed, and <b>0</b> means the opposite.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_REVERSE: ArkUI_NodeAttributeType = 17010;
#[doc = " @brief Defines the style of the slider thumb and track. This attribute can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: style of the slider thumb and track. The parameter type is {@link ArkUI_SliderStyle}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: style of the slider thumb and track. The parameter type is {@link ArkUI_SliderStyle}.\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_STYLE: ArkUI_NodeAttributeType = 17011;
#[doc = " @brief Sets the track thickness of the slider.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: track thickness of the slider, in vp. The default value is 4.0 vp when <b>NODE_SLIDER_STYLE</b>\n is set to <b>ARKUI_SLIDER_STYLE_OUT_SET</b> and 20.0 vp when <b>NODE_SLIDER_STYLE</b> is set to\n <b>ARKUI_SLIDER_STYLE_IN_SET</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: track thickness of the slider, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SLIDER_TRACK_THICKNESS: ArkUI_NodeAttributeType = 17012;
#[doc = " @brief Set the selection status of an option button. Attribute setting,\n attribute resetting, and attribute obtaining are supported.\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: check status of an option button. The default value is false.\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: selection status of an option button."]
pub const ArkUI_NodeAttributeType_NODE_RADIO_CHECKED: ArkUI_NodeAttributeType = 18000;
#[doc = " @brief Set the styles of the selected and deselected states of the option button.\n The attribute setting, attribute resetting, and attribute obtaining are supported.\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0]?. u32: color of the mother board in enabled state. \\n\n The type is 0xARGB, and the default value is 0xFF007DFF. \\n\n .value[1]?. u32: stroke color in the close state. The type is 0xARGB, \\n\n and the default value is 0xFF182431. \\n\n .value[2]?. u32: color of the internal round pie in the enabled state. \\n\n The type is 0xARGB, and the default value is 0xFFFFFFFF. \\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0]. u32: color of the mother board in enabled state. \\n\n The type is 0xARGB, and the default value is 0xFF007DFF. \\n\n .value[1]. u32: stroke color in the close state. The type is 0xARGB, \\n\n and the default value is 0xFF182431. \\n\n .value[2]. u32: color of the internal round pie in the enabled state. \\n\n The type is 0xARGB, and the default value is 0xFFFFFFF. \\n"]
pub const ArkUI_NodeAttributeType_NODE_RADIO_STYLE: ArkUI_NodeAttributeType = 18001;
#[doc = " @brief Sets the value of the current radio.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .string: radio value.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: radio value.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RADIO_VALUE: ArkUI_NodeAttributeType = 18002;
#[doc = " @brief Set the group name of the current Radio group, only one radio of the same group can be selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .string: name of the group to which the current option box belongs.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: name of the group to which the current option box belongs.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RADIO_GROUP: ArkUI_NodeAttributeType = 18003;
#[doc = " @brief Set the image frames for the image animator. Dynamic updates is not supported.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .size: number of the images.\\n\n .object: array of the images, the type is {@ArkUI_ImageAnimatorFrameInfo} array.\\n\n \\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .size: number of the images.\\n\n .object: array of the images, the type is {@ArkUI_ImageAnimatorFrameInfo} array.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_IMAGES: ArkUI_NodeAttributeType = 19000;
#[doc = " @brief Set the playback status of the animation for the image animator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the playback status of the animation, the type is {@link ArkUI_AnimationStatus},\n and the default value is ARKUI_ANIMATION_STATUS_INITIAL.\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: the playback status of the animation, the type is {@link ArkUI_AnimationStatus}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_STATE: ArkUI_NodeAttributeType = 19001;
#[doc = " @brief Set the playback duration for the image animator. When the duration is 0, no image is played.\n The value change takes effect only at the beginning of the next cycle.\n When a separate duration is set in images, the setting of this attribute is invalid.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the playback duration, the unit is ms and the default value is 1000.\\n\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: the playback duration, the unit is ms.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_DURATION: ArkUI_NodeAttributeType = 19002;
#[doc = " @brief Set the playback direction for the image animator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the playback direction. 0 indicates that images are played from the first one to the last one,\n and 1 indicates that images are played from the last one to the first one.\\n\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: the playback direction. 0 indicates that images are played from the first one to the last one,\n and 1 indicates that images are played from the last one to the first one.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_REVERSE: ArkUI_NodeAttributeType = 19003;
#[doc = " @brief Set whether the image size is the same as the component size.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: whether the image size is the same as the component size.\n 1 indicates the image size is the same as the component size.\n In this case, the width, height, top, and left attributes of the image are invalid.\n 0 indicates the image size is customized.\n The width, height, top, and left attributes of each image must be set separately.\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: whether the image size is the same as the component size.\n 1 indicates the image size is the same as the component size.\n 0 indicates the image size is customized.\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_FIXED_SIZE: ArkUI_NodeAttributeType = 19004;
#[doc = " @brief Set the status before and after execution of the animation in the current playback direction.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the status before and after execution of the animation in the current playback direction,\n the type is {ArkUI_AnimationFillMode} and the default value is ARKUI_ANIMATION_FILL_MODE_FORWARDS.\\n\n\n Attribute obtaining method return value {@Link ArkUI_AttributeItem} format:\\n\n .value[0].i32: the status before and after execution of the animation in the current playback direction,\n the type is {ArkUI_AnimationFillMode}.\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_FILL_MODE: ArkUI_NodeAttributeType = 19005;
#[doc = " @brief Set the number of times that the animation is played.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the number of times that the animation is played.\\n\n\n Attribute setting method {@Link ArkUI_AttributeItem} Parameter format:\\n\n .value[0].i32: the number of times that the animation is played.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_IMAGE_ANIMATOR_ITERATION: ArkUI_NodeAttributeType = 19006;
#[doc = " @brief Defines the name of the checkboxgroup.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: component name. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: component name. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_NAME: ArkUI_NodeAttributeType = 21000;
#[doc = " @brief Defines whether the checkboxgroup is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether the checkboxgroup is selected.\n The value <b>1</b> means that the checkboxgroup is selected, and <b>0</b> means the opposite. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The value <b>1</b> means that the checkboxgroup is selected, and <b>0</b> means the opposite. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_SELECT_ALL: ArkUI_NodeAttributeType = 21001;
#[doc = " @brief Defines the color of the checkboxgroup when it is selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the checkboxgroup when it is selected, in 0xARGB format,\n for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the checkboxgroup when it is selected, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_SELECTED_COLOR: ArkUI_NodeAttributeType =
    21002;
#[doc = " @brief Defines the border color of the checkboxgroup when it is not selected.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_UNSELECTED_COLOR: ArkUI_NodeAttributeType =
    21003;
#[doc = " @brief Defines the internal icon style of the checkboxgroup.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\\n\n .value[1]?.f32: size of the internal mark, in vp. Optional.\\n\n .value[2]?.f32: stroke width of the internal mark, in vp. Optional. The default value is <b>2</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: border color, in 0xARGB format, for example, <b>0xFF1122FF</b>.\\n\n .value[1].f32: size of the internal mark, in vp. \\n\n .value[2].f32: stroke width of the internal mark, in vp. The default value is <b>2</b>. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_MARK: ArkUI_NodeAttributeType = 21004;
#[doc = " @brief Defines the shape of the checkboxgroup.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: component shape. The parameter type is {@link ArkUI_CheckboxShape}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: component shape. The parameter type is {@link ArkUI_CheckboxShape}.\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_CHECKBOX_GROUP_SHAPE: ArkUI_NodeAttributeType = 21005;
#[doc = " @brief Defines the alignment mode of the child components in the container. This attribute can be set, reset,\n and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode. The data type is {@link ArkUI_Alignment}.\n The default value is <b>ARKUI_ALIGNMENT_CENTER</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode. The data type is {@link ArkUI_Alignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_STACK_ALIGN_CONTENT: ArkUI_NodeAttributeType = 1000000;
#[doc = " @brief Defines the scrollbar status. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: scrollbar status. The parameter type is {@link ArkUI_ScrollBarDisplayMode}. The default value is\n <b>ARKUI_SCROLL_BAR_DISPLAY_MODE_AUTO</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: scrollbar status. The parameter type is {@link ArkUI_ScrollBarDisplayMode}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BAR_DISPLAY_MODE: ArkUI_NodeAttributeType = 1002000;
#[doc = " @brief Defines the width of the scrollbar. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: width of the scrollbar, in vp. The default value is <b>4</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: width of the scrollbar, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BAR_WIDTH: ArkUI_NodeAttributeType = 1002001;
#[doc = " @brief Defines the color of the scrollbar. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .data[0].u32: color of the scrollbar, in 0xARGB format. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .data[0].u32: color of the scrollbar, in 0xARGB format. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BAR_COLOR: ArkUI_NodeAttributeType = 1002002;
#[doc = " @brief Defines the scroll direction. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: scroll direction. The parameter type is {@link ArkUI_ScrollDirection}.\n The default value is <b>ARKUI_SCROLL_DIRECTION_VERTICAL</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: scroll direction. The parameter type is {@link ArkUI_ScrollDirection}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_SCROLL_DIRECTION: ArkUI_NodeAttributeType = 1002003;
#[doc = " @brief Defines the effect used at the edges of the component when the boundary of the scrollable content is\n reached. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: effect used at the edges of the component when the boundary of the scrollable content is reached.\n The parameter type is {@link ArkUI_EdgeEffect}. The default value is <b>ARKUI_EDGE_EFFECT_NONE</b>.\\n\n .value[1]?.i32: whether to enable the scroll effect when the component content size is smaller than the\n component itself. Optional. The value <b>1</b> means to enable the scroll effect, and <b>0</b> means the\n opposite. The default value is <b>1</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: effect used at the edges of the component when the boundary of the scrollable content is reached.\n The parameter type is {@link ArkUI_EdgeEffect}. \\n\n .value[1].i32: whether to enable the scroll effect when the component content size is smaller than the component\n itself. Optional. The value <b>1</b> means to enable the scroll effect, and <b>0</b> means the opposite. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_EDGE_EFFECT: ArkUI_NodeAttributeType = 1002004;
#[doc = " @brief Defines whether to support scroll gestures. When this attribute is set to <b>false</b>, scrolling by\n finger or mouse is not supported, but the scroll controller API is not affected.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to support scroll gestures. The default value is <b>true</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to support scroll gestures. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_ENABLE_SCROLL_INTERACTION: ArkUI_NodeAttributeType =
    1002005;
#[doc = " @brief Defines the friction coefficient. It applies only to gestures in the scrolling area, and it affects only\n indirectly the scroll chaining during the inertial scrolling process.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: friction coefficient. The default value is <b>0.6</b> for non-wearable devices and <b>0.9</b>\n for wearable devices. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: friction coefficient.\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_FRICTION: ArkUI_NodeAttributeType = 1002006;
#[doc = " @brief Defines the scroll snapping mode. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode for the scroll snap position. The parameter type is {@link ArkUI_ScrollSnapAlign}.\n The default value is <b>ARKUI_SCROLL_SNAP_ALIGN_NONE</b>.\\n\n .value[1].i32: whether to enable the snap to start feature. When scroll snapping is defined for the\n <b><Scroll></b> component, setting this attribute to <b>false</b> enables the component to scroll between the\n start edge and the first snap point. The default value is <b>true</b>. It is valid only when there are multiple\n snap points.\\n\n .value[2].i32: Whether to enable the snap to end feature. When scroll snapping is defined for the\n <b><Scroll></b> component, setting this attribute to <b>false</b> enables the component to scroll between the\n end edge and the last snap point. The default value is <b>true</b>. It is valid only when there are multiple\n snap points.\\n\n .value[3...].f32: snap points for the <b><Scroll></b> component. Each snap point defines the offset from an\n edge to which the <b><Scroll></b> component can scroll.  \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode for the scroll snap position. The parameter type is {@link ArkUI_ScrollSnapAlign}.\\n\n .value[1].i32: whether to enable the snap to start feature. When scroll snapping is defined for the\n <b><Scroll></b> component, setting this attribute to <b>false</b> enables the component to scroll between the\n start edge and the first snap point.\\n\n .value[2].i32: Whether to enable the snap to end feature. When scroll snapping is defined for the\n <b><Scroll></b> component, setting this attribute to <b>false</b> enables the component to scroll between the\n end edge and the last snap point.\\n\n .value[3...].f32: snap points for the <b><Scroll></b> component. Each snap point defines the offset from an edge\n to which the <b><Scroll></b> component can scroll. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_SNAP: ArkUI_NodeAttributeType = 1002007;
#[doc = " @brief Defines the nested scrolling options. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: nested scrolling option when the component scrolls forward.\n The parameter type is {@link ArkUI_ScrollNestedMode}. \\n\n .value[1].i32: nested scrolling option when the component scrolls backward.\n The parameter type is {@link ArkUI_ScrollNestedMode}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: nested scrolling option when the component scrolls forward.\n The parameter type is {@link ArkUI_ScrollNestedMode}. \\n\n .value[1].i32: nested scrolling option when the component scrolls backward.\n The parameter type is {@link ArkUI_ScrollNestedMode}.\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_NESTED_SCROLL: ArkUI_NodeAttributeType = 1002008;
#[doc = " @brief Defines the specified position to scroll to. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: horizontal scrolling offset, in vp. \\n\n .value[1].f32: vertical scrolling offset, in vp. \\n\n .value[2]?.i32: scrolling duration, in milliseconds. Optional. \\n\n .value[3]?.i32: scrolling curve. Optional. The parameter type is {@link ArkUI_AnimationCurve}.\n The default value is <b>ARKUI_CURVE_EASE</b>. \\n\n .value[4]?.i32: whether to enable the default spring animation. Optional. The default value <b>0</b> means not\n to enable the default spring animation. \\n\n .value[5]?.i32: Optional value, sets whether scrolling can cross the boundary. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: horizontal scrolling offset, in vp. \\n\n .value[1].f32: vertical scrolling offset, in vp. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_OFFSET: ArkUI_NodeAttributeType = 1002009;
#[doc = " @brief Defines the edge position to scroll to. This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: edge position to scroll to. The parameter type is {@link ArkUI_ScrollEdge}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether the container at the edge position. The value <b>-1</b> means that the container is not\n at the edge position. If the container is at the edge position, the parameter type is {@link ArkUI_ScrollEdge}.\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_EDGE: ArkUI_NodeAttributeType = 1002010;
#[doc = " @brief Defines whether to enable the swipe-to-turn-pages feature. This attribute can be set, reset, and obtained\n as required through APIs.\n\n If both <b>enablePaging</b> and <b>scrollSnap</b> are set, <b>scrollSnap</b> takes effect, but\n <b>enablePaging</b> does not. \\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the swipe-to-turn-pages feature. The default value is <b>false</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable the swipe-to-turn-pages feature. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_ENABLE_PAGING: ArkUI_NodeAttributeType = 1002011;
#[doc = " @brief Scroll to the next or previous page.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32 Indicates whether to scroll to next page. Value 0 indicates scroll to next page and value 1\n indicates scroll to previous page. \\n\n .value[1]?.i32 Indicates whether to enable animation. Value 1 indicates enable and 0 indicates disable. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_PAGE: ArkUI_NodeAttributeType = 1002012;
#[doc = " @brief Scroll a specified distance.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32：Horizontal scrolling distance in vp; \\n\n .value[1].f32: Vertical scrolling distance in vp; \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BY: ArkUI_NodeAttributeType = 1002013;
#[doc = " @brief Performs inertial scrolling based on the initial velocity passed in.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: Initial velocity of inertial scrolling. Unit: vp/s. If the value specified is 0, it is\n considered as invalid, and the scrolling for this instance will not take effect. If the value is positive,\n the scroll will move downward; if the value is negative, the scroll will move upward. \\n\n\n @since 13"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_FLING: ArkUI_NodeAttributeType = 1002014;
#[doc = " @brief Sets the fading effect for the edges of scrollable components.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\n .value[0].i32: whether to enable the fading effect on edges. The value 0 means to disable the fading effect,\n and 1 means to enable it.\n .value[1]?.f32: length of the fading effect on edges, in vp. Default value: 32.\n\n Format of the return value {@link ArkUI_AttributeItem}:\n .value[0].i32: whether the fading effect on edges is enabled. The value 0 means that the fading effect is\n disabled, and 1 means that it is enabled.\n .value[1].f32: length of the fading effect on edges, in vp.\n\n @since 14"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_FADING_EDGE: ArkUI_NodeAttributeType = 1002015;
#[doc = " @brief Obtains the total size of all child components when fully expanded in the scrollable component.\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: total width of all child components when fully expanded in the scrollable component.\n                The default unit is vp. \\n\n .value[1].f32: total height of all child components when fully expanded in the scrollable component.\n                The default unit is vp. \\n\n When <b>NODE_PADDING</b>, <b>NODE_MARGIN</b>, or <b>NODE_BORDER_WIDTH</b> is set, the values are rounded to the\n nearest pixel when being converted from vp to px.\n The returned values are calculated based on these rounded pixel values. \\n\n\n @since 14"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_SIZE: ArkUI_NodeAttributeType = 1002016;
#[doc = " @brief Sets the offset from the start of the scrollable components content.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: offset from the start of the content, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: offset from the start of the content, in vp. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_CONTENT_START_OFFSET: ArkUI_NodeAttributeType =
    1002017;
#[doc = " @brief Sets the offset from the end of the scrollable components content.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: offset from the end of the content, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: offset from the end of the content, in vp. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_CONTENT_END_OFFSET: ArkUI_NodeAttributeType = 1002018;
#[doc = " @brief Defines whether the scrollable scrolls back to top when status bar is clicked.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute: \\n\n .value[0].i32: whether the scrollable scrolls back to top when status bar is clicked.\n The value <b>1</b> means to scroll back to top, and <b>0</b> means the opposite. The default value is <b>0/b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}: \\n\n .value[0].i32: whether the scrollable scrolls back to top when status bar is clicked. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_SCROLL_BACK_TO_TOP: ArkUI_NodeAttributeType = 1002021;
#[doc = " @brief Defines the direction in which the list items are arranged. This attribute can be set, reset, and\n obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: direction in which the list items are arranged. The parameter type is {@link ArkUI_Axis}.\n The default value is <b>ARKUI_AXIS_VERTICAL</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: direction in which the list items are arranged. The parameter type is {@link ArkUI_Axis}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_DIRECTION: ArkUI_NodeAttributeType = 1003000;
#[doc = " @brief Defines whether to pin the header to the top or the footer to the bottom in the <b><ListItemGroup></b>\n component. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to pin the header to the top or the footer to the bottom in the <b><ListItemGroup></b>\n component. It is used together with the <b><ListItemGroup></b> component. The parameter type is\n {@link ArkUI_StickyStyle}. The default value is <b>ARKUI_STICKY_STYLE_NONE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to pin the header to the top or the footer to the bottom in the <b><ListItemGroup></b>\n component. It is used together with the <b><ListItemGroup></b> component. The parameter type is\n {@link ArkUI_StickyStyle}.\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_STICKY: ArkUI_NodeAttributeType = 1003001;
#[doc = " @brief Defines the spacing between list items. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: spacing between list items along the main axis. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: spacing between list items along the main axis. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_SPACE: ArkUI_NodeAttributeType = 1003002;
#[doc = " @brief Defines the list adapter. The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_NODE_ADAPTER: ArkUI_NodeAttributeType = 1003003;
#[doc = " @brief Sets the number of cached items in the list adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of cached items in the list adapter. \\n\n .value[1]?.i32: whether to show cached items. The value <b>0</b> means to hide cached items, and <b>0</b> means\n to show cached items. The default value is <b>0</b>. This parameter is supported since API version 15. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: number of cached items in the list adapter. \\n\n .value[1].i32: whether to show cached items. The value <b>0</b> means to hide cached items, and <b>0</b> means\n to show cached items. This parameter is supported since API version 15. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_CACHED_COUNT: ArkUI_NodeAttributeType = 1003004;
#[doc = " @brief Scroll to the specified index.\n\n When activating the smooth animation, all items passed through will be loaded and layout calculated, which can\n lead to performance issues when loading a large number of items.\\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32：The index value of the target element to be slid to in the current container.\\n\n .value[1]?.i32：Set whether there is an action when sliding to the index value of a list item in the list, where\n 1 indicates an action and 0 indicates no action. Default value: 0。\\n\n .value[2]?.i32：Specify the alignment of the sliding element with the current container,The parameter type is\n {@link ArkUI_ScrollAlignment}, default value is ARKUI_SCROLL_ALIGNMENT_START. \\n\n .value[3]?.f32: extra offset, in vp. The default value is <b>0</b>.\n This parameter is supported since API version 15. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_SCROLL_TO_INDEX: ArkUI_NodeAttributeType = 1003005;
#[doc = " @brief Sets the alignment mode of list items along the cross axis when the cross-axis width of the list is\n greater than the cross-axis width of list items multiplied by the value of lanes.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode of list items along the cross axis.\n The parameter type is {@link ArkUI_ListItemAlignment}. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: alignment mode of list items along the cross axis.\n The parameter type is {@link ArkUI_ListItemAlignment}. \\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ALIGN_LIST_ITEM: ArkUI_NodeAttributeType = 1003006;
#[doc = " @brief Set the default spindle size for the List subcomponent.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: The parameter format is {@ ArkUI-ListChildrenMainSize} \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: The parameter format is {@ ArkUI-ListChildrenMainSize} \\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_CHILDREN_MAIN_SIZE: ArkUI_NodeAttributeType = 1003007;
#[doc = " @brief Set the index value of the item displayed at the start of the viewport\n when the current List is first loaded.This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: index value of the item displayed at\n the start of the viewport when the current List is loaded for the first time. Default value: 0.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: index value of the item displayed at\n the start of the viewport when the current List is loaded for the first time. Default value: 0.\\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_INITIAL_INDEX: ArkUI_NodeAttributeType = 1003008;
#[doc = " @brief sets the ListItem splitter style. By default, there is no splitter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} Format: \\n\n.value[0].u32: divider color, type 0xargb; \\n\n.value[1].f32: dividing line width; \\n\n.value[2].f32: the distance between the divider and the beginning of the side of the list, unit vp; \\n\n.value[3].f32: the distance between the divider and the end of the side of the list (unit: vp). \\n\n \\n\n Attribute fetch method return value {@link ArkUI_AttributeItem} format: \\n\n.value[0].u32: divider color, type 0xargb; \\n\n.value[1].f32: dividing line width; \\n\n.value[2].f32: the distance between the divider and the beginning of the side of the list, unit vp; \\n\n.value[3].f32: the distance between the divider and the end of the side of the list (unit: vp). \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_DIVIDER: ArkUI_NodeAttributeType = 1003009;
#[doc = " @brief Scrolls to the item with the specified index in the specified list item group.\n\n When <b>smooth</b> is set to <b>true</b>, all passed items are loaded and counted in layout calculation.\n This may result in performance issues if a large number of items are involved. \\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: index of the target list item group in the current list. \\n\n.value[1].i32: index of the target list item in the list item group. \\n\n .value[2]?.i32: whether to enable the smooth animation for scrolling to the item with the specified index.\n The value <b>1</b> means to enable the animation, and <b>0</b> means the opposite.\n The default value is <b>0</b>. \\n\n .value[3]?.i32: how the item to scroll to is aligned with the container. The parameter type is\n {@link ArkUI_ScrollAlignment}. The default value is <b>ARKUI_SCROLL_ALIGNMENT_START</b>. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_LIST_SCROLL_TO_INDEX_IN_GROUP: ArkUI_NodeAttributeType =
    1003010;
#[doc = " @brief Sets the number of lanes in the list.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: number of lanes in the list. If the maximum and minimum lane widths are set, setting the number\n of lanes will not take effect. \\n\n .value[1]?.f32: minimum lane width, in vp. \\n\n .value[2]?.f32: maximum column width, in vp. \\n\n .value[3]?.f32: lane spacing, in vp. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: number of lanes in the list. \\n\n .value[1].f32: minimum lane width, in vp. \\n\n .value[2].f32: maximum column width, in vp. \\n\n .value[3].f32: lane spacing, in vp. \\n \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_LIST_LANES: ArkUI_NodeAttributeType = 1003011;
#[doc = " @brief Sets the list snap alignment mode.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: alignment mode for the list snap position. The parameter type is {@link ArkUI_ScrollSnapAlign}.\n The default value is <b>ARKUI_SCROLL_SNAP_ALIGN_NONE</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n.value[0].i32: alignment mode for the list snap position. The parameter type is {@link ArkUI_ScrollSnapAlign}.\\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_LIST_SCROLL_SNAP_ALIGN: ArkUI_NodeAttributeType = 1003012;
#[doc = " @brief Sets whether to maintain the visible content's position when data is inserted or deleted outside the\n display area of the <b>List</b> component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to maintain the visible content's position when data is inserted or deleted outside the\n display area of the <b>List</b> component. The value <b>0</b> means not to maintain the visible content's\n position, and <b>1</b> means the opposite. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to maintain the visible content's position when data is inserted or deleted outside the\n display area of the <b>List</b> component. The value <b>0</b> means not to maintain the visible content's\n position, and <b>1</b> means the opposite. The default value is <b>0</b>. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_LIST_MAINTAIN_VISIBLE_CONTENT_POSITION:
    ArkUI_NodeAttributeType = 1003013;
#[doc = " @brief Defines whether to enable loop playback for the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable loop playback. The value <b>1</b> means to enable loop playback, and <b>0</b>\n means the opposite. The default value is <b>1/b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable loop playback. The value <b>1</b> means to enable loop playback, and <b>0</b>\n means the opposite. The default value is <b>1</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_LOOP: ArkUI_NodeAttributeType = 1001000;
#[doc = " @brief Defines whether to enable automatic playback for child component switching in the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable automatic playback for child component switching. The value <b>1</b>\n means to enable automatic playback, and <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable automatic playback for child component switching. The value <b>1</b> means\n to enable automatic playback, and <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_AUTO_PLAY: ArkUI_NodeAttributeType = 1001001;
#[doc = " @brief Defines whether to enable the navigation point indicator for the swiper. This attribute can be set,\n reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to enable the navigation point indicator. The value <b>1</b> means to enable the\n navigation point indicator, and <b>0</b> means the opposite. The default value is <b>1</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to enable the navigation point indicator. The value <b>1</b> means to enable the\n navigation point indicator, and <b>0</b> means the opposite. The default value is <b>1</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_SHOW_INDICATOR: ArkUI_NodeAttributeType = 1001002;
#[doc = " @brief Defines the interval for automatic playback. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: interval for automatic playback, in milliseconds. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: interval for automatic playback, in milliseconds. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_INTERVAL: ArkUI_NodeAttributeType = 1001003;
#[doc = " @brief Defines whether vertical swiping is used for the swiper. This attribute can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether vertical swiping is used. The value <b>1</b> means that vertical swiping is used, and\n <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether vertical swiping is used. The value <b>1</b> means that vertical swiping is used, and\n <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_VERTICAL: ArkUI_NodeAttributeType = 1001004;
#[doc = " @brief Defines the duration of the animation for switching child components. This attribute can be set, reset,\n and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: duration of the animation for switching child components, in milliseconds. The default value is\n <b>400</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: duration of the animation for switching child components, in milliseconds. The default value is\n <b>400</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_DURATION: ArkUI_NodeAttributeType = 1001005;
#[doc = " @brief Defines the animation curve for the swiper. This attribute can be set, reset, and obtained as required\n through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: animation curve. The parameter type is {@link ArkUI_AnimationCurve}.\n The default value is <b>ARKUI_CURVE_LINEAR</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: animation curve. The parameter type is {@link ArkUI_AnimationCurve}.\n The default value is <b>ARKUI_CURVE_LINEAR</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_CURVE: ArkUI_NodeAttributeType = 1001006;
#[doc = " @brief Defines the spacing between child components in the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: spacing between child components. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: spacing between child components. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_ITEM_SPACE: ArkUI_NodeAttributeType = 1001007;
#[doc = " @brief Defines the index of the child component currently displayed in the swiper.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: index value of the child component. \\n\n .value[1]?.i32: animation mode, the parameter type is {@link ArkUI_SwiperAnimationMode}. \\n\n The default value is ARKUI_SWIPER_NO_ANIMATION. This parameter is valid only for the current call. \\n\n This parameter is supported since API version 15. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: index value of the child component. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_INDEX: ArkUI_NodeAttributeType = 1001008;
#[doc = " @brief Defines the number of elements to display per page.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: index value of the child component. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: index value of the child component. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_DISPLAY_COUNT: ArkUI_NodeAttributeType = 1001009;
#[doc = " @brief Defines whether to disable the swipe feature.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to disable the swipe feature. The value <b>1</b> means to disable\n the swipe feature, and <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to disable the swipe feature. The value <b>1</b> means to disable the swipe\n feature, and <b>0</b> means the opposite. The default value is <b>0</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_DISABLE_SWIPE: ArkUI_NodeAttributeType = 1001010;
#[doc = " @brief Defines whether to show the arrow when the mouse pointer hovers over the navigation point indicator.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to show the arrow when the mouse pointer hovers over the navigation point indicator.\n The parameter type is {@link ArkUI_SwiperArrow}.\\n\n The default value is <b>ARKUI_SWIPER_ARROW_HIDE</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to show the arrow when the mouse pointer hovers over the navigation point indicator.\n The parameter type is {@link ArkUI_SwiperArrow}.\\n\n The default value is <b>ARKUI_SWIPER_ARROW_HIDE</b>. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_SHOW_DISPLAY_ARROW: ArkUI_NodeAttributeType = 1001011;
#[doc = " @brief Defines the effect used at the edges of the swiper when the boundary of the scrollable content is reached.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: effect used at the edges of the swiper when the boundary of the scrollable content is reached.\n The parameter type is {@link ArkUI_EdgeEffect}.\\n\n The default value is <b>ARKUI_EDGE_EFFECT_SPRING</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: effect used at the edges of the swiper when the boundary of the scrollable content is reached.\n The parameter type is {@link ArkUI_EdgeEffect}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_EDGE_EFFECT_MODE: ArkUI_NodeAttributeType = 1001012;
#[doc = " @brief Defines the swiper adapter. The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_NODE_ADAPTER: ArkUI_NodeAttributeType = 1001013;
#[doc = " @brief Sets the number of cached items in the swiper adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of cached items in the swiper adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_CACHED_COUNT: ArkUI_NodeAttributeType = 1001014;
#[doc = " @brief Defines the front margin of the wiper.\n The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: the front margin. The unit is vp. The default value is <b>0.0</b>\\n\n .value[1]?.i32: whether to ignore blanks, the default value is 0.\n The value <b>1</b> means to ignore blank areas, and <b>0</b> means the opposite. \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: the front margin, the unit is vp. \\n\n .value[1].i32: whether to ignore blank areas. The value <b>1</b> means to ignore blank areas, and <b>0</b> means\n the opposite. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_PREV_MARGIN: ArkUI_NodeAttributeType = 1001015;
#[doc = " @brief Defines the back margin of the wiper.\n The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: the back margin. The unit is vp. The default value is <b>0.0</b>\\n\n .value[1]?.i32: whether to ignore blanks, the default value is 0.\n The value <b>1</b> means to ignore blank areas, and <b>0</b> means the opposite. \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: the back margin, the unit is vp. \\n\n .value[1].i32: whether to ignore blank areas. The value <b>1</b> means to ignore blank areas, and <b>0</b> means\n the opposite. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_NEXT_MARGIN: ArkUI_NodeAttributeType = 1001016;
#[doc = " @brief Defines the navigation indicator type of the swiper.\n The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: navigation indicator type, the parameter type is {@link ArkUI_SwiperIndicatorType}.\\n\n .object: The parameter type is {@link ArkUI_SwiperIndicator}.\\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: navigation indicator type, the parameter type is {@link ArkUI_SwiperIndicatorType}.\\n\n .object: The parameter type is {@link ArkUI_SwiperIndicator}.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_INDICATOR: ArkUI_NodeAttributeType = 1001017;
#[doc = " @brief Set the nested scrolling mode for the Swiper component and parent component.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32：Nested scrolling patterns for Swiper components and parent components. The parameter type is\n {@link ArkUI_SwiperNestedScrollMode} \\n\n The default value is <b>ARKUI_SWIPER_NESTED_SRCOLL_SELF_ONLY<b> \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32：Nested scrolling patterns for Swiper components and parent components. The parameter type is\n {@link ArkUI_SwiperNestedScrollMode} \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_NESTED_SCROLL: ArkUI_NodeAttributeType = 1001018;
#[doc = " @brief Set the switcher component to flip to the specified page.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32：Specify the index value of the page in Swiper.\\n\n .value[1]?.i32：Set whether there is an animation effect when flipping to the specified page. 1 indicates active\n effect, 0 indicates no active effect, default value is 0。\\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_SWIPE_TO_INDEX: ArkUI_NodeAttributeType = 1001019;
#[doc = " @brief Set to disable component navigation point interaction function。\n\n Property setting method parameter {@link ArkUI-AttributeItem} format: \\n\n .value[0].i32：Set to disable the interaction function of component navigation points. When set to true, it\n indicates that the navigation points are interactive. The default value is true. \\n\n The return value of the attribute acquisition method is in the format of {@ link ArkUI-AttributeItem}： \\n\n .value[0].i32：Set to disable component navigation point interaction. \\n"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_INDICATOR_INTERACTIVE: ArkUI_NodeAttributeType =
    1001020;
#[doc = " @brief Sets the page flipping mode using the mouse wheel.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: page flipping mode using the mouse wheel. The parameter type is {@link ArkUI_PageFlipMode}. \\n\n \\n\n Format of the return value {@link ArkUI_PageFlipMode}:\\n\n .value[0].i32: page flipping mode using the mouse wheel. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_SWIPER_PAGE_FLIP_MODE: ArkUI_NodeAttributeType = 1001021;
#[doc = " @brief: Set the delineation component of the ListItem, supporting property settings, property resets, and\n property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .object: Construct using the {@link ArkUI_ListitemSwipeActionOption} object. \\n\n \\n\n The return value of the attribute acquisition method {@link ArkUI_AttributeItem} format: \\n\n .object: Construct using the {@link ArkUI_ListitemSwipeActionOption} object. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_SWIPE_ACTION: ArkUI_NodeAttributeType = 1004000;
#[doc = " @brief Defines the header of the list item group.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeHandle} object to be used as the header of the list item group. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: {@link ArkUI_NodeHandle} object to be used as the header of the list item group. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_SET_HEADER: ArkUI_NodeAttributeType =
    1005000;
#[doc = " @brief Defines the footer of the list item group. This attribute can be set, reset, and obtained as\n required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeHandle} object to be used as the footer of the list item group. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: {@link ArkUI_NodeHandle} object to be used as the footer of the list item group. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_SET_FOOTER: ArkUI_NodeAttributeType =
    1005001;
#[doc = " @brief Defines the style of the divider for the list items. This attribute can be set, reset, and obtained\n as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].u32: color of the divider, in 0xARGB format.\\n\n .value[1].f32: stroke width of the divider, in vp.\\n\n .value[2].f32: distance between the divider and the start of the list, in vp.\\n\n .value[3].f32: distance between the divider and the end of the list, in vp.\\n \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].u32: color of the divider, in 0xARGB format.\\n\n .value[1].f32: stroke width of the divider, in vp.\\n\n .value[2].f32: distance between the divider and the start of the list, in vp.\\n\n .value[3].f32: distance between the divider and the end of the list, in vp.\\n \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_SET_DIVIDER: ArkUI_NodeAttributeType =
    1005002;
#[doc = " @brief Set the default spindle size for the ListItem Group subcomponent.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: The parameter format is {@ ArkUI-ListChildrenMainSize} \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: The parameter format is {@ ArkUI-ListChildrenMainSize} \\n"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_CHILDREN_MAIN_SIZE: ArkUI_NodeAttributeType =
    1005003;
#[doc = " @brief Defines the list item group adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: {@link ArkUI_NodeAdapter} object. \\n\n\n @since 15"]
pub const ArkUI_NodeAttributeType_NODE_LIST_ITEM_GROUP_NODE_ADAPTER: ArkUI_NodeAttributeType =
    1005004;
#[doc = " @brief Defines the horizontal alignment mode of child components in the column.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: horizontal alignment mode of child components.\n The parameter type is {@link ArkUI_HorizontalAlignment}.\\n\n Default value: <b>ARKUI_HORIZONTAL_ALIGNMENT_CENTER</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: horizontal alignment mode of child components.\n The parameter type is {@link ArkUI_HorizontalAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_COLUMN_ALIGN_ITEMS: ArkUI_NodeAttributeType = 1006000;
#[doc = " @brief Defines the vertical alignment mode of child components in the column.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: vertical alignment mode of child components. The parameter type is {@link ArkUI_FlexAlignment}.\\n\n Default value: <b>ARKUI_FLEX_ALIGNMENT_START</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: vertical alignment mode of child components. The parameter type is {@link ArkUI_FlexAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_COLUMN_JUSTIFY_CONTENT: ArkUI_NodeAttributeType = 1006001;
#[doc = " @brief Defines the vertical alignment mode of child components in the row.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: vertical alignment mode of child components.\n The parameter type is {@link ArkUI_VerticalAlignment}.\\n\n Default value: <b>ARKUI_VERTICAL_ALIGNMENT_CENTER</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: vertical alignment mode of child components.\n The parameter type is {@link ArkUI_VerticalAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ROW_ALIGN_ITEMS: ArkUI_NodeAttributeType = 1007000;
#[doc = " @brief Defines the horizontal alignment mode of child components in the row.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: horizontal alignment mode of child components.\n The parameter type is {@link ArkUI_FlexAlignment}.\\n\n Default value: <b>ARKUI_FLEX_ALIGNMENT_START</b>. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: horizontal alignment mode of child components.\n The parameter type is {@link ArkUI_FlexAlignment}. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_ROW_JUSTIFY_CONTENT: ArkUI_NodeAttributeType = 1007001;
#[doc = " @brief Defines the flex attribute. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0]?.i32: direction in which flex items are arranged. The parameter type is {@link ArkUI_FlexDirection}.\n The default value is <b>ARKUI_FLEX_DIRECTION_ROW</b>.\\n\n .value[1]?.i32: how the flex items are wrapped. The parameter type is {@link ArkUI_FlexWrap}.\n The default value is <b>ARKUI_FLEX_WRAP_NO_WRAP</b>.\\n\n .value[2]?.i32: alignment mode along the main axis. The parameter type is {@link ArkUI_FlexAlignment}.\n The default value is <b>ARKUI_FLEX_ALIGNMENT_START</b>.\\n\n .value[3]?.i32: alignment mode along the cross axis. The parameter type is {@link ArkUI_ItemAlignment}.\n The default value is <b>ARKUI_ITEM_ALIGNMENT_START</b>.\\n\n .value[4]?.i32: alignment mode along the cross axis for multi-line content. The parameter type is\n {@link ArkUI_FlexAlignment}. The default value is <b>ARKUI_FLEX_ALIGNMENT_START</b>.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: direction in which flex items are arranged. \\n\n .value[1].i32: how the flex items are wrapped. \\n\n .value[2].i32: alignment mode along the main axis. \\n\n .value[3].i32: alignment mode along the cross axis. \\n\n .value[4].i32: alignment mode along the cross axis for multi-line content.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_FLEX_OPTION: ArkUI_NodeAttributeType = 1008000;
#[doc = " @brief Sets whether the component is being refreshed.\n This attribute can be set and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: The parameter type is 1 or 0.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: The parameter type is 1 or 0.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_REFRESHING: ArkUI_NodeAttributeType = 1009000;
#[doc = " @brief Sets the custom content in the pull-down area.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: The parameter type is {@Link ArkUI_NodeHandle}.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_CONTENT: ArkUI_NodeAttributeType = 1009001;
#[doc = " @brief Set the pull-down hand coefficient.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32：Pull-down hand coefficient, valid value between 0 and 1.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32：Pull-down hand coefficient, valid value between 0 and 1.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_PULL_DOWN_RATIO: ArkUI_NodeAttributeType = 1009002;
#[doc = " @brief Sets the pull-down offset that initiates a refresh.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: pull-down offset, in vp. The default value is <b>64vp</b>.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: pull-down offset, in vp. The default value is <b>64vp</b>.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_OFFSET: ArkUI_NodeAttributeType = 1009003;
#[doc = " @brief Sets whether to initiate a refresh when the pull-down distance exceeds the value of <b>refreshOffset</b>.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: whether to initiate a refresh. The value <b>true</b> means to initiate a refresh, and\n <b>false</b> means the opposite.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: whether to initiate a refresh. The value <b>1</b> means to initiate a refresh, and\n <b>0</b> means the opposite.\n"]
pub const ArkUI_NodeAttributeType_NODE_REFRESH_PULL_TO_REFRESH: ArkUI_NodeAttributeType = 1009004;
#[doc = " @brief Defines the main axis direction of the <b><WaterFlow></b> component layout.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: main axis direction. The parameter type is {@Link ArkUI_FlexDirection}.\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].i32: main axis direction. The parameter type is {@Link ArkUI_FlexDirection}.\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_LAYOUT_DIRECTION: ArkUI_NodeAttributeType =
    1010000;
#[doc = " @brief Sets the number of columns in the water flow layout. If this parameter is not set, one column is used\n by default. This attribute can be set, reset, and obtained as required through APIs.\n For example, <b>'1fr 1fr 2fr'</b> indicates three columns, with the first column taking up 1/4 of the parent\n component's full width, the second column 1/4, and the third column 2/4.\n You can use <b>columnsTemplate('repeat(auto-fill,track-size)')</b> to automatically calculate the number of\n columns based on the specified column width <b>track-size</b>.\n <b>repeat</b> and <b>auto-fill</b> are keywords. The units for <b>track-size</b> can be px, vp (default), %,\n or a valid number.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: number of columns in the layout.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: number of columns in the layout.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_COLUMN_TEMPLATE: ArkUI_NodeAttributeType =
    1010001;
#[doc = " @brief Sets the number of rows in the water flow layout. If this parameter is not set, one row is used\n by default. This attribute can be set, reset, and obtained as required through APIs.\n For example, <b>'1fr 1fr 2fr'</b> indicates three rows, with the first row taking up 1/4 of the parent\n component's full height, the second row 1/4, and the third row 2/4.\n You can use <b>rowsTemplate('repeat(auto-fill,track-size)')</b> to automatically calculate the number of rows\n based on the specified row height <b>track-size</b>.\n <b>repeat</b> and <b>auto-fill</b> are keywords. The units for <b>track-size</b> can be px, vp (default), %,\n or a valid number.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: number of rows in the layout. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: number of rows in the layout. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_ROW_TEMPLATE: ArkUI_NodeAttributeType = 1010002;
#[doc = " @brief Sets the gap between columns.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: gap between columns, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: gap between columns, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_COLUMN_GAP: ArkUI_NodeAttributeType = 1010003;
#[doc = " @brief Sets the gap between rows.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: gap between lines, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: gap between lines, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_ROW_GAP: ArkUI_NodeAttributeType = 1010004;
#[doc = " @brief Defines the water flow section configuration.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: An index calculated from 0 is converted to an integer,\n indicating that you want to start changing the position of the group.\n .object: {@ArkUI_WaterFlowSectionOption} object.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .object: {@ArkUI_WaterFlowSectionOption} object.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_SECTION_OPTION: ArkUI_NodeAttributeType = 1010005;
#[doc = " @brief Defines the water flow adapter. The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_NODE_ADAPTER: ArkUI_NodeAttributeType = 1010006;
#[doc = " @brief Sets the number of cached items in the water flow adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of cached items in the water flowadapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_CACHED_COUNT: ArkUI_NodeAttributeType = 1010007;
#[doc = " @brief Set the custom display component at the end of the waterfall flow component.\n\n Attribute setting method {@link ArkUI_AttributeItem} parameter format: \\n\n .object: Parameter type {@link ArkUI_NodeHandle}.\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_FOOTER: ArkUI_NodeAttributeType = 1010008;
#[doc = " @brief Scroll to the specified index.\n\n When activating the smooth animation, all items passed through will be loaded and layout calculated, which can\n lead to performance issues when loading a large number of items.\\n\n \\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32：The index value of the target element to be slid to in the current container.\\n\n .value[1]?.i32：Set whether there is an action when sliding to the index value of a list item in the list, where\n 1 indicates an action and 0 indicates no action. Default value is 0。\\n\n .value[2]?.i32：Specify the alignment of the sliding element with the current container，The parameter type is\n {@link ArkUI_ScrollAlignment}. Default value is </b>ARKUI_SCROLL_ALIGNMENT_START</b>。\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_SCROLL_TO_INDEX: ArkUI_NodeAttributeType =
    1010009;
#[doc = " @brief Defines the size constraints to apply to water flow items.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: minimum width, in vp.\\n\n .value[1].f32: maximum width, in vp.\\n\n .value[2].f32: minimum height, in vp.\\n\n .value[3].f32: maximum height, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: minimum width, in vp.\\n\n .value[1].f32: maximum width, in vp.\\n\n .value[2].f32: minimum height, in vp.\\n\n .value[3].f32: maximum height, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_WATER_FLOW_ITEM_CONSTRAINT_SIZE: ArkUI_NodeAttributeType =
    1010010;
#[doc = " @brief Set the auxiliary line in the RelativeContaine container, supporting property setting,\n property reset and property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .object: Auxiliary lines within the RelativeContaine container: \\n\n\\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .object: Auxiliary lines within the RelativeContaine container: \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RELATIVE_CONTAINER_GUIDE_LINE: ArkUI_NodeAttributeType =
    1012000;
#[doc = " @brief Sets the barrier within the RelativeContaine container and supports property setting,\n property reset and property acquisition interfaces.\n\n Attribute setting method parameter {@link ArkUI_AttributeItem} format: \\n\n .object: Auxiliary lines within the RelativeContaine container: \\n\n\\n\n Attribute acquisition method return value {@link ArkUI_AttributeItem} format: \\n\n .object: Barrier within the RelativeContaine container: \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_RELATIVE_CONTAINER_BARRIER: ArkUI_NodeAttributeType =
    1012001;
#[doc = " @brief Sets the number of columns in the grid layout. If this parameter is not set, one column is used\n by default. This attribute can be set, reset, and obtained as required through APIs.\n For example, <b>'1fr 1fr 2fr'</b> indicates three columns, with the first column taking up 1/4 of the parent\n component's full width, the second column 1/4, and the third column 2/4.\n You can use <b>columnsTemplate('repeat(auto-fill,track-size)')</b> to automatically calculate the number of\n columns based on the specified column width <b>track-size</b>.\n <b>repeat</b> and <b>auto-fill</b> are keywords. The units for <b>track-size</b> can be px, vp (default), %,\n or a valid number.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: number of columns in the layout.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: number of columns in the layout.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_COLUMN_TEMPLATE: ArkUI_NodeAttributeType = 1013000;
#[doc = " @brief Sets the number of rows in the grid layout. If this parameter is not set, one row is used\n by default. This attribute can be set, reset, and obtained as required through APIs.\n For example, <b>'1fr 1fr 2fr'</b> indicates three rows, with the first row taking up 1/4 of the parent\n component's full height, the second row 1/4, and the third row 2/4.\n You can use <b>rowsTemplate('repeat(auto-fill,track-size)')</b> to automatically calculate the number of rows\n based on the specified row height <b>track-size</b>.\n <b>repeat</b> and <b>auto-fill</b> are keywords. The units for <b>track-size</b> can be px, vp (default), %,\n or a valid number.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .string: number of rows in the layout. \\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .string: number of rows in the layout. \\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_ROW_TEMPLATE: ArkUI_NodeAttributeType = 1013001;
#[doc = " @brief Sets the gap between columns. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: gap between columns, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: gap between columns, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_COLUMN_GAP: ArkUI_NodeAttributeType = 1013002;
#[doc = " @brief Sets the gap between rows. This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].f32: gap between lines, in vp.\\n\n \\n\n Format of the return value {@link ArkUI_AttributeItem}:\\n\n .value[0].f32: gap between lines, in vp.\\n\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_ROW_GAP: ArkUI_NodeAttributeType = 1013003;
#[doc = " @brief Defines the grid adapter. The attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .object: {@link ArkUI_NodeAdapter} object as the adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_NODE_ADAPTER: ArkUI_NodeAttributeType = 1013004;
#[doc = " @brief Sets the number of cached items in the grid adapter.\n This attribute can be set, reset, and obtained as required through APIs.\n\n Format of the {@link ArkUI_AttributeItem} parameter for setting the attribute:\\n\n .value[0].i32: number of cached items in the grid adapter. \\n"]
pub const ArkUI_NodeAttributeType_NODE_GRID_CACHED_COUNT: ArkUI_NodeAttributeType = 1013005;
#[doc = " @brief Defines the ArkUI style attributes that can be set on the native side.\n\n @since 12"]
pub type ArkUI_NodeAttributeType = ::std::os::raw::c_uint;
#[doc = " @brief Defines the parameter type of the component callback event.\n\n @since 12"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ArkUI_NodeComponentEvent {
    #[doc = " Data array object."]
    pub data: [ArkUI_NumberValue; 12usize],
}
#[doc = " @brief Defines the string type parameter used by the component callback event.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_StringAsyncEvent {
    #[doc = " String."]
    pub pStr: *const ::std::os::raw::c_char,
}
#[doc = " @brief Defines a hybrid data structure for component events.\n\n @since 15"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_TextChangeEvent {
    #[doc = " String data"]
    pub pStr: *const ::std::os::raw::c_char,
    #[doc = " Extended string data"]
    pub pExtendStr: *const ::std::os::raw::c_char,
    #[doc = " Numeric data"]
    pub number: i32,
}
#[doc = " @brief Defines the gesture event type.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}."]
pub const ArkUI_NodeEventType_NODE_TOUCH_EVENT: ArkUI_NodeEventType = 0;
#[doc = " @brief Defines the mount event.\n\n This event is triggered when the component is mounted and displayed. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_APPEAR: ArkUI_NodeEventType = 1;
#[doc = " @brief Defines the unmount event.\n\n This event is triggered when the component is unmounted and hidden. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_DISAPPEAR: ArkUI_NodeEventType = 2;
#[doc = " @brief Defines the area change event.\n\n This event is triggered when the component's size, position, or any other attribute that may\n affect its display area changes. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n  {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains 12 parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: original width of the target element, in vp.\n The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: original height of the target element, in vp.\n The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: original X coordinate of the target element's upper left corner\n relative to the parent element's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[3].f32</b>: original Y coordinate of the target element's upper left corner\n relative to the parent element's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[4].f32</b>: original X coordinate of the target element's upper left corner\n relative to the page's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[5].f32</b>: original Y coordinate of the target element's upper left corner\n relative to the page's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[6].f32</b>: new width of the target element, in vp. The value is a number. \\n\n <b>ArkUI_NodeComponentEvent.data[7].f32</b>: new height of the target element, in vp. The value is a number. \\n\n <b>ArkUI_NodeComponentEvent.data[8].f32</b>: new X coordinate of the target element's upper left corner relative\n to the parent element's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[9].f32</b>: new Y coordinate of the target element's upper left corner relative\n to the parent element's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[10].f32</b>: new X coordinate of the target element's upper left corner relative\n to the page's, in vp. The value type is number. \\n\n <b>ArkUI_NodeComponentEvent.data[11].f32</b>: new Y coordinate of the target element's upper left corner relative\n to the page's, in vp. The value type is number. \\n"]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_AREA_CHANGE: ArkUI_NodeEventType = 3;
#[doc = " @brief Defines the focus event.\n\n This event is triggered when the component obtains the focus. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_ON_FOCUS: ArkUI_NodeEventType = 4;
#[doc = " @brief Defines the blur event.\n\n This event is triggered when the component loses the focus. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_ON_BLUR: ArkUI_NodeEventType = 5;
#[doc = " @brief Defines the click event.\n\n This event is triggered when the component is clicked. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains 12 parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: X coordinate of the click relative to the upper left corner of the\n clicked component's original area, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: Y coordinate of the click relative to the upper left corner of the\n clicked component's original area, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: event timestamp. It is the interval between the time when the event\n is triggered and the time when the system starts, in microseconds. \\n\n <b>ArkUI_NodeComponentEvent.data[3].i32</b>: event input device. The value <b>1</b> indicates the mouse,\n <b>2</b> indicates the touchscreen, and <b>4</b> indicates the key. \\n\n <b>ArkUI_NodeComponentEvent.data[4].f32</b>: X coordinate of the click relative to the upper left corner of the\n application window, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[5].f32</b>: Y coordinate of the click relative to the upper left corner of the\n application window, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[6].f32</b>: X coordinate of the click relative to the upper left corner of the\n application screen, in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[7].f32</b>: Y coordinate of the click relative to the upper left corner of the\n application screen, in vp. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_CLICK: ArkUI_NodeEventType = 6;
#[doc = " @brief Defines event interception.\n\n This event is triggered when the component is touched. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_TOUCH_INTERCEPT: ArkUI_NodeEventType = 7;
#[doc = " @brief Defines the visible area change event.\n\n This event is triggered when the ratio of the component's visible area to its total area is greater than or less\n than the threshold.\n Before registering this event, you must set <b>NODE_VISIBLE_AREA_CHANGE_RATIO</b>. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: how the ratio of the component's visible area to its total area\n changes compared to the previous one. The value <b>1</b> indicates an increase, and <b>0</b> indicates a\n decrease. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: ratio of the component's visible area to its total area when this\n callback is invoked. \\n"]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_VISIBLE_AREA_CHANGE: ArkUI_NodeEventType = 8;
#[doc = " @brief Defines the event triggered when the mouse pointer is moved over or away from the component.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: whether the mouse pointer is hovered over the component.\n The value <b>1</b> indicates that the mouse pointer is hovered over the component, and <b>0</b> indicates that\n the mouse pointer is moved away from the component. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_HOVER: ArkUI_NodeEventType = 9;
#[doc = " @brief Defines the click event.\n\n This event is triggered when the component is clicked by a mouse device button or when the mouse pointer moves\n within the component. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_MOUSE: ArkUI_NodeEventType = 10;
#[doc = " @brief Defines the attach event.\n\n This event is triggered when the component is attached. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_ATTACH: ArkUI_NodeEventType = 11;
#[doc = " @brief Defines the detach event.\n\n This event is triggered when the component is detached. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_EVENT_ON_DETACH: ArkUI_NodeEventType = 12;
#[doc = " @brief Defines the accessibility action event.\n\n This event is triggered when The accessibility operation type has been set and\n corresponding operations have been carried out. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].u32</b>: accessibility action type，the union type is\n {@link ArkUI_AccessibilityActionType} \\n\n"]
pub const ArkUI_NodeEventType_NODE_ON_ACCESSIBILITY_ACTIONS: ArkUI_NodeEventType = 13;
#[doc = " @brief Notifies the listener of the interaction state prior to a drop and drop operation.\n\n This event is triggered when a drag operation is about to start on a draggable item. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: corresponds to {@link ArkUI_PreDragStatus}. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_PRE_DRAG: ArkUI_NodeEventType = 14;
#[doc = " @brief Called when the user starts to drag an ite\n\n A drag operation is recognized only when the dragged item is moved far enough. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_START: ArkUI_NodeEventType = 15;
#[doc = " @brief Called when a dragged item enters the boundaries of the current component.\n\n The current component refers to the component that listens for this event. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_ENTER: ArkUI_NodeEventType = 16;
#[doc = " @brief Called  when a dragged item moves in the current component.\n\n The current component refers to the component that listens for this event. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_MOVE: ArkUI_NodeEventType = 17;
#[doc = " @brief Called when a dragged item leaves the boundaries of the current component.\n\n The current component refers to the component that listens for this event. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_LEAVE: ArkUI_NodeEventType = 18;
#[doc = " @brief Called when a dragged item is dropped on the current component.\n The component can obtain the drag data for processing through the callback.\n\n The current component refers to the component that listens for this event. \\n\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DROP: ArkUI_NodeEventType = 19;
#[doc = " @brief Called when a drag operation ends.\n The drag source can obtain the drag result by registering this callback.\n\n A drag operation ends when the dragged item is released.\n When the event callback occurs, the {@link ArkUI_DragEvent} object can be obtained from the\n {@link ArkUI_NodeEvent} object. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_DRAG_END: ArkUI_NodeEventType = 20;
#[doc = " @brief Defines the event triggered when a key event occurs.\n\n The callback can be triggered during interactions with a focused window using an external keyboard or other input\n device. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n\n @since 14"]
pub const ArkUI_NodeEventType_NODE_ON_KEY_EVENT: ArkUI_NodeEventType = 21;
#[doc = " @brief Defines the event triggered before the input method responds to the key action.\n\n If the return value of this callback is <b>true</b>, it is considered that the key event has been consumed, and\n subsequent event callbacks (<b>keyboardShortcut</b>, input method events, <b>onKeyEvent</b>) will be intercepted\n and no longer triggered.\n The callback can be triggered during interactions with a focused window using an external keyboard or other input\n device. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n\n @since 14"]
pub const ArkUI_NodeEventType_NODE_ON_KEY_PRE_IME: ArkUI_NodeEventType = 22;
#[doc = " @brief Defines the event triggered when the bound component receives a focus axis event after gaining focus.\n\n The event callback is triggered by interactions with a joystick and a focused component. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_UIInputEvent}. \\n\n\n @since 15"]
pub const ArkUI_NodeEventType_NODE_ON_FOCUS_AXIS: ArkUI_NodeEventType = 23;
#[doc = " @brief Dispatch key event on the component node.\n\n When the component node receives a key event, this callback will be triggered instead of dispatching event to its\n children. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n\n @since 15"]
pub const ArkUI_NodeEventType_NODE_DISPATCH_KEY_EVENT: ArkUI_NodeEventType = 24;
#[doc = " @brief Defines the hover event.\n\n The event is triggered when the pointer is hovered by a pen device.\n within the component. \\n\n When the event callback occurs, the {@link ArkUI_NodeEvent} object can be obtained from the\n {@link ArkUI_UIInputEvent} object. \\n\n @since 15"]
pub const ArkUI_NodeEventType_NODE_ON_HOVER_MOVE: ArkUI_NodeEventType = 29;
#[doc = " @brief Triggers onDetectResultUpdate callback\n when the text is set to TextDataDetectorConfig and recognized successfully.\n\n Trigger this event when TextDataDetectorConfig is set and recognized successfully.\\n\n When the event callback occurs, the event parameter{@link ArkUI_NodeEvent}The union type in the object is\n {@link ArkUI_StringAsyncEvent}.\\n\n {@link ArkUI_StringAsyncEvent}contains 1 parameter\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>：Indicates the result of text recognition, in Json format.\\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_ON_DETECT_RESULT_UPDATE: ArkUI_NodeEventType = 1000;
#[doc = " @brief Defines the image loading success event.\n\n This event is triggered when an image is successfully loaded or decoded. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains nine parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: loading status. The value <b>0</b> indicates that the image is\n loaded successfully, and the value <b>1</b> indicates that the image is decoded successfully. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: width of the image, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: height of the image, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[3].f32</b>: width of the component, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[4].f32</b>: height of the component, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[5].f32</b>: offset of the rendered content relative to the component on the\n x-axis, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[6].f32</b>: offset of the rendered content relative to the component on the\n y-axis, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[7].f32</b>: actual rendered width of the image, in px. \\n\n <b>ArkUI_NodeComponentEvent.data[8].f32</b>: actual rendered height of the image, in px. \\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ON_COMPLETE: ArkUI_NodeEventType = 4000;
#[doc = " @brief Defines the image loading failure event.\n\n This event is triggered when an error occurs during image loading. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>error code:\\n\n 401: The image could not be obtained because the image path is invalid. \\n\n 103101: The image format is not supported. \\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ON_ERROR: ArkUI_NodeEventType = 4001;
#[doc = " @brief Defines the SVG animation playback completion event.\n\n This event is triggered when the animation playback in the loaded SVG image is complete. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters."]
pub const ArkUI_NodeEventType_NODE_IMAGE_ON_SVG_PLAY_FINISH: ArkUI_NodeEventType = 4002;
#[doc = " @brief Defines image download process event.\n\n This event is triggered when downloading webpage images from page components.\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].u32</b>: the num of bytes downloaded. \\n\n <b>ArkUI_NodeComponentEvent.data[1].u32</b>: the total number of bytes to download. \\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ON_DOWNLOAD_PROGRESS: ArkUI_NodeEventType = 4003;
#[doc = " @brief Defines the event triggered when the toggle status changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter: \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: toggle status. <b>1</b>: on; <b>0</b>: off.\n"]
pub const ArkUI_NodeEventType_NODE_TOGGLE_ON_CHANGE: ArkUI_NodeEventType = 5000;
#[doc = " @brief Defines the event triggered when the text input content changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text input.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CHANGE: ArkUI_NodeEventType = 7000;
#[doc = " @brief Defines the event triggered when the Enter key of the text input method is pressed.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: Enter key type of the input method.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_SUBMIT: ArkUI_NodeEventType = 7001;
#[doc = " @brief Defines the event triggered when the cut button on the pasteboard, which displays when the text box\n is long pressed, is clicked.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text that is cut.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CUT: ArkUI_NodeEventType = 7002;
#[doc = " @brief Defines the event triggered when the paste button on the pasteboard, which displays when the text box\n is long pressed, is clicked.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text that is pasted\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_PASTE: ArkUI_NodeEventType = 7003;
#[doc = " @brief Defines the event triggered when the text selection position changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: start position of the text selection area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: end position of the text selection area. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_TEXT_SELECTION_CHANGE: ArkUI_NodeEventType = 7004;
#[doc = " @brief Defines the event triggered when the input status changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: <b>true</b> indicates that text input is in progress. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_EDIT_CHANGE: ArkUI_NodeEventType = 7005;
#[doc = " @brief textInput This event is triggered when the input content changes.\n\n Conditions for triggering this event: When the input content changes. \\n\n When the event callback occurs, the union type in the event parameter\n {@link ArkUI_NodeEvent} object is {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains 2 parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: Indicates the width of the text. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: Indicates the height of the text. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CONTENT_SIZE_CHANGE: ArkUI_NodeEventType = 7006;
#[doc = " @brief Defines the event triggered when matching with the regular expression specified by\n <b>NODE_TEXT_INPUT_INPUT_FILTER</b> fails.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: content that is filtered out when regular expression matching fails. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_INPUT_FILTER_ERROR: ArkUI_NodeEventType = 7007;
#[doc = " @brief This callback is triggered when the text content is scrolled.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: Indicates the horizontal offset of the text in the content area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: Indicates the vertical coordinate offset of \\n\n the text in the content area. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CONTENT_SCROLL: ArkUI_NodeEventType = 7008;
#[doc = " @brief Defines the event triggered when text is about to be entered.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>.\n @return Returns <b>true</b> if the text is entered; returns <b>false</b> otherwise.\n You can set the return value using <b>OH_ArkUI_NodeEvent_SetReturnNumberValue</b>. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_WILL_INSERT: ArkUI_NodeEventType = 7009;
#[doc = " @brief Defines the event triggered when text is entered.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>."]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_DID_INSERT: ArkUI_NodeEventType = 7010;
#[doc = " @brief Defines the event triggered when text is about to be deleted.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text to delete, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n value.i32: direction for deleting the text, with the index of <b>1</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. The value <b>0</b> indicates backward-delete, and <b>1</b> indicates\n forward-delete. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>.\n @return Returns <b>true</b> if the text is deleted; returns <b>false</b> otherwise. \\n\n You can set the return value using <b>OH_ArkUI_NodeEvent_SetReturnNumberValue</b>. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_WILL_DELETE: ArkUI_NodeEventType = 7011;
#[doc = " @brief Defines the event triggered when text is deleted.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text deleted, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n value.i32: direction for deleting the text, with the index of <b>1</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. The value <b>0</b> indicates backward-delete, and <b>1</b> indicates\n forward-delete. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>."]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_DID_DELETE: ArkUI_NodeEventType = 7012;
#[doc = " @brief Defines the event triggered when content (including preview text) changes in the <b>TextInput</b>\n component.\n\n When the event callback occurs, the union type {@link ArkUI_NodeEvent} is {@link ArkUI_TextChangeEvent}. \\n\n {@link ArkUI_TextChangeEvent} contains the following parameters: \\n\n <b>ArkUI_TextChangeEvent.pStr</b>: content in the <b>TextInput</b> component.\n <b>ArkUI_TextChangeEvent.pExtendStr</b>: content of the preview text in the <b>TextInput</b> component.\n <b>ArkUI_TextChangeEvent.number</b>: start position of the preview text in the <b>TextInput</b> component.\n\n @since 15"]
pub const ArkUI_NodeEventType_NODE_TEXT_INPUT_ON_CHANGE_WITH_PREVIEW_TEXT: ArkUI_NodeEventType =
    7013;
#[doc = " @brief Defines the event triggered when the input in the text box changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text entered.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_CHANGE: ArkUI_NodeEventType = 8000;
#[doc = " @brief Defines the event triggered when the paste button on the pasteboard, which displays when the text box is\n long pressed, is clicked.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: text that is pasted\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_PASTE: ArkUI_NodeEventType = 8001;
#[doc = " @brief Defines the event triggered when the text selection position changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: start position of the text selection area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: end position of the text selection area. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_TEXT_SELECTION_CHANGE: ArkUI_NodeEventType = 8002;
#[doc = " @brief Defines the event triggered when matching with the regular expression specified by\n <b>NODE_TEXT_AREA_INPUT_FILTER</b> fails.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n {@link ArkUI_StringAsyncEvent} contains one parameter:\\n\n <b>ArkUI_StringAsyncEvent.pStr</b>: content that is filtered out when regular expression matching fails. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_INPUT_FILTER_ERROR: ArkUI_NodeEventType = 8003;
#[doc = " @brief This callback is triggered when the text content is scrolled.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: Indicates the horizontal offset of the text in the content area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: Indicates the vertical coordinate offset of \\n\n the text in the content area. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_CONTENT_SCROLL: ArkUI_NodeEventType = 8004;
#[doc = " @brief Defines the event triggered when the input status changes.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is \\n\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: <b>true</b> indicates that text input is in progress. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_EDIT_CHANGE: ArkUI_NodeEventType = 8005;
#[doc = " @brief Defines the event triggered when the Enter key on the keyboard is pressed for the multi-line text box.\n\n This event is not triggered when <b>keyType</b> is <b>ARKUI_ENTER_KEY_TYPE_NEW_LINE</b>. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is \\n\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: type of the Enter key.\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_SUBMIT: ArkUI_NodeEventType = 8006;
#[doc = " @brief textArea This event is triggered when the input content changes.\n\n Conditions for triggering this event: When the input content changes. \\n\n When the event callback occurs, the union type in the event parameter {@link ArkUI_NodeEvent} object is \\n\n {@link ArkUI_NodeComponentEvent}.\\n\n {@link ArkUI_NodeComponentEvent} contains 2 parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: Indicates the width of the text. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: Indicates the height of the text. \\n\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_CONTENT_SIZE_CHANGE: ArkUI_NodeEventType = 8007;
#[doc = " @brief Defines the event triggered when text is about to be entered.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>.\n @return Returns <b>true</b> if the text is entered; returns <b>false</b> otherwise.\n You can set the return value using <b>OH_ArkUI_NodeEvent_SetReturnNumberValue</b>. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_WILL_INSERT: ArkUI_NodeEventType = 8008;
#[doc = " @brief Defines the event triggered when text is entered.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>."]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_DID_INSERT: ArkUI_NodeEventType = 8009;
#[doc = " @brief Defines the event triggered when text is about to be deleted.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text to delete, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n value.i32: direction for deleting the text, with the index of <b>1</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. The value <b>0</b> indicates backward-delete, and <b>1</b> indicates\n forward-delete. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>.\n @return Returns <b>true</b> if the text is deleted; returns <b>false</b> otherwise. \\n\n You can set the return value using <b>OH_ArkUI_NodeEvent_SetReturnNumberValue</b>. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_WILL_DELETE: ArkUI_NodeEventType = 8010;
#[doc = " @brief Defines the event triggered when text is deleted.\n\n The event parameter is {@link ArkUI_NodeEvent}. \\n\n value.f32: position of the text deleted, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. \\n\n value.i32: direction for deleting the text, with the index of <b>1</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetNumberValue</b>. The value <b>0</b> indicates backward-delete, and <b>1</b> indicates\n forward-delete. \\n\n buffer: string value of the text, with the index of <b>0</b>; obtained using\n <b>OH_ArkUI_NodeEvent_GetStringValue</b>."]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_DID_DELETE: ArkUI_NodeEventType = 8011;
#[doc = " @brief Defines the event triggered when content (including preview text) changes in the <b>TextArea</b>\n component.\n\n When the event callback occurs, the union type {@link ArkUI_NodeEvent} is {@link ArkUI_TextChangeEvent}. \\n\n {@link ArkUI_TextChangeEvent} contains the following parameters: \\n\n <b>ArkUI_TextChangeEvent.pStr</b>: content in the <b>TextArea</b> component.\n <b>ArkUI_TextChangeEvent.pExtendStr</b>: content of the preview text in the <b>TextArea</b> component.\n <b>ArkUI_TextChangeEvent.number</b>: start position of the preview text in the <b>TextArea</b> component.\n\n @since 15"]
pub const ArkUI_NodeEventType_NODE_TEXT_AREA_ON_CHANGE_WITH_PREVIEW_TEXT: ArkUI_NodeEventType =
    8012;
#[doc = " @brief Defines the event triggered when the selected status of the <b>ARKUI_NODE_CHECKBOX</b> component changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b><b>1</b>: selected; <b>0</b>: not selected.\\n"]
pub const ArkUI_NodeEventType_NODE_CHECKBOX_EVENT_ON_CHANGE: ArkUI_NodeEventType = 11000;
#[doc = " @brief Defines the event triggered when a date is selected in the <b>ARKUI_NODE_DATE_PICKER</b> component.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains three parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: year of the selected date. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: month of the selected date. Value range: [0-11]. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: day of the selected date. \\n"]
pub const ArkUI_NodeEventType_NODE_DATE_PICKER_EVENT_ON_DATE_CHANGE: ArkUI_NodeEventType = 13000;
#[doc = " @brief Defines the event triggered when a time is selected in the <b>ARKUI_NODE_TIME_PICKER</b> component.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: hour of the selected time. Value range: [0-23]. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: minute of the selected time. Value range: [0-59]. \\n"]
pub const ArkUI_NodeEventType_NODE_TIME_PICKER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 14000;
#[doc = " @brief Defines the event triggered when an item is selected in the <b>ARKUI_NODE_TEXT_PICKER</b> component.\n\n\\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0...11].i32</b>: value of the selected item. \\n"]
pub const ArkUI_NodeEventType_NODE_TEXT_PICKER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 15000;
#[doc = " @brief Defines the event triggered when an item is selected and scrolling has stopped in the\n <b>ARKUI_NODE_TEXT_PICKER</b> component.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0...11].i32</b>: value of the selected item. \\n\n\n @since 14"]
pub const ArkUI_NodeEventType_NODE_TEXT_PICKER_EVENT_ON_SCROLL_STOP: ArkUI_NodeEventType = 15001;
#[doc = " @brief Defines the event triggered when a date is selected in the <b>NODE_CALENDAR_PICKER</b>.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n <b>ArkUI_NodeComponent.data[0].u32</b>: year of the selected date. \\n\n <b>ArkUI_NodeComponent.data[1].u32</b>: month of the selected date. \\n\n <b>ArkUI_NodeComponent.data[2].u32</b>: day of the selected date. \\n"]
pub const ArkUI_NodeEventType_NODE_CALENDAR_PICKER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 16000;
#[doc = " @brief Defines the event triggered when the <b>ARKUI_NODE_SLIDER</b> component is dragged or clicked.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: current slider value. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: state triggered by the event.\\n"]
pub const ArkUI_NodeEventType_NODE_SLIDER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 17000;
#[doc = " @brief Defines the event callback function triggered when an object is dragged or clicked by ARKUI_NODE_RADIO.\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains one parameter:\\n\n ArkUI_NodeComponentEvent.data[0].i32: option button status. \\n"]
pub const ArkUI_NodeEventType_NODE_RADIO_EVENT_ON_CHANGE: ArkUI_NodeEventType = 18000;
#[doc = " @brief Defines the event callback function triggered when the animation starts to play.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_START: ArkUI_NodeEventType = 19000;
#[doc = " @brief Defines the event callback function triggered when the animation playback is paused.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_PAUSE: ArkUI_NodeEventType = 19001;
#[doc = " @brief Defines the event callback function triggered when the animation playback is repeated.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_REPEAT: ArkUI_NodeEventType = 19002;
#[doc = " @brief Defines the event callback function when the animation playback returns to the initial state.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_CANCEL: ArkUI_NodeEventType = 19003;
#[doc = " @brief Defines the event callback function triggered when the animation playback is complete or stopped.\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameter:\\n\n"]
pub const ArkUI_NodeEventType_NODE_IMAGE_ANIMATOR_EVENT_ON_FINISH: ArkUI_NodeEventType = 19004;
#[doc = " @brief Defines the callback triggered when the selected status of the <b>ARKUI_NODE_CHECKBOX_GROOUP</b>\n or checkbox changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_StringAsyncEvent}. \\n\n <b>ArkUI_StringAsyncEvent.pStr</b>\n Name: The names of the selected checkboxes;\n Status:\n 0: All checkboxes are selected.\n 1: Some checkboxes are selected.\n 2: No checkboxes are selected. \\n\n\n @since 15"]
pub const ArkUI_NodeEventType_NODE_CHECKBOX_GROUP_EVENT_ON_CHANGE: ArkUI_NodeEventType = 21000;
#[doc = " @brief Defines the event triggered when the index of the currently displayed element of this\n <b>ARKUI_NODE_SWIPER</b> instance changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the currently displayed element. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_CHANGE: ArkUI_NodeEventType = 1001000;
#[doc = " @brief Defines the event triggered when the switching animation of this <b>ARKUI_NODE_SWIPER</b> instance starts.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains five parameters: \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the currently displayed element. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: index of the target element to switch to. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: offset of the currently displayed element relative to the\n start position of the swiper along the main axis. \\n\n <b>ArkUI_NodeComponentEvent.data[3].f32</b>: offset of the target element relative to the start position\n of the swiper along the main axis. \\n\n <b>ArkUI_NodeComponentEvent.data[4].f32</b>: hands-off velocity. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_ANIMATION_START: ArkUI_NodeEventType = 1001001;
#[doc = " @brief Defines the event triggered when the switching animation of this <b>ARKUI_NODE_SWIPER</b> instance ends.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the currently displayed element. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: offset of the currently displayed element relative to the\n start position of the swiper along the main axis. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_ANIMATION_END: ArkUI_NodeEventType = 1001002;
#[doc = " @brief Defines the event triggered on a frame-by-frame basis when the page is turned by a swipe in this\n <b>ARKUI_NODE_SWIPER</b> instance.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the currently displayed element. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: offset of the currently displayed element relative to the\n start position of the swiper along the main axis. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_GESTURE_SWIPE: ArkUI_NodeEventType = 1001003;
#[doc = " @brief Define the <b>ARKUI_NODE_SWIPER</b> to listen for Swiper page slide events.\n Instruction: \\n\n 1. If the {@link ArkUI_SwiperDisplayModeType} attribute is set to \\n\n ARKUI_SWIPER_DISPLAY_MODE_AUTO_LINEAR, the interface does not take effect. \\n\n 2, circular scenario, set prevMargin and nextMargin attributes, \\n\n so that Swiper front and back end display the same page, the interface does not take effect. \\n\n 3. During page sliding, the ContentDidScrollCallback callback is \\n\n triggered frame-by-frame for all pages in the window. \\n\n For example, when there are two pages in the window with subscripts 0 and 1, \\n\n callbacks with index values 0 and 1 are triggered twice per frame. \\n\n 4, set the swipeByGroup parameter of the displayCount property to \\n\n true if at least one page in the same group is in the window, \\n\n A callback is triggered for all pages in the group. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains four parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b> : indicates the index of the Swiper component, \\n\n which is consistent with the index change in the onChange event. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b> : The index of a page in the window. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b> : The proportion of page movement relative to \\n\n the start position of the Swiper spindle (selectedIndex corresponds to the start position of the page). \\n\n <b>ArkUI_NodeComponentEvent.data[3].f32</b> : The length of the page in the axis direction. \\n"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_CONTENT_DID_SCROLL: ArkUI_NodeEventType =
    1001004;
#[doc = " @brief Defines the event triggered when content in the swiper component will scroll.\n Instructions: Before page scrolling, the </b>ContentWillScrollCallback</b> callback is invoked. \\n \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains three parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: the index value of the current child page. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: the index value of the child page that will display. \\n\n <b>ArkUI_NodeComponentEvent.data[2].f32</b>: the sliding offset of each frame.\n Positive numbers indicating slide backward(e.g. from index=1 to index=0), negative numbers indicating\n slide forward(e.g. from index=0 to index=1). \\n\n\n @since 15"]
pub const ArkUI_NodeEventType_NODE_SWIPER_EVENT_ON_CONTENT_WILL_SCROLL: ArkUI_NodeEventType =
    1001007;
#[doc = " @brief Defines the event triggered when the <b>ARKUI_NODE_SCROLL</b> component scrolls.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started by the <b>ARKUI_NODE_SCROLL</b> component or other input\n settings, such as keyboard and mouse operations. \\n\n 2. Scrolling can be initiated by calling the controller API. \\n\n 3. The out-of-bounds bounce effect is supported. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: horizontal scrolling offset. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: vertical scrolling offset. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL: ArkUI_NodeEventType = 1002000;
#[doc = " @brief Defines the event triggered when each frame scrolling starts in the <b>ARKUI_NODE_SCROLL</b> component.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started by the <b>ARKUI_NODE_SCROLL</b> component or other input\n settings, such as keyboard and mouse operations. \\n\n 2. This event is not triggered when the controller API is called. \\n\n 3. This event does not support the out-of-bounds bounce effect. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains two parameters:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: amount to scroll by. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: current scrolling state. \\n\n <b>::ArkUI_NodeComponentEvent</b> contains one return value:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: The event handler can work out the amount by which the component\n needs to scroll based on the real-world situation and return the result in this parameter. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL_FRAME_BEGIN: ArkUI_NodeEventType =
    1002001;
#[doc = " @brief Define the enumeration value of the pre sliding trigger event for the scrolling container component.\n\n The conditions that trigger this event: \\n\n 1. When the scrolling component triggers scrolling, it supports input settings such as keyboard and mouse\n operations that trigger scrolling.\\n\n 2. Called through the rolling controller API interface.\\n\n 3. Cross boundary rebound.\\n\n When an event callback occurs, the union type in the event parameter {@ link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains four parameters: \\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: The offset for each frame of scrolling is positive when scrolling to\n the left and negative when scrolling to the right, measured in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: The offset of each frame scrolling, with a positive offset when\n scrolling up and a negative offset when scrolling down, measured in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: Current sliding state, \\n\n parameter type is {@link ArkUI_ScrollState}. \\n\n <b>ArkUI_NodeComponentEvent.data[3].i32</b>: Current scroll source, \\n\n parameter type is {@link ArkUI_ScrollSource}. \\n\n @return Does not return or returns a number that sets the actual scroll distance of the scroll component."]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_WILL_SCROLL: ArkUI_NodeEventType = 1002002;
#[doc = " @brief Define the event enumeration value triggered when sliding a scrolling container component.\n\n The conditions that trigger this event: \\n\n 1. When the scrolling component triggers scrolling, it supports input settings such as keyboard and mouse\n operations that trigger scrolling.\\n\n 2. Called through the rolling controller API interface.\\n\n 3. Cross boundary rebound.\\n\n When an event callback occurs, the union type in the event parameter {@ link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains three parameters: \\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: The offset for each frame of scrolling is positive when scrolling to\n the left and negative when scrolling to the right, measured in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[1].f32</b>: The offset of each frame scrolling, with a positive offset when\n scrolling up and a negative offset when scrolling down, measured in vp. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: Current sliding state, \\n\nparameter type is {@link ArkUI_ScrollState}. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_DID_SCROLL: ArkUI_NodeEventType = 1002003;
#[doc = " @brief Defines the event triggered when scrolling starts in the <b>ARKUI_NODE_SCROLL</b> component.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started, with support for other input settings, such as keyboard\n and mouse operations. \\n\n 2. This event is triggered when the controller API is called, accompanied by a transition animation. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL_START: ArkUI_NodeEventType = 1002004;
#[doc = " @brief Defines the event triggered when scrolling of the <b>ARKUI_NODE_SCROLL</b> component stops.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is stopped by the <b>ARKUI_NODE_SCROLL</b> component or other input\n settings, such as keyboard and mouse operations. \\n\n 2. This event is triggered when the controller API is called, accompanied by a transition animation. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL_STOP: ArkUI_NodeEventType = 1002005;
#[doc = " @brief Defines the event triggered when scrolling of the <b>ARKUI_NODE_SCROLL</b> component reaches\n one of the edges.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling reaches the edge after being started by the <b>ARKUI_NODE_SCROLL</b>\n component or other input settings, such as keyboard and mouse operations. \\n\n 2. Scrolling can be initiated by calling the controller API. \\n\n 3. The out-of-bounds bounce effect is supported. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter. \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: edge (top, bottom, left, or right) that the scrolling reaches. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_SCROLL_EDGE: ArkUI_NodeEventType = 1002006;
#[doc = " @brief Define that a callback is triggered when the scrolling container component reaches the start position.\n Condition for triggering the event: \\n\n Triggered when the component reaches the start position. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameters. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_REACH_START: ArkUI_NodeEventType = 1002007;
#[doc = " @brief Define that a callback is triggered when the scrolling container component ends. \\n\n Condition for triggering the event: \\n\n Triggered when the component reaches the end. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains no parameters. \\n"]
pub const ArkUI_NodeEventType_NODE_SCROLL_EVENT_ON_REACH_END: ArkUI_NodeEventType = 1002008;
#[doc = " @brief Defines the enumerated values of the event triggered, \\n\n when a subcomponent of ARKUI_NODE_LIST is moved into or out of the list display area. \\n\n Condition for triggering the event: \\n\n This method is triggered once during list initialization. \\n\n It is triggered when the index value of the first or last subcomponent in the list display area changes. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains three parameters: \\n\n ArkUI_NodeComponentEvent.data[0].i32: List Displays the index value of \\n\n the first child component in the region. \\n\n ArkUI_NodeComponentEvent.data[1].i32: List Displays the index value of \\n\n the last child component in the region. \\n\n ArkUI_NodeComponentEvent.data[2].i32: List Displays the index value of \\n\n the subcomponent in the middle of the area. \\n"]
pub const ArkUI_NodeEventType_NODE_LIST_ON_SCROLL_INDEX: ArkUI_NodeEventType = 1003000;
#[doc = " @brief Defines the enumerated values of the event triggered\n before the sliding of the ARKUI_NODE_LIST component. \\n\n Condition for triggering the event: \\n\n This event is triggered when the scrolling component triggers scrolling. \\n\n Other inputs that trigger scrolling, such as keyboard and mouse operations, can be set. \\n\n Called through the scroll controller API. \\n\n Out-of-bounds rebound. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains three parameters: \\n\n ArkUI_NodeComponentEvent.data[0].f32: offset of each frame scrolling. \\n\n The offset is positive when the list content is scrolled up and \\n\n is negative when the list content is scrolled down. \\n\n ArkUI_NodeComponentEvent.data[1].i32: Current sliding state. \\n\n parameter type is {@link ArkUI_ScrollState}. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: Current scroll source, \\n\n parameter type is {@link ArkUI_ScrollSource}. \\n\n @return Does not return or returns a number that sets the actual scroll distance of the scroll component. \\n"]
pub const ArkUI_NodeEventType_NODE_LIST_ON_WILL_SCROLL: ArkUI_NodeEventType = 1003001;
#[doc = " @brief Define the enumerated values of the event triggered when the ARKUI_NODE_LIST component is flicked.\n Condition for triggering the event: \\n\n This event is triggered when the scrolling component triggers scrolling. \\n\n Other inputs that trigger scrolling, such as keyboard and mouse operations, can be set. \\n\n Called through the scroll controller API. \\n\n Out-of-bounds rebound. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains two parameters:\\n\n ArkUI_NodeComponentEvent.data[0].f32: offset of each frame scrolling. \\n\n The offset is positive when the list content is scrolled up and \\n\n is negative when the list content is scrolled down. \\n\n ArkUI_NodeComponentEvent.data[1].i32: Current sliding state. \\n"]
pub const ArkUI_NodeEventType_NODE_LIST_ON_DID_SCROLL: ArkUI_NodeEventType = 1003002;
#[doc = " @brief Defines the event triggered when the currently displayed content of the <b>ARKUI_NODE_LIST</b> changes.\n\n Notes for triggering the event:\\n\n This event is triggered once when the list is initialized and when the index of the first child component or the\n next child component in the list display area changes.\n During index calculation, the list item, header of the list item group, and footer of the list item group each\n are counted as a child component. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains three parameters: \\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: index of the first child component in the list display area. \\n\n <b>ArkUI_NodeComponentEvent.data[1].i32</b>: area in the list item group where the list display area starts.\n The type is {@link ArkUI_ListItemGroupArea}. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: index of the list item at the start of the list display area\n in the list item group.\n If the start of the list display area is not on a list item, the value is <b>-1</b>. \\n\n <b>ArkUI_NodeComponentEvent.data[3].i32</b>: index of the last child component in the list display area. \\n\n <b>ArkUI_NodeComponentEvent.data[4].i32</b>: area in the list item group where the list display area ends.\n The type is {@link ArkUI_ListItemGroupArea}. \\n\n <b>ArkUI_NodeComponentEvent.data[5].i32</b>: index of the list item at the end of the list display area in the\n list item group.\n If the end of the list display area is not on a list item, the value is <b>-1</b>. \\n\n\n @since 15"]
pub const ArkUI_NodeEventType_NODE_LIST_ON_SCROLL_VISIBLE_CONTENT_CHANGE: ArkUI_NodeEventType =
    1003003;
#[doc = " @brief Defines the event triggered when the refresh state of the <b>ARKUI_NODE_REFRESH</b> object changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].i32</b>: refresh state. \\n"]
pub const ArkUI_NodeEventType_NODE_REFRESH_STATE_CHANGE: ArkUI_NodeEventType = 1009000;
#[doc = " @brief Defines the event triggered when the <b>ARKUI_NODE_REFRESH</b> object enters the refresh state.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} does not contain parameters:\\n"]
pub const ArkUI_NodeEventType_NODE_REFRESH_ON_REFRESH: ArkUI_NodeEventType = 1009001;
#[doc = " @brief Defines the event that is triggered when the <b>ARKUI_NODE_REFRESH</b> drop-down distance changes.\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@link ArkUI_NodeComponentEvent} contains one parameter:\\n\n <b>ArkUI_NodeComponentEvent.data[0].f32</b>: Pull-down distance. \\n"]
pub const ArkUI_NodeEventType_NODE_REFRESH_ON_OFFSET_CHANGE: ArkUI_NodeEventType = 1009002;
#[doc = " @brief Defines the event triggered when the <b>ARKUI_NODE_SCROLL</b> component is about to scroll.\n\n Notes for triggering the event:\\n\n 1. This event is triggered when scrolling is started by the <b>ARKUI_NODE_SCROLL</b> component or other\n input settings, such as keyboard and mouse operations. \\n\n 2. Scrolling can be initiated by calling the controller API. \\n\n 3. The out-of-bounds bounce effect is supported. \\n\n When the event callback occurs, the union type in the {@link ArkUI_NodeEvent} object is\n {@link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains three parameters: \\n\n ArkUI_NodeComponentEvent.data[0].f32: offset of each frame scrolling. \\n\n The offset is positive when the list content is scrolled up and \\n\n is negative when the list content is scrolled down. \\n\n ArkUI_NodeComponentEvent.data[1].i32: Current sliding state. \\n\n parameter type is {@link ArkUI_ScrollState}. \\n\n <b>ArkUI_NodeComponentEvent.data[2].i32</b>: Current scroll source, \\n\n parameter type is {@link ArkUI_ScrollSource}. \\n\n @return Does not return or returns a number that sets the actual scroll distance of the scroll component. \\n"]
pub const ArkUI_NodeEventType_NODE_ON_WILL_SCROLL: ArkUI_NodeEventType = 1010000;
#[doc = " @brief Define the enumerated values of the event triggered when the ARKUI_NODE_WATER_FLOW component slides.\n Condition for triggering the event: \\n\n This event is triggered when the scrolling component triggers scrolling.\n Other inputs that trigger scrolling, such as keyboard and mouse operations, can be set. \\n\n Called through the scroll controller API. \\n\n Out-of-bounds rebound. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains two parameters:\\n\n ArkUI_NodeComponentEvent.data[0].f32: offset of each frame scrolling. \\n\n The offset is positive when the content is scrolled up and is negative when the content is scrolled down. \\n\n ArkUI_NodeComponentEvent.data[1].i32: Current sliding state. \\n"]
pub const ArkUI_NodeEventType_NODE_WATER_FLOW_ON_DID_SCROLL: ArkUI_NodeEventType = 1010001;
#[doc = " @brief Defines the enumerated values of the event triggered,\n when the subcomponent of the start position or end position displayed in the current waterfall changes.\n Condition for triggering the event: \\n\n This event is triggered when the index value of the \\n\n first or last subcomponent in the waterfall display area changes. \\n\n When the event callback occurs, the union type in the {@Link ArkUI_NodeEvent} object is \\n\n {@Link ArkUI_NodeComponentEvent}. \\n\n {@Link ArkUI_NodeComponentEvent} contains three parameters: \\n\n ArkUI_NodeComponentEvent.data[0].i32: The index value of the \\n\n start position of the currently displayed WaterFlow. \\n\n ArkUI_NodeComponentEvent.data[1].i32: The index value of \\n\n the end position of the currently displayed waterfall. \\n"]
pub const ArkUI_NodeEventType_NODE_WATER_FLOW_ON_SCROLL_INDEX: ArkUI_NodeEventType = 1010002;
#[doc = " @brief Enumerates the event types supported by the NativeNode component.\n\n @since 12"]
pub type ArkUI_NodeEventType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Obtains the type of a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the type of the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetEventType(event: *mut ArkUI_NodeEvent) -> ArkUI_NodeEventType;
}
extern "C" {
    #[doc = " @brief Obtains the custom ID of a component event.\n\n The event ID is passed in as a parameter when the {@link registerNodeEvent} function is called and can be applied\n to the dispatch logic of the same event entry function {@link registerNodeEventReceiver}.\n\n @param event Indicates the pointer to the component event.\n @return Returns the custom ID of the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetTargetId(event: *mut ArkUI_NodeEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the component object that triggers a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the component object that triggers the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetNodeHandle(event: *mut ArkUI_NodeEvent) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Obtains input event (for example, touch event) data for a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the pointer to the input event data.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetInputEvent(event: *mut ArkUI_NodeEvent)
        -> *mut ArkUI_UIInputEvent;
}
extern "C" {
    #[doc = " @brief Obtains the numerical data in a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the pointer to the numerical data.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetNodeComponentEvent(
        event: *mut ArkUI_NodeEvent,
    ) -> *mut ArkUI_NodeComponentEvent;
}
extern "C" {
    #[doc = " @brief Obtains the string data in a component event.\n\n @param event Indicates the pointer to the component event.\n @return Returns the pointer to the string data.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetStringAsyncEvent(
        event: *mut ArkUI_NodeEvent,
    ) -> *mut ArkUI_StringAsyncEvent;
}
extern "C" {
    #[doc = " @brief Obtains the ArkUI_TextChangeEvent data from a component event.\n\n @param event Pointer to a component event. It cannot be null.\n @return Returns the pointer to the <b>ArkUI_TextChangeEvent</b> object.\n @since 15"]
    pub fn OH_ArkUI_NodeEvent_GetTextChangeEvent(
        event: *mut ArkUI_NodeEvent,
    ) -> *mut ArkUI_TextChangeEvent;
}
extern "C" {
    #[doc = " @brief Obtains the custom data in a component event.\n\n This parameter is passed in {@link registerNodeEvent} and can be applied to the service logic when the event\n is triggered.\n\n @param event Indicates the pointer to the component event.\n @return Returns the pointer to the custom data.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetUserData(
        event: *mut ArkUI_NodeEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the numeric-type parameter of a component event.\n\n @param event Indicates the pointer to the component event.\n @param index Indicates the index of the return value.\n @param value Indicates the return value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INDEX_OUT_OF_RANGE} if the parameter length exceeds\n         the limit.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INVALID} if the data does not exist in the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetNumberValue(
        event: *mut ArkUI_NodeEvent,
        index: i32,
        value: *mut ArkUI_NumberValue,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the string-type parameter of a component event. The string data is valid only during an event\n callback. To use it outside an event callback, you are advised to copy the string data.\n\n @param event Indicates the pointer to the component event.\n @param index Indicates the index of the return value.\n @param string Indicates the pointer to the string array.\n @param stringSize Indicates the length of the string array.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INDEX_OUT_OF_RANGE} if the parameter length exceeds\n         the limit.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INVALID} if the data does not exist in the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_GetStringValue(
        event: *mut ArkUI_NodeEvent,
        index: i32,
        string: *mut *mut ::std::os::raw::c_char,
        stringSize: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the return value for a component event.\n\n @param event Indicates the pointer to the component event.\n @param value Indicates the numeric-type array.\n @param size Indicates the array length.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_NO_RETURN} if the component event does not support return values.\n         Returns {@link ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INVALID} if data does not exist in the component event.\n @since 12"]
    pub fn OH_ArkUI_NodeEvent_SetReturnNumberValue(
        event: *mut ArkUI_NodeEvent,
        value: *mut ArkUI_NumberValue,
        size: i32,
    ) -> i32;
}
#[doc = " @brief Remeasure.\n\n When this type of flag is specified, re-layout is triggered by default."]
pub const ArkUI_NodeDirtyFlag_NODE_NEED_MEASURE: ArkUI_NodeDirtyFlag = 1;
#[doc = " Re-layout."]
pub const ArkUI_NodeDirtyFlag_NODE_NEED_LAYOUT: ArkUI_NodeDirtyFlag = 2;
#[doc = " Re-rendering."]
pub const ArkUI_NodeDirtyFlag_NODE_NEED_RENDER: ArkUI_NodeDirtyFlag = 3;
#[doc = " @brief Defines the dirty area flag passed in the <b>::markDirty</b> API.\n\n @since 12"]
pub type ArkUI_NodeDirtyFlag = ::std::os::raw::c_uint;
#[doc = " Measure type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_MEASURE: ArkUI_NodeCustomEventType =
    1;
#[doc = " Layout type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_LAYOUT: ArkUI_NodeCustomEventType =
    2;
#[doc = " Draw type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_DRAW: ArkUI_NodeCustomEventType = 4;
#[doc = " Foreground type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_FOREGROUND_DRAW:
    ArkUI_NodeCustomEventType = 8;
#[doc = " Overlay type."]
pub const ArkUI_NodeCustomEventType_ARKUI_NODE_CUSTOM_EVENT_ON_OVERLAY_DRAW:
    ArkUI_NodeCustomEventType = 16;
#[doc = " @brief Defines the custom component event type.\n\n @since 12"]
pub type ArkUI_NodeCustomEventType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeCustomEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeAdapter {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the component adapter, which is used for lazy loading of elements of scrollable components.\n\n @since 12"]
pub type ArkUI_NodeAdapterHandle = *mut ArkUI_NodeAdapter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeAdapterEvent {
    _unused: [u8; 0],
}
#[doc = " This event occurs when the component is attached to the adapter."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_WILL_ATTACH_TO_NODE:
    ArkUI_NodeAdapterEventType = 1;
#[doc = " This event occurs when the component is detached from the adapter."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_WILL_DETACH_FROM_NODE:
    ArkUI_NodeAdapterEventType = 2;
#[doc = " This event occurs when the adapter obtains the unique ID of the new element to add."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_ON_GET_NODE_ID: ArkUI_NodeAdapterEventType =
    3;
#[doc = " This event occurs when the adapter obtains the content of the new element to add."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_ON_ADD_NODE_TO_ADAPTER:
    ArkUI_NodeAdapterEventType = 4;
#[doc = " This event occurs when the adapter removes an element."]
pub const ArkUI_NodeAdapterEventType_NODE_ADAPTER_EVENT_ON_REMOVE_NODE_FROM_ADAPTER:
    ArkUI_NodeAdapterEventType = 5;
#[doc = " @brief Enumerates component adapter events.\n\n @since 12"]
pub type ArkUI_NodeAdapterEventType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Creates a component adapter.\n\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_Create() -> ArkUI_NodeAdapterHandle;
}
extern "C" {
    #[doc = " @brief Destroys a component adapter.\n\n @param handle Indicates the target component adapter.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_Dispose(handle: ArkUI_NodeAdapterHandle);
}
extern "C" {
    #[doc = " @brief Sets the total number of elements in the specified adapter.\n\n @param handle Indicates the target component adapter.\n @param size Indicates the number of elements.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_SetTotalNodeCount(
        handle: ArkUI_NodeAdapterHandle,
        size: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the total number of elements in the specified adapter.\n\n @param handle Indicates the target component adapter.\n @return Returns the total number of elements in the adapter.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_GetTotalNodeCount(handle: ArkUI_NodeAdapterHandle) -> u32;
}
extern "C" {
    #[doc = " @brief Registers an event callback for the adapter.\n\n @param handle Indicates the target component adapter.\n @param userData Indicates custom data.\n @param receiver Indicates the event receiver callback.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_RegisterEventReceiver(
        handle: ArkUI_NodeAdapterHandle,
        userData: *mut ::std::os::raw::c_void,
        receiver: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeAdapterEvent)>,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Deregisters an event callback for the adapter.\n\n @param handle Indicates the target component adapter.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_UnregisterEventReceiver(handle: ArkUI_NodeAdapterHandle);
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to reload all elements.\n\n @param handle Indicates the target component adapter.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_ReloadAllItems(handle: ArkUI_NodeAdapterHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to reload certain elements.\n\n @param handle Indicates the target component adapter.\n @param startPosition Indicates the start position of the elements to reload.\n @param itemCount Indicates the number of the elements to reload.\n  @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_ReloadItem(
        handle: ArkUI_NodeAdapterHandle,
        startPosition: u32,
        itemCount: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to remove certain elements.\n\n @param handle Indicates the target component adapter.\n @param startPosition Indicates the start position of the elements to remove.\n @param itemCount Indicates the number of the elements to remove.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_RemoveItem(
        handle: ArkUI_NodeAdapterHandle,
        startPosition: u32,
        itemCount: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to insert certain elements.\n\n @param handle Indicates the target component adapter.\n @param startPosition Indicates the start position of the elements to insert.\n @param itemCount Indicates the number of the elements to insert.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_InsertItem(
        handle: ArkUI_NodeAdapterHandle,
        startPosition: u32,
        itemCount: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Instructs the specified adapter to move certain elements.\n\n @param handle Indicates the target component adapter.\n @param from Indicates the start position of the elements to move.\n @param to  Indicates the end position of the elements to move.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_MoveItem(
        handle: ArkUI_NodeAdapterHandle,
        from: u32,
        to: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains all elements stored in the specified adapter.\n\n This API returns the pointer to the array of the elements. You need to manually release the memory data\n to which the pointer points.\n\n @param handle Indicates the target component adapter.\n @param items Indicates the pointer to the array of the elements in the adapter.\n @param size Indicates the number of elements.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapter_GetAllItems(
        handle: ArkUI_NodeAdapterHandle,
        items: *mut *mut ArkUI_NodeHandle,
        size: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the custom data passed in during registration of the specified event.\n\n @param event Indicates the target adapter event.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetUserData(
        event: *mut ArkUI_NodeAdapterEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains the event type.\n\n @param event Indicates the target adapter event.\n @return Returns the event type.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetType(
        event: *mut ArkUI_NodeAdapterEvent,
    ) -> ArkUI_NodeAdapterEventType;
}
extern "C" {
    #[doc = " @brief Obtains the element to be removed for the event to be destroyed.\n\n @param event Indicates the target adapter event.\n @return Returns the element to be removed.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetRemovedNode(
        event: *mut ArkUI_NodeAdapterEvent,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Obtains the index of the element to be operated for the specified adapter event.\n\n @param event Indicates the target adapter event.\n @return Returns the index of the element.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetItemIndex(event: *mut ArkUI_NodeAdapterEvent) -> u32;
}
extern "C" {
    #[doc = " @brief Obtains the scrollable container node that uses the specified adapter.\n\n @param event Indicates the target adapter event.\n @return Returns the scrollable container node that uses the specified adapter.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_GetHostNode(
        event: *mut ArkUI_NodeAdapterEvent,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Sets the component to be added to the specified adapter.\n\n @param event Indicates the target adapter event.\n @param node Indicates the component to be added.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_SetItem(
        event: *mut ArkUI_NodeAdapterEvent,
        node: ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the component ID to be generated.\n\n @param event Indicates the target adapter event.\n @param id Indicates the component ID to set.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeAdapterEvent_SetNodeId(event: *mut ArkUI_NodeAdapterEvent, id: i32) -> i32;
}
#[doc = " @brief Declares a collection of native node APIs provided by ArkUI.\n\n The APIs related to the native node must be called in the main thread.\n\n @version 1\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NativeNodeAPI_1 {
    #[doc = " Struct version."]
    pub version: i32,
    #[doc = " @brief Creates a component based on {@link ArkUI_NodeType} and returns the pointer to the created component.\n\n @param type Indicates the type of component to create.\n @return Returns the pointer to the created component. If the component fails to be created, NULL is returned."]
    pub createNode:
        ::std::option::Option<unsafe extern "C" fn(type_: ArkUI_NodeType) -> ArkUI_NodeHandle>,
    #[doc = " @brief Destroys the component to which the specified pointer points.\n\n @param node Indicates the pointer."]
    pub disposeNode: ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle)>,
    #[doc = " @brief Adds a component to a parent node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub addChild: ::std::option::Option<
        unsafe extern "C" fn(parent: ArkUI_NodeHandle, child: ArkUI_NodeHandle) -> i32,
    >,
    #[doc = " @brief Removes a component from its parent node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub removeChild: ::std::option::Option<
        unsafe extern "C" fn(parent: ArkUI_NodeHandle, child: ArkUI_NodeHandle) -> i32,
    >,
    #[doc = " @brief Inserts a component to a parent node after the specified <b>sibling</b> node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @param sibling Indicates the pointer to the sibling node after which the target node is to be inserted.\n If the value is null, the node is inserted at the start of the parent node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub insertChildAfter: ::std::option::Option<
        unsafe extern "C" fn(
            parent: ArkUI_NodeHandle,
            child: ArkUI_NodeHandle,
            sibling: ArkUI_NodeHandle,
        ) -> i32,
    >,
    #[doc = " @brief Inserts a component to a parent node before the specified <b>sibling</b> node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @param sibling Indicates the pointer to the sibling node before which the target node is to be inserted.\n If the value is null, the node is inserted at the end of the parent node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub insertChildBefore: ::std::option::Option<
        unsafe extern "C" fn(
            parent: ArkUI_NodeHandle,
            child: ArkUI_NodeHandle,
            sibling: ArkUI_NodeHandle,
        ) -> i32,
    >,
    #[doc = " @brief Inserts a component to the specified position in a parent node.\n\n @param parent Indicates the pointer to the parent node.\n @param child Indicates the pointer to the child node.\n @param position Indicates the position to which the target child node is to be inserted. If the value is a\n negative number or invalid, the node is inserted at the end of the parent node.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub insertChildAt: ::std::option::Option<
        unsafe extern "C" fn(
            parent: ArkUI_NodeHandle,
            child: ArkUI_NodeHandle,
            position: i32,
        ) -> i32,
    >,
    #[doc = " @brief Sets the attribute of a node.\n\n @param node Indicates the node whose attribute needs to be set.\n @param attribute Indicates the type of attribute to set.\n @param value Indicates the attribute value.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} if the dynamic implementation library\n         of the native API was not found.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n         on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub setAttribute: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            attribute: ArkUI_NodeAttributeType,
            item: *const ArkUI_AttributeItem,
        ) -> i32,
    >,
    #[doc = " @brief Obtains an attribute.\n\n The pointer returned by this API is an internal buffer pointer of the ArkUI framework. As such, you do not need\n to call <b>delete</b> to release the memory. However, the pointer must be used before this API is called next\n time. Otherwise, the pointer may be overwritten by other values.\n @param node Indicates the node whose attribute needs to be obtained.\n @param attribute Indicates the type of attribute to obtain.\n @return Returns the attribute value. If the operation fails, a null pointer is returned."]
    pub getAttribute: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            attribute: ArkUI_NodeAttributeType,
        ) -> *const ArkUI_AttributeItem,
    >,
    #[doc = " @brief Resets an attribute.\n\n @param node Indicates the node whose attribute needs to be reset.\n @param attribute Indicates the type of attribute to reset.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} if the dynamic implementation library\n         of the native API was not found.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n         on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub resetAttribute: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, attribute: ArkUI_NodeAttributeType) -> i32,
    >,
    #[doc = " @brief Registers an event for the specified node.\n\n When the component is being displayed, this API must be called in the main thread.\n\n @param node Indicates the target node.\n @param eventType Indicates the type of event to register.\n @param targetId Indicates the custom event ID, which is passed in the callback of {@link ArkUI_NodeEvent}\n when the event is triggered.\n @param userData Indicates the custom event parameter, which is passed in the callback of {@link ArkUI_NodeEvent}\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} if the dynamic implementation library\n         of the native API was not found.\n         Returns {@link ARKUI_ERROR_CODE_NOT_SUPPROTED_FOR_ARKTS_NODE} if the following operations are not allowed\n         on BuilderNode generated nodes:\n         setting or resetting attributes, setting events, or adding or editing subnodes."]
    pub registerNodeEvent: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventType: ArkUI_NodeEventType,
            targetId: i32,
            userData: *mut ::std::os::raw::c_void,
        ) -> i32,
    >,
    #[doc = " @brief Unregisters an event for the specified node.\n\n When the component is being displayed, this API must be called in the main thread.\n\n @param node Indicates the target node.\n @param eventType Indicates the type of event to unregister."]
    pub unregisterNodeEvent: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, eventType: ArkUI_NodeEventType),
    >,
    #[doc = " @brief Registers an event receiver.\n\n The ArkUI framework collects component events generated during the process and calls back the events through\n the registered event receiver. \\n\n A new call to this API will overwrite the previously registered event receiver. \\n\n Do not directly save the <b>ArkUI_NodeEvent</b> object pointer. The data will be destroyed after the\n callback is complete. \\n\n To bind with a component instance, you can use the <b>addNodeEventReceiver</b> function. \\n\n\n @param eventReceiver Indicates the event receiver to register."]
    pub registerNodeEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            eventReceiver: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeEvent)>,
        ),
    >,
    #[doc = " @brief Unregisters the event receiver.\n"]
    pub unregisterNodeEventReceiver: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " @brief Forcibly marks the current node that needs to be measured, laid out, or rendered again.\n\n Regarding updates to system attributes, the ArkUI framework automatically marks the dirty area and performs\n measuring, layout, or rendering again. In this case, you do not need to call this API.\n @param node Indicates the node for which you want to mark as dirty area.\n @param dirtyFlag Indicates type of dirty area."]
    pub markDirty: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, dirtyFlag: ArkUI_NodeDirtyFlag),
    >,
    #[doc = " @brief Obtains the number of subnodes.\n\n @param node Indicates the target node.\n @return the number of subnodes. If not, returns 0."]
    pub getTotalChildCount:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> u32>,
    #[doc = " @brief Obtains a subnode.\n\n @param node Indicates the target node.\n @param position Indicates the position of the subnode.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getChildAt: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, position: i32) -> ArkUI_NodeHandle,
    >,
    #[doc = " @brief Obtains the first subnode.\n\n @param node Indicates the target node.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getFirstChild:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Obtains the last subnode.\n\n @param node Indicates the target node.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getLastChild:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Obtains the previous sibling node.\n\n @param node Indicates the target node.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getPreviousSibling:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Obtains the next sibling node.\n\n @param node Indicates the target node.\n @return Returns the pointer to the subnode if the subnode exists; returns <b>NULL</b> otherwise."]
    pub getNextSibling:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Registers a custom event for a node. When the event is triggered, the value is returned through the entry\n point function registered by <b>registerNodeCustomEventReceiver</b>.\n\n @param node Indicates the target node.\n @param eventType Indicates the type of event to register.\n @param targetId Indicates the custom event ID, which is passed in the callback of {@link ArkUI_NodeCustomEvent}\n when the event is triggered.\n @param userData Indicates the custom event parameter, which is passed in the callback of\n {@link ArkUI_NodeCustomEvent} when the event is triggered.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} if the dynamic implementation library\n         of the native API was not found."]
    pub registerNodeCustomEvent: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventType: ArkUI_NodeCustomEventType,
            targetId: i32,
            userData: *mut ::std::os::raw::c_void,
        ) -> i32,
    >,
    #[doc = " @brief Unregisters a custom event for a node.\n\n @param node Indicates the target node.\n @param eventType Indicates the type of event to unregister."]
    pub unregisterNodeCustomEvent: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, eventType: ArkUI_NodeCustomEventType),
    >,
    #[doc = " @brief Registers a unified entry point function for custom node event callbacks.\n\n The ArkUI framework collects custom component events generated during the process and calls back the events\n through the registered <b>registerNodeCustomEventReceiver</b>. \\n\n A new call to this API will overwrite the previously registered event receiver.\n Do not directly save the <b>ArkUI_NodeCustomEvent</b> object pointer.\n The data will be destroyed after the callback is complete. \\n\n To bind with a component instance, you can use the <b>addNodeCustomEventReceiver</b> function. \\n\n\n @param eventReceiver Indicates the event receiver to register."]
    pub registerNodeCustomEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            eventReceiver: ::std::option::Option<
                unsafe extern "C" fn(event: *mut ArkUI_NodeCustomEvent),
            >,
        ),
    >,
    #[doc = " @brief Unregisters the unified entry point function for custom node event callbacks.\n"]
    pub unregisterNodeCustomEventReceiver: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " @brief Sets the width and height for a component after the measurement.\n\n @param node Indicates the target node.\n @param width Indicates the width.\n @param height Indicates the height.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub setMeasuredSize: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, width: i32, height: i32) -> i32,
    >,
    #[doc = " @brief Sets the position for a component.\n\n @param node Indicates the target node.\n @param positionX Indicates the X coordinate.\n @param positionY Indicates the Y coordinate.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub setLayoutPosition: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, positionX: i32, positionY: i32) -> i32,
    >,
    #[doc = " @brief Obtains the width and height of a component after measurement.\n\n @param node Indicates the target node.\n @return Returns the width and height of the component."]
    pub getMeasuredSize:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_IntSize>,
    #[doc = " @brief Obtains the position of a component after the layout is complete.\n\n @param node Indicates the target node.\n @return Returns the position of the component."]
    pub getLayoutPosition:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_IntOffset>,
    #[doc = " @brief Measures a node. You can use the <b>getMeasuredSize</b> API to obtain the size after the measurement.\n\n @param node Indicates the target node.\n @param Constraint Indicates the size constraint.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub measureNode: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            Constraint: *mut ArkUI_LayoutConstraint,
        ) -> i32,
    >,
    #[doc = " @brief Lays outs a component and passes the expected position of the component relative to its parent component.\n\n When the component is being displayed, this API must be called in the main thread.\n\n @param node Indicates the target node.\n @param positionX Indicates the X coordinate.\n @param positionY Indicates the Y coordinate.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub layoutNode: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, positionX: i32, positionY: i32) -> i32,
    >,
    #[doc = " @brief Adds a component event callback function to a component to receive component events generated\n by the component.\n\n Unlike the global registration function <b>registerNodeEventReceiver</b>, this API allows multiple event\n receivers to be added to the same component. \\n\n The callback added by this API is triggered before the global callback registered by\n <b>registerNodeEventReceiver</b>. \\n\n Do not directly save the <b>ArkUI_NodeEvent</b> object pointer.\n The data will be destroyed after the callback is complete. \\n\n\n @param node Indicates the component for which you want to add the event callback function.\n @param eventReceiver Indicates the component event callback function to add.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub addNodeEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventReceiver: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeEvent)>,
        ) -> i32,
    >,
    #[doc = " @brief Removes the registered component event callback function from a component.\n\n @param node Indicates the component from which you want to remove the event callback function.\n @param eventReceiver Indicates the component event callback function to remove.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub removeNodeEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventReceiver: ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeEvent)>,
        ) -> i32,
    >,
    #[doc = " @brief Adds a custom event callback function to a component to receive custom events\n (such as layout and drawing events) generated by the component.\n\n Unlike the global registration function <b>registerNodeCustomEventReceiver</b>, this API allows\n multiple event receivers to be added to the same component. \\n\n The callback added by this API is triggered before the global callback registered by\n <b>registerNodeCustomEventReceiver</b>. \\n\n Do not directly save the <b>ArkUI_NodeCustomEvent</b> object pointer.\n The data will be destroyed after the callback is complete. \\n\n\n @param node Indicates the component for which you want to add the custom event callback function.\n @param eventReceiver Indicates the custom event callback function to add.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub addNodeCustomEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventReceiver: ::std::option::Option<
                unsafe extern "C" fn(event: *mut ArkUI_NodeCustomEvent),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Removes a registered custom event callback function from a component.\n\n @param node Indicates the component from which you want to remove the custom event callback function.\n @param eventReceiver Indicates the custom event callback function to remove.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub removeNodeCustomEventReceiver: ::std::option::Option<
        unsafe extern "C" fn(
            node: ArkUI_NodeHandle,
            eventReceiver: ::std::option::Option<
                unsafe extern "C" fn(event: *mut ArkUI_NodeCustomEvent),
            >,
        ) -> i32,
    >,
    #[doc = " @brief Saves custom data on the specified component.\n\n @param node Indicates the component on which the custom data will be saved.\n @param userData Indicates the custom data to be saved.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.."]
    pub setUserData: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, userData: *mut ::std::os::raw::c_void) -> i32,
    >,
    #[doc = " @brief Obtains the custom data saved on the specified component.\n\n @param node Indicates the target component.\n @return Returns the custom data."]
    pub getUserData: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " @brief Sets the unit for a component.\n\n @param node Indicates the component for which you want to set the unit.\n @param unit Indicates the unit, which is an enumerated value of {@link ArkUI_LengthMetricUnit}.\n The default value is <b>ARKUI_LENGTH_METRIC_UNIT_DEFAULT</b>.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs."]
    pub setLengthMetricUnit: ::std::option::Option<
        unsafe extern "C" fn(node: ArkUI_NodeHandle, unit: ArkUI_LengthMetricUnit) -> i32,
    >,
    #[doc = " @brief Get the parent node.\n\n @param node target node object.\n @return Returns the pointer of the component, if not return NULL"]
    pub getParent:
        ::std::option::Option<unsafe extern "C" fn(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle>,
    #[doc = " @brief Uninstall all child nodes from the parent component.\n\n @param parent target node object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub removeAllChildren:
        ::std::option::Option<unsafe extern "C" fn(parent: ArkUI_NodeHandle) -> i32>,
}
extern "C" {
    #[doc = " @brief Obtains the size constraint for measurement through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the pointer to the size constraint.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetLayoutConstraintInMeasure(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> *mut ArkUI_LayoutConstraint;
}
extern "C" {
    #[doc = " @brief Obtains the expected position of a component relative to its parent component in the layout phase through a\n custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the expected position relative to the parent component.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetPositionInLayout(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> ArkUI_IntOffset;
}
extern "C" {
    #[doc = " @brief Obtains the drawing context through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the drawing context.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetDrawContextInDraw(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> *mut ArkUI_DrawContext;
}
extern "C" {
    #[doc = " @brief Obtains the ID of a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the ID of the custom component event.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetEventTargetId(event: *mut ArkUI_NodeCustomEvent) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains custom event parameters through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the custom event parameters.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetUserData(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Obtains a component object through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the component object.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetNodeHandle(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Obtains the event type through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @return Returns the type of the custom component event.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetEventType(
        event: *mut ArkUI_NodeCustomEvent,
    ) -> ArkUI_NodeCustomEventType;
}
extern "C" {
    #[doc = " @brief Obtains the measurement information of a custom span through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @param info Indicates the measurement information to be obtained.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetCustomSpanMeasureInfo(
        event: *mut ArkUI_NodeCustomEvent,
        info: *mut ArkUI_CustomSpanMeasureInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the measurement metrics of a custom span through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @param metrics Indicates the measurement metrics to set.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_SetCustomSpanMetrics(
        event: *mut ArkUI_NodeCustomEvent,
        metrics: *mut ArkUI_CustomSpanMetrics,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the drawing information of a custom span through a custom component event.\n\n @param event Indicates the pointer to the custom component event.\n @param info Indicates the drawing information to obtain.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.\n @since 12"]
    pub fn OH_ArkUI_NodeCustomEvent_GetCustomSpanDrawInfo(
        event: *mut ArkUI_NodeCustomEvent,
        info: *mut ArkUI_CustomSpanDrawInfo,
    ) -> i32;
}
#[doc = " Defines the attach event."]
pub const ArkUI_NodeContentEventType_NODE_CONTENT_EVENT_ON_ATTACH_TO_WINDOW:
    ArkUI_NodeContentEventType = 0;
#[doc = " Defines the detach event."]
pub const ArkUI_NodeContentEventType_NODE_CONTENT_EVENT_ON_DETACH_FROM_WINDOW:
    ArkUI_NodeContentEventType = 1;
#[doc = " @brief Defines the node content event type.\n\n @since 12"]
pub type ArkUI_NodeContentEventType = ::std::os::raw::c_uint;
#[doc = " @error Success."]
pub const ArkUI_InspectorErrorCode_ARKUI_INSPECTOR_NATIVE_RESULT_SUCCESSFUL:
    ArkUI_InspectorErrorCode = 0;
#[doc = " @error Invalid parameter."]
pub const ArkUI_InspectorErrorCode_ARKUI_INSPECTOR_NATIVE_RESULT_BAD_PARAMETER:
    ArkUI_InspectorErrorCode = -1;
#[doc = " @brief Enumerates the inspector error codes.\n @since 15"]
pub type ArkUI_InspectorErrorCode = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_NodeContentEvent {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the callback function of a node content event.\n @since 12"]
pub type ArkUI_NodeContentCallback =
    ::std::option::Option<unsafe extern "C" fn(event: *mut ArkUI_NodeContentEvent)>;
extern "C" {
    #[doc = " @brief register a callback function to a node content.\n\n @param content Indicates the pointer to the node content instance.\n @param callback Indicates the callback function.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_RegisterCallback(
        content: ArkUI_NodeContentHandle,
        callback: ArkUI_NodeContentCallback,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the type of a node content event.\n\n @param event Indicates the pointer to the node content event.\n @return Returns the type of the node content event.\n @since 12"]
    pub fn OH_ArkUI_NodeContentEvent_GetEventType(
        event: *mut ArkUI_NodeContentEvent,
    ) -> ArkUI_NodeContentEventType;
}
extern "C" {
    #[doc = " @brief Obtains the node content object that triggers a node content event.\n\n @param event Indicates the pointer to the node content event.\n @return Returns the node content object that triggers the node content event.\n @since 12"]
    pub fn OH_ArkUI_NodeContentEvent_GetNodeContentHandle(
        event: *mut ArkUI_NodeContentEvent,
    ) -> ArkUI_NodeContentHandle;
}
extern "C" {
    #[doc = " @brief Saves custom data on the specified node content.\n\n @param content Indicates the node content on which the custom data will be saved.\n @param userData Indicates the custom data to be saved.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_SetUserData(
        content: ArkUI_NodeContentHandle,
        userData: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the custom data saved on the specified node content.\n\n @param content Indicates the target node content.\n @return Returns the custom data.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_GetUserData(
        content: ArkUI_NodeContentHandle,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Add a node to a node content.\n\n @param content Indicates the pointer to the node content instance.\n @param node Indicates the pointer to the node\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_AddNode(
        content: ArkUI_NodeContentHandle,
        node: ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief remove a node from a node content.\n\n @param content Indicates the pointer to the node content instance.\n @param node Indicates the pointer to the node\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_RemoveNode(
        content: ArkUI_NodeContentHandle,
        node: ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief insert a node into a node content at a given position.\n\n @param content Indicates the pointer to the node content instance.\n @param node Indicates the pointer to the node\n @param position Indicates the position for inserting the node\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeContent_InsertNode(
        content: ArkUI_NodeContentHandle,
        node: ArkUI_NodeHandle,
        position: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the size of the component layout area.\n The layout area size does not include graphic variation attributes such as scaling.\n\n @param node ArkUI_NodeHandle pointer.\n @param size The drawing area size of the component handle, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetLayoutSize(
        node: ArkUI_NodeHandle,
        size: *mut ArkUI_IntSize,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component layout area relative to the parent component.\n The relative position of the layout area does not include graphic variation attributes, such as translation.\n\n @param node ArkUI_NodeHandle pointer.\n @param localOffset The offset value of the component handle relative to the parent component, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetLayoutPosition(
        node: ArkUI_NodeHandle,
        localOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component layout area relative to the window.\n The relative position of the layout area does not include graphic variation attributes, such as translation.\n\n @param node ArkUI_NodeHandle pointer.\n @param globalOffset The offset value of the component handle relative to the window, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetLayoutPositionInWindow(
        node: ArkUI_NodeHandle,
        globalOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component layout area relative to the screen.\n The relative position of the layout area does not include graphic variation attributes, such as translation.\n\n @param node ArkUI_NodeHandle pointer.\n @param screenOffset The offset value of the component handle relative to the screen, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetLayoutPositionInScreen(
        node: ArkUI_NodeHandle,
        screenOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component in the window, including the properties of graphic translation changes.\n\n @param node ArkUI_NodeHandle pointer.\n @param translateOffset The cumulative offset value of the component handle itself,\n parent components, and ancestor nodes, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetPositionWithTranslateInWindow(
        node: ArkUI_NodeHandle,
        translateOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the position of the component on the screen, including the attributes of graphic translation changes.\n\n @param node ArkUI_NodeHandle pointer.\n @param translateOffset The cumulative offset value of the component handle itself,\n parent components, and ancestor nodes, in px.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_NodeUtils_GetPositionWithTranslateInScreen(
        node: ArkUI_NodeHandle,
        translateOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Add the custom property of the component. This interface only works on the main thread.\n\n @param node ArkUI_NodeHandle pointer.\n @param name The name of the custom property. Passing null pointers is not allowed.\n @param value The value of the custom property. Passing null pointers is not allowed.\n @since 13"]
    pub fn OH_ArkUI_NodeUtils_AddCustomProperty(
        node: ArkUI_NodeHandle,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Remove the custom property of the component.\n\n @param node ArkUI_NodeHandle pointer.\n @param name The name of the custom property.\n @since 13"]
    pub fn OH_ArkUI_NodeUtils_RemoveCustomProperty(
        node: ArkUI_NodeHandle,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Get the value of the custom property of the component.\n\n @param node ArkUI-NodeHandle pointer.\n @param name The name of the custom attribute.\n @param handle The structure of the custom attribute corresponding to the key parameter name obtained.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 14"]
    pub fn OH_ArkUI_NodeUtils_GetCustomProperty(
        node: ArkUI_NodeHandle,
        name: *const ::std::os::raw::c_char,
        handle: *mut *mut ArkUI_CustomProperty,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the parent node to obtain the component nodes created by ArkTs.\n\n @param node Target node object.\n @return Return the pointer of the component.\n @since 14"]
    pub fn OH_ArkUI_NodeUtils_GetParentInPageTree(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Retrieve all active child nodes of a node. Span will not be counted in the children.\n\n @param head Pass in the node that needs to be obtained.\n @param handle The structure corresponding to the sub node information of the head node.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 14"]
    pub fn OH_ArkUI_NodeUtils_GetActiveChildrenInfo(
        head: ArkUI_NodeHandle,
        handle: *mut *mut ArkUI_ActiveChildrenInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Retrieve the root node of the current page.\n\n @param node Target node object.\n @return Return the pointer of the component.\n @since 14"]
    pub fn OH_ArkUI_NodeUtils_GetCurrentPageRootNode(node: ArkUI_NodeHandle) -> ArkUI_NodeHandle;
}
extern "C" {
    #[doc = " @brief Retrieve whether the component is labeled by C-API.\n\n @param node Target node object.\n @return Return whether the node is a Tag created by C-API,\n         true represents created by C-API, false represents not created by C-API.\n @since 14"]
    pub fn OH_ArkUI_NodeUtils_IsCreatedByNDK(node: ArkUI_NodeHandle) -> bool;
}
extern "C" {
    #[doc = " @brief Get the type of node.\n\n @param node Target node object.\n @return Return the type of the node.\n         For specific open types, refer to {@link ArkUI_NodeType}. For unopened nodes, return -1.\n @since 14"]
    pub fn OH_ArkUI_NodeUtils_GetNodeType(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Get info of the window to which the node belongs.\n\n @param node Target node object.\n @param info Window info. Use {@link OH_ArkUI_HostWindowInfo_Destroy} to release memory.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n         {@link ARKUI_ERROR_CODE_NODE_NOT_ON_MAIN_TREE} The node is not mounted.\n @since 15"]
    pub fn OH_ArkUI_NodeUtils_GetWindowInfo(
        node: ArkUI_NodeHandle,
        info: *mut *mut ArkUI_HostWindowInfo,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the index of the current FrameNode's first child node which is on the tree.\n\n @param node Indicates the target node.\n @param index The index of the subnode.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    pub fn OH_ArkUI_NodeUtils_GetFirstChildIndexWithoutExpand(
        node: ArkUI_NodeHandle,
        index: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the index of the current FrameNode's last child node which is on the tree.\n\n @param node Indicates the target node.\n @param index the index of the subnode.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    pub fn OH_ArkUI_NodeUtils_GetLastChildIndexWithoutExpand(
        node: ArkUI_NodeHandle,
        index: *mut u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a subnode by position with the expand mode.\n\n @param node Indicates the target node.\n @param position Indicates the position of the subnode.\n @param subnode The pointer to the subnode.\n @param expandMode Indicates the expand mode. {@link ArkUI_ExpandMode}.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    pub fn OH_ArkUI_NodeUtils_GetChildWithExpandMode(
        node: ArkUI_NodeHandle,
        position: i32,
        subnode: *mut ArkUI_NodeHandle,
        expandMode: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Collapse the ListItem in its expanded state.\n\n @param node Node objects that need to be registered for events.\n @param userData Custom event parameters are carried back in the callback parameter when the event is triggered.\n @param onFinish The callback triggered after the completion of the folding animation.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n         {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} The component does not support this event.\n @since 12"]
    pub fn OH_ArkUI_List_CloseAllSwipeActions(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onFinish: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the UIContext pointer to the page where the node is located.\n\n @param node The node.\n @return The UIContext pointer.\n         If a null pointer is returned, it may be because the node is empty.\n @since 12"]
    pub fn OH_ArkUI_GetContextByNode(node: ArkUI_NodeHandle) -> ArkUI_ContextHandle;
}
extern "C" {
    #[doc = " @brief The event called when the system color mode changes.\n        Only one system color change callback can be registered for the same component.\n\n @param node Indicates the target node.\n @param userData Indicates the custom data to be saved.\n @param onColorModeChange Callback Events.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n         {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} The component does not support this event.\n @since 12"]
    pub fn OH_ArkUI_RegisterSystemColorModeChangeEvent(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onColorModeChange: ::std::option::Option<
            unsafe extern "C" fn(
                colorMode: ArkUI_SystemColorMode,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregister the event callback when the system color mode changes.\n\n @param node Indicates the target node.\n @since 12"]
    pub fn OH_ArkUI_UnregisterSystemColorModeChangeEvent(node: ArkUI_NodeHandle);
}
extern "C" {
    #[doc = " @brief The event called when the system font style changes.\n        Only one system font change callback can be registered for the same component.\n\n @param node Indicates the target node.\n @param userData Indicates the custom data to be saved.\n @param onFontStyleChange Callback Events.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} Success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n         {@link ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED} The component does not support this event.\n @since 12"]
    pub fn OH_ArkUI_RegisterSystemFontStyleChangeEvent(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onFontStyleChange: ::std::option::Option<
            unsafe extern "C" fn(
                event: *mut ArkUI_SystemFontStyleEvent,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregister the event callback when the system font style changes.\n\n @param node Indicates the target node.\n @since 12"]
    pub fn OH_ArkUI_UnregisterSystemFontStyleChangeEvent(node: ArkUI_NodeHandle);
}
extern "C" {
    #[doc = " @brief Retrieve the font size value for system font change events.\n\n @param event Indicates a pointer to the current system font change event.\n @return Updated system font size scaling factor. Default value: 1.0.\n @since 12"]
    pub fn OH_ArkUI_SystemFontStyleEvent_GetFontSizeScale(
        event: *const ArkUI_SystemFontStyleEvent,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Retrieve the font thickness values for system font change events.\n\n @param event Indicates a pointer to the current system font change event.\n @return The updated system font thickness scaling factor. Default value: 1.0.\n @since 12"]
    pub fn OH_ArkUI_SystemFontStyleEvent_GetFontWeightScale(
        event: *const ArkUI_SystemFontStyleEvent,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Registers a callback for node when layout is completed.\n\n @param node Indicates the target node.\n @param userData Indicates the custom data used in onLayoutCompleted callback function.\n @param onLayoutCompleted Indicates the function when layout completed is callback.\n @return error code\n{@link ARKUI_INSPECTOR_NATIVE_RESULT_SUCCESSFUL} if the operation is successful.\n         {@link ARKUI_INSPECTOR_NATIVE_RESULT_BAD_PARAMETER} if a parameter is incorrect.\n @since 15"]
    pub fn OH_ArkUI_RegisterLayoutCallbackOnNodeHandle(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onLayoutCompleted: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Registers a callback for node when draw is completed.\n\n @param node Indicates the target node.\n @param userData Indicates the custom data used in onDrawCompleted callback function.\n @param onDrawCompleted Indicates the function when draw completed is callback.\n @return error code\n{@link ARKUI_INSPECTOR_NATIVE_RESULT_SUCCESSFUL} if the operation is successful.\n         {@link ARKUI_INSPECTOR_NATIVE_RESULT_BAD_PARAMETER} if a parameter is incorrect.\n @since 15"]
    pub fn OH_ArkUI_RegisterDrawCallbackOnNodeHandle(
        node: ArkUI_NodeHandle,
        userData: *mut ::std::os::raw::c_void,
        onDrawCompleted: ::std::option::Option<
            unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void),
        >,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Unregisters the layout completed callback for node.\n\n @param node Indicates the target node.\n @return error code\n{@link ARKUI_INSPECTOR_NATIVE_RESULT_SUCCESSFUL} if the operation is successful.\n         {@link ARKUI_INSPECTOR_NATIVE_RESULT_BAD_PARAMETER} if a parameter is incorrect.\n @since 15"]
    pub fn OH_ArkUI_UnregisterLayoutCallbackOnNodeHandle(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Unregisters the draw completed callback for node.\n\n @param node Indicates the target node.\n @return error code\n{@link ARKUI_INSPECTOR_NATIVE_RESULT_SUCCESSFUL} if the operation is successful.\n         {@link ARKUI_INSPECTOR_NATIVE_RESULT_BAD_PARAMETER} if a parameter is incorrect.\n @since 15"]
    pub fn OH_ArkUI_UnregisterDrawCallbackOnNodeHandle(node: ArkUI_NodeHandle) -> i32;
}
extern "C" {
    #[doc = " @brief Get the node handle by id.\n\n @param id The id of the target node handle.\n @param node The handle of target node handle.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    pub fn OH_ArkUI_NodeUtils_GetAttachedNodeHandleById(
        id: *const ::std::os::raw::c_char,
        node: *mut ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the cross-language option of the target node handle.\n\n @param node The target node handle.\n @param option The cross-language option {@link ArkUI_CrossLanguageOption}.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    pub fn OH_ArkUI_NodeUtils_SetCrossLanguageOption(
        node: ArkUI_NodeHandle,
        option: *mut ArkUI_CrossLanguageOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the snapshot pixelmap for the given node synchronously, will get error if the node is not on the\n tree or is not rendered yet.\n Note: the pixelmap should be released through OH_PixelmapNative_Release when it's not used any more.\n\n @param node Indicates the target node.\n @param snapshotOptions the given configuration for taking snapshot, can be null for using default.\n @param pixelmap Pixelmap pointer created by system, it's the out result.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_INTERNAL_ERROR} if the snapshot taking failed will null pixelmap returned.\n         Returns {@link ARKUI_ERROR_CODE_COMPONENT_SNAPSHOT_TIMEOUT} if the snapshot taking is timeout.\n @since 15"]
    pub fn OH_ArkUI_GetNodeSnapshot(
        node: ArkUI_NodeHandle,
        snapshotOptions: *mut ArkUI_SnapshotOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the cross-language option of the target node handle.\n\n @param node The target node handle.\n @param option The cross-language option {@link ArkUI_CrossLanguageOption}.\n @return Error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} success.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} Function parameter exception.\n @since 15"]
    pub fn OH_ArkUI_NodeUtils_GetCrossLanguageOption(
        node: ArkUI_NodeHandle,
        option: *mut ArkUI_CrossLanguageOption,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains the offset of a specific node relative to its parent node.\n\n @param node Target node.\n @param globalOffset Offset of the target node relative to its parent node, in px.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 15"]
    pub fn OH_ArkUI_NodeUtils_GetPositionToParent(
        node: ArkUI_NodeHandle,
        globalOffset: *mut ArkUI_IntOffset,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>FrameNode</b> object on the ArkTS side and maps it to an <b>ArkUI_NodeHandle</b> object on the\n native side.\n\n @param env Indicates the NAPI environment pointer.\n @param frameNode Indicates the <b>FrameNode</b> object created on the ArkTS side.\n @param handle Indicates the pointer to the <b>ArkUI_NodeHandle</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetNodeHandleFromNapiValue(
        env: napi_env,
        frameNode: napi_value,
        handle: *mut ArkUI_NodeHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>UIContext</b> object on the ArkTS side and maps it to an <b>ArkUI_ContextHandle</b> object on the\n native side.\n\n @param env ndicates the NAPI environment pointer.\n @param value Indicates the <b>UIContext</b> object created on the ArkTS side.\n @param context Indicates the pointer to the <b>ArkUI_ContextHandle</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetContextFromNapiValue(
        env: napi_env,
        value: napi_value,
        context: *mut ArkUI_ContextHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>NodeContent</b> object on the ArkTS side and maps it to an <b>ArkUI_NodeContentHandle</b>\n object on the native side.\n\n @param env ndicates the NAPI environment pointer.\n @param value Indicates the <b>NodeContent</b> object created on the ArkTS side.\n @param content Indicates the pointer to the <b>ArkUI_NodeContentHandle</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetNodeContentFromNapiValue(
        env: napi_env,
        value: napi_value,
        content: *mut ArkUI_NodeContentHandle,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>DrawableDescriptor</b> object on the ArkTS side and maps it to an\n <b>ArkUI_DrawableDescriptro</b> object on the native side.\n\n @param env Indicates the NAPI environment pointer.\n @param value Indicates the <b>DrawableDescriptor</b> object created on the ArkTS side.\n @param drawableDescriptor Indicates the pointer to the <b>ArkUI_DrawableDescriptro</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetDrawableDescriptorFromNapiValue(
        env: napi_env,
        value: napi_value,
        drawableDescriptor: *mut *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtains a <b>Resource</b> object on the ArkTS side and maps it to an\n <b>ArkUI_DrawableDescriptro</b> object on the native side.\n\n @param env Indicates the NAPI environment pointer.\n @param value Indicates the <b>Resource</b> object created on the ArkTS side.\n @param drawableDescriptor Indicates the pointer to the <b>ArkUI_DrawableDescriptro</b> object.\n @return Returns the error code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 12"]
    pub fn OH_ArkUI_GetDrawableDescriptorFromResourceNapiValue(
        env: napi_env,
        value: napi_value,
        drawableDescriptor: *mut *mut ArkUI_DrawableDescriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Obtain the ID of the Navigation component where the node is located.\n\n @param node The node.\n @param buffer The buffer to which NavigationID writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetNavigationId(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the name of the NavDestination component where the node is located.\n\n @param node The node.\n @param buffer The buffer to which NavDestination name writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationName(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Based on the given index value, obtain the length of the Navigation stack where the node is located.\n\n @param node The node.\n @param length The length of the stack. After the operation succeeds, the result is written back to this parameter.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or length is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n @since 12"]
    pub fn OH_ArkUI_GetNavStackLength(node: ArkUI_NodeHandle, length: *mut i32) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Based on the given index value, obtain the page name of the corresponding position\n        in the navigation stack where the node is located.\n        Index values are counted from 0, with 0 being the bottom of the stack.\n\n @param node The node.\n @param index The index of the NavDestination in the stack is queried.\n @param buffer The buffer to which NavDestination index writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_NODE_INDEX_INVALID} if index is an invalid value.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationNameByIndex(
        node: ArkUI_NodeHandle,
        index: i32,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the ID of the NavDestination component where the node is located.\n\n @param node The node.\n @param buffer The buffer to which NavDestination ID writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationId(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the state of the NavDestination component where the node is located.\n\n @param node The node.\n @param state The state value of NavDestination is written back into this parameter.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or state is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationState(
        node: ArkUI_NodeHandle,
        state: *mut ArkUI_NavDestinationState,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the index of the NavDestination component on the Navigation stack where the node is located.\n\n @param node The node.\n @param index Index value, counted from 0.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or index is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in Navigation.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationIndex(
        node: ArkUI_NodeHandle,
        index: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the parameters of the NavDestination component where the node is located.\n\n @param node The node.\n @return The parameters.\n         If a null pointer is returned, it may be because the node is empty or the parameters does not exist.\n @since 12"]
    pub fn OH_ArkUI_GetNavDestinationParam(node: ArkUI_NodeHandle) -> napi_value;
}
extern "C" {
    #[doc = " @brief Obtain the index of the page where the node resides in the Router page stack.\n\n @param node The node.\n @param index Index value, counted from 1.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or index is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPageIndex(node: ArkUI_NodeHandle, index: *mut i32) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the name of the page where the node is located.\n\n @param node The node.\n @param buffer The buffer to which page name writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPageName(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the path of the page where the node is located.\n\n @param node The node.\n @param buffer The buffer to which page path writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPagePath(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the state of the page where the node is located.\n\n @param node The node.\n @param state The state value of the page is written back to this parameter.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node or state is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPageState(
        node: ArkUI_NodeHandle,
        state: *mut ArkUI_RouterPageState,
    ) -> ArkUI_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtain the ID of the page where the node is located.\n\n @param node The node.\n @param buffer The buffer to which page ID writes to the memory,\n               memory space needs to be allocated by the developer.\n @param bufferSize The buffer size\n @param writeLength Indicates the string length actually written to the buffer\n                    when returning {@link ARKUI_ERROR_CODE_NO_ERROR}.\n                    Indicates the minimum buffer size that can accommodate the target\n                    when {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} is returned.\n @return The error code.\n         {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         {@link ARKUI_ERROR_CODE_PARAM_INVALID} if the node, buffer or writeLength is null.\n         {@link ARKUI_ERROR_CODE_GET_INFO_FAILED} if query information failed,\n         this may be because the node is not in RouterPage.\n         {@link ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR} If the buffer size is less than the minimum buffer size.\n @since 12"]
    pub fn OH_ArkUI_GetRouterPageId(
        node: ArkUI_NodeHandle,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: i32,
        writeLength: *mut i32,
    ) -> ArkUI_ErrorCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontCollection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Typography {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_TextStyle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_TypographyStyle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_TypographyCreate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_TextBox {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_PositionAndAffinity {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Range {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontParser {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_TextShadow {
    _unused: [u8; 0],
}
#[doc = " @error Operation completed successfully."]
pub const OH_Drawing_ErrorCode_OH_DRAWING_SUCCESS: OH_Drawing_ErrorCode = 0;
#[doc = " @error Permission verification failed."]
pub const OH_Drawing_ErrorCode_OH_DRAWING_ERROR_NO_PERMISSION: OH_Drawing_ErrorCode = 201;
#[doc = " @error Invalid input parameter. For example, the pointer in the parameter is a nullptr."]
pub const OH_Drawing_ErrorCode_OH_DRAWING_ERROR_INVALID_PARAMETER: OH_Drawing_ErrorCode = 401;
#[doc = " @error The parameter is not in the valid range."]
pub const OH_Drawing_ErrorCode_OH_DRAWING_ERROR_PARAMETER_OUT_OF_RANGE: OH_Drawing_ErrorCode =
    26200001;
#[doc = " @error mem allocate failed.\n @since 13"]
pub const OH_Drawing_ErrorCode_OH_DRAWING_ERROR_ALLOCATION_FAILED: OH_Drawing_ErrorCode = 26200002;
#[doc = " @brief Enumerates error codes of drawing.\n @since 12"]
pub type OH_Drawing_ErrorCode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Obtains the error code of the drawing module.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @return Returns the error code.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_ErrorCodeGet() -> OH_Drawing_ErrorCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Canvas {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Pen {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Region {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Brush {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Bitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Point {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_PixelMap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_ColorSpace {
    _unused: [u8; 0],
}
#[doc = " @brief Defines a point of 2d.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Point2D {
    pub x: f32,
    pub y: f32,
}
#[doc = " @brief Defines a corner radii, which is on x-axis and y-axis.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_Corner_Radii = OH_Drawing_Point2D;
#[doc = " @brief Defines a point of 3d, which is used to describe the coordinate point.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Point3D {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_PathEffect {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Rect {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_RoundRect {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Matrix {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_ShaderEffect {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_ShadowLayer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_MaskFilter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_ColorFilter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Font {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_MemoryStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontArguments {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Typeface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_TextBlob {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Image {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_ImageFilter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_SamplingOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_TextBlobBuilder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_GpuContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Surface {
    _unused: [u8; 0],
}
#[doc = " Unknown format."]
pub const OH_Drawing_ColorFormat_COLOR_FORMAT_UNKNOWN: OH_Drawing_ColorFormat = 0;
#[doc = " Each pixel is represented by 8 bits, which together indicate alpha."]
pub const OH_Drawing_ColorFormat_COLOR_FORMAT_ALPHA_8: OH_Drawing_ColorFormat = 1;
#[doc = " Each pixel is represented by 16 bits. From the most significant bit to the least significant bit,\n the first 5 bits indicate red, the subsequent 6 bits indicate green, and the last 5 bits indicate blue."]
pub const OH_Drawing_ColorFormat_COLOR_FORMAT_RGB_565: OH_Drawing_ColorFormat = 2;
#[doc = " Each pixel is represented by 16 bits. From the most significant bit to the least significant bit,\n every 4 bits indicate alpha, red, green, and blue, respectively."]
pub const OH_Drawing_ColorFormat_COLOR_FORMAT_ARGB_4444: OH_Drawing_ColorFormat = 3;
#[doc = " Each pixel is represented by 32 bits. From the most significant bit to the least significant bit,\n every 8 bits indicate alpha, red, green, and blue, respectively."]
pub const OH_Drawing_ColorFormat_COLOR_FORMAT_RGBA_8888: OH_Drawing_ColorFormat = 4;
#[doc = " Each pixel is represented by 32 bits. From the most significant bit to the least significant bit,\n every 8 bits indicate blue, green, red, and alpha, respectively."]
pub const OH_Drawing_ColorFormat_COLOR_FORMAT_BGRA_8888: OH_Drawing_ColorFormat = 5;
#[doc = " @brief Enumerates storage formats of bitmap pixels.\n\n @since 8\n @version 1.0"]
pub type OH_Drawing_ColorFormat = ::std::os::raw::c_uint;
#[doc = " Unknown format."]
pub const OH_Drawing_AlphaFormat_ALPHA_FORMAT_UNKNOWN: OH_Drawing_AlphaFormat = 0;
#[doc = " The bitmap does not have the alpha component."]
pub const OH_Drawing_AlphaFormat_ALPHA_FORMAT_OPAQUE: OH_Drawing_AlphaFormat = 1;
#[doc = " The color component of each pixel is premultiplied by the alpha component."]
pub const OH_Drawing_AlphaFormat_ALPHA_FORMAT_PREMUL: OH_Drawing_AlphaFormat = 2;
#[doc = " The color component of each pixel is not premultiplied by the alpha component."]
pub const OH_Drawing_AlphaFormat_ALPHA_FORMAT_UNPREMUL: OH_Drawing_AlphaFormat = 3;
#[doc = " @brief Enumerates alpha formats of bitmap pixels.\n\n @since 8\n @version 1.0"]
pub type OH_Drawing_AlphaFormat = ::std::os::raw::c_uint;
#[doc = " r = 0."]
pub const OH_Drawing_BlendMode_BLEND_MODE_CLEAR: OH_Drawing_BlendMode = 0;
#[doc = " r = s."]
pub const OH_Drawing_BlendMode_BLEND_MODE_SRC: OH_Drawing_BlendMode = 1;
#[doc = " r = d."]
pub const OH_Drawing_BlendMode_BLEND_MODE_DST: OH_Drawing_BlendMode = 2;
#[doc = " r = s + (1-sa)*d."]
pub const OH_Drawing_BlendMode_BLEND_MODE_SRC_OVER: OH_Drawing_BlendMode = 3;
#[doc = " r = d + (1-da)*s."]
pub const OH_Drawing_BlendMode_BLEND_MODE_DST_OVER: OH_Drawing_BlendMode = 4;
#[doc = " r = s * da."]
pub const OH_Drawing_BlendMode_BLEND_MODE_SRC_IN: OH_Drawing_BlendMode = 5;
#[doc = " r = d * sa."]
pub const OH_Drawing_BlendMode_BLEND_MODE_DST_IN: OH_Drawing_BlendMode = 6;
#[doc = " r = s * (1-da)."]
pub const OH_Drawing_BlendMode_BLEND_MODE_SRC_OUT: OH_Drawing_BlendMode = 7;
#[doc = " r = d * (1-sa)."]
pub const OH_Drawing_BlendMode_BLEND_MODE_DST_OUT: OH_Drawing_BlendMode = 8;
#[doc = " r = s*da + d*(1-sa)."]
pub const OH_Drawing_BlendMode_BLEND_MODE_SRC_ATOP: OH_Drawing_BlendMode = 9;
#[doc = " r = d*sa + s*(1-da)."]
pub const OH_Drawing_BlendMode_BLEND_MODE_DST_ATOP: OH_Drawing_BlendMode = 10;
#[doc = " r = s*(1-da) + d*(1-sa)."]
pub const OH_Drawing_BlendMode_BLEND_MODE_XOR: OH_Drawing_BlendMode = 11;
#[doc = " r = min(s + d, 1)."]
pub const OH_Drawing_BlendMode_BLEND_MODE_PLUS: OH_Drawing_BlendMode = 12;
#[doc = " r = s*d."]
pub const OH_Drawing_BlendMode_BLEND_MODE_MODULATE: OH_Drawing_BlendMode = 13;
#[doc = " r = s + d - s*d."]
pub const OH_Drawing_BlendMode_BLEND_MODE_SCREEN: OH_Drawing_BlendMode = 14;
#[doc = " multiply or screen, depending on destination."]
pub const OH_Drawing_BlendMode_BLEND_MODE_OVERLAY: OH_Drawing_BlendMode = 15;
#[doc = " rc = s + d - max(s*da, d*sa), ra = s + (1-sa)*d."]
pub const OH_Drawing_BlendMode_BLEND_MODE_DARKEN: OH_Drawing_BlendMode = 16;
#[doc = " rc = s + d - min(s*da, d*sa), ra = s + (1-sa)*d."]
pub const OH_Drawing_BlendMode_BLEND_MODE_LIGHTEN: OH_Drawing_BlendMode = 17;
#[doc = " brighten destination to reflect source."]
pub const OH_Drawing_BlendMode_BLEND_MODE_COLOR_DODGE: OH_Drawing_BlendMode = 18;
#[doc = " darken destination to reflect source."]
pub const OH_Drawing_BlendMode_BLEND_MODE_COLOR_BURN: OH_Drawing_BlendMode = 19;
#[doc = " multiply or screen, depending on source."]
pub const OH_Drawing_BlendMode_BLEND_MODE_HARD_LIGHT: OH_Drawing_BlendMode = 20;
#[doc = " lighten or darken, depending on source."]
pub const OH_Drawing_BlendMode_BLEND_MODE_SOFT_LIGHT: OH_Drawing_BlendMode = 21;
#[doc = " rc = s + d - 2*(min(s*da, d*sa)), ra = s + (1-sa)*d."]
pub const OH_Drawing_BlendMode_BLEND_MODE_DIFFERENCE: OH_Drawing_BlendMode = 22;
#[doc = " rc = s + d - two(s*d), ra = s + (1-sa)*d."]
pub const OH_Drawing_BlendMode_BLEND_MODE_EXCLUSION: OH_Drawing_BlendMode = 23;
#[doc = " r = s*(1-da) + d*(1-sa) + s*d."]
pub const OH_Drawing_BlendMode_BLEND_MODE_MULTIPLY: OH_Drawing_BlendMode = 24;
#[doc = " hue of source with saturation and luminosity of destination."]
pub const OH_Drawing_BlendMode_BLEND_MODE_HUE: OH_Drawing_BlendMode = 25;
#[doc = " saturation of source with hue and luminosity of destination."]
pub const OH_Drawing_BlendMode_BLEND_MODE_SATURATION: OH_Drawing_BlendMode = 26;
#[doc = " hue and saturation of source with luminosity of destination."]
pub const OH_Drawing_BlendMode_BLEND_MODE_COLOR: OH_Drawing_BlendMode = 27;
#[doc = " luminosity of source with hue and saturation of destination."]
pub const OH_Drawing_BlendMode_BLEND_MODE_LUMINOSITY: OH_Drawing_BlendMode = 28;
#[doc = " @brief The blending operation generates a new color for the two colors (source, destination).\n These operations are the same on the 4 color channels: red, green, blue, alpha.\n For these, we use alpha channel as an example, rather than naming each channel individually.\n\n For brevity, we use the following abbreviations.\n s  : source\n d  : destination\n sa : source alpha\n da : destination alpha\n\n Results are abbreviated\n r  : if all 4 channels are computed in the same manner\n ra : result alpha channel\n rc : result \"color\": red, green, blue channels\n\n @since 11\n @version 1.0"]
pub type OH_Drawing_BlendMode = ::std::os::raw::c_uint;
#[doc = " @brief Defines image info struct.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Image_Info {
    #[doc = " storage for width of image"]
    pub width: i32,
    #[doc = " storage for height of image"]
    pub height: i32,
    #[doc = " storage for color formats"]
    pub colorType: OH_Drawing_ColorFormat,
    #[doc = " storage for alpha formats"]
    pub alphaType: OH_Drawing_AlphaFormat,
}
#[doc = " @brief Defines rectstyle info struct.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_RectStyle_Info {
    #[doc = " color of rectstyle"]
    pub color: u32,
    #[doc = " radius in left top of rectstyle"]
    pub leftTopRadius: f64,
    #[doc = " radius in right top of rectstyle"]
    pub rightTopRadius: f64,
    #[doc = " radius in right bottom of rectstyle"]
    pub rightBottomRadius: f64,
    #[doc = " radius in left bottom of rectstyle"]
    pub leftBottomRadius: f64,
}
#[doc = " @brief Defines the string information struct.\n\n @since 14\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_String {
    #[doc = " A pointer to a byte string containing UTF-16 encoded entities"]
    pub strData: *mut u8,
    #[doc = " The length of `strData` in bytes"]
    pub strLen: u32,
}
#[doc = " uses bytes to represent UTF-8 or ASCII"]
pub const OH_Drawing_TextEncoding_TEXT_ENCODING_UTF8: OH_Drawing_TextEncoding = 0;
#[doc = " uses two byte words to represent most of Unicode"]
pub const OH_Drawing_TextEncoding_TEXT_ENCODING_UTF16: OH_Drawing_TextEncoding = 1;
#[doc = " uses four byte words to represent all of Unicode"]
pub const OH_Drawing_TextEncoding_TEXT_ENCODING_UTF32: OH_Drawing_TextEncoding = 2;
#[doc = " uses two byte words to represent glyph indices"]
pub const OH_Drawing_TextEncoding_TEXT_ENCODING_GLYPH_ID: OH_Drawing_TextEncoding = 3;
#[doc = " @brief Enumerates text encoding types.\n @since 12\n @version 1.0"]
pub type OH_Drawing_TextEncoding = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontMgr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontStyleSet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_RecordCmdUtils {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_RecordCmd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Array {
    _unused: [u8; 0],
}
#[doc = " Using sampling only inside bounds in a slower manner."]
pub const OH_Drawing_SrcRectConstraint_STRICT_SRC_RECT_CONSTRAINT: OH_Drawing_SrcRectConstraint = 0;
#[doc = " Using sampling outside bounds in a faster manner."]
pub const OH_Drawing_SrcRectConstraint_FAST_SRC_RECT_CONSTRAINT: OH_Drawing_SrcRectConstraint = 1;
#[doc = " @brief Enumeration defines the constraint type.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_SrcRectConstraint = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Creates an <b>OH_Drawing_Canvas</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @return Returns the pointer to the <b>OH_Drawing_Canvas</b> object created.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasCreate() -> *mut OH_Drawing_Canvas;
}
extern "C" {
    #[doc = " @brief Destroys an <b>OH_Drawing_Canvas</b> object and reclaims the memory occupied by the object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasDestroy(canvas: *mut OH_Drawing_Canvas);
}
extern "C" {
    #[doc = " @brief Binds a bitmap to a canvas so that the content drawn on the canvas\n is output to the bitmap (this process is called CPU rendering).\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param bitmap Indicates the pointer to an <b>OH_Drawing_Bitmap</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasBind(canvas: *mut OH_Drawing_Canvas, bitmap: *mut OH_Drawing_Bitmap);
}
extern "C" {
    #[doc = " @brief Attaches a pen to a canvas so that the canvas will use the style and color of the pen to outline a shape.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param pen Indicates the pointer to an <b>OH_Drawing_Pen</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasAttachPen(canvas: *mut OH_Drawing_Canvas, pen: *const OH_Drawing_Pen);
}
extern "C" {
    #[doc = " @brief Detaches the pen from a canvas so that the canvas will not use the style\n and color of the pen to outline a shape.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasDetachPen(canvas: *mut OH_Drawing_Canvas);
}
extern "C" {
    #[doc = " @brief Attaches a brush to a canvas so that the canvas will use the style and color of the brush to fill in a shape.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param brush Indicates the pointer to an <b>OH_Drawing_Brush</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasAttachBrush(
        canvas: *mut OH_Drawing_Canvas,
        brush: *const OH_Drawing_Brush,
    );
}
extern "C" {
    #[doc = " @brief Detaches the brush from a canvas so that the canvas will not use the style\n and color of the brush to fill in a shape.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasDetachBrush(canvas: *mut OH_Drawing_Canvas);
}
extern "C" {
    #[doc = " @brief Saves the current canvas status (canvas matrix) to the top of the stack.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasSave(canvas: *mut OH_Drawing_Canvas);
}
extern "C" {
    #[doc = " @brief Saves matrix and clip, and allocates a bitmap for subsequent drawing.\n Calling restore discards changes to matrix and clip, and draws the bitmap.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param rect Indicates the pointer to an <b>OH_Drawing_Rect</b> object.\n @param brush Indicates the pointer to an <b>OH_Drawing_Brush</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasSaveLayer(
        canvas: *mut OH_Drawing_Canvas,
        rect: *const OH_Drawing_Rect,
        brush: *const OH_Drawing_Brush,
    );
}
extern "C" {
    #[doc = " @brief Restores the canvas status (canvas matrix) saved on the top of the stack.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasRestore(canvas: *mut OH_Drawing_Canvas);
}
extern "C" {
    #[doc = " @brief Gets the number of the canvas status (canvas matrix) saved in the stack.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @return Returns a 32-bit variable that describes the number of canvas status.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasGetSaveCount(canvas: *mut OH_Drawing_Canvas) -> u32;
}
extern "C" {
    #[doc = " @brief Restores the specific number of the canvas status (canvas matrix) saved in the stack.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param saveCount Indicates the specific number of canvas status.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasRestoreToCount(canvas: *mut OH_Drawing_Canvas, saveCount: u32);
}
extern "C" {
    #[doc = " @brief Draws a line segment.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param x1 Indicates the x coordinate of the start point of the line segment.\n @param y1 Indicates the y coordinate of the start point of the line segment.\n @param x2 Indicates the x coordinate of the end point of the line segment.\n @param y2 Indicates the y coordinate of the end point of the line segment.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawLine(
        canvas: *mut OH_Drawing_Canvas,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    );
}
extern "C" {
    #[doc = " @brief Draws a path.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param path Indicates the pointer to an <b>OH_Drawing_Path</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawPath(canvas: *mut OH_Drawing_Canvas, path: *const OH_Drawing_Path);
}
extern "C" {
    #[doc = " @brief Draw the specified area of the Media::PixelMap to the specified area of the canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param pixelMap Indicates the pointer to an <b>OH_Drawing_PixelMap</b> object.\n @param src the area of source pixelmap.\n @param dst the area of destination canvas.\n @param samplingOptions the sampling mode.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawPixelMapRect(
        canvas: *mut OH_Drawing_Canvas,
        pixelMap: *mut OH_Drawing_PixelMap,
        src: *const OH_Drawing_Rect,
        dst: *const OH_Drawing_Rect,
        samplingOptions: *const OH_Drawing_SamplingOptions,
    );
}
extern "C" {
    #[doc = " @brief Fills clipped canvas area with brush.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param brush Indicates the pointer to an <b>OH_Drawing_Brush</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawBackground(
        canvas: *mut OH_Drawing_Canvas,
        brush: *const OH_Drawing_Brush,
    );
}
extern "C" {
    #[doc = " @brief Draws region using clip, matrix and paint.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param region Indicates the pointer to an <b>OH_Drawing_Region</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawRegion(
        canvas: *mut OH_Drawing_Canvas,
        region: *const OH_Drawing_Region,
    );
}
#[doc = " Draw each point separately."]
pub const OH_Drawing_PointMode_POINT_MODE_POINTS: OH_Drawing_PointMode = 0;
#[doc = " Draw each pair of points as a line segment."]
pub const OH_Drawing_PointMode_POINT_MODE_LINES: OH_Drawing_PointMode = 1;
#[doc = " Draw the array of points as a open polygon."]
pub const OH_Drawing_PointMode_POINT_MODE_POLYGON: OH_Drawing_PointMode = 2;
#[doc = " @brief Enumerates of scale to fit flags, selects if an array of points are drawn as discrete points, as lines,\n or as an open polygon.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_PointMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Draws a point.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param point Indicates the pointer to an <b>OH_Drawing_Point</b> object.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if canvas or point is nullptr.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawPoint(
        canvas: *mut OH_Drawing_Canvas,
        point: *const OH_Drawing_Point2D,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Draws point array as separate point, line segment or open polygon according to given point mode.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param mode Draw points enum.\n @param count The point count.\n @param point2D Point struct array.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawPoints(
        canvas: *mut OH_Drawing_Canvas,
        mode: OH_Drawing_PointMode,
        count: u32,
        point2D: *const OH_Drawing_Point2D,
    );
}
extern "C" {
    #[doc = " @brief Draws a bitmap.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param bitmap Indicates the pointer to an <b>OH_Drawing_Bitmap</b> object.\n @param left Indicates the left position of the <b>OH_Drawing_Bitmap</b>.\n @param top Indicates the top position of the <b>OH_Drawing_Bitmap</b>.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawBitmap(
        canvas: *mut OH_Drawing_Canvas,
        bitmap: *const OH_Drawing_Bitmap,
        left: f32,
        top: f32,
    );
}
extern "C" {
    #[doc = " @brief Draw the specified area of the bitmap to the specified area of the canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param bitmap Indicates the pointer to an <b>OH_Drawing_Bitmap</b> object.\n @param src the area of source bitmap, can be nullptr.\n @param dst the area of destination canvas.\n @param samplingOptions the sampling mode.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawBitmapRect(
        canvas: *mut OH_Drawing_Canvas,
        bitmap: *const OH_Drawing_Bitmap,
        src: *const OH_Drawing_Rect,
        dst: *const OH_Drawing_Rect,
        samplingOptions: *const OH_Drawing_SamplingOptions,
    );
}
extern "C" {
    #[doc = " @brief Draws a rect.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param rect Indicates the pointer to an <b>OH_Drawing_Rect</b> object.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawRect(canvas: *mut OH_Drawing_Canvas, rect: *const OH_Drawing_Rect);
}
extern "C" {
    #[doc = " @brief Draws a circle.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param point Indicates the pointer to an <b>OH_Drawing_Point</b> object.\n @param radius Indicates the radius of the circle.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawCircle(
        canvas: *mut OH_Drawing_Canvas,
        point: *const OH_Drawing_Point,
        radius: f32,
    );
}
extern "C" {
    #[doc = " @brief Fills the entire canvas with the specified color and blend mode.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param color Indicates the color, which is a 32-bit variable.\n @param blendMode Indicates the blend mode.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if canvas is nullptr.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawColor(
        canvas: *mut OH_Drawing_Canvas,
        color: u32,
        blendMode: OH_Drawing_BlendMode,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Draws an oval.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param rect Indicates the pointer to an <b>OH_Drawing_Rect</b> object.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawOval(canvas: *mut OH_Drawing_Canvas, rect: *const OH_Drawing_Rect);
}
extern "C" {
    #[doc = " @brief Draws an arc.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param rect Indicates the pointer to an <b>OH_Drawing_Rect</b> object.\n @param startAngle Indicates the startAngle of the arc.\n @param sweepAngle Indicates the sweepAngle of the arc.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawArc(
        canvas: *mut OH_Drawing_Canvas,
        rect: *const OH_Drawing_Rect,
        startAngle: f32,
        sweepAngle: f32,
    );
}
extern "C" {
    #[doc = " @brief Draws a roundrect.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param roundRect Indicates the pointer to an <b>OH_Drawing_RoundRect</b> object.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawRoundRect(
        canvas: *mut OH_Drawing_Canvas,
        roundRect: *const OH_Drawing_RoundRect,
    );
}
extern "C" {
    #[doc = " @brief Draws a single character.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param str Indicates the single character encoded in UTF-8.\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param x Indicates the horizontal offset applied to the single character.\n @param y Indicates the vertical offset applied to the single character.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if any of canvas, str\n                 and font is nullptr or strlen(str) is 0.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawSingleCharacter(
        canvas: *mut OH_Drawing_Canvas,
        str_: *const ::std::os::raw::c_char,
        font: *const OH_Drawing_Font,
        x: f32,
        y: f32,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Draws a textblob.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param textBlob Indicates the pointer to an <b>OH_Drawing_TextBlob</b> object.\n @param x Indicates the horizontal offset applied to blob.\n @param y Indicates the vertical offset applied to blob.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawTextBlob(
        canvas: *mut OH_Drawing_Canvas,
        textBlob: *const OH_Drawing_TextBlob,
        x: f32,
        y: f32,
    );
}
#[doc = " Clip with difference."]
pub const OH_Drawing_CanvasClipOp_DIFFERENCE: OH_Drawing_CanvasClipOp = 0;
#[doc = " Clip with intersection."]
pub const OH_Drawing_CanvasClipOp_INTERSECT: OH_Drawing_CanvasClipOp = 1;
#[doc = " @brief Enumerates clip op.\n\n @since 11\n @version 1.0"]
pub type OH_Drawing_CanvasClipOp = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Clip a rect.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param rect Indicates the pointer to an <b>OH_Drawing_Rect</b> object.\n @param clipOp Indicates the operation to apply to clip.\n @param doAntiAlias Indicates whether clip operation requires anti-aliased.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasClipRect(
        canvas: *mut OH_Drawing_Canvas,
        rect: *const OH_Drawing_Rect,
        clipOp: OH_Drawing_CanvasClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[doc = " @brief Clip a round rect.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param roundRect Indicates the pointer to an <b>OH_Drawing_RoundRect</b> object.\n @param clipOp Indicates the operation to apply to clip.\n @param doAntiAlias Indicates whether clip operation requires anti-aliased.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasClipRoundRect(
        canvas: *mut OH_Drawing_Canvas,
        roundRect: *const OH_Drawing_RoundRect,
        clipOp: OH_Drawing_CanvasClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[doc = " @brief Clip a path.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param path Indicates the pointer to an <b>OH_Drawing_Path</b> object.\n @param clipOp Indicates the operation to apply to clip.\n @param doAntiAlias Indicates whether clip operation requires anti-aliased.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasClipPath(
        canvas: *mut OH_Drawing_Canvas,
        path: *const OH_Drawing_Path,
        clipOp: OH_Drawing_CanvasClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[doc = " @brief Clips a region.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param region Indicates the pointer to an <b>OH_Drawing_Region</b> object.\n @param clipOp To apply to clip.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if canvas or region is nullptr.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasClipRegion(
        canvas: *mut OH_Drawing_Canvas,
        region: *const OH_Drawing_Region,
        clipOp: OH_Drawing_CanvasClipOp,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Rotates by degrees. Positive degrees rotates clockwise.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param degrees Indicates the amount to rotate, in degrees.\n @param px Indicates the x-axis value of the point to rotate about.\n @param py Indicates the y-axis value of the point to rotate about.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasRotate(canvas: *mut OH_Drawing_Canvas, degrees: f32, px: f32, py: f32);
}
extern "C" {
    #[doc = " @brief Translates by dx along the x-axis and dy along the y-axis.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param dx Indicates the distance to translate on x-axis.\n @param dy Indicates the distance to translate on y-axis.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasTranslate(canvas: *mut OH_Drawing_Canvas, dx: f32, dy: f32);
}
extern "C" {
    #[doc = " @brief Scales by sx on the x-axis and sy on the y-axis.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param sx Indicates the amount to scale on x-axis.\n @param sy Indicates the amount to scale on y-axis.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_CanvasScale(canvas: *mut OH_Drawing_Canvas, sx: f32, sy: f32);
}
extern "C" {
    #[doc = " @brief Skew by sx on the x-axis and sy on the y-axis.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param sx Indicates the amount to skew on x-axis.\n @param sy Indicates the amount to skew on y-axis.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasSkew(canvas: *mut OH_Drawing_Canvas, sx: f32, sy: f32);
}
extern "C" {
    #[doc = " @brief Get the width of a canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasGetWidth(canvas: *mut OH_Drawing_Canvas) -> i32;
}
extern "C" {
    #[doc = " @brief Get the height of a canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasGetHeight(canvas: *mut OH_Drawing_Canvas) -> i32;
}
extern "C" {
    #[doc = " @brief Get the bounds of clip of a canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param rect Indicates the pointer to an <b>OH_Drawing_Rect</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasGetLocalClipBounds(
        canvas: *mut OH_Drawing_Canvas,
        rect: *mut OH_Drawing_Rect,
    );
}
extern "C" {
    #[doc = " @brief Get a 3x3 matrix of the transform from local coordinates to 'device'.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param matrix Indicates the pointer to an <b>OH_Drawing_Matrix</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasGetTotalMatrix(
        canvas: *mut OH_Drawing_Canvas,
        matrix: *mut OH_Drawing_Matrix,
    );
}
extern "C" {
    #[doc = " @brief Use the passed matrix to transforming the geometry, then use existing matrix.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param matrix Indicates the pointer to an <b>OH_Drawing_Matrix</b> object,\n represents the matrix which is passed.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasConcatMatrix(
        canvas: *mut OH_Drawing_Canvas,
        matrix: *mut OH_Drawing_Matrix,
    );
}
#[doc = " Use no shadow flags."]
pub const OH_Drawing_CanvasShadowFlags_SHADOW_FLAGS_NONE: OH_Drawing_CanvasShadowFlags = 0;
#[doc = " The occluding object is transparent."]
pub const OH_Drawing_CanvasShadowFlags_SHADOW_FLAGS_TRANSPARENT_OCCLUDER:
    OH_Drawing_CanvasShadowFlags = 1;
#[doc = " No need to analyze shadows."]
pub const OH_Drawing_CanvasShadowFlags_SHADOW_FLAGS_GEOMETRIC_ONLY: OH_Drawing_CanvasShadowFlags =
    2;
#[doc = " Use all shadow flags."]
pub const OH_Drawing_CanvasShadowFlags_SHADOW_FLAGS_ALL: OH_Drawing_CanvasShadowFlags = 3;
#[doc = " @brief Enumerates of shadow flags.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_CanvasShadowFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Use circular light to draw an offset spot shadow and outlining ambient shadow for the given path.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param path Indicates the pointer to an <b>OH_Drawing_Path</b> object, use to generate shadows.\n @param planeParams Represents the value of the function which returns Z offset of the occluder from the\n canvas based on x and y.\n @param devLightPos Represents the position of the light relative to the canvas.\n @param lightRadius The radius of the circular light.\n @param ambientColor Ambient shadow's color.\n @param spotColor Spot shadow's color.\n @param flag Indicates the flag to control opaque occluder, shadow, and light position.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawShadow(
        canvas: *mut OH_Drawing_Canvas,
        path: *mut OH_Drawing_Path,
        planeParams: OH_Drawing_Point3D,
        devLightPos: OH_Drawing_Point3D,
        lightRadius: f32,
        ambientColor: u32,
        spotColor: u32,
        flag: OH_Drawing_CanvasShadowFlags,
    );
}
extern "C" {
    #[doc = " @brief Clears a canvas by using a specified color.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param color Indicates the color, which is a 32-bit (ARGB) variable.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CanvasClear(canvas: *mut OH_Drawing_Canvas, color: u32);
}
extern "C" {
    #[doc = " @brief Sets matrix of canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param matrix Indicates the pointer to an <b>OH_Drawing_Matrix</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasSetMatrix(
        canvas: *mut OH_Drawing_Canvas,
        matrix: *mut OH_Drawing_Matrix,
    );
}
extern "C" {
    #[doc = " @brief Reset matrix to the idenmtity matrix, any prior matrix state is overwritten.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasResetMatrix(canvas: *mut OH_Drawing_Canvas);
}
extern "C" {
    #[doc = " @brief Draws the specified source rectangle of the image onto the canvas,\n scaled and translated to the destination rectangle.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param image Indicates the pointer to an <b>OH_Drawing_Image</b> object.\n @param src The area of source image.\n @param dst The area of destination canvas.\n @param samplingOptions Indicates the pointer to an <b>OH_Drawing_SamplingOptions</b> object.\n @param srcRectConstraint Constraint type.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawImageRectWithSrc(
        canvas: *mut OH_Drawing_Canvas,
        image: *const OH_Drawing_Image,
        src: *const OH_Drawing_Rect,
        dst: *const OH_Drawing_Rect,
        samplingOptions: *const OH_Drawing_SamplingOptions,
        srcRectConstraint: OH_Drawing_SrcRectConstraint,
    );
}
extern "C" {
    #[doc = " @brief Draws the specified source rectangle of the image onto the canvas,\n scaled and translated to the destination rectangle.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param image Indicates the pointer to an <b>OH_Drawing_Image</b> object.\n @param rect Indicates the pointer to an <b>OH_Drawing_Rect</b> object.\n @param samplingOptions Indicates the pointer to an <b>OH_Drawing_SamplingOptions</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawImageRect(
        canvas: *mut OH_Drawing_Canvas,
        image: *mut OH_Drawing_Image,
        rect: *mut OH_Drawing_Rect,
        samplingOptions: *mut OH_Drawing_SamplingOptions,
    );
}
#[doc = " The vertices are a triangle list."]
pub const OH_Drawing_VertexMode_VERTEX_MODE_TRIANGLES: OH_Drawing_VertexMode = 0;
#[doc = " The vertices are a triangle strip."]
pub const OH_Drawing_VertexMode_VERTEX_MODE_TRIANGLES_STRIP: OH_Drawing_VertexMode = 1;
#[doc = " The vertices are a triangle fan."]
pub const OH_Drawing_VertexMode_VERTEX_MODE_TRIANGLE_FAN: OH_Drawing_VertexMode = 2;
#[doc = " @brief Enumerates of vertices flags.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_VertexMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Draw a triangular mesh with vertex descriptions.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param vertexMmode Draw a set of vertices.\n @param vertexCount Vertex count.\n @param positions Positions data pointer.\n @param texs Texture coordinate data pointer.\n @param colors Color data pointer.\n @param indexCount Index count.\n @param indices Index data pointer.\n @param mode Blend mode used for drawing.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawVertices(
        canvas: *mut OH_Drawing_Canvas,
        vertexMmode: OH_Drawing_VertexMode,
        vertexCount: i32,
        positions: *const OH_Drawing_Point2D,
        texs: *const OH_Drawing_Point2D,
        colors: *const u32,
        indexCount: i32,
        indices: *const u16,
        mode: OH_Drawing_BlendMode,
    );
}
extern "C" {
    #[doc = " @brief Read pixels data from canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param imageInfo width, height, colorType, and alphaType of dstPixels.\n @param dstPixels destination pixel storage.\n @param dstRowBytes size of one row of pixels.\n @param srcX offset into canvas writable pixels on x-axis.\n @param srcY offset into canvas writable pixels on y-axis.\n @return true if pixels are copied to dstPixels.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasReadPixels(
        canvas: *mut OH_Drawing_Canvas,
        imageInfo: *mut OH_Drawing_Image_Info,
        dstPixels: *mut ::std::os::raw::c_void,
        dstRowBytes: u32,
        srcX: i32,
        srcY: i32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Read pixels data to a bitmap from canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param bitmap Indicates the pointer to an <b>OH_Drawing_Bitmap</b> object.\n @param srcX offset into canvas writable pixels on x-axis.\n @param srcY offset into canvas writable pixels on y-axis.\n @return true if pixels are copied to dstBitmap.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasReadPixelsToBitmap(
        canvas: *mut OH_Drawing_Canvas,
        bitmap: *mut OH_Drawing_Bitmap,
        srcX: i32,
        srcY: i32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Checks whether the drawable area is empty.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param isClipEmpty Indicates if drawable area is empty.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if canvas or isClipEmpty is nullptr.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasIsClipEmpty(
        canvas: *mut OH_Drawing_Canvas,
        isClipEmpty: *mut bool,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Gets image info of canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param imageInfo Indicates the pointer to an <b>OH_Drawing_Image_Info</b> object.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if canvas or imageInfo is nullptr.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CanvasGetImageInfo(
        canvas: *mut OH_Drawing_Canvas,
        imageInfo: *mut OH_Drawing_Image_Info,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Replay drawing command.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param recordCmd Indicates the pointer to an <b>OH_Drawing_RecordCmd</b> object.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if canvas or recordCmd is nullptr.\n @since 13\n @version 1.0"]
    pub fn OH_Drawing_CanvasDrawRecordCmd(
        canvas: *mut OH_Drawing_Canvas,
        recordCmd: *mut OH_Drawing_RecordCmd,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Converts four variables (alpha, red, green, and blue) into a 32-bit (ARGB) variable that describes a color.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param alpha Indicates a variable that describes alpha. The value ranges from 0x00 to 0xFF.\n @param red Indicates a variable that describes red. The value ranges from 0x00 to 0xFF.\n @param green Indicates a variable that describes green. The value ranges from 0x00 to 0xFF.\n @param blue Indicates a variable that describes blue. The value ranges from 0x00 to 0xFF.\n @return Returns a 32-bit (ARGB) variable that describes the color.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_ColorSetArgb(alpha: u32, red: u32, green: u32, blue: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Creates an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @return Returns the pointer to the <b>OH_Drawing_Font</b> object created.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_FontCreate() -> *mut OH_Drawing_Font;
}
#[doc = " glyph outlines unchanged"]
pub const OH_Drawing_FontHinting_FONT_HINTING_NONE: OH_Drawing_FontHinting = 0;
#[doc = " minimal modification to improve contrast"]
pub const OH_Drawing_FontHinting_FONT_HINTING_SLIGHT: OH_Drawing_FontHinting = 1;
#[doc = " glyph outlines modified to improve contrast"]
pub const OH_Drawing_FontHinting_FONT_HINTING_NORMAL: OH_Drawing_FontHinting = 2;
#[doc = " modifies glyph outlines for maximum contrast"]
pub const OH_Drawing_FontHinting_FONT_HINTING_FULL: OH_Drawing_FontHinting = 3;
#[doc = " @brief Enumerates font hinting pattern.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_FontHinting = ::std::os::raw::c_uint;
#[doc = " no transparent pixels on glyph edges"]
pub const OH_Drawing_FontEdging_FONT_EDGING_ALIAS: OH_Drawing_FontEdging = 0;
#[doc = " may have transparent pixels on glyph edges"]
pub const OH_Drawing_FontEdging_FONT_EDGING_ANTI_ALIAS: OH_Drawing_FontEdging = 1;
#[doc = " glyph positioned in pixel using transparency"]
pub const OH_Drawing_FontEdging_FONT_EDGING_SUBPIXEL_ANTI_ALIAS: OH_Drawing_FontEdging = 2;
#[doc = " @brief Enumerates font edging effect.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_FontEdging = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Sets whether the font baselines and pixels alignment when the transformation matrix is \u{200b}\u{200b}axis aligned.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param baselineSnap Indicates whether the font baselines and pixels alignment.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontSetBaselineSnap(font: *mut OH_Drawing_Font, baselineSnap: bool);
}
extern "C" {
    #[doc = " @brief Gets whether the font baselines and pixels alignment when the transformation matrix is \u{200b}\u{200b}axis aligned.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns <b>true</b> if the font baselines and pixels alignment; returns <b>false</b> otherwise.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontIsBaselineSnap(font: *const OH_Drawing_Font) -> bool;
}
extern "C" {
    #[doc = " @brief Sets whether the font uses sub-pixel rendering.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param isSubpixel Indicates whether the font uses sub-pixel rendering.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontSetSubpixel(font: *mut OH_Drawing_Font, isSubpixel: bool);
}
extern "C" {
    #[doc = " @brief Gets whether the font uses sub-pixel rendering.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns <b>true</b> if the font uses sub-pixel rendering; returns <b>false</b> otherwise.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontIsSubpixel(font: *const OH_Drawing_Font) -> bool;
}
extern "C" {
    #[doc = " @brief Sets whether the font outline is automatically adjusted.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param isForceAutoHinting Indicates whether the font outline is automatically adjusted.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontSetForceAutoHinting(font: *mut OH_Drawing_Font, isForceAutoHinting: bool);
}
extern "C" {
    #[doc = " @brief Gets whether the font outline is automatically adjusted.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns <b>true</b> if the font outline is automatically adjusted; returns <b>false</b> otherwise.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontIsForceAutoHinting(font: *const OH_Drawing_Font) -> bool;
}
extern "C" {
    #[doc = " @brief Sets an <b>OH_Drawing_Typeface</b> object for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param typeface Indicates the pointer to an <b>OH_Drawing_Typeface</b> object.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_FontSetTypeface(
        font: *mut OH_Drawing_Font,
        typeface: *mut OH_Drawing_Typeface,
    );
}
extern "C" {
    #[doc = " @brief Gets an <b>OH_Drawing_Typeface</b> object from the <b>OH_Drawing_Typeface</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return OH_Drawing_Typeface Indicates the pointer to an <b>OH_Drawing_Typeface</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontGetTypeface(font: *mut OH_Drawing_Font) -> *mut OH_Drawing_Typeface;
}
extern "C" {
    #[doc = " @brief Sets text size for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param textSize Indicates the text size.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_FontSetTextSize(font: *mut OH_Drawing_Font, textSize: f32);
}
extern "C" {
    #[doc = " @brief Gets text size for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns the size of text.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontGetTextSize(font: *const OH_Drawing_Font) -> f32;
}
extern "C" {
    #[doc = " @brief Calculate number of glyphs represented by text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param text Indicates the character storage encoded with text encoding.\n @param byteLength Indicates the text length in bytes.\n @param encoding Indicates the text encoding.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontCountText(
        font: *mut OH_Drawing_Font,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        encoding: OH_Drawing_TextEncoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Converts text into glyph indices.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param text Indicates the character storage encoded with text encoding.\n @param byteLength Indicates the text length in bytes.\n @param encoding Indicates the text encoding.\n @param glyphs Indicates the storage for glyph indices.\n @param maxGlyphCount Indicates the storage capacity.\n @return Returns the number of glyph indices represented by text.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontTextToGlyphs(
        font: *const OH_Drawing_Font,
        text: *const ::std::os::raw::c_void,
        byteLength: u32,
        encoding: OH_Drawing_TextEncoding,
        glyphs: *mut u16,
        maxGlyphCount: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Retrieves the advance for each glyph in glyphs.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param glyphs Indicates the array of glyph indices to be measured.\n @param count Indicates the number of glyphs.\n @param widths Indicates the text advances for each glyph returned to the caller.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontGetWidths(
        font: *const OH_Drawing_Font,
        glyphs: *const u16,
        count: ::std::os::raw::c_int,
        widths: *mut f32,
    );
}
extern "C" {
    #[doc = " @brief Measures the width of a single character.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param str Indicates the single character encoded in UTF-8.\n @param textWidth Indicates the width of the single character.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if any of font, str\n                 and textWidth is nullptr or strlen(str) is 0.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontMeasureSingleCharacter(
        font: *const OH_Drawing_Font,
        str_: *const ::std::os::raw::c_char,
        textWidth: *mut f32,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Measures the width of text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param text Indicates the character storage encoded with text encoding.\n @param byteLength Indicates the text length in bytes.\n @param encoding Indicates the text encoding.\n @param bounds Gets the bounding box relative to (0, 0) if not nullptr.\n @param textWidth Indicates the width of text.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if any of font, text\n                 and textWidth is nullptr or byteLength is 0.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontMeasureText(
        font: *const OH_Drawing_Font,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        encoding: OH_Drawing_TextEncoding,
        bounds: *mut OH_Drawing_Rect,
        textWidth: *mut f32,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Enables or disables linearly scalable font for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param isLinearText Indicates whether to enable linearly scalable font.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_FontSetLinearText(font: *mut OH_Drawing_Font, isLinearText: bool);
}
extern "C" {
    #[doc = " @brief Gets whether the font is linearly scalable.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns <b>true</b> if the font is linearly scalable; returns <b>false</b> otherwise.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontIsLinearText(font: *const OH_Drawing_Font) -> bool;
}
extern "C" {
    #[doc = " @brief Sets text skew on x-axis for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param skewX Indicates the additional shear on x-axis relative to y-axis.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_FontSetTextSkewX(font: *mut OH_Drawing_Font, skewX: f32);
}
extern "C" {
    #[doc = " @brief Gets text skew on x-axis for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns additional skew on x-axis relative to y-axis.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontGetTextSkewX(font: *const OH_Drawing_Font) -> f32;
}
extern "C" {
    #[doc = " @brief Enables or disables to increase stroke width to approximate bold fonts for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param isFakeBoldText Indicates whether to enable to increase stroke width.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_FontSetFakeBoldText(font: *mut OH_Drawing_Font, isFakeBoldText: bool);
}
extern "C" {
    #[doc = " @brief Gets whether to increase the stroke width to approximate bold fonts.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns <b>true</b> to increase the stroke width to approximate bold fonts; returns <b>false</b> otherwise.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontIsFakeBoldText(font: *const OH_Drawing_Font) -> bool;
}
extern "C" {
    #[doc = " @brief Sets text scale on x-axis for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param scaleX Indicates the text horizontal scale.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontSetScaleX(font: *mut OH_Drawing_Font, scaleX: f32);
}
extern "C" {
    #[doc = " @brief Gets text scale on x-axis from an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns text horizontal scale on x-axis.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontGetScaleX(font: *const OH_Drawing_Font) -> f32;
}
extern "C" {
    #[doc = " @brief Sets hinting pattern for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param fontHinting Indicates the font hinting pattern.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontSetHinting(
        font: *mut OH_Drawing_Font,
        fontHinting: OH_Drawing_FontHinting,
    );
}
extern "C" {
    #[doc = " @brief Gets hinting pattern from an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns the font hinting pattern.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontGetHinting(font: *const OH_Drawing_Font) -> OH_Drawing_FontHinting;
}
extern "C" {
    #[doc = " @brief Sets whether to use bitmaps instead of outlines in the <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param isEmbeddedBitmaps Indicates whether to use bitmaps instead of outlines.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontSetEmbeddedBitmaps(font: *mut OH_Drawing_Font, isEmbeddedBitmaps: bool);
}
extern "C" {
    #[doc = " @brief Gets whether to use bitmaps instead of outlines in the <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns <b>true</b> if using bitmaps instead of outlines; returns <b>false</b> otherwise.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontIsEmbeddedBitmaps(font: *const OH_Drawing_Font) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the font edging effect for an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param fontEdging Indicates the font edging effect.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontSetEdging(font: *mut OH_Drawing_Font, fontEdging: OH_Drawing_FontEdging);
}
extern "C" {
    #[doc = " @brief Gets the font edging effect from an <b>OH_Drawing_Font</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @return Returns the font edging effect.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontGetEdging(font: *const OH_Drawing_Font) -> OH_Drawing_FontEdging;
}
extern "C" {
    #[doc = " @brief Destroys an <b>OH_Drawing_Font</b> object and reclaims the memory occupied by the object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_FontDestroy(font: *mut OH_Drawing_Font);
}
#[doc = " @brief Defines a run, supplies storage for the metrics of an <b>OH_Drawing_Font</b>.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Font_Metrics {
    #[doc = " Indicating which metrics are valid"]
    pub flags: u32,
    #[doc = " storage for top in font metrics"]
    pub top: f32,
    #[doc = " storage for ascent in font metrics"]
    pub ascent: f32,
    #[doc = " storage for descent in font metrics"]
    pub descent: f32,
    #[doc = " storage for bottom in font metrics"]
    pub bottom: f32,
    #[doc = " storage for leading in font metrics"]
    pub leading: f32,
    #[doc = "  Average character width, zero if unknown"]
    pub avgCharWidth: f32,
    #[doc = " Maximum character width, zero if unknown"]
    pub maxCharWidth: f32,
    #[doc = " Greatest extent to left of origin of any glyph bounding box, typically negative; deprecated with variable fonts"]
    pub xMin: f32,
    #[doc = " Greatest extent to right of origin of any glyph bounding box, typically positive; deprecated with variable fonts"]
    pub xMax: f32,
    #[doc = " Height of lower-case letter, zero if unknown, typically negative"]
    pub xHeight: f32,
    #[doc = " Height of an upper-case letter, zero if unknown, typically negative"]
    pub capHeight: f32,
    #[doc = " @brief Underline thickness"]
    pub underlineThickness: f32,
    #[doc = " Distance from baseline to top of stroke, typically positive"]
    pub underlinePosition: f32,
    #[doc = " Strikeout thickness"]
    pub strikeoutThickness: f32,
    #[doc = " Distance from baseline to bottom of stroke, typically negative"]
    pub strikeoutPosition: f32,
}
extern "C" {
    #[doc = " @brief Obtains the metrics of a font.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param fontMetrics Indicates the pointer to an <b>OH_Drawing_Font_Metrics</b> object.\n @return Returns a float variable that recommended spacing between lines.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontGetMetrics(
        font: *mut OH_Drawing_Font,
        fontMetrics: *mut OH_Drawing_Font_Metrics,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Sets whether to follow the theme font. If the value is true, the theme font is used when typeface is not set.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param followed Indicates whether to follow the theme font.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if font is nullptr.\n @since 15"]
    pub fn OH_Drawing_FontSetThemeFontFollowed(
        font: *mut OH_Drawing_Font,
        followed: bool,
    ) -> OH_Drawing_ErrorCode;
}
extern "C" {
    #[doc = " @brief Gets whether to follow the theme font.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param font Indicates the pointer to an <b>OH_Drawing_Font</b> object.\n @param followed Indicates whether to follow the theme font.\n @return Returns the error code.\n         Returns {@link OH_DRAWING_SUCCESS} if the operation is successful.\n         Returns {@link OH_DRAWING_ERROR_INVALID_PARAMETER} if font or followed is nullptr.\n @since 15"]
    pub fn OH_Drawing_FontIsThemeFontFollowed(
        font: *const OH_Drawing_Font,
        followed: *mut bool,
    ) -> OH_Drawing_ErrorCode;
}
#[doc = " Right to left (RTL)"]
pub const OH_Drawing_TextDirection_TEXT_DIRECTION_RTL: OH_Drawing_TextDirection = 0;
#[doc = " Left to right (LTR)"]
pub const OH_Drawing_TextDirection_TEXT_DIRECTION_LTR: OH_Drawing_TextDirection = 1;
#[doc = " @brief Enumerates text directions.\n\n @since 8\n @version 1.0"]
pub type OH_Drawing_TextDirection = ::std::os::raw::c_uint;
#[doc = " Left-aligned"]
pub const OH_Drawing_TextAlign_TEXT_ALIGN_LEFT: OH_Drawing_TextAlign = 0;
#[doc = " Right-aligned"]
pub const OH_Drawing_TextAlign_TEXT_ALIGN_RIGHT: OH_Drawing_TextAlign = 1;
#[doc = " Center-aligned"]
pub const OH_Drawing_TextAlign_TEXT_ALIGN_CENTER: OH_Drawing_TextAlign = 2;
#[doc = " Justified, which means that each line (except the last line) is stretched so that every line has equal width,\n and the left and right margins are straight."]
pub const OH_Drawing_TextAlign_TEXT_ALIGN_JUSTIFY: OH_Drawing_TextAlign = 3;
#[doc = " <b>TEXT_ALIGN_START</b> achieves the same effect as <b>TEXT_ALIGN_LEFT</b>\n when <b>OH_Drawing_TextDirection</b> is <b>TEXT_DIRECTION_LTR</b>;\n it achieves the same effect as <b>TEXT_ALIGN_RIGHT</b>\n when <b>OH_Drawing_TextDirection</b> is <b>TEXT_DIRECTION_RTL</b>."]
pub const OH_Drawing_TextAlign_TEXT_ALIGN_START: OH_Drawing_TextAlign = 4;
#[doc = " <b>TEXT_ALIGN_END</b> achieves the same effect as <b>TEXT_ALIGN_RIGHT</b>\n when <b>OH_Drawing_TextDirection</b> is <b>TEXT_DIRECTION_LTR</b>;\n it achieves the same effect as <b>TEXT_ALIGN_LEFT</b>\n when <b>OH_Drawing_TextDirection</b> is <b>TEXT_DIRECTION_RTL</b>."]
pub const OH_Drawing_TextAlign_TEXT_ALIGN_END: OH_Drawing_TextAlign = 5;
#[doc = " @brief Enumerates text alignment modes.\n\n @since 8\n @version 1.0"]
pub type OH_Drawing_TextAlign = ::std::os::raw::c_uint;
#[doc = " Thin"]
pub const OH_Drawing_FontWeight_FONT_WEIGHT_100: OH_Drawing_FontWeight = 0;
#[doc = " Extra-light"]
pub const OH_Drawing_FontWeight_FONT_WEIGHT_200: OH_Drawing_FontWeight = 1;
#[doc = " Light"]
pub const OH_Drawing_FontWeight_FONT_WEIGHT_300: OH_Drawing_FontWeight = 2;
#[doc = " Normal/Regular"]
pub const OH_Drawing_FontWeight_FONT_WEIGHT_400: OH_Drawing_FontWeight = 3;
#[doc = " Medium"]
pub const OH_Drawing_FontWeight_FONT_WEIGHT_500: OH_Drawing_FontWeight = 4;
#[doc = " Semi-bold"]
pub const OH_Drawing_FontWeight_FONT_WEIGHT_600: OH_Drawing_FontWeight = 5;
#[doc = " Bold"]
pub const OH_Drawing_FontWeight_FONT_WEIGHT_700: OH_Drawing_FontWeight = 6;
#[doc = " Extra-bold"]
pub const OH_Drawing_FontWeight_FONT_WEIGHT_800: OH_Drawing_FontWeight = 7;
#[doc = " Black"]
pub const OH_Drawing_FontWeight_FONT_WEIGHT_900: OH_Drawing_FontWeight = 8;
#[doc = " @brief Enumerates font weights.\n\n @since 8\n @version 1.0"]
pub type OH_Drawing_FontWeight = ::std::os::raw::c_uint;
#[doc = " Alphabetic, where the letters in alphabets like English sit on."]
pub const OH_Drawing_TextBaseline_TEXT_BASELINE_ALPHABETIC: OH_Drawing_TextBaseline = 0;
#[doc = " Ideographic. The baseline is at the bottom of the text area."]
pub const OH_Drawing_TextBaseline_TEXT_BASELINE_IDEOGRAPHIC: OH_Drawing_TextBaseline = 1;
#[doc = " @brief Enumerates text baselines.\n\n @since 8\n @version 1.0"]
pub type OH_Drawing_TextBaseline = ::std::os::raw::c_uint;
#[doc = " No decoration."]
pub const OH_Drawing_TextDecoration_TEXT_DECORATION_NONE: OH_Drawing_TextDecoration = 0;
#[doc = " A underline is used for decoration."]
pub const OH_Drawing_TextDecoration_TEXT_DECORATION_UNDERLINE: OH_Drawing_TextDecoration = 1;
#[doc = " An overline is used for decoration."]
pub const OH_Drawing_TextDecoration_TEXT_DECORATION_OVERLINE: OH_Drawing_TextDecoration = 2;
#[doc = " A strikethrough is used for decoration."]
pub const OH_Drawing_TextDecoration_TEXT_DECORATION_LINE_THROUGH: OH_Drawing_TextDecoration = 4;
#[doc = " @brief Enumerates text decorations.\n\n @since 8\n @version 1.0"]
pub type OH_Drawing_TextDecoration = ::std::os::raw::c_uint;
#[doc = " Normal style"]
pub const OH_Drawing_FontStyle_FONT_STYLE_NORMAL: OH_Drawing_FontStyle = 0;
#[doc = " Italic style"]
pub const OH_Drawing_FontStyle_FONT_STYLE_ITALIC: OH_Drawing_FontStyle = 1;
#[doc = " Oblique style"]
pub const OH_Drawing_FontStyle_FONT_STYLE_OBLIQUE: OH_Drawing_FontStyle = 2;
#[doc = " @brief Enumerates font styles.\n\n @since 8\n @version 1.0"]
pub type OH_Drawing_FontStyle = ::std::os::raw::c_uint;
#[doc = " Offset At Baseline"]
pub const OH_Drawing_PlaceholderVerticalAlignment_ALIGNMENT_OFFSET_AT_BASELINE:
    OH_Drawing_PlaceholderVerticalAlignment = 0;
#[doc = " Above Baseline"]
pub const OH_Drawing_PlaceholderVerticalAlignment_ALIGNMENT_ABOVE_BASELINE:
    OH_Drawing_PlaceholderVerticalAlignment = 1;
#[doc = " Below Baseline"]
pub const OH_Drawing_PlaceholderVerticalAlignment_ALIGNMENT_BELOW_BASELINE:
    OH_Drawing_PlaceholderVerticalAlignment = 2;
#[doc = " Top of Row Box"]
pub const OH_Drawing_PlaceholderVerticalAlignment_ALIGNMENT_TOP_OF_ROW_BOX:
    OH_Drawing_PlaceholderVerticalAlignment = 3;
#[doc = " Bottom of Row Box"]
pub const OH_Drawing_PlaceholderVerticalAlignment_ALIGNMENT_BOTTOM_OF_ROW_BOX:
    OH_Drawing_PlaceholderVerticalAlignment = 4;
#[doc = " Center of Row Box"]
pub const OH_Drawing_PlaceholderVerticalAlignment_ALIGNMENT_CENTER_OF_ROW_BOX:
    OH_Drawing_PlaceholderVerticalAlignment = 5;
#[doc = " @brief Enumerates placeholder vertical alignment.\n\n @since 11\n @version 1.0"]
pub type OH_Drawing_PlaceholderVerticalAlignment = ::std::os::raw::c_uint;
#[doc = " @brief Defines the placeholder span.\n\n @since 11\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_PlaceholderSpan {
    #[doc = " width of placeholder"]
    pub width: f64,
    #[doc = " height of placeholder"]
    pub height: f64,
    #[doc = " alignment of placeholder"]
    pub alignment: OH_Drawing_PlaceholderVerticalAlignment,
    #[doc = " baseline of placeholder"]
    pub baseline: OH_Drawing_TextBaseline,
    #[doc = " baselineoffset of placeholder"]
    pub baselineOffset: f64,
}
#[doc = " Solid style"]
pub const OH_Drawing_TextDecorationStyle_TEXT_DECORATION_STYLE_SOLID:
    OH_Drawing_TextDecorationStyle = 0;
#[doc = " Double style"]
pub const OH_Drawing_TextDecorationStyle_TEXT_DECORATION_STYLE_DOUBLE:
    OH_Drawing_TextDecorationStyle = 1;
#[doc = " Dotted style"]
pub const OH_Drawing_TextDecorationStyle_TEXT_DECORATION_STYLE_DOTTED:
    OH_Drawing_TextDecorationStyle = 2;
#[doc = " Dashed style"]
pub const OH_Drawing_TextDecorationStyle_TEXT_DECORATION_STYLE_DASHED:
    OH_Drawing_TextDecorationStyle = 3;
#[doc = " Wavy style"]
pub const OH_Drawing_TextDecorationStyle_TEXT_DECORATION_STYLE_WAVY:
    OH_Drawing_TextDecorationStyle = 4;
#[doc = " @brief Enumerates text decoration style.\n\n @since 11\n @version 1.0"]
pub type OH_Drawing_TextDecorationStyle = ::std::os::raw::c_uint;
#[doc = " Head modal"]
pub const OH_Drawing_EllipsisModal_ELLIPSIS_MODAL_HEAD: OH_Drawing_EllipsisModal = 0;
#[doc = " Middle modal"]
pub const OH_Drawing_EllipsisModal_ELLIPSIS_MODAL_MIDDLE: OH_Drawing_EllipsisModal = 1;
#[doc = " Tail modal"]
pub const OH_Drawing_EllipsisModal_ELLIPSIS_MODAL_TAIL: OH_Drawing_EllipsisModal = 2;
#[doc = " @brief Enumerates ellipsis modal.\n\n @since 11\n @version 1.0"]
pub type OH_Drawing_EllipsisModal = ::std::os::raw::c_uint;
#[doc = " Greedy strategy"]
pub const OH_Drawing_BreakStrategy_BREAK_STRATEGY_GREEDY: OH_Drawing_BreakStrategy = 0;
#[doc = " Quality strategy"]
pub const OH_Drawing_BreakStrategy_BREAK_STRATEGY_HIGH_QUALITY: OH_Drawing_BreakStrategy = 1;
#[doc = " Balanced strategy"]
pub const OH_Drawing_BreakStrategy_BREAK_STRATEGY_BALANCED: OH_Drawing_BreakStrategy = 2;
#[doc = " @brief Enumerates break strategy.\n\n @since 11\n @version 1.0"]
pub type OH_Drawing_BreakStrategy = ::std::os::raw::c_uint;
#[doc = " Normal type"]
pub const OH_Drawing_WordBreakType_WORD_BREAK_TYPE_NORMAL: OH_Drawing_WordBreakType = 0;
#[doc = " Break All type"]
pub const OH_Drawing_WordBreakType_WORD_BREAK_TYPE_BREAK_ALL: OH_Drawing_WordBreakType = 1;
#[doc = " Break Word type"]
pub const OH_Drawing_WordBreakType_WORD_BREAK_TYPE_BREAK_WORD: OH_Drawing_WordBreakType = 2;
#[doc = " @brief Enumerates word break type.\n\n @since 11\n @version 1.0"]
pub type OH_Drawing_WordBreakType = ::std::os::raw::c_uint;
#[doc = " Tight style"]
pub const OH_Drawing_RectHeightStyle_RECT_HEIGHT_STYLE_TIGHT: OH_Drawing_RectHeightStyle = 0;
#[doc = " Max style"]
pub const OH_Drawing_RectHeightStyle_RECT_HEIGHT_STYLE_MAX: OH_Drawing_RectHeightStyle = 1;
#[doc = " Includelinespacemiddle style"]
pub const OH_Drawing_RectHeightStyle_RECT_HEIGHT_STYLE_INCLUDELINESPACEMIDDLE:
    OH_Drawing_RectHeightStyle = 2;
#[doc = " Includelinespacetop style"]
pub const OH_Drawing_RectHeightStyle_RECT_HEIGHT_STYLE_INCLUDELINESPACETOP:
    OH_Drawing_RectHeightStyle = 3;
#[doc = " Includelinespacebottom style"]
pub const OH_Drawing_RectHeightStyle_RECT_HEIGHT_STYLE_INCLUDELINESPACEBOTTOM:
    OH_Drawing_RectHeightStyle = 4;
#[doc = " Struct style"]
pub const OH_Drawing_RectHeightStyle_RECT_HEIGHT_STYLE_STRUCT: OH_Drawing_RectHeightStyle = 5;
#[doc = " @brief Enumerates rect height style.\n\n @since 11\n @version 1.0"]
pub type OH_Drawing_RectHeightStyle = ::std::os::raw::c_uint;
#[doc = " Tight style"]
pub const OH_Drawing_RectWidthStyle_RECT_WIDTH_STYLE_TIGHT: OH_Drawing_RectWidthStyle = 0;
#[doc = " Max style"]
pub const OH_Drawing_RectWidthStyle_RECT_WIDTH_STYLE_MAX: OH_Drawing_RectWidthStyle = 1;
#[doc = " @brief Enumerates rect Width style.\n\n @since 11\n @version 1.0"]
pub type OH_Drawing_RectWidthStyle = ::std::os::raw::c_uint;
#[doc = " The list of system font configuration information was successfully obtained"]
pub const OH_Drawing_FontConfigInfoErrorCode_SUCCESS_FONT_CONFIG_INFO:
    OH_Drawing_FontConfigInfoErrorCode = 0;
#[doc = " Unknown error"]
pub const OH_Drawing_FontConfigInfoErrorCode_ERROR_FONT_CONFIG_INFO_UNKNOWN:
    OH_Drawing_FontConfigInfoErrorCode = 1;
#[doc = " Parse system config file error"]
pub const OH_Drawing_FontConfigInfoErrorCode_ERROR_FONT_CONFIG_INFO_PARSE_FILE:
    OH_Drawing_FontConfigInfoErrorCode = 2;
#[doc = " Alloc memory error"]
pub const OH_Drawing_FontConfigInfoErrorCode_ERROR_FONT_CONFIG_INFO_ALLOC_MEMORY:
    OH_Drawing_FontConfigInfoErrorCode = 3;
#[doc = " Copy string data error"]
pub const OH_Drawing_FontConfigInfoErrorCode_ERROR_FONT_CONFIG_INFO_COPY_STRING_DATA:
    OH_Drawing_FontConfigInfoErrorCode = 4;
#[doc = " @brief Gets system font configuration information list result enum.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_FontConfigInfoErrorCode = ::std::os::raw::c_uint;
#[doc = " @brief Fallback font information.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontFallbackInfo {
    #[doc = " The type of language supported by the font set. The language format is bcp47"]
    pub language: *mut ::std::os::raw::c_char,
    #[doc = " Font family name"]
    pub familyName: *mut ::std::os::raw::c_char,
}
#[doc = " @brief Fallback font group.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontFallbackGroup {
    #[doc = " The name of the font set corresponding to the fallback font set. If the value is null,\n all fonts can be set using the fallback font set list."]
    pub groupName: *mut ::std::os::raw::c_char,
    #[doc = " Fallback font Info Size"]
    pub fallbackInfoSize: usize,
    #[doc = " A list of font sets for fallback fonts"]
    pub fallbackInfoSet: *mut OH_Drawing_FontFallbackInfo,
}
#[doc = " @brief Font weight mapping information.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontAdjustInfo {
    #[doc = " The font's original weight value"]
    pub weight: ::std::os::raw::c_int,
    #[doc = " The font weight displayed in the application"]
    pub to: ::std::os::raw::c_int,
}
#[doc = " @brief Alias font information.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontAliasInfo {
    #[doc = " Font family name"]
    pub familyName: *mut ::std::os::raw::c_char,
    #[doc = " Font weight value. When the weight value is greater than 0,\n the font set contains only fonts with the specified weight.\n When the weight value is equal to 0, the font set contains all fonts."]
    pub weight: ::std::os::raw::c_int,
}
#[doc = " @brief General font set information supported by the system.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontGenericInfo {
    #[doc = " Font family name"]
    pub familyName: *mut ::std::os::raw::c_char,
    #[doc = " The size of alias font lists"]
    pub aliasInfoSize: usize,
    #[doc = " The size of font weight mapping information lists"]
    pub adjustInfoSize: usize,
    #[doc = " List of alias fonts"]
    pub aliasInfoSet: *mut OH_Drawing_FontAliasInfo,
    #[doc = " Font weight mapping information lists"]
    pub adjustInfoSet: *mut OH_Drawing_FontAdjustInfo,
}
#[doc = " @brief System font configuration information.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontConfigInfo {
    #[doc = " Count of system font file paths"]
    pub fontDirSize: usize,
    #[doc = " List size of generic font sets"]
    pub fontGenericInfoSize: usize,
    #[doc = " Count of fallback font set lists"]
    pub fallbackGroupSize: usize,
    #[doc = " List of system font file paths"]
    pub fontDirSet: *mut *mut ::std::os::raw::c_char,
    #[doc = " List of generic font sets"]
    pub fontGenericInfoSet: *mut OH_Drawing_FontGenericInfo,
    #[doc = " List of fallback font sets"]
    pub fallbackGroupSet: *mut OH_Drawing_FontFallbackGroup,
}
#[doc = " @brief Describes the font information.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontDescriptor {
    #[doc = " The file path of System font"]
    pub path: *mut ::std::os::raw::c_char,
    #[doc = " A name that uniquely identifies the font"]
    pub postScriptName: *mut ::std::os::raw::c_char,
    #[doc = " The name of System font"]
    pub fullName: *mut ::std::os::raw::c_char,
    #[doc = " The family of System font"]
    pub fontFamily: *mut ::std::os::raw::c_char,
    #[doc = " The subfont family of the system font"]
    pub fontSubfamily: *mut ::std::os::raw::c_char,
    #[doc = " The weight of System font"]
    pub weight: ::std::os::raw::c_int,
    #[doc = " The width of System font"]
    pub width: ::std::os::raw::c_int,
    #[doc = " Whether the system font is tilted"]
    pub italic: ::std::os::raw::c_int,
    #[doc = " Whether the system font is compact"]
    pub monoSpace: bool,
    #[doc = " whether symbolic fonts are supported"]
    pub symbolic: bool,
}
#[doc = " @brief The metrics of line.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_LineMetrics {
    #[doc = " Text ascender height"]
    pub ascender: f64,
    #[doc = " Tex descender height"]
    pub descender: f64,
    #[doc = " The height of a capital letter"]
    pub capHeight: f64,
    #[doc = " The height of a lowercase letter"]
    pub xHeight: f64,
    #[doc = " Text width"]
    pub width: f64,
    #[doc = " Line height"]
    pub height: f64,
    #[doc = " The distance from the left end of the text to the left end of the container,\n aligned to 0, is the width of the container minus the width of the line of text"]
    pub x: f64,
    #[doc = " The height from the top of the text to the top of the container, the first line is 0,\n and the second line is the height of the first line"]
    pub y: f64,
    #[doc = " Start Index"]
    pub startIndex: usize,
    #[doc = " End Index"]
    pub endIndex: usize,
    #[doc = " The metrics information of the first character"]
    pub firstCharMetrics: OH_Drawing_Font_Metrics,
}
#[doc = " both ascend of first row and last row style"]
pub const OH_Drawing_TextHeightBehavior_TEXT_HEIGHT_ALL: OH_Drawing_TextHeightBehavior = 0;
#[doc = " forbidding ascend of first row style"]
pub const OH_Drawing_TextHeightBehavior_TEXT_HEIGHT_DISABLE_FIRST_ASCENT:
    OH_Drawing_TextHeightBehavior = 1;
#[doc = " forbidding ascend of last row style"]
pub const OH_Drawing_TextHeightBehavior_TEXT_HEIGHT_DISABLE_LAST_ASCENT:
    OH_Drawing_TextHeightBehavior = 2;
#[doc = " neither ascend of first row nor last row style"]
pub const OH_Drawing_TextHeightBehavior_TEXT_HEIGHT_DISABLE_ALL: OH_Drawing_TextHeightBehavior = 3;
#[doc = " @brief Enumerates of heightmode of text.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_TextHeightBehavior = ::std::os::raw::c_uint;
#[doc = " None style"]
pub const OH_Drawing_TextStyleType_TEXT_STYLE_NONE: OH_Drawing_TextStyleType = 0;
#[doc = " All attributes style"]
pub const OH_Drawing_TextStyleType_TEXT_STYLE_ALL_ATTRIBUTES: OH_Drawing_TextStyleType = 1;
#[doc = " Font style"]
pub const OH_Drawing_TextStyleType_TEXT_STYLE_FONT: OH_Drawing_TextStyleType = 2;
#[doc = " Foreground style"]
pub const OH_Drawing_TextStyleType_TEXT_STYLE_FOREGROUND: OH_Drawing_TextStyleType = 3;
#[doc = " Background style"]
pub const OH_Drawing_TextStyleType_TEXT_STYLE_BACKGROUND: OH_Drawing_TextStyleType = 4;
#[doc = " Shadow style"]
pub const OH_Drawing_TextStyleType_TEXT_STYLE_SHADOW: OH_Drawing_TextStyleType = 5;
#[doc = " Decorations style"]
pub const OH_Drawing_TextStyleType_TEXT_STYLE_DECORATIONS: OH_Drawing_TextStyleType = 6;
#[doc = " Letter spacing style"]
pub const OH_Drawing_TextStyleType_TEXT_STYLE_LETTER_SPACING: OH_Drawing_TextStyleType = 7;
#[doc = " Word spacing style"]
pub const OH_Drawing_TextStyleType_TEXT_STYLE_WORD_SPACING: OH_Drawing_TextStyleType = 8;
#[doc = " @brief Enumerates text style type.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_TextStyleType = ::std::os::raw::c_uint;
pub const OH_Drawing_FontWidth_FONT_WIDTH_ULTRA_CONDENSED: OH_Drawing_FontWidth = 1;
pub const OH_Drawing_FontWidth_FONT_WIDTH_EXTRA_CONDENSED: OH_Drawing_FontWidth = 2;
pub const OH_Drawing_FontWidth_FONT_WIDTH_CONDENSED: OH_Drawing_FontWidth = 3;
pub const OH_Drawing_FontWidth_FONT_WIDTH_SEMI_CONDENSED: OH_Drawing_FontWidth = 4;
pub const OH_Drawing_FontWidth_FONT_WIDTH_NORMAL: OH_Drawing_FontWidth = 5;
pub const OH_Drawing_FontWidth_FONT_WIDTH_SEMI_EXPANDED: OH_Drawing_FontWidth = 6;
pub const OH_Drawing_FontWidth_FONT_WIDTH_EXPANDED: OH_Drawing_FontWidth = 7;
pub const OH_Drawing_FontWidth_FONT_WIDTH_EXTRA_EXPANDED: OH_Drawing_FontWidth = 8;
pub const OH_Drawing_FontWidth_FONT_WIDTH_ULTRA_EXPANDED: OH_Drawing_FontWidth = 9;
#[doc = " @brief Enumerates font width.\n\n @since 12\n @version 1.0"]
pub type OH_Drawing_FontWidth = ::std::os::raw::c_uint;
#[doc = " @brief Defines the font style struct.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontStyleStruct {
    #[doc = " Font weight"]
    pub weight: OH_Drawing_FontWeight,
    #[doc = " Font width"]
    pub width: OH_Drawing_FontWidth,
    #[doc = " Font slant"]
    pub slant: OH_Drawing_FontStyle,
}
#[doc = " @brief Defines the fontfeature.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_FontFeature {
    #[doc = " key of fontfeature"]
    pub tag: *mut ::std::os::raw::c_char,
    #[doc = " value of fontfeature"]
    pub value: ::std::os::raw::c_int,
}
#[doc = " @brief Defines StrutStyle info struct.\n\n @since 12\n @version 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_StrutStyle {
    #[doc = " The font weight to use when calculating the strut"]
    pub weight: OH_Drawing_FontWeight,
    #[doc = " The font style to use when calculating the strut"]
    pub style: OH_Drawing_FontStyle,
    #[doc = " The size of the ascent plus descent in logical pixels"]
    pub size: f64,
    #[doc = " The minimum height of the strut, as a multiple of fontSize"]
    pub heightScale: f64,
    #[doc = " Whether the height is override"]
    pub heightOverride: bool,
    #[doc = " Whether the halfleading is enable"]
    pub halfLeading: bool,
    #[doc = " The additional leading to apply to the strut as a multiple of Size"]
    pub leading: f64,
    #[doc = " Whether the strut height should be forced"]
    pub forceStrutHeight: bool,
    #[doc = " The size of font families"]
    pub familiesSize: usize,
    #[doc = " The families of the font to use when calculating the strut"]
    pub families: *mut *mut ::std::os::raw::c_char,
}
extern "C" {
    #[doc = " @brief Creates an <b>OH_Drawing_TypographyStyle</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @return Returns the pointer to the <b>OH_Drawing_TypographyStyle</b> object created.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CreateTypographyStyle() -> *mut OH_Drawing_TypographyStyle;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by an <b>OH_Drawing_TypographyStyle</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_DestroyTypographyStyle(style: *mut OH_Drawing_TypographyStyle);
}
extern "C" {
    #[doc = " @brief Sets the text direction.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param direction Indicates the text direction to set. For details, see the enum <b>OH_Drawing_TextDirection</b>.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextDirection(
        style: *mut OH_Drawing_TypographyStyle,
        direction: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the text alignment mode.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param align Indicates the text alignment mode to set. For details, see the enum <b>OH_Drawing_TextAlign</b>.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextAlign(
        style: *mut OH_Drawing_TypographyStyle,
        align: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the maximum number of lines in a text file.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param lineNumber Indicates the maximum number of lines to set.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextMaxLines(
        style: *mut OH_Drawing_TypographyStyle,
        lineNumber: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Creates an <b>OH_Drawing_TextStyle</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @return Returns the pointer to the <b>OH_Drawing_TextStyle</b> object created.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CreateTextStyle() -> *mut OH_Drawing_TextStyle;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by an <b>OH_Drawing_TextStyle</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_DestroyTextStyle(style: *mut OH_Drawing_TextStyle);
}
extern "C" {
    #[doc = " @brief Sets the text color.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param color Indicates the color to set.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleColor(style: *mut OH_Drawing_TextStyle, color: u32);
}
extern "C" {
    #[doc = " @brief Sets the font size.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param fontSize Indicates the font size to set.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleFontSize(style: *mut OH_Drawing_TextStyle, fontSize: f64);
}
extern "C" {
    #[doc = " @brief Sets the font weight.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param fontWeight Indicates the font weight to set. For details, see the enum <b>OH_Drawing_FontWeight</b>.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleFontWeight(
        style: *mut OH_Drawing_TextStyle,
        fontWeight: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the text baseline.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param baseline Indicates the text baseline to set. For details, see the enum <b>OH_Drawing_TextBaseline</b>.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleBaseLine(
        style: *mut OH_Drawing_TextStyle,
        baseline: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the text decoration.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param decoration Indicates the text decoration to set. For details, see the enum <b>OH_Drawing_TextDecoration</b>.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleDecoration(
        style: *mut OH_Drawing_TextStyle,
        decoration: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the color for the text decoration.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param color Indicates the color to set.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleDecorationColor(style: *mut OH_Drawing_TextStyle, color: u32);
}
extern "C" {
    #[doc = " @brief Sets the font height.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param fontHeight Indicates the font height to set.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleFontHeight(style: *mut OH_Drawing_TextStyle, fontHeight: f64);
}
extern "C" {
    #[doc = " @brief Sets the font families.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param fontFamiliesNumber Indicates the number of font families to set.\n @param fontFamilies Indicates the pointer to the font families to set.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleFontFamilies(
        style: *mut OH_Drawing_TextStyle,
        fontFamiliesNumber: ::std::os::raw::c_int,
        fontFamilies: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets the font style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param fontStyle Indicates the font style to set. For details, see the enum <b>OH_Drawing_FontStyle</b>.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleFontStyle(
        style: *mut OH_Drawing_TextStyle,
        fontStyle: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the locale.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param locale Indicates the pointer to the locale to set.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleLocale(
        style: *mut OH_Drawing_TextStyle,
        locale: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets the foreground brush style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param foregroundBrush Indicates the pointer to a brush object <b>OH_Drawing_Brush</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleForegroundBrush(
        style: *mut OH_Drawing_TextStyle,
        foregroundBrush: *mut OH_Drawing_Brush,
    );
}
extern "C" {
    #[doc = " @brief Gets the foreground brush style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param foregroundBrush Indicates the pointer to a brush object <b>OH_Drawing_Brush</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetForegroundBrush(
        style: *mut OH_Drawing_TextStyle,
        foregroundBrush: *mut OH_Drawing_Brush,
    );
}
extern "C" {
    #[doc = " @brief Sets the foreground pen style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param foregroundPen Indicates the pointer to a pen object <b>OH_Drawing_Pen</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleForegroundPen(
        style: *mut OH_Drawing_TextStyle,
        foregroundPen: *mut OH_Drawing_Pen,
    );
}
extern "C" {
    #[doc = " @brief Gets the foreground pen style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param foregroundPen Indicates the pointer to a pen object <b>OH_Drawing_Pen</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetForegroundPen(
        style: *mut OH_Drawing_TextStyle,
        foregroundPen: *mut OH_Drawing_Pen,
    );
}
extern "C" {
    #[doc = " @brief Sets the background brush style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param foregroundPen Indicates the pointer to a brush object <b>OH_Drawing_Brush</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleBackgroundBrush(
        style: *mut OH_Drawing_TextStyle,
        foregroundPen: *mut OH_Drawing_Brush,
    );
}
extern "C" {
    #[doc = " @brief Gets the background brush style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param backgroundBrush Indicates the pointer to a brush object <b>OH_Drawing_Brush</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetBackgroundBrush(
        style: *mut OH_Drawing_TextStyle,
        backgroundBrush: *mut OH_Drawing_Brush,
    );
}
extern "C" {
    #[doc = " @brief Sets the background pen style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param backgroundPen Indicates the pointer to a pen object <b>OH_Drawing_Pen</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleBackgroundPen(
        style: *mut OH_Drawing_TextStyle,
        backgroundPen: *mut OH_Drawing_Pen,
    );
}
extern "C" {
    #[doc = " @brief Gets the background pen style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param backgroundPen Indicates the pointer to a pen object <b>OH_Drawing_Pen</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetBackgroundPen(
        style: *mut OH_Drawing_TextStyle,
        backgroundPen: *mut OH_Drawing_Pen,
    );
}
extern "C" {
    #[doc = " @brief Creates a pointer to an <b>OH_Drawing_TypographyCreate</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param fontCollection Indicates the pointer to an <b>OH_Drawing_FontCollection</b> object.\n @return Returns the pointer to the <b>OH_Drawing_TypographyCreate</b> object created.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CreateTypographyHandler(
        style: *mut OH_Drawing_TypographyStyle,
        fontCollection: *mut OH_Drawing_FontCollection,
    ) -> *mut OH_Drawing_TypographyCreate;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by an <b>OH_Drawing_TypographyCreate</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param handler Indicates the pointer to an <b>OH_Drawing_TypographyCreate</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_DestroyTypographyHandler(handler: *mut OH_Drawing_TypographyCreate);
}
extern "C" {
    #[doc = " @brief Sets the text style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param handler Indicates the pointer to an <b>OH_Drawing_TypographyCreate</b> object.\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_TypographyHandlerPushTextStyle(
        handler: *mut OH_Drawing_TypographyCreate,
        style: *mut OH_Drawing_TextStyle,
    );
}
extern "C" {
    #[doc = " @brief Sets the text content.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param handler Indicates the pointer to an <b>OH_Drawing_TypographyCreate</b> object.\n @param text Indicates the pointer to the text content to set.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_TypographyHandlerAddText(
        handler: *mut OH_Drawing_TypographyCreate,
        text: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Removes the topmost style in the stack, leaving the remaining styles in effect.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param handler Indicates the pointer to an <b>OH_Drawing_TypographyCreate</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_TypographyHandlerPopTextStyle(handler: *mut OH_Drawing_TypographyCreate);
}
extern "C" {
    #[doc = " @brief Creates an <b>OH_Drawing_Typography</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param handler Indicates the pointer to an <b>OH_Drawing_TypographyCreate</b> object.\n @return Returns the pointer to the <b>OH_Drawing_Typography</b> object created.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_CreateTypography(
        handler: *mut OH_Drawing_TypographyCreate,
    ) -> *mut OH_Drawing_Typography;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by an <b>OH_Drawing_Typography</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_DestroyTypography(typography: *mut OH_Drawing_Typography);
}
extern "C" {
    #[doc = " @brief Lays out the typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param maxWidth Indicates the maximum text width to set.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_TypographyLayout(typography: *mut OH_Drawing_Typography, maxWidth: f64);
}
extern "C" {
    #[doc = " @brief Paints text on the canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param potisionX Indicates the x coordinate.\n @param potisionY Indicates the y coordinate.\n @since 8\n @version 1.0"]
    pub fn OH_Drawing_TypographyPaint(
        typography: *mut OH_Drawing_Typography,
        canvas: *mut OH_Drawing_Canvas,
        potisionX: f64,
        potisionY: f64,
    );
}
extern "C" {
    #[doc = " @brief Paints path text on the canvas.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param canvas Indicates the pointer to an <b>OH_Drawing_Canvas</b> object.\n @param path Indicates path information.\n @param hOffset Indicates the distance along the path to add to the text's starting position.\n @param vOffset Indicates the distance above(-) or below(+) the path to position the text.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyPaintOnPath(
        typography: *mut OH_Drawing_Typography,
        canvas: *mut OH_Drawing_Canvas,
        path: *mut OH_Drawing_Path,
        hOffset: f64,
        vOffset: f64,
    );
}
extern "C" {
    #[doc = " @brief Gets the max width.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @return Returns the max width.\n @since 9\n @version 1.1"]
    pub fn OH_Drawing_TypographyGetMaxWidth(typography: *mut OH_Drawing_Typography) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the height.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @return Returns the height.\n @since 9\n @version 1.1"]
    pub fn OH_Drawing_TypographyGetHeight(typography: *mut OH_Drawing_Typography) -> f64;
}
extern "C" {
    #[doc = " @brief Obtains the width of the longest line. You are advised to round up the return value in actual use.\n When the text content is empty, the minimum float value,\n that is, -340282346638528859811704183484516925440.000000, is returned.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Pointer to an <b>OH_Drawing_Typography</b> object, which is obtained by\n {@link OH_Drawing_CreateTypography}.\n @return Returns the width of the longest line.\n @since 9\n @version 1.1"]
    pub fn OH_Drawing_TypographyGetLongestLine(typography: *mut OH_Drawing_Typography) -> f64;
}
extern "C" {
    #[doc = " @brief Obtains the width of the longest line with indent. You are advised to\n round up the return value in actual use. When the text content is empty, the\n minimum float value, that is, 0.0, is returned.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Pointer to an <b>OH_Drawing_Typography</b> object, which is obtained by\n {@link OH_Drawing_CreateTypography}.\n @return Returns the width of the longest line with indent.\n @since 13\n @version 1.1"]
    pub fn OH_Drawing_TypographyGetLongestLineWithIndent(
        typography: *mut OH_Drawing_Typography,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the min intrinsic width.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography the pointer to an <b>OH_Drawing_Typography</b> object.\n @return Returns the min intrinsic width.\n @since 9\n @version 1.1"]
    pub fn OH_Drawing_TypographyGetMinIntrinsicWidth(typography: *mut OH_Drawing_Typography)
        -> f64;
}
extern "C" {
    #[doc = " @brief Gets the max intrinsic width.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @return Returns the max intrinsic width.\n @since 9\n @version 1.1"]
    pub fn OH_Drawing_TypographyGetMaxIntrinsicWidth(typography: *mut OH_Drawing_Typography)
        -> f64;
}
extern "C" {
    #[doc = " @brief Gets the alphabetic baseline.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @return Returns the alphabetic baseline.\n @since 9\n @version 1.1"]
    pub fn OH_Drawing_TypographyGetAlphabeticBaseline(
        typography: *mut OH_Drawing_Typography,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the ideographic baseline.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @return Returns the ideographic baseline.\n @since 9\n @version 1.1"]
    pub fn OH_Drawing_TypographyGetIdeographicBaseline(
        typography: *mut OH_Drawing_Typography,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Sets the placeholder.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param handler Indicates the pointer to an <b>OH_Drawing_TypographyCreate</b> object.\n @param span Indicates the pointer to an <b>OH_Drawing_PlaceholderSpan</b> object.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyHandlerAddPlaceholder(
        handler: *mut OH_Drawing_TypographyCreate,
        span: *mut OH_Drawing_PlaceholderSpan,
    );
}
extern "C" {
    #[doc = " @brief Gets the exceed maxLines.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @return Returns the exceed maxLines.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyDidExceedMaxLines(typography: *mut OH_Drawing_Typography) -> bool;
}
extern "C" {
    #[doc = " @brief Gets the rects for range.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param start Indicates the start of range to set.\n @param end Indicates the end of range to set.\n @param heightStyle Indicates the height style to set.\n For details, see the enum <b>OH_Drawing_RectHeightStyle</b>.\n @param widthStyle Indicates the width style to set.\n For details, see the enum <b>OH_Drawing_RectWidthStyle</b>.\n @return Returns the rects for range.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetRectsForRange(
        typography: *mut OH_Drawing_Typography,
        start: usize,
        end: usize,
        heightStyle: OH_Drawing_RectHeightStyle,
        widthStyle: OH_Drawing_RectWidthStyle,
    ) -> *mut OH_Drawing_TextBox;
}
extern "C" {
    #[doc = " @brief Gets the rects for placeholders.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @return Returns the rects for placeholders.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetRectsForPlaceholders(
        typography: *mut OH_Drawing_Typography,
    ) -> *mut OH_Drawing_TextBox;
}
extern "C" {
    #[doc = " @brief Gets left from textbox.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param textbox Indicates the pointer to an <b>OH_Drawing_TextBox</b> object.\n @param index Indicates the index of textbox.\n @return Returns left from textbox.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetLeftFromTextBox(
        textbox: *mut OH_Drawing_TextBox,
        index: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Gets right from textbox.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param textbox Indicates the pointer to an <b>OH_Drawing_TextBox</b> object.\n @param index Indicates the index of textbox.\n @return Returns right from textbox.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetRightFromTextBox(
        textbox: *mut OH_Drawing_TextBox,
        index: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Gets top from textbox.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param textbox Indicates the pointer to an <b>OH_Drawing_TextBox</b> object.\n @param index Indicates the index of textbox.\n @return Returns top from textbox.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetTopFromTextBox(
        textbox: *mut OH_Drawing_TextBox,
        index: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Gets bottom from textbox.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param textbox Indicates the pointer to an <b>OH_Drawing_TextBox</b> object.\n @param index Indicates the index of textbox.\n @return Returns bottom from textbox.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetBottomFromTextBox(
        textbox: *mut OH_Drawing_TextBox,
        index: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Gets direction from textbox.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param textbox Indicates the pointer to an <b>OH_Drawing_TextBox</b> object.\n @param index Indicates the index of textbox.\n @return Returns direction from textbox.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetTextDirectionFromTextBox(
        textbox: *mut OH_Drawing_TextBox,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets size of textBox.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param textBox Indicates the pointer to an <b>OH_Drawing_TextBox</b> object.\n @return Returns size of textBox.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetSizeOfTextBox(textBox: *mut OH_Drawing_TextBox) -> usize;
}
extern "C" {
    #[doc = " @brief Gets the glyphposition at coordinate.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param dx Indicates the positionX of typography to set.\n @param dy Indicates the positionY of typography to set.\n @return Returns the glyphposition at coordinate.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetGlyphPositionAtCoordinate(
        typography: *mut OH_Drawing_Typography,
        dx: f64,
        dy: f64,
    ) -> *mut OH_Drawing_PositionAndAffinity;
}
extern "C" {
    #[doc = " @brief Gets the glyphposition at coordinate with cluster.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param dx Indicates the positionX of typography to set.\n @param dy Indicates the positionY of typography to set.\n @return Returns the glyphposition at coordinate with cluster.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetGlyphPositionAtCoordinateWithCluster(
        typography: *mut OH_Drawing_Typography,
        dx: f64,
        dy: f64,
    ) -> *mut OH_Drawing_PositionAndAffinity;
}
extern "C" {
    #[doc = " @brief Gets position from position and affinity.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param positionAndAffinity Indicates the pointer to an <b>OH_Drawing_PositionAndAffinity</b> object.\n @return Returns position from position and affinity.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetPositionFromPositionAndAffinity(
        positionAndAffinity: *mut OH_Drawing_PositionAndAffinity,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Gets affinity from position and affinity.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param positionandaffinity Indicates the pointer to an <b>OH_Drawing_PositionAndAffinity</b> object.\n @return Returns affinity from position and affinity.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetAffinityFromPositionAndAffinity(
        positionandaffinity: *mut OH_Drawing_PositionAndAffinity,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets the word boundary.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param offset Indicates the size of text to set.\n @return Returns the word boundary.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetWordBoundary(
        typography: *mut OH_Drawing_Typography,
        offset: usize,
    ) -> *mut OH_Drawing_Range;
}
extern "C" {
    #[doc = " @brief Gets start from range.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param range Indicates the pointer to an <b>OH_Drawing_Range</b> object.\n @return Returns start from range.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetStartFromRange(range: *mut OH_Drawing_Range) -> usize;
}
extern "C" {
    #[doc = " @brief Gets end from range.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param range Indicates the pointer to an <b>OH_Drawing_Range</b> object.\n @return Returns end from range.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_GetEndFromRange(range: *mut OH_Drawing_Range) -> usize;
}
extern "C" {
    #[doc = " @brief Gets the line count.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @return Returns the line count.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetLineCount(typography: *mut OH_Drawing_Typography) -> usize;
}
extern "C" {
    #[doc = " @brief Sets the decoration style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param decorationStyle Indicates the text decoration style to set.\n For details, see the enum <b>OH_Drawing_TextDecorationStyle</b>.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleDecorationStyle(
        style: *mut OH_Drawing_TextStyle,
        decorationStyle: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the decoration thickness scale.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param decorationThicknessScale Indicates the thickness scale of text decoration to set.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleDecorationThicknessScale(
        style: *mut OH_Drawing_TextStyle,
        decorationThicknessScale: f64,
    );
}
extern "C" {
    #[doc = " @brief Sets the letter spacing.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param letterSpacing Indicates the letter space to set.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleLetterSpacing(
        style: *mut OH_Drawing_TextStyle,
        letterSpacing: f64,
    );
}
extern "C" {
    #[doc = " @brief Sets the word spacing.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param wordSpacing Indicates the word space to set.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleWordSpacing(style: *mut OH_Drawing_TextStyle, wordSpacing: f64);
}
extern "C" {
    #[doc = " @brief Sets the half leading.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param halfLeading Indicates the half leading to set.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleHalfLeading(style: *mut OH_Drawing_TextStyle, halfLeading: bool);
}
extern "C" {
    #[doc = " @brief Sets the ellipsis.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param ellipsis Indicates the pointer to ellipsis style.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleEllipsis(
        style: *mut OH_Drawing_TextStyle,
        ellipsis: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets the ellipsis modal.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param ellipsisModal Indicates the ellipsis model to set. For details, see the enum <b>OH_Drawing_EllipsisModal</b>.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleEllipsisModal(
        style: *mut OH_Drawing_TextStyle,
        ellipsisModal: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the break strategy.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param breakStrategy Indicates the break strategy to set. For details, see the enum <b>OH_Drawing_BreakStrategy</b>.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextBreakStrategy(
        style: *mut OH_Drawing_TypographyStyle,
        breakStrategy: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the word break type.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param wordBreakType Indicates the word break type to set. For details, see the enum <b>OH_Drawing_WordBreakType</b>.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextWordBreakType(
        style: *mut OH_Drawing_TypographyStyle,
        wordBreakType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the ellipsis modal.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param ellipsisModal Indicates the ellipsis modal to set. For details, see the enum <b>OH_Drawing_EllipsisModal</b>.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextEllipsisModal(
        style: *mut OH_Drawing_TypographyStyle,
        ellipsisModal: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief get line height.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param lineNumber Indicates the line number.\n @return Returns line height.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetLineHeight(
        typography: *mut OH_Drawing_Typography,
        lineNumber: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief get line width.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param lineNumber Indicates the line number.\n @return Returns line width.\n @since 11\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetLineWidth(
        typography: *mut OH_Drawing_Typography,
        lineNumber: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief get line text range.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to an <b>OH_Drawing_Typography</b> object.\n @param lineNumber Indicates the line number.\n @param includeSpaces Indicates whether spaces are contained.\n @return Returns line text range.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetLineTextRange(
        typography: *mut OH_Drawing_Typography,
        lineNumber: ::std::os::raw::c_int,
        includeSpaces: bool,
    ) -> *mut OH_Drawing_Range;
}
extern "C" {
    #[doc = " @brief Creates an <b>OH_Drawing_FontDescriptor</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @return Returns the pointer to the font descriptor object <b>OH_Drawing_FontDescriptor</b> created.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CreateFontDescriptor() -> *mut OH_Drawing_FontDescriptor;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by an <b>OH_Drawing_FontDescriptor</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param descriptor the pointer to the font descriptor object <b>OH_Drawing_FontDescriptor</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_DestroyFontDescriptor(descriptor: *mut OH_Drawing_FontDescriptor);
}
extern "C" {
    #[doc = " @brief Creates an <b>OH_Drawing_FontParser</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @return Returns the pointer to the font parser object <b>OH_Drawing_FontParser</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CreateFontParser() -> *mut OH_Drawing_FontParser;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by an <b>OH_Drawing_FontParser</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param parser Indicates the pointer to the font parser object <b>OH_Drawing_FontParser</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_DestroyFontParser(parser: *mut OH_Drawing_FontParser);
}
extern "C" {
    #[doc = " @brief Gets a list of system font names.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param fontParser Indicates the pointer to the font parser object <b>OH_Drawing_FontParser</b>.\n @param num Returns the number of obtained system font names.\n @return Returns a list of obtained system fonts.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontParserGetSystemFontList(
        fontParser: *mut OH_Drawing_FontParser,
        num: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by a list of system font names.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param fontList Indicates the pointer to a list of system font names.\n @param num The number of obtained system font names.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_DestroySystemFontList(fontList: *mut *mut ::std::os::raw::c_char, num: usize);
}
extern "C" {
    #[doc = " @brief Gets information about the system font by font name.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param fontParser Indicates the pointer to the font parser object <b>OH_Drawing_FontParser</b>.\n @param name font name.\n @return Returns system fonts information.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_FontParserGetFontByName(
        fontParser: *mut OH_Drawing_FontParser,
        name: *const ::std::os::raw::c_char,
    ) -> *mut OH_Drawing_FontDescriptor;
}
extern "C" {
    #[doc = " @brief Get line metrics information.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to a typography object <b>OH_Drawing_Typography</b>.\n @return Indicates the pointer to a line metrics object <b>OH_Drawing_LineMetrics</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetLineMetrics(
        typography: *mut OH_Drawing_Typography,
    ) -> *mut OH_Drawing_LineMetrics;
}
extern "C" {
    #[doc = " @brief Get the number of lines.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param lineMetrics Indicates the pointer to a line metrics object <b>OH_Drawing_LineMetrics</b>.\n @return Returns the number of lines.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_LineMetricsGetSize(lineMetrics: *mut OH_Drawing_LineMetrics) -> usize;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by line metrics.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param lineMetrics Indicates the pointer to a line metrics object <b>OH_Drawing_LineMetrics</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_DestroyLineMetrics(lineMetrics: *mut OH_Drawing_LineMetrics);
}
extern "C" {
    #[doc = " @brief Gets the specified line by line number.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to a typography object <b>OH_Drawing_Typography</b>.\n @param lineNumber Line number.\n @param lineMetric Indicates the pointer to a line metrics object <b>OH_Drawing_LineMetrics</b>.\n @return Whether the line metrics was obtained.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetLineMetricsAt(
        typography: *mut OH_Drawing_Typography,
        lineNumber: ::std::os::raw::c_int,
        lineMetric: *mut OH_Drawing_LineMetrics,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief  Sets the ellipsis of lines in a text file.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography object <b>OH_Drawing_Typography</b>.\n @param ellipsis Indicates the line textellipsis.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextEllipsis(
        style: *mut OH_Drawing_TypographyStyle,
        ellipsis: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets the locale of lines in a text file.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param locale Indicates the pointer to the locale to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextLocale(
        style: *mut OH_Drawing_TypographyStyle,
        locale: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets the textSplitRatio of lines in a text file.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param textSplitRatio Indicates the textSplitRatio of lines to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextSplitRatio(
        style: *mut OH_Drawing_TypographyStyle,
        textSplitRatio: f32,
    );
}
extern "C" {
    #[doc = " @brief Gets the TextStyle of lines in a text file.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Returns line text textstyle.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetTextStyle(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> *mut OH_Drawing_TextStyle;
}
extern "C" {
    #[doc = " @brief Gets the EffectiveAlign of lines in a text file.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Returns line text align.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetEffectiveAlignment(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets the UnlimitedLines of lines in a text file.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Returns whether the text has a maximum line limit,\n with true indicating a maximum line limit and false indicating no maximum line limit.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyIsLineUnlimited(style: *mut OH_Drawing_TypographyStyle) -> bool;
}
extern "C" {
    #[doc = " @brief Gets the IsEllipsized of lines in a text file.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Returns whether the text has ellipsis,\n true meaning there is an ellipsis and false meaning there is no ellipsis.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyIsEllipsized(style: *mut OH_Drawing_TypographyStyle) -> bool;
}
extern "C" {
    #[doc = " @brief set line textstyle.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param handler Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextStyle(
        handler: *mut OH_Drawing_TypographyStyle,
        style: *mut OH_Drawing_TextStyle,
    );
}
extern "C" {
    #[doc = " @brief get line fontmetrics.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to a typography object <b>OH_Drawing_Typography</b>.\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param fontmetrics Indicates the pointer to a font metrics object <b>OH_Drawing_Font_Metrics</b>.\n @return Whether the font metrics was obtained.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetFontMetrics(
        typography: *mut OH_Drawing_Typography,
        style: *mut OH_Drawing_TextStyle,
        fontmetrics: *mut OH_Drawing_Font_Metrics,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Gets the position of the specified line or the first text of the specified line.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to a typography object <b>OH_Drawing_Typography</b>.\n @param lineNumber Line number.\n @param oneLine True is the information for the whole line, and false is the information to get the first character\n @param includeWhitespace Whether the text width contains whitespace.\n @param drawingLineMetrics Indicates the pointer to a line metrics object <b>OH_Drawing_LineMetrics</b>.\n @return return whether the information was successfully fetched.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetLineInfo(
        typography: *mut OH_Drawing_Typography,
        lineNumber: ::std::os::raw::c_int,
        oneLine: bool,
        includeWhitespace: bool,
        drawingLineMetrics: *mut OH_Drawing_LineMetrics,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the font weight of text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param weight Indicates the font weight of text typography to set. For details,\n see the enum <b>OH_Drawing_FontWeight</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextFontWeight(
        style: *mut OH_Drawing_TypographyStyle,
        weight: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the font style of text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param fontStyle Indicates the font style of text typography to set. For details,\n see the enum <b>OH_Drawing_FontStyle</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextFontStyle(
        style: *mut OH_Drawing_TypographyStyle,
        fontStyle: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the font family of text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param fontFamily Indicates the pointer to the font family of text typography to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextFontFamily(
        style: *mut OH_Drawing_TypographyStyle,
        fontFamily: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets the font size of text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param fontSize Indicates the font size of text typography to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextFontSize(
        style: *mut OH_Drawing_TypographyStyle,
        fontSize: f64,
    );
}
extern "C" {
    #[doc = " @brief Sets the font height of text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param fontHeight Indicates the font height of text typography to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextFontHeight(
        style: *mut OH_Drawing_TypographyStyle,
        fontHeight: f64,
    );
}
extern "C" {
    #[doc = " @brief Sets the half leading of text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param halfLeading Indicates the half leading of text typography to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextHalfLeading(
        style: *mut OH_Drawing_TypographyStyle,
        halfLeading: bool,
    );
}
extern "C" {
    #[doc = " @brief Sets whether to enable line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param useLineStyle Indicates whether the line style for text typography is used.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextUseLineStyle(
        style: *mut OH_Drawing_TypographyStyle,
        useLineStyle: bool,
    );
}
extern "C" {
    #[doc = " @brief Sets the font weight of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param weight Indicates the font weight of line style for text typography to set.\n For details, see the enum <b>OH_Drawing_FontWeight</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextLineStyleFontWeight(
        style: *mut OH_Drawing_TypographyStyle,
        weight: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the font style of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param fontStyle Indicates the font style of line style for text typography to set. For details,\n see the enum <b>OH_Drawing_FontStyle</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextLineStyleFontStyle(
        style: *mut OH_Drawing_TypographyStyle,
        fontStyle: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the font families of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param fontFamiliesNumber Indicates the number of font families to set.\n @param fontFamilies Indicates the pointer to the font families of line style for text typography to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextLineStyleFontFamilies(
        style: *mut OH_Drawing_TypographyStyle,
        fontFamiliesNumber: ::std::os::raw::c_int,
        fontFamilies: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets the font size of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param lineStyleFontSize Indicates the font size of line style for text typography to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextLineStyleFontSize(
        style: *mut OH_Drawing_TypographyStyle,
        lineStyleFontSize: f64,
    );
}
extern "C" {
    #[doc = " @brief Sets the font height of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param lineStyleFontHeight Indicates the font height of line style for text typography to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextLineStyleFontHeight(
        style: *mut OH_Drawing_TypographyStyle,
        lineStyleFontHeight: f64,
    );
}
extern "C" {
    #[doc = " @brief Sets the half leading of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param lineStyleHalfLeading Indicates the half leading of line for text typography to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextLineStyleHalfLeading(
        style: *mut OH_Drawing_TypographyStyle,
        lineStyleHalfLeading: bool,
    );
}
extern "C" {
    #[doc = " @brief Sets the spacing scale of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param spacingScale Indicates the space scale of line for text typography to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextLineStyleSpacingScale(
        style: *mut OH_Drawing_TypographyStyle,
        spacingScale: f64,
    );
}
extern "C" {
    #[doc = " @brief Sets whether only line style is enabled for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param lineStyleOnly Indicates the line style for text typography to set only.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyTextLineStyleOnly(
        style: *mut OH_Drawing_TypographyStyle,
        lineStyleOnly: bool,
    );
}
extern "C" {
    #[doc = " @brief Creates an <b>OH_Drawing_TextShadow</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @return Returns the pointer to the text shadow object created <b>OH_Drawing_TextShadow</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_CreateTextShadow() -> *mut OH_Drawing_TextShadow;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by the text shadow object <b>OH_Drawing_TextShadow</b>.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param shadow Indicates the pointer to the text shadow object <b>OH_Drawing_TextShadow</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_DestroyTextShadow(shadow: *mut OH_Drawing_TextShadow);
}
extern "C" {
    #[doc = " @brief Gets the vector of TextShadow in TextStyle.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param int Indicates the number in vector to set.\n @param style Indicates the pointer to the text shadow object <b>OH_Drawing_TextShadow</b>.\n @return Returns the vector of TextShadow.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetShadows(
        style: *mut OH_Drawing_TextStyle,
    ) -> *mut OH_Drawing_TextShadow;
}
extern "C" {
    #[doc = " @brief Gets the size of vector of TextShadow in TextStyle.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @return Returns the size of vector.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetShadowCount(
        style: *mut OH_Drawing_TextStyle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Adds element in vector of TextShadow in TextStyle.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param shadow Indicates the pointer to the text shadow object <b>OH_Drawing_TextShadow</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleAddShadow(
        style: *mut OH_Drawing_TextStyle,
        shadow: *const OH_Drawing_TextShadow,
    );
}
extern "C" {
    #[doc = " @brief clear elements in vector of TextShadow in TextStyle.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleClearShadows(style: *mut OH_Drawing_TextStyle);
}
extern "C" {
    #[doc = " @brief Gets element in vector of TextShadow with index.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a text style object <b>OH_Drawing_TextStyle</b>.\n @param index Indicates the index to set.\n @return Returns the pointer to element with the index in vector of the text style object\n <b>OH_Drawing_TextStyle</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetShadowWithIndex(
        style: *mut OH_Drawing_TextStyle,
        index: ::std::os::raw::c_int,
    ) -> *mut OH_Drawing_TextShadow;
}
extern "C" {
    #[doc = " @brief Set indents of the typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to a typography object <b>OH_Drawing_Typography</b>.\n @param indentsNumber Indicates the pointer to the indents to set.\n @param indents Indicates the pointer to the indents to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographySetIndents(
        typography: *mut OH_Drawing_Typography,
        indentsNumber: ::std::os::raw::c_int,
        indents: *const f32,
    );
}
extern "C" {
    #[doc = " @brief Gets element with index in vector of Indents.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to a typography object <b>OH_Drawing_Typography</b>.\n @param index Indicates the index to set.\n @return float Indicates the element with the index in vector of Indents.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetIndentsWithIndex(
        typography: *mut OH_Drawing_Typography,
        index: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by vector with the text shadow object <b>OH_Drawing_TextShadow</b>.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param shadow the pointer to the text shadow object <b>OH_Drawing_TextShadow</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_DestroyTextShadows(shadow: *mut OH_Drawing_TextShadow);
}
extern "C" {
    #[doc = " @brief Set mode of applying the leading over and under text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param heightMode Indicates the mode to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextSetHeightBehavior(
        style: *mut OH_Drawing_TypographyStyle,
        heightMode: OH_Drawing_TextHeightBehavior,
    );
}
extern "C" {
    #[doc = " @brief Get mode of applying the leading over and under text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @return Returns the mode.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextGetHeightBehavior(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> OH_Drawing_TextHeightBehavior;
}
extern "C" {
    #[doc = " @brief Set struct of background rect and styleId of text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param rectStyleInfo Indicates the pointer to an <b>OH_Drawing_RectStyle_Info</b> object.\n @param styleId Indicates the styleId of text to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleSetBackgroundRect(
        style: *mut OH_Drawing_TextStyle,
        rectStyleInfo: *const OH_Drawing_RectStyle_Info,
        styleId: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Add symbols in creating typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param handler Indicates the pointer to an <b>OH_Drawing_TypographyCreate</b> object.\n @param symbol Indicates the symbol to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyHandlerAddSymbol(
        handler: *mut OH_Drawing_TypographyCreate,
        symbol: u32,
    );
}
extern "C" {
    #[doc = " @brief Add font feature.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param tag Indicates the pointer to the tag to set.\n @param value Indicates the value to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleAddFontFeature(
        style: *mut OH_Drawing_TextStyle,
        tag: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Add font variation.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param axis Indicates the pointer to font variation axis.\n @param value Indicates the font variation value to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleAddFontVariation(
        style: *mut OH_Drawing_TextStyle,
        axis: *const ::std::os::raw::c_char,
        value: f32,
    );
}
extern "C" {
    #[doc = " @brief Get all font features.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return OH_Drawing_FontFeature Indicates the pointer to an array of structures of OH_Drawing_FontFeature.\n Get size of font feature by OH_Drawing_TextStyleGetFontFeatureSize.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetFontFeatures(
        style: *mut OH_Drawing_TextStyle,
    ) -> *mut OH_Drawing_FontFeature;
}
extern "C" {
    #[doc = " @brief Release the memory occupied by array of structures of font features.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param fontFeature Indicates the pointer to an array of structures of OH_Drawing_FontFeature.\n @param fontFeatureSize Indicates the size of array of structures of OH_Drawing_FontFeature.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleDestroyFontFeatures(
        fontFeature: *mut OH_Drawing_FontFeature,
        fontFeatureSize: usize,
    );
}
extern "C" {
    #[doc = " @brief Get size of font features.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns the size of fontfeatures map.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetFontFeatureSize(style: *mut OH_Drawing_TextStyle) -> usize;
}
extern "C" {
    #[doc = " @brief Clear font features.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleClearFontFeature(style: *mut OH_Drawing_TextStyle);
}
extern "C" {
    #[doc = " @brief Set baseline shift of text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param lineShift Indicates the baseline shift to set.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleSetBaselineShift(style: *mut OH_Drawing_TextStyle, lineShift: f64);
}
extern "C" {
    #[doc = " @brief Get baseline shift of text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns the baseline shift.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetBaselineShift(style: *mut OH_Drawing_TextStyle) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the text color.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns the text color.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetColor(style: *mut OH_Drawing_TextStyle) -> u32;
}
extern "C" {
    #[doc = " @brief Gets text decoration style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns text decoration style.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetDecorationStyle(
        style: *mut OH_Drawing_TextStyle,
    ) -> OH_Drawing_TextDecorationStyle;
}
extern "C" {
    #[doc = " @brief Gets font weight.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns font Weight.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetFontWeight(
        style: *mut OH_Drawing_TextStyle,
    ) -> OH_Drawing_FontWeight;
}
extern "C" {
    #[doc = " @brief Gets font style.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns font style.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetFontStyle(
        style: *mut OH_Drawing_TextStyle,
    ) -> OH_Drawing_FontStyle;
}
extern "C" {
    #[doc = " @brief Gets the font baseline.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns the font baseline.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetBaseline(
        style: *mut OH_Drawing_TextStyle,
    ) -> OH_Drawing_TextBaseline;
}
extern "C" {
    #[doc = " @brief Gets a list of font families.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param num Indicates count of font families result.\n @return Returns a list of font families.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetFontFamilies(
        style: *mut OH_Drawing_TextStyle,
        num: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by a list of font families.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param fontFamilies Indicates the pointer to a list of font families.\n @param num Indicates the count of obtained font families.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleDestroyFontFamilies(
        fontFamilies: *mut *mut ::std::os::raw::c_char,
        num: usize,
    );
}
extern "C" {
    #[doc = " @brief Gets font size.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns font size.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetFontSize(style: *mut OH_Drawing_TextStyle) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the letter spacing of the text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns the size of the letter spacing.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetLetterSpacing(style: *mut OH_Drawing_TextStyle) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the word spacing of the text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns word spacing size.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetWordSpacing(style: *mut OH_Drawing_TextStyle) -> f64;
}
extern "C" {
    #[doc = " @brief Gets font height.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns font height.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetFontHeight(style: *mut OH_Drawing_TextStyle) -> f64;
}
extern "C" {
    #[doc = " @brief Gets whether to set the text to half line spacing.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns true indicates that the spacing takes effect,\n false indicates that the spacing does not take effect.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetHalfLeading(style: *mut OH_Drawing_TextStyle) -> bool;
}
extern "C" {
    #[doc = " @brief Gets the locale.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns a locale of data type as a pointer to a char. As with the TextStyle lifecycle.\n No release is required and the return value is invalidated after the set method is called.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetLocale(
        style: *mut OH_Drawing_TextStyle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Sets the text style, including font weight, font width and font slant.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param drawingTextStyle Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @param fontStyle Indicates an <b>OH_Drawing_FontStyleStruct</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTextStyleFontStyleStruct(
        drawingTextStyle: *mut OH_Drawing_TextStyle,
        fontStyle: OH_Drawing_FontStyleStruct,
    );
}
extern "C" {
    #[doc = " @brief Gets the text style, including font weight, font width and font slant.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param drawingTextStyle Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Returns the <b>OH_Drawing_FontStyleStruct</b> object getted.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleGetFontStyleStruct(
        drawingTextStyle: *mut OH_Drawing_TextStyle,
    ) -> OH_Drawing_FontStyleStruct;
}
extern "C" {
    #[doc = " @brief Sets the typography style, including font weight, font width and font slant.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param drawingStyle Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param fontStyle Indicates an <b>OH_Drawing_FontStyleStruct</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyStyleFontStyleStruct(
        drawingStyle: *mut OH_Drawing_TypographyStyle,
        fontStyle: OH_Drawing_FontStyleStruct,
    );
}
extern "C" {
    #[doc = " @brief Gets the typography style, including font weight, font width and font slant.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param drawingStyle Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @return Returns the <b>OH_Drawing_FontStyleStruct</b> object getted.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyStyleGetFontStyleStruct(
        drawingStyle: *mut OH_Drawing_TypographyStyle,
    ) -> OH_Drawing_FontStyleStruct;
}
extern "C" {
    #[doc = " @brief Gets whether the two TextStyle objects are equal.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates source of comparison <b>OH_Drawing_TextStyle</b> object.\n @param comparedStyle Indicates comparison <b>OH_Drawing_TextStyle</b> object.\n @return Compare result.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleIsEqual(
        style: *const OH_Drawing_TextStyle,
        comparedStyle: *const OH_Drawing_TextStyle,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Gets whether the font properties of two TextStyle objects are equal.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates source of <b>comparison OH_Drawing_TextStyle</b> object.\n @param comparedStyle Indicates comparison <b>OH_Drawing_TextStyle</b> object.\n @return Compare result.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleIsEqualByFont(
        style: *const OH_Drawing_TextStyle,
        comparedStyle: *const OH_Drawing_TextStyle,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Gets whether two TextStyle objects match attributes\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates enumerates of text style type.\n @param comparedStyle Indicates source of comparison <b>OH_Drawing_TextStyle</b> object.\n @param textStyleType Indicates comparison <b>OH_Drawing_TextStyle</b> object.\n @return Match attributes result.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleIsAttributeMatched(
        style: *const OH_Drawing_TextStyle,
        comparedStyle: *const OH_Drawing_TextStyle,
        textStyleType: OH_Drawing_TextStyleType,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set placeholder of TextStyle.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleSetPlaceholder(style: *mut OH_Drawing_TextStyle);
}
extern "C" {
    #[doc = " @brief Gets whether placeholder is enable.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TextStyle</b> object.\n @return Whether placeholder is enable.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TextStyleIsPlaceholder(style: *mut OH_Drawing_TextStyle) -> bool;
}
extern "C" {
    #[doc = " @brief Gets text alignment mode.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @return Returns text alignment mode.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyStyleGetEffectiveAlignment(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> OH_Drawing_TextAlign;
}
extern "C" {
    #[doc = " @brief Gets whether the hinting is enabled.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @return True, if the hinting takes effect; False, if the hinting does not take effect.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyStyleIsHintEnabled(style: *mut OH_Drawing_TypographyStyle) -> bool;
}
extern "C" {
    #[doc = " @brief Gets system font configuration information.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param errorCode Indicates error code returned, based on the error code to\n release the memory of system font configuration information.\n For details, see the enum <b>OH_Drawing_FontConfigInfoErrorCode</b>.\n @return Returns a pointer to system font configuration information.\n Indicates the pointer to an <b>OH_Drawing_FontConfigInfo</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_GetSystemFontConfigInfo(
        errorCode: *mut OH_Drawing_FontConfigInfoErrorCode,
    ) -> *mut OH_Drawing_FontConfigInfo;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by system font configuration information.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param drawFontCfgInfo Indicates the pointer to an <b>OH_Drawing_FontConfigInfo</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_DestroySystemFontConfigInfo(drawFontCfgInfo: *mut OH_Drawing_FontConfigInfo);
}
extern "C" {
    #[doc = " @brief Sets the strut style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param strutstyle Indicates the pointer of <b>OH_Drawing_StrutStyle</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTypographyStyleTextStrutStyle(
        style: *mut OH_Drawing_TypographyStyle,
        strutstyle: *mut OH_Drawing_StrutStyle,
    );
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by an <b>OH_Drawing_StrutStyle</b> object.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param strutstyle Indicates the pointer of <b>OH_Drawing_StrutStyle</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyStyleDestroyStrutStyle(strutstyle: *mut OH_Drawing_StrutStyle);
}
extern "C" {
    #[doc = " @brief Gets the strut style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @return Returns the pointer of <b>OH_Drawing_StrutStyle</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyStyleGetStrutStyle(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> *mut OH_Drawing_StrutStyle;
}
extern "C" {
    #[doc = " @brief Overriding the struct StrutStyle equals operator.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param from Indicates source of comparison object.\n @param to Indicates comparison object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyStyleStrutStyleEquals(
        from: *mut OH_Drawing_StrutStyle,
        to: *mut OH_Drawing_StrutStyle,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the hinting of text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to an <b>OH_Drawing_TypographyStyle</b> object.\n @param hintsEnabled Indicates the hinting of text typography..\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyStyleSetHintsEnabled(
        style: *mut OH_Drawing_TypographyStyle,
        hintsEnabled: bool,
    );
}
extern "C" {
    #[doc = " @brief Getting all font metrics from target row.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates a pointer to a typesetting object.\n @param lineNumber Indicates specifies the number of rows.\n @param fontMetricsSize Indicates the return size of font metrics struct from current line.\n @return Returns all character measures for the current row.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetLineFontMetrics(
        typography: *mut OH_Drawing_Typography,
        lineNumber: usize,
        fontMetricsSize: *mut usize,
    ) -> *mut OH_Drawing_Font_Metrics;
}
extern "C" {
    #[doc = " @brief Free up all the space taken up by the lineFontMetric.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param lineFontMetric Indicates the first address of the lineFontMetric gather to be destroyed.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyDestroyLineFontMetrics(
        lineFontMetric: *mut OH_Drawing_Font_Metrics,
    );
}
extern "C" {
    #[doc = " @brief Mark the Typography as dirty, and initially state the Typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to the text <b>OH_Drawing_Typography</b> object.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyMarkDirty(typography: *mut OH_Drawing_Typography);
}
extern "C" {
    #[doc = " @brief Get the unresolved Glyphs count of lines in a text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to the text <b>OH_Drawing_Typography</b> object.\n @return Returns unresolved Glyphs count.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetUnresolvedGlyphsCount(
        typography: *mut OH_Drawing_Typography,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Update the font size of lines in a text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param typography Indicates the pointer to the text <b>OH_Drawing_Typography</b> object.\n @param from Indicates the source of the original font size.\n @param to Indicates the destination of the updated font size.\n @param fontSize Indicates the size of the font.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyUpdateFontSize(
        typography: *mut OH_Drawing_Typography,
        from: usize,
        to: usize,
        fontSize: f32,
    );
}
extern "C" {
    #[doc = " @brief Get whether the text layout enables line styles.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to the text <b>OH_Drawing_TypographyStyle</b> object.\n @return Whether or not to enable line styles in text layout only, true means enable, false means disable.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextGetLineStyle(style: *mut OH_Drawing_TypographyStyle) -> bool;
}
extern "C" {
    #[doc = " @brief Get the font weight of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Return the font weight of line style for text typography.\n For details, see the enum <b>OH_Drawing_FontWeight</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineStyleGetFontWeight(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> OH_Drawing_FontWeight;
}
extern "C" {
    #[doc = " @brief Get the font style of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Return the font style of line style for text typography.\n For details, see the enum <b>OH_Drawing_FontStyle</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineStyleGetFontStyle(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> OH_Drawing_FontStyle;
}
extern "C" {
    #[doc = " @brief Get the font families of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @param num The number of obtained font names.\n @return Return the font families of line style for text typography.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineStyleGetFontFamilies(
        style: *mut OH_Drawing_TypographyStyle,
        num: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by a list of font families names.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param fontFamilies Indicates the pointer to a list of font families names.\n @param fontFamiliesNum Indicates the number of obtained font names.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineStyleDestroyFontFamilies(
        fontFamilies: *mut *mut ::std::os::raw::c_char,
        fontFamiliesNum: usize,
    );
}
extern "C" {
    #[doc = " @brief Get the font size of font size for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Return the font size of font size for text typography.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineStyleGetFontSize(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Get the font height scale in text layout.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Retrun the font height scale in text layout.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineStyleGetHeightScale(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Get whether to enable font height for line styles in text layout only.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Whether or not to enable the font height for line styles in text layout only,\n true means enable, false means disable.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineStyleGetHeightOnly(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the half leading of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Whether to enable the text line half leading style, true means enable, false means disable.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineStyleGetHalfLeading(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the spacing scale of line style for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Return the spacing scale of line style for text typography.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineStyleGetSpacingScale(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Get whether only line style is enabled for text typography.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Returns whether only line style is enabled for text layout, true means it is enabled,\n false means it is not.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyTextlineGetStyleOnly(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the text alignment mode.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Return the text alignment mode. For details, see the enum <b>OH_Drawing_TextAlign</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetTextAlign(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> OH_Drawing_TextAlign;
}
extern "C" {
    #[doc = " @brief Get the text direction.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Return the text direction. For details, see the enum <b>OH_Drawing_TextDirection</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetTextDirection(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> OH_Drawing_TextDirection;
}
extern "C" {
    #[doc = " @brief Sets the maximum number of lines in a text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Return the maximum number of lines in a text.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetTextMaxLines(style: *mut OH_Drawing_TypographyStyle) -> usize;
}
extern "C" {
    #[doc = " @brief Get the ellipsis of lines in a text.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param style Indicates the pointer to a typography style object\n <b>OH_Drawing_TypographyStyle</b>.\n @return Return the ellipsis of lines in a text.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyGetTextEllipsis(
        style: *mut OH_Drawing_TypographyStyle,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by a list of Ellipsis names.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param ellipsis Indicates the pointer to a list of Ellipsis names.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyDestroyEllipsis(ellipsis: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Overriding the class ParagraphStyle equals operator.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param from Indicates source of comparison object.\n @param to Indicates comparison object.\n @return Compare result.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyStyleEquals(
        from: *mut OH_Drawing_TypographyStyle,
        to: *mut OH_Drawing_TypographyStyle,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Releases the memory occupied by text box.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param textBox Indicates the pointer to a text box object <b>OH_Drawing_TextBox</b>.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_TypographyDestroyTextBox(textBox: *mut OH_Drawing_TextBox);
}
extern "C" {
    #[doc = " @brief Sets the parameter of text-shadow.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param shadow Indicates the pointer to an <b>OH_Drawing_TextShadow</b> object.\n @param color Indicates the color setting of text-shadow.\n @param offset Indicates the pointer to an <b>OH_Drawing_Point</b> object.\n @param blurRadius Indicates the radius of blur for text-shadow.\n @since 12\n @version 1.0"]
    pub fn OH_Drawing_SetTextShadow(
        shadow: *mut OH_Drawing_TextShadow,
        color: u32,
        offset: *mut OH_Drawing_Point,
        blurRadius: f64,
    );
}
extern "C" {
    #[doc = " @brief Get DrawingArray size.\n\n @syscap SystemCapability.Graphic.Graphic2D.NativeDrawing\n @param drawingArray Indicates the pointer to the array object <b>OH_Drawing_Array</b>.\n @return Size of array.\n @since 14\n @version 1.0"]
    pub fn OH_Drawing_GetDrawingArraySize(drawingArray: *mut OH_Drawing_Array) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkUI_StyledString {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates a pointer to the ArkUI_StyledString object.\n\n @param style A pointer to OH_Drawing_TypographyStyle, obtained by {@link OH_Drawing_CreateTypographyStyle}.\n @param collection A pointer to OH_Drawing_FontCollection, obtained by {@link OH_Drawing_CreateFontCollection}.\n @return Creates a pointer to the ArkUI_StyledString object. If the object returns a null pointer,\n         the creation failed, either because the address space was full,\n         or because the style, collection parameter was an exception such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_StyledString_Create(
        style: *mut OH_Drawing_TypographyStyle,
        collection: *mut OH_Drawing_FontCollection,
    ) -> *mut ArkUI_StyledString;
}
extern "C" {
    #[doc = " @brief Free the memory occupied by the ArkUI_StyledString object.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @since 12"]
    pub fn OH_ArkUI_StyledString_Destroy(handle: *mut ArkUI_StyledString);
}
extern "C" {
    #[doc = " @brief Sets the new layout style to the top of the current format string style stack.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @param style A pointer to the OH_Drawing_TextStyle object.\n @since 12"]
    pub fn OH_ArkUI_StyledString_PushTextStyle(
        handle: *mut ArkUI_StyledString,
        style: *mut OH_Drawing_TextStyle,
    );
}
extern "C" {
    #[doc = " @brief Sets the corresponding text content based on the current format string style.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @param content A pointer to the text content.\n @since 12"]
    pub fn OH_ArkUI_StyledString_AddText(
        handle: *mut ArkUI_StyledString,
        content: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Removes the top style from the stack in the current format string object.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @since 12"]
    pub fn OH_ArkUI_StyledString_PopTextStyle(handle: *mut ArkUI_StyledString);
}
extern "C" {
    #[doc = " @brief Creates a pointer to an OH_Drawing_Typography object based on a format string object\n for advanced text estimation and typography.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @return A pointer to the OH_Drawing_Typography object. If the object returns a null pointer,\n         the creation fails because the handle parameter is abnormal, such as a null pointer.\n @since 12"]
    pub fn OH_ArkUI_StyledString_CreateTypography(
        handle: *mut ArkUI_StyledString,
    ) -> *mut OH_Drawing_Typography;
}
extern "C" {
    #[doc = " @brief Set the placeholder.\n\n @param handle A pointer to the ArkUI_StyledString object.\n @param placeholder A pointer to the OH_Drawing_PlaceholderSpan object.\n @since 12"]
    pub fn OH_ArkUI_StyledString_AddPlaceholder(
        handle: *mut ArkUI_StyledString,
        placeholder: *mut OH_Drawing_PlaceholderSpan,
    );
}
extern "C" {
    #[doc = " @brief Creates an <b>ArkUI_StyledString_Descriptor</b> object.\n\n @return Returns the pointer to the <b>ArkUI_StyledString_Descriptor</b> object created.\n @since 14"]
    pub fn OH_ArkUI_StyledString_Descriptor_Create() -> *mut ArkUI_StyledString_Descriptor;
}
extern "C" {
    #[doc = " @brief Destroys an <b>ArkUI_StyledString_Descriptor</b> object and reclaims the memory occupied by the object.\n\n @param descriptor Pointer to an <b>ArkUI_StyledString_Descriptor</b> object.\n @since 14"]
    pub fn OH_ArkUI_StyledString_Descriptor_Destroy(descriptor: *mut ArkUI_StyledString_Descriptor);
}
extern "C" {
    #[doc = " @brief Converts styled string information into HTML.\n\n @param descriptor Pointer to an <b>ArkUI_StyledString_Descriptor</b> object.\n @return Returns the pointer to the resulting HTML string. This pointer is managed internally and should be destroyed\n         by calling <b>OH_ArkUI_StyledString_Descriptor_Destroy()</b> when no longer needed to free the memory.\n @since 14"]
    pub fn OH_ArkUI_ConvertToHtml(
        descriptor: *mut ArkUI_StyledString_Descriptor,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Deserializes a byte array containing styled string information into a styled string.\n\n @param buffer Byte array to be deserialized.\n @param bufferSize Length of the byte array.\n @param descriptor Pointer to an <b>ArkUI_StyledString_Descriptor</b> object.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n @since 14"]
    pub fn OH_ArkUI_UnmarshallStyledStringDescriptor(
        buffer: *mut u8,
        bufferSize: usize,
        descriptor: *mut ArkUI_StyledString_Descriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Serializes the styled string information into a byte array.\n\n @param buffer Byte array where the serialized data will be stored.\n @param bufferSize Length of the byte array.\n @param descriptor Pointer to an <b>ArkUI_StyledString_Descriptor</b> object.\n @param resultSize Actual length of the byte array.\n @return Returns the result code.\n         Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.\n         Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.\n         Returns {@link ARKUI_ERROR_CODE_INVALID_STYLED_STRING} if the styled string is invalid.\n @since 14"]
    pub fn OH_ArkUI_MarshallStyledStringDescriptor(
        buffer: *mut u8,
        bufferSize: usize,
        descriptor: *mut ArkUI_StyledString_Descriptor,
        resultSize: *mut usize,
    ) -> i32;
}
