/* automatically generated by rust-bindgen 0.65.1 */

#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(clippy::missing_safety_doc)]

#[link(name = "ohweb")]
unsafe extern "C" {}

#[doc = " @error Success."]
pub const ArkWeb_ErrorCode_ARKWEB_SUCCESS: ArkWeb_ErrorCode = 0;
#[doc = " @error Init error."]
pub const ArkWeb_ErrorCode_ARKWEB_INIT_ERROR: ArkWeb_ErrorCode = 17100001;
#[doc = " @error Unknown error."]
pub const ArkWeb_ErrorCode_ARKWEB_ERROR_UNKNOWN: ArkWeb_ErrorCode = 17100100;
#[doc = " @error Invalid param."]
pub const ArkWeb_ErrorCode_ARKWEB_INVALID_PARAM: ArkWeb_ErrorCode = 17100101;
#[doc = " @error Register custom schemes should be called before create any ArkWeb."]
pub const ArkWeb_ErrorCode_ARKWEB_SCHEME_REGISTER_FAILED: ArkWeb_ErrorCode = 17100102;
#[doc = " @error Invalid url."]
pub const ArkWeb_ErrorCode_ARKWEB_INVALID_URL: ArkWeb_ErrorCode = 17100103;
#[doc = " @error Invalid cookie value."]
pub const ArkWeb_ErrorCode_ARKWEB_INVALID_COOKIE_VALUE: ArkWeb_ErrorCode = 17100104;
pub const ArkWeb_ErrorCode_ARKWEB_LIBRARY_OPEN_FAILURE: ArkWeb_ErrorCode = 17100105;
pub const ArkWeb_ErrorCode_ARKWEB_LIBRARY_SYMBOL_NOT_FOUND: ArkWeb_ErrorCode = 17100106;
#[cfg(feature = "api-20")]
#[doc = " @brief The CookieManager not initialized.\n\n @since 20"]
pub const ArkWeb_ErrorCode_ARKWEB_COOKIE_MANAGER_NOT_INITIALIZED: ArkWeb_ErrorCode = 17100107;
#[cfg(feature = "api-20")]
#[doc = " @brief The CookieManager initialize failed.\n\n @since 20"]
pub const ArkWeb_ErrorCode_ARKWEB_COOKIE_MANAGER_INITIALIZE_FAILED: ArkWeb_ErrorCode = 17100108;
#[cfg(feature = "api-20")]
#[doc = " @brief Save cookie failed.\n\n @since 20"]
pub const ArkWeb_ErrorCode_ARKWEB_COOKIE_SAVE_FAILED: ArkWeb_ErrorCode = 17100109;
pub type ArkWeb_ErrorCode = ::std::os::raw::c_uint;
#[doc = " @error The operation is successful."]
#[cfg(feature = "api-20")]
pub const ArkWeb_BlanklessErrorCode_ARKWEB_BLANKLESS_SUCCESS: ArkWeb_BlanklessErrorCode = 0;
#[doc = " @error Unidentified error."]
#[cfg(feature = "api-20")]
pub const ArkWeb_BlanklessErrorCode_ARKWEB_BLANKLESS_ERR_UNKNOWN: ArkWeb_BlanklessErrorCode = -1;
#[doc = " @error Invalid parameter."]
#[cfg(feature = "api-20")]
pub const ArkWeb_BlanklessErrorCode_ARKWEB_BLANKLESS_ERR_INVALID_ARGS: ArkWeb_BlanklessErrorCode =
    -2;
#[doc = " @error The web controller is not bound to a component."]
#[cfg(feature = "api-20")]
pub const ArkWeb_BlanklessErrorCode_ARKWEB_BLANKLESS_ERR_CONTROLLER_NOT_INITED:
    ArkWeb_BlanklessErrorCode = -3;
#[doc = " @error The key value is not matched. The OH_NativeArkWeb_SetBlanklessLoadingWithKey\n and OH_NativeArkWeb_GetBlanklessInfoWithKey APIs must be used in pair and use the same key value."]
#[cfg(feature = "api-20")]
pub const ArkWeb_BlanklessErrorCode_ARKWEB_BLANKLESS_ERR_KEY_NOT_MATCH: ArkWeb_BlanklessErrorCode =
    -4;
#[doc = " @error If the similarity is low, the system determines that the change is too large.\n As a result, the OH_NativeArkWeb_SetBlanklessLoadingWithKey API fails to enable frame interpolation."]
#[cfg(feature = "api-20")]
pub const ArkWeb_BlanklessErrorCode_ARKWEB_BLANKLESS_ERR_SIGNIFICANT_CHANGE:
    ArkWeb_BlanklessErrorCode = -5;
#[doc = " @error The device does not support this feature."]
#[cfg(feature = "api-20")]
pub const ArkWeb_BlanklessErrorCode_ARKWEB_BLANKLESS_ERR_DEVICE_NOT_SUPPORT:
    ArkWeb_BlanklessErrorCode = 801;
#[cfg(feature = "api-20")]
#[doc = " @brief Defines an enum for the error codes of the white screen optimization solution.\n\n @since 20"]
pub type ArkWeb_BlanklessErrorCode = ::std::os::raw::c_int;
#[doc = " @brief Defines the javascript bridge data type.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_JavaScriptBridgeData {
    #[doc = " A buffer that contains data."]
    pub buffer: *const u8,
    #[doc = " The size of the buffer."]
    pub size: usize,
}
#[doc = " Represent error data"]
pub const ArkWeb_WebMessageType_ARKWEB_NONE: ArkWeb_WebMessageType = 0;
#[doc = " The data carried in the ArkWeb_WebMessage is string."]
pub const ArkWeb_WebMessageType_ARKWEB_STRING: ArkWeb_WebMessageType = 1;
#[doc = " The data carried in the ArkWeb_WebMessage is buffer(uint8_t)."]
pub const ArkWeb_WebMessageType_ARKWEB_BUFFER: ArkWeb_WebMessageType = 2;
#[doc = " @brief Defines the data type carried in a ArkWeb_WebMessage.\n\n @since 12"]
pub type ArkWeb_WebMessageType = ::std::os::raw::c_uint;
#[doc = " Represent error data"]
#[cfg(feature = "api-18")]
pub const ArkWeb_JavaScriptValueType_ARKWEB_JAVASCRIPT_NONE: ArkWeb_JavaScriptValueType = 0;
#[doc = " The data carried in the ArkWeb_JavaScriptValue is string."]
#[cfg(feature = "api-18")]
pub const ArkWeb_JavaScriptValueType_ARKWEB_JAVASCRIPT_STRING: ArkWeb_JavaScriptValueType = 1;
#[doc = " The data carried in the ArkWeb_JavaScriptValue is bool."]
#[cfg(feature = "api-18")]
pub const ArkWeb_JavaScriptValueType_ARKWEB_JAVASCRIPT_BOOL: ArkWeb_JavaScriptValueType = 2;
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the data type carried in a ArkWeb_JavaScriptValue.\n\n @since 18"]
pub type ArkWeb_JavaScriptValueType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_WebMessage {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the ArkWeb_WebMessage.\n\n @since 12"]
pub type ArkWeb_WebMessagePtr = *mut ArkWeb_WebMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_JavaScriptValue {
    _unused: [u8; 0],
}
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the ArkWeb_JavaScriptValuePtr.\n\n @since 18"]
pub type ArkWeb_JavaScriptValuePtr = *mut ArkWeb_JavaScriptValue;
#[doc = " @brief Defines the javascript callback of the native ArkWeb.\n\n @since 12"]
pub type ArkWeb_OnJavaScriptCallback = ::std::option::Option<
    unsafe extern "C" fn(
        webTag: *const ::std::os::raw::c_char,
        data: *const ArkWeb_JavaScriptBridgeData,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Defines the javascript proxy callback of the native ArkWeb.\n\n @since 12"]
pub type ArkWeb_OnJavaScriptProxyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        webTag: *const ::std::os::raw::c_char,
        dataArray: *const ArkWeb_JavaScriptBridgeData,
        arraySize: usize,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the JavaScript proxy callback of the native ArkWeb.\n\n @param webTag The name of the web component.\n @param dataArray The JavaScript bridge data array from HTML.\n @param arraySize The number of elements in the array.\n @param userData The data set by user.\n\n @since 18"]
pub type ArkWeb_OnJavaScriptProxyCallbackWithResult = ::std::option::Option<
    unsafe extern "C" fn(
        webTag: *const ::std::os::raw::c_char,
        dataArray: *const ArkWeb_JavaScriptBridgeData,
        arraySize: usize,
        userData: *mut ::std::os::raw::c_void,
    ) -> ArkWeb_JavaScriptValuePtr,
>;
#[doc = " @brief Defines the component callback of the native ArkWeb.\n\n @since 12"]
pub type ArkWeb_OnComponentCallback = ::std::option::Option<
    unsafe extern "C" fn(
        webTag: *const ::std::os::raw::c_char,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the scroll callback of the native ArkWeb.\n\n @param webTag The name of the web component.\n @param userData The data set by user.\n @param x X-axis scrolling offset.\n @param y Y-axis scrolling offset.\n\n @since 18"]
pub type ArkWeb_OnScrollCallback = ::std::option::Option<
    unsafe extern "C" fn(
        webTag: *const ::std::os::raw::c_char,
        userData: *mut ::std::os::raw::c_void,
        x: f64,
        y: f64,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_WebMessagePort {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the ArkWeb_WebMessagePort that represent a HTML5 message port.\n\n @since 12"]
pub type ArkWeb_WebMessagePortPtr = *mut ArkWeb_WebMessagePort;
#[doc = " @brief Defines the callback to receive message from HTML.\n\n @param webTag The name of the web component.\n @param port The ArkWeb_WebMessagePort for registering the ArkWeb_OnMessageEventHandler.\n @param message The received ArkWeb_WebMessage.\n @param userData The data set by user.\n\n @since 12"]
pub type ArkWeb_OnMessageEventHandler = ::std::option::Option<
    unsafe extern "C" fn(
        webTag: *const ::std::os::raw::c_char,
        port: ArkWeb_WebMessagePortPtr,
        message: ArkWeb_WebMessagePtr,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Defines the javascript object.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_JavaScriptObject {
    #[doc = " A piece of javascript code."]
    pub buffer: *const u8,
    #[doc = " The size of the javascript code."]
    pub size: usize,
    #[doc = " Callbacks execute JavaScript script results."]
    pub callback: ArkWeb_OnJavaScriptCallback,
    #[doc = " The user data to set."]
    pub userData: *mut ::std::os::raw::c_void,
}
#[doc = " @brief Defines the javascript proxy registered method object.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_ProxyMethod {
    #[doc = " The method of the application side JavaScript object participating in the registration."]
    pub methodName: *const ::std::os::raw::c_char,
    #[doc = " The callback function registered by developer is called back when HTML side uses."]
    pub callback: ArkWeb_OnJavaScriptProxyCallback,
    #[doc = " The user data to set."]
    pub userData: *mut ::std::os::raw::c_void,
}
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the JavaScript proxy method with a return value.\n\n @since 18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_ProxyMethodWithResult {
    #[doc = " The method of the application side JavaScript object participating in the registration."]
    pub methodName: *const ::std::os::raw::c_char,
    #[doc = " The callback function with a return value registered by developer is called back when HTML side uses."]
    pub callback: ArkWeb_OnJavaScriptProxyCallbackWithResult,
    #[doc = " The user data to set."]
    pub userData: *mut ::std::os::raw::c_void,
}
#[doc = " @brief Defines the javascript proxy registered object.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_ProxyObject {
    #[doc = " The name of the registered object."]
    pub objName: *const ::std::os::raw::c_char,
    #[doc = " The javascript proxy registered method object list"]
    pub methodList: *const ArkWeb_ProxyMethod,
    #[doc = " The size of the methodList."]
    pub size: usize,
}
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the JavaScript proxy registered object with methodList that has a return value.\n\n @since 18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_ProxyObjectWithResult {
    #[doc = " The name of the registered object."]
    pub objName: *const ::std::os::raw::c_char,
    #[doc = " The JavaScript proxy registered method object list with a callback function that has a return value"]
    pub methodList: *const ArkWeb_ProxyMethodWithResult,
    #[doc = " The size of the methodList."]
    pub size: usize,
}
#[doc = " @brief Defines the controller API for native ArkWeb.\n Before invoking an API, you are advised to use ARKWEB_MEMBER_MISSING to check\n whether the function structure has a corresponding function pointer to avoid crash\n caused by mismatch between the SDK and the device ROM.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_ControllerAPI {
    #[doc = " The ArkWeb_ControllerAPI struct size."]
    pub size: usize,
    #[doc = " Load a piece of code and execute JS code in the context of the currently displayed page."]
    pub runJavaScript: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            javascriptObject: *const ArkWeb_JavaScriptObject,
        ),
    >,
    #[doc = " Register the JavaScript object and method list."]
    pub registerJavaScriptProxy: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            proxyObject: *const ArkWeb_ProxyObject,
        ),
    >,
    #[doc = " Deletes the registered object which th given name."]
    pub deleteJavaScriptRegister: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            objName: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Refresh the current web page."]
    pub refresh: ::std::option::Option<unsafe extern "C" fn(webTag: *const ::std::os::raw::c_char)>,
    #[doc = " Register the JavaScript object and async method list."]
    pub registerAsyncJavaScriptProxy: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            proxyObject: *const ArkWeb_ProxyObject,
        ),
    >,
    #[doc = " @brief Creates a message channel to communicate with HTML and returns\n        the message ports representing the message channel endpoints.\n\n @param webTag The name of the web component.\n @param size The quantity of message ports."]
    pub createWebMessagePorts: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            size: *mut usize,
        ) -> *mut ArkWeb_WebMessagePortPtr,
    >,
    #[doc = " @brief Destroy message ports.\n\n @param ports Address of the message ports array pointer.\n @param size The quantity of message ports."]
    pub destroyWebMessagePorts: ::std::option::Option<
        unsafe extern "C" fn(ports: *mut *mut ArkWeb_WebMessagePortPtr, size: usize),
    >,
    #[doc = " @brief Post message ports to main frame.\n\n @param webTag The name of the web component.\n @param name Name of the message to be sent.\n @param size The quantity of message ports.\n @param url Indicates the URI for receiving the message.\n @return Post web message result code.\n         {@link ARKWEB_SUCCESS} post web message success.\n         {@link ARKWEB_INVALID_PARAM} the parameter verification fails.\n         {@link ARKWEB_INIT_ERROR} no web associated with this webTag."]
    pub postWebMessage: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            name: *const ::std::os::raw::c_char,
            webMessagePorts: *mut ArkWeb_WebMessagePortPtr,
            size: usize,
            url: *const ::std::os::raw::c_char,
        ) -> ArkWeb_ErrorCode,
    >,
    #[cfg(feature = "api-14")]
    #[doc = " @brief Get the url of the last frame that calls the JavaScriptProxy.\n        This should be call on the thread which JavaScriptProxy called.\n\n @return The url of the last frame that calls the JavaScriptProxy.\n @since 14"]
    pub getLastJavascriptProxyCallingFrameUrl:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    #[cfg(feature = "api-18")]
    #[doc = " @brief Register the JavaScript object and method list, the method is callback function that has a return value.\n\n @param webTag The name of the web component.\n @param proxyObject The JavaScript object to register, the object has callback functions with return value.\n @param permission The JSON string, which defaults to null, is used to configure the permission control for\n JSBridge, allowing for the definition of URL whitelists at the object and method levels.\n\n @since 18"]
    pub registerJavaScriptProxyEx: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            proxyObject: *const ArkWeb_ProxyObjectWithResult,
            permission: *const ::std::os::raw::c_char,
        ),
    >,
    #[cfg(feature = "api-18")]
    #[doc = " @brief Register the JavaScript object and async method list.\n\n @param webTag The name of the web component.\n @param proxyObject The JavaScript object to register.\n @param permission The JSON string, which defaults to null, is used to configure the permission control\n for JSBridge, allowing for the definition of URL whitelists at the object and method levels.\n\n @since 18"]
    pub registerAsyncJavaScriptProxyEx: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            proxyObject: *const ArkWeb_ProxyObject,
            permission: *const ::std::os::raw::c_char,
        ),
    >,
}
#[doc = " @brief Defines the component API for native ArkWeb.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_ComponentAPI {
    #[doc = " The ArkWeb_ComponentAPI struct size."]
    pub size: usize,
    #[doc = " Register the OnControllerAttached callback."]
    pub onControllerAttached: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            callback: ArkWeb_OnComponentCallback,
            userData: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Register the OnPageBegin callback."]
    pub onPageBegin: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            callback: ArkWeb_OnComponentCallback,
            userData: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Register the OnPageEnd callback."]
    pub onPageEnd: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            callback: ArkWeb_OnComponentCallback,
            userData: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Register the OnDestroy callback."]
    pub onDestroy: ::std::option::Option<
        unsafe extern "C" fn(
            webTag: *const ::std::os::raw::c_char,
            callback: ArkWeb_OnComponentCallback,
            userData: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[doc = " @brief Defines the web message API for native ArkWeb.\n Before invoking an API, you are advised to use ARKWEB_MEMBER_MISSING to check\n whether the function structure has a corresponding function pointer to avoid crash\n caused by mismatch between the SDK and the device ROM.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_WebMessagePortAPI {
    #[doc = " The ArkWeb_WebMessagePortAPI struct size."]
    pub size: usize,
    #[doc = " @brief Post message to HTML.\n\n @param webMessagePort The ArkWeb_WebMessagePort.\n @param webTag The name of the web component.\n @param webMessage The ArkWeb_WebMessage to send.\n @return Post message result code.\n         {@link ARKWEB_SUCCESS} post message success.\n         {@link ARKWEB_INVALID_PARAM} the parameter verification fails.\n         {@link ARKWEB_INIT_ERROR} no web associated with this webTag."]
    pub postMessage: ::std::option::Option<
        unsafe extern "C" fn(
            webMessagePort: ArkWeb_WebMessagePortPtr,
            webTag: *const ::std::os::raw::c_char,
            webMessage: ArkWeb_WebMessagePtr,
        ) -> ArkWeb_ErrorCode,
    >,
    #[doc = " @brief Close the message port.\n\n @param webMessagePort The ArkWeb_WebMessagePort.\n @param webTag The name of the web component."]
    pub close: ::std::option::Option<
        unsafe extern "C" fn(
            webMessagePort: ArkWeb_WebMessagePortPtr,
            webTag: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " @brief Set a callback to receive message from HTML.\n\n @param webMessagePort The ArkWeb_WebMessagePort.\n @param webTag The name of the web component.\n @param messageEventHandler The handler to receive message from HTML.\n @param userData The data set by user."]
    pub setMessageEventHandler: ::std::option::Option<
        unsafe extern "C" fn(
            webMessagePort: ArkWeb_WebMessagePortPtr,
            webTag: *const ::std::os::raw::c_char,
            messageEventHandler: ArkWeb_OnMessageEventHandler,
            userData: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[doc = " @brief Defines the web message data API for native ArkWeb.\n Before invoking an API, you are advised to use ARKWEB_MEMBER_MISSING to check\n whether the function structure has a corresponding function pointer to avoid crash\n caused by mismatch between the SDK and the device ROM.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_WebMessageAPI {
    #[doc = " The ArkWeb_WebMessageAPI struct size."]
    pub size: usize,
    #[doc = "  @brief Used to create a ArkWeb_WebMessage.\n\n  @return The created ArkWeb_WebMessage, destroy it through\n  destroyWebMessage after it is no longer used."]
    pub createWebMessage: ::std::option::Option<unsafe extern "C" fn() -> ArkWeb_WebMessagePtr>,
    #[doc = "  @brief Used to destroy a ArkWeb_WebMessage.\n\n  @param webMessage The ArkWeb_WebMessage to destroy."]
    pub destroyWebMessage:
        ::std::option::Option<unsafe extern "C" fn(webMessage: *mut ArkWeb_WebMessagePtr)>,
    #[doc = "  @brief Set the type of ArkWeb_WebMessage.\n\n  @param webMessage The ArkWeb_WebMessage.\n  @param type The type of ArkWeb_WebMessage."]
    pub setType: ::std::option::Option<
        unsafe extern "C" fn(webMessage: ArkWeb_WebMessagePtr, type_: ArkWeb_WebMessageType),
    >,
    #[doc = "  @brief Get the type of ArkWeb_WebMessage.\n\n  @param webMessage The ArkWeb_WebMessage.\n  @return The type of ArkWeb_WebMessage."]
    pub getType: ::std::option::Option<
        unsafe extern "C" fn(webMessage: ArkWeb_WebMessagePtr) -> ArkWeb_WebMessageType,
    >,
    #[doc = "  @brief Set the data of ArkWeb_WebMessage.\n\n  @param webMessage The ArkWeb_WebMessage.\n  @param data The data of ArkWeb_WebMessage.\n  @param dataLength The length of data."]
    pub setData: ::std::option::Option<
        unsafe extern "C" fn(
            webMessage: ArkWeb_WebMessagePtr,
            data: *mut ::std::os::raw::c_void,
            dataLength: usize,
        ),
    >,
    #[doc = "  @brief Get the data of ArkWeb_WebMessage.\n\n  @param webMessage The ArkWeb_WebMessage.\n  @param dataLength The length of data.\n  @return The data of ArkWeb_WebMessage."]
    pub getData: ::std::option::Option<
        unsafe extern "C" fn(
            webMessage: ArkWeb_WebMessagePtr,
            dataLength: *mut usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
}
#[doc = " @brief Defines the native CookieManager API for ArkWeb.\n Before invoking an API, you are advised to use ARKWEB_MEMBER_MISSING to check\n whether the function structure has a corresponding function pointer to avoid crash\n caused by mismatch between the SDK and the device ROM.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_CookieManagerAPI {
    #[doc = " The ArkWeb_CookieManagerAPI struct size."]
    pub size: usize,
    #[doc = " @brief Obtains the cookie value corresponding to a specified URL.\n\n @param url URL to which the cookie to be obtained belongs. A complete URL is recommended.\n @param incognito True indicates that the memory cookies of the webview in privacy mode are obtained,\n                  and false indicates that cookies in non-privacy mode are obtained.\n @param includeHttpOnly If true HTTP-only cookies will also be included in the cookieValue.\n @param cookieValue Get the cookie value corresponding to the URL.\n @return Fetch cookie result code.\n         {@link ARKWEB_SUCCESS} fetch cookie success.\n         {@link ARKWEB_INVALID_URL} invalid url.\n         {@link ARKWEB_INVALID_PARAM} cookieValue is nullptr."]
    pub fetchCookieSync: ::std::option::Option<
        unsafe extern "C" fn(
            url: *const ::std::os::raw::c_char,
            incognito: bool,
            includeHttpOnly: bool,
            cookieValue: *mut *mut ::std::os::raw::c_char,
        ) -> ArkWeb_ErrorCode,
    >,
    #[doc = " @brief Sets the cookie value for a specified URL.\n\n @param url Specifies the URL to which the cookie belongs. A complete URL is recommended.\n @param cookieValue The value of the cookie to be set.\n @param incognito True indicates that cookies of the corresponding URL are set in privacy mode,\n                  and false indicates that cookies of the corresponding URL are set in non-privacy mode.\n @param includeHttpOnly If true, HTTP-only cookies can also be overwritten.\n @return Config cookie result code.\n         {@link ARKWEB_SUCCESS} config cookie success.\n         {@link ARKWEB_INVALID_URL} invalid url.\n         {@link ARKWEB_INVALID_COOKIE_VALUE} invalid cookie value."]
    pub configCookieSync: ::std::option::Option<
        unsafe extern "C" fn(
            url: *const ::std::os::raw::c_char,
            cookieValue: *const ::std::os::raw::c_char,
            incognito: bool,
            includeHttpOnly: bool,
        ) -> ArkWeb_ErrorCode,
    >,
    #[doc = " @brief Check whether cookies exist.\n\n @param incognito True indicates whether cookies exist in privacy mode,\n                  and false indicates whether cookies exist in non-privacy mode.\n @return True indicates that the cookie exists, and false indicates that the cookie does not exist."]
    pub existCookies: ::std::option::Option<unsafe extern "C" fn(incognito: bool) -> bool>,
    #[doc = " @brief Clear all cookies.\n\n @param incognito True indicates that all memory cookies of the webview are cleared in privacy mode,\n                  and false indicates that persistent cookies in non-privacy mode are cleared."]
    pub clearAllCookiesSync: ::std::option::Option<unsafe extern "C" fn(incognito: bool)>,
    #[doc = " @brief Clear all session cookies."]
    pub clearSessionCookiesSync: ::std::option::Option<unsafe extern "C" fn()>,
}
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the native JavaScriptValue API for ArkWeb.\n Before invoking an API, you are advised to use ARKWEB_MEMBER_MISSING to check\n whether the function structure has a corresponding function pointer to avoid crash\n caused by mismatch between the SDK and the device ROM.\n\n @since 18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_JavaScriptValueAPI {
    #[doc = " The ArkWeb_JavaScriptValueAPI struct size."]
    pub size: usize,
    #[doc = " @brief Create the JavaScript value responding to HTML.\n\n @param type The type of ArkWeb_JavaScriptValue.\n @param data The data buffer of ArkWeb_JavaScriptValue.\n @param dataLength The length of data buffer.\n @return ArkWeb_JavaScriptValuePtr created by ArkWeb, the memory of ArkWeb_JavaScriptValue\n is managed by ArkWeb itself."]
    pub createJavaScriptValue: ::std::option::Option<
        unsafe extern "C" fn(
            type_: ArkWeb_JavaScriptValueType,
            data: *mut ::std::os::raw::c_void,
            dataLength: usize,
        ) -> ArkWeb_JavaScriptValuePtr,
    >,
}
#[doc = " @brief Defines the native API type of any size.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_AnyNativeAPI {
    #[doc = " Defines the size information of the native API set."]
    pub size: usize,
}
#[doc = " API type related to ArkWeb component."]
pub const ArkWeb_NativeAPIVariantKind_ARKWEB_NATIVE_COMPONENT: ArkWeb_NativeAPIVariantKind = 0;
#[doc = " API type related to ArkWeb controller."]
pub const ArkWeb_NativeAPIVariantKind_ARKWEB_NATIVE_CONTROLLER: ArkWeb_NativeAPIVariantKind = 1;
#[doc = " API type related to ArkWeb WebMessagePort."]
pub const ArkWeb_NativeAPIVariantKind_ARKWEB_NATIVE_WEB_MESSAGE_PORT: ArkWeb_NativeAPIVariantKind =
    2;
#[doc = " API type related to ArkWeb WebMessage."]
pub const ArkWeb_NativeAPIVariantKind_ARKWEB_NATIVE_WEB_MESSAGE: ArkWeb_NativeAPIVariantKind = 3;
#[doc = " API type related to ArkWeb cookie manager."]
pub const ArkWeb_NativeAPIVariantKind_ARKWEB_NATIVE_COOKIE_MANAGER: ArkWeb_NativeAPIVariantKind = 4;
#[cfg(feature = "api-18")]
#[doc = " @brief API type related to ArkWeb JavaScript value.\n\n @since 18"]
pub const ArkWeb_NativeAPIVariantKind_ARKWEB_NATIVE_JAVASCRIPT_VALUE: ArkWeb_NativeAPIVariantKind =
    5;
#[doc = " @brief Defines the native API set type.\n\n @since 12"]
pub type ArkWeb_NativeAPIVariantKind = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Obtains the native API set of a specified type.\n @param type Indicates the type of the native API set provided by ArkWeb.\n @return Return the pointer to the native API abstract object that carries the size.\n         If the type is incorrect, a null pointer is returned.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_GetNativeAPI(type_: ArkWeb_NativeAPIVariantKind) -> *mut ArkWeb_AnyNativeAPI;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Register a scrolling event callback.\n @param webTag The name of the web component.\n @param callback The ArkWeb scrolling callback.\n @param userData The data set by user.\n @return Returns whether the registration was successful, false indicates failure.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 18"]
    pub fn OH_ArkWeb_RegisterScrollCallback(
        webTag: *const ::std::os::raw::c_char,
        callback: ArkWeb_OnScrollCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[doc = " @error Normal."]
pub const ArkWeb_NetError_ARKWEB_NET_OK: ArkWeb_NetError = 0;
#[doc = " @error An asynchronous IO operation is not yet complete.  This usually does not\n        indicate a fatal error.  Typically this error will be generated as a\n        notification to wait for some external notification that the IO operation\n        finally completed."]
pub const ArkWeb_NetError_ARKWEB_ERR_IO_PENDING: ArkWeb_NetError = -1;
#[doc = " @error A generic failure occurred."]
pub const ArkWeb_NetError_ARKWEB_ERR_FAILED: ArkWeb_NetError = -2;
#[doc = " @error An operation was aborted."]
pub const ArkWeb_NetError_ARKWEB_ERR_ABORTED: ArkWeb_NetError = -3;
#[doc = " @error An argument to the function is incorrect."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_ARGUMENT: ArkWeb_NetError = -4;
#[doc = " @error The handle or file descriptor is invalid."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_HANDLE: ArkWeb_NetError = -5;
#[doc = " @error The file or directory cannot be found."]
pub const ArkWeb_NetError_ARKWEB_ERR_FILE_NOT_FOUND: ArkWeb_NetError = -6;
#[doc = " @error An operation timed out."]
pub const ArkWeb_NetError_ARKWEB_ERR_TIMED_OUT: ArkWeb_NetError = -7;
#[doc = " @error The file is too large."]
pub const ArkWeb_NetError_ARKWEB_ERR_FILE_TOO_LARGE: ArkWeb_NetError = -8;
#[doc = " @error An unexpected error.  This may be caused by a programming mistake or an\n        invalid assumption."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNEXPECTED: ArkWeb_NetError = -9;
#[doc = " @error Permission to access a resource, other than the network, was denied."]
pub const ArkWeb_NetError_ARKWEB_ERR_ACCESS_DENIED: ArkWeb_NetError = -10;
#[doc = " @error The operation failed because of unimplemented functionality."]
pub const ArkWeb_NetError_ARKWEB_ERR_NOT_IMPLEMENTED: ArkWeb_NetError = -11;
#[doc = " @error There were not enough resources to complete the operation."]
pub const ArkWeb_NetError_ARKWEB_ERR_INSUFFICIENT_RESOURCES: ArkWeb_NetError = -12;
#[doc = " @error Memory allocation failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_OUT_OF_MEMORY: ArkWeb_NetError = -13;
#[doc = " @error The file upload failed because the file's modification time was different\n        from the expectation."]
pub const ArkWeb_NetError_ARKWEB_ERR_UPLOAD_FILE_CHANGED: ArkWeb_NetError = -14;
#[doc = " @error The socket is not connected."]
pub const ArkWeb_NetError_ARKWEB_ERR_SOCKET_NOT_CONNECTED: ArkWeb_NetError = -15;
#[doc = " @error The file already exists."]
pub const ArkWeb_NetError_ARKWEB_ERR_FILE_EXISTS: ArkWeb_NetError = -16;
#[doc = " @error The path or file name is too long."]
pub const ArkWeb_NetError_ARKWEB_ERR_FILE_PATH_TOO_LONG: ArkWeb_NetError = -17;
#[doc = " @error Not enough room left on the disk."]
pub const ArkWeb_NetError_ARKWEB_ERR_FILE_NO_SPACE: ArkWeb_NetError = -18;
#[doc = " @error The file has a virus."]
pub const ArkWeb_NetError_ARKWEB_ERR_FILE_VIRUS_INFECTED: ArkWeb_NetError = -19;
#[doc = " @error The client chose to block the request."]
pub const ArkWeb_NetError_ARKWEB_ERR_BLOCKED_BY_CLIENT: ArkWeb_NetError = -20;
#[doc = " @error The network changed."]
pub const ArkWeb_NetError_ARKWEB_ERR_NETWORK_CHANGED: ArkWeb_NetError = -21;
#[doc = " @error The request was blocked by the URL block list configured by the domain\n        administrator."]
pub const ArkWeb_NetError_ARKWEB_ERR_BLOCKED_BY_ADMINISTRATOR: ArkWeb_NetError = -22;
#[doc = " @error The socket is already connected."]
pub const ArkWeb_NetError_ARKWEB_ERR_SOCKET_CONNECTED: ArkWeb_NetError = -23;
#[doc = " @error The upload failed because the upload stream needed to be re-read, due to a\n        retry or a redirect, but the upload stream doesn't support that operation."]
pub const ArkWeb_NetError_ARKWEB_ERR_UPLOAD_STREAM_REWIND_NOT_SUPPORTED: ArkWeb_NetError = -25;
#[doc = " @error The request failed because the URLRequestContext is shutting down, or has\n        been shut down."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONTEXT_SHUT_DOWN: ArkWeb_NetError = -26;
#[doc = " @error The request failed because the response was delivered along with requirements\n        which are not met ('X-Frame-Options' and 'Content-Security-Policy' ancestor\n        checks and 'Cross-Origin-Resource-Policy' for instance)."]
pub const ArkWeb_NetError_ARKWEB_ERR_BLOCKED_BY_RESPONSE: ArkWeb_NetError = -27;
#[doc = " @error The request was blocked by system policy disallowing some or all cleartext\n        requests."]
pub const ArkWeb_NetError_ARKWEB_ERR_CLEARTEXT_NOT_PERMITTED: ArkWeb_NetError = -29;
#[doc = " @error The request was blocked by a Content Security Policy."]
pub const ArkWeb_NetError_ARKWEB_ERR_BLOCKED_BY_CSP: ArkWeb_NetError = -30;
#[doc = " @error The request was blocked because of no H/2 or QUIC session."]
pub const ArkWeb_NetError_ARKWEB_ERR_H2_OR_QUIC_REQUIRED: ArkWeb_NetError = -31;
#[doc = " @error The request was blocked by CORB or ORB."]
pub const ArkWeb_NetError_ARKWEB_ERR_BLOCKED_BY_ORB: ArkWeb_NetError = -32;
#[doc = " @error A connection was closed (corresponding to a TCP FIN)."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONNECTION_CLOSED: ArkWeb_NetError = -100;
#[doc = " @error A connection was reset (corresponding to a TCP RST)."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONNECTION_RESET: ArkWeb_NetError = -101;
#[doc = " @error A connection attempt was refused."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONNECTION_REFUSED: ArkWeb_NetError = -102;
#[doc = " @error A connection timed out as a result of not receiving an ACK for data sent.\n        This can include a FIN packet that did not get ACK'd."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONNECTION_ABORTED: ArkWeb_NetError = -103;
#[doc = " @error A connection attempt failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONNECTION_FAILED: ArkWeb_NetError = -104;
#[doc = " @error The host name could not be resolved."]
pub const ArkWeb_NetError_ARKWEB_ERR_NAME_NOT_RESOLVED: ArkWeb_NetError = -105;
#[doc = " @error The Internet connection has been lost."]
pub const ArkWeb_NetError_ARKWEB_ERR_INTERNET_DISCONNECTED: ArkWeb_NetError = -106;
#[doc = " @error An SSL protocol error occurred."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_PROTOCOL_ERROR: ArkWeb_NetError = -107;
#[doc = " @error The IP address or port number is invalid (e.g., cannot connect to the IP\n        address 0 or the port 0)."]
pub const ArkWeb_NetError_ARKWEB_ERR_ADDRESS_INVALID: ArkWeb_NetError = -108;
#[doc = " @error The IP address is unreachable.  This usually means that there is no route to\n        the specified host or network."]
pub const ArkWeb_NetError_ARKWEB_ERR_ADDRESS_UNREACHABLE: ArkWeb_NetError = -109;
#[doc = " @error The server requested a client certificate for SSL client authentication."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_CLIENT_AUTH_CERT_NEEDED: ArkWeb_NetError = -110;
#[doc = " @error A tunnel connection through the proxy could not be established."]
pub const ArkWeb_NetError_ARKWEB_ERR_TUNNEL_CONNECTION_FAILED: ArkWeb_NetError = -111;
#[doc = " @error No SSL protocol versions are enabled."]
pub const ArkWeb_NetError_ARKWEB_ERR_NO_SSL_VERSIONS_ENABLED: ArkWeb_NetError = -112;
#[doc = " @error The client and server don't support a common SSL protocol version or\n        cipher suite."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_VERSION_OR_CIPHER_MISMATCH: ArkWeb_NetError = -113;
#[doc = " @error The server requested a renegotiation (rehandshake)."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_RENEGOTIATION_REQUESTED: ArkWeb_NetError = -114;
#[doc = " @error The proxy requested authentication (for tunnel establishment, with an\n        unsupported method."]
pub const ArkWeb_NetError_ARKWEB_ERR_PROXY_AUTH_UNSUPPORTED: ArkWeb_NetError = -115;
#[doc = " @error The SSL handshake failed because of a bad or missing client certificate."]
pub const ArkWeb_NetError_ARKWEB_ERR_BAD_SSL_CLIENT_AUTH_CERT: ArkWeb_NetError = -117;
#[doc = " @error A connection attempt timed out."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONNECTION_TIMED_OUT: ArkWeb_NetError = -118;
#[doc = " @error There are too many pending DNS resolves, so a request in the queue was\n        aborted."]
pub const ArkWeb_NetError_ARKWEB_ERR_HOST_RESOLVER_QUEUE_TOO_LARGE: ArkWeb_NetError = -119;
#[doc = " @error Failed establishing a connection to the SOCKS proxy server for a target host."]
pub const ArkWeb_NetError_ARKWEB_ERR_SOCKS_CONNECTION_FAILED: ArkWeb_NetError = -120;
#[doc = " @error The SOCKS proxy server failed establishing connection to the target host\n        because that host is unreachable."]
pub const ArkWeb_NetError_ARKWEB_ERR_SOCKS_CONNECTION_HOST_UNREACHABLE: ArkWeb_NetError = -121;
#[doc = " @error The request to negotiate an alternate protocol failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_ALPN_NEGOTIATION_FAILED: ArkWeb_NetError = -122;
#[doc = " @error The peer sent an SSL no_renegotiation alert message."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_NO_RENEGOTIATION: ArkWeb_NetError = -123;
#[doc = " @error Winsock sometimes reports more data written than passed.  This is probably\n        due to a broken LSP."]
pub const ArkWeb_NetError_ARKWEB_ERR_WINSOCK_UNEXPECTED_WRITTEN_BYTES: ArkWeb_NetError = -124;
#[doc = " @error An SSL peer sent us a fatal decompression_failure alert. This typically\n        occurs when a peer selects DEFLATE compression in the mistaken belief that\n        it supports it."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_DECOMPRESSION_FAILURE_ALERT: ArkWeb_NetError = -125;
#[doc = " @error An SSL peer sent us a fatal bad_record_mac alert. This has been observed\n        from servers with buggy DEFLATE support."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_BAD_RECORD_MAC_ALERT: ArkWeb_NetError = -126;
#[doc = " @error The proxy requested authentication (for tunnel establishment)."]
pub const ArkWeb_NetError_ARKWEB_ERR_PROXY_AUTH_REQUESTED: ArkWeb_NetError = -127;
#[doc = " @error Could not create a connection to the proxy server. An error occurred\n        either in resolving its name, or in connecting a socket to it.\n        Note that this does NOT include failures during the actual \"CONNECT\" method\n        of an HTTP proxy."]
pub const ArkWeb_NetError_ARKWEB_ERR_PROXY_CONNECTION_FAILED: ArkWeb_NetError = -130;
#[doc = " @error A mandatory proxy configuration could not be used. Currently this means\n        that a mandatory PAC script could not be fetched, parsed or executed."]
pub const ArkWeb_NetError_ARKWEB_ERR_MANDATORY_PROXY_CONFIGURATION_FAILED: ArkWeb_NetError = -131;
#[doc = " @error We've hit the max socket limit for the socket pool while preconnecting.  We\n        don't bother trying to preconnect more sockets."]
pub const ArkWeb_NetError_ARKWEB_ERR_PRECONNECT_MAX_SOCKET_LIMIT: ArkWeb_NetError = -133;
#[doc = " @error The permission to use the SSL client certificate's private key was denied."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_CLIENT_AUTH_PRIVATE_KEY_ACCESS_DENIED: ArkWeb_NetError =
    -134;
#[doc = " @error The SSL client certificate has no private key."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY: ArkWeb_NetError = -135;
#[doc = " @error The certificate presented by the HTTPS Proxy was invalid."]
pub const ArkWeb_NetError_ARKWEB_ERR_PROXY_CERTIFICATE_INVALID: ArkWeb_NetError = -136;
#[doc = " @error An error occurred when trying to do a name resolution (DNS)."]
pub const ArkWeb_NetError_ARKWEB_ERR_NAME_RESOLUTION_FAILED: ArkWeb_NetError = -137;
#[doc = " @error Permission to access the network was denied. This is used to distinguish\n        errors that were most likely caused by a firewall from other access denied\n        errors. See also ERR_ACCESS_DENIED."]
pub const ArkWeb_NetError_ARKWEB_ERR_NETWORK_ACCESS_DENIED: ArkWeb_NetError = -138;
#[doc = " @error The request throttler module cancelled this request to avoid DDOS."]
pub const ArkWeb_NetError_ARKWEB_ERR_TEMPORARILY_THROTTLED: ArkWeb_NetError = -139;
#[doc = " @error A request to create an SSL tunnel connection through the HTTPS proxy\n        received a 302 (temporary redirect, response.  The response body might\n        include a description of why the request failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTPS_PROXY_TUNNEL_RESPONSE_REDIRECT: ArkWeb_NetError = -140;
#[doc = " @error We were unable to sign the CertificateVerify data of an SSL client auth\n        handshake with the client certificate's private key.\n        Possible causes for this include the user implicitly or explicitly\n        denying access to the private key, the private key may not be valid for\n        signing, the key may be relying on a cached handle which is no longer\n        valid, or the CSP won't allow arbitrary data to be signed."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED: ArkWeb_NetError = -141;
#[doc = " @error The message was too large for the transport. (for example a UDP message\n        which exceeds size threshold)."]
pub const ArkWeb_NetError_ARKWEB_ERR_MSG_TOO_BIG: ArkWeb_NetError = -142;
#[doc = " @error Websocket protocol error. Indicates that we are terminating the connection\n        due to a malformed frame or other protocol violation."]
pub const ArkWeb_NetError_ARKWEB_ERR_WS_PROTOCOL_ERROR: ArkWeb_NetError = -145;
#[doc = " @error Returned when attempting to bind an address that is already in use."]
pub const ArkWeb_NetError_ARKWEB_ERR_ADDRESS_IN_USE: ArkWeb_NetError = -147;
#[doc = " @error An operation failed because the SSL handshake has not completed."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_HANDSHAKE_NOT_COMPLETED: ArkWeb_NetError = -148;
#[doc = " @error SSL peer's public key is invalid."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_BAD_PEER_PUBLIC_KEY: ArkWeb_NetError = -149;
#[doc = " @error The certificate didn't match the built-in public key pins for the host name.\n        The pins are set in net/http/transport_security_state.cc and require that\n        one of a set of public keys exist on the path from the leaf to the root."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN: ArkWeb_NetError = -150;
#[doc = " @error Server request for client certificate did not contain any types we support."]
pub const ArkWeb_NetError_ARKWEB_ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED: ArkWeb_NetError = -151;
#[doc = " @error An SSL peer sent us a fatal decrypt_error alert. This typically occurs when\n        a peer could not correctly verify a signature (in CertificateVerify or\n        ServerKeyExchange, or validate a Finished message."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_DECRYPT_ERROR_ALERT: ArkWeb_NetError = -153;
#[doc = " @error There are too many pending WebSocketJob instances, so the new job was not\n        pushed to the queue."]
pub const ArkWeb_NetError_ARKWEB_ERR_WS_THROTTLE_QUEUE_TOO_LARGE: ArkWeb_NetError = -154;
#[doc = " @error The SSL server certificate changed in a renegotiation."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_SERVER_CERT_CHANGED: ArkWeb_NetError = -156;
#[doc = " @error The SSL server sent us a fatal unrecognized_name alert."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_UNRECOGNIZED_NAME_ALERT: ArkWeb_NetError = -159;
#[doc = " @error Failed to set the socket's receive buffer size as requested."]
pub const ArkWeb_NetError_ARKWEB_ERR_SOCKET_SET_RECEIVE_BUFFER_SIZE_ERROR: ArkWeb_NetError = -160;
#[doc = " @error Failed to set the socket's send buffer size as requested."]
pub const ArkWeb_NetError_ARKWEB_ERR_SOCKET_SET_SEND_BUFFER_SIZE_ERROR: ArkWeb_NetError = -161;
#[doc = " @error Failed to set the socket's receive buffer size as requested, despite success\n        return code from setsockopt."]
pub const ArkWeb_NetError_ARKWEB_ERR_SOCKET_RECEIVE_BUFFER_SIZE_UNCHANGEABLE: ArkWeb_NetError =
    -162;
#[doc = " @error Failed to set the socket's send buffer size as requested, despite success\n        return code from setsockopt."]
pub const ArkWeb_NetError_ARKWEB_ERR_SOCKET_SEND_BUFFER_SIZE_UNCHANGEABLE: ArkWeb_NetError = -163;
#[doc = " @error Failed to import a client certificate from the platform store into the SSL\n        library."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT: ArkWeb_NetError = -164;
#[doc = " @error Resolving a hostname to an IP address list included the IPv4 address\n        \"127.0.53.53\". This is a special IP address which ICANN has recommended to\n        indicate there was a name collision, and alert admins to a potential\n        problem."]
pub const ArkWeb_NetError_ARKWEB_ERR_ICANN_NAME_COLLISION: ArkWeb_NetError = -166;
#[doc = " @error The SSL server presented a certificate which could not be decoded. This is\n        not a certificate error code as no X509Certificate object is available. This\n        error is fatal."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_SERVER_CERT_BAD_FORMAT: ArkWeb_NetError = -167;
#[doc = " @error Certificate Transparency: Received a signed tree head that failed to parse."]
pub const ArkWeb_NetError_ARKWEB_ERR_CT_STH_PARSING_FAILED: ArkWeb_NetError = -168;
#[doc = " @error Certificate Transparency: Received a signed tree head whose JSON parsing was\n        OK but was missing some of the fields."]
pub const ArkWeb_NetError_ARKWEB_ERR_CT_STH_INCOMPLETE: ArkWeb_NetError = -169;
#[doc = " @error The attempt to reuse a connection to send proxy auth credentials failed\n        before the AuthController was used to generate credentials. The caller should\n        reuse the controller with a new connection. This error is only used\n        internally by the network stack."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNABLE_TO_REUSE_CONNECTION_FOR_PROXY_AUTH: ArkWeb_NetError =
    -170;
#[doc = " @error Certificate Transparency: Failed to parse the received consistency proof."]
pub const ArkWeb_NetError_ARKWEB_ERR_CT_CONSISTENCY_PROOF_PARSING_FAILED: ArkWeb_NetError = -171;
#[doc = " @error The SSL server required an unsupported cipher suite that has since been\n        removed. This error will temporarily be signaled on a fallback for one or two\n        releases immediately following a cipher suite's removal, after which the\n        fallback will be removed."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_OBSOLETE_CIPHER: ArkWeb_NetError = -172;
#[doc = " @error When a WebSocket handshake is done successfully and the connection has been\n        upgraded, the URLRequest is cancelled with this error code."]
pub const ArkWeb_NetError_ARKWEB_ERR_WS_UPGRADE: ArkWeb_NetError = -173;
#[doc = " @error Socket ReadIfReady support is not implemented. This error should not be user\n        visible, because the normal Read(, method is used as a fallback."]
pub const ArkWeb_NetError_ARKWEB_ERR_READ_IF_READY_NOT_IMPLEMENTED: ArkWeb_NetError = -174;
#[doc = " @error No socket buffer space is available."]
pub const ArkWeb_NetError_ARKWEB_ERR_NO_BUFFER_SPACE: ArkWeb_NetError = -176;
#[doc = " @error There were no common signature algorithms between our client certificate\n        private key and the server's preferences."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_CLIENT_AUTH_NO_COMMON_ALGORITHMS: ArkWeb_NetError = -177;
#[doc = " @error TLS 1.3 early data was rejected by the server. This will be received before\n        any data is returned from the socket. The request should be retried with\n        early data disabled."]
pub const ArkWeb_NetError_ARKWEB_ERR_EARLY_DATA_REJECTED: ArkWeb_NetError = -178;
#[doc = " @error TLS 1.3 early data was offered, but the server responded with TLS 1.2 or\n        earlier. This is an internal error code to account for a\n        backwards-compatibility issue with early data and TLS 1.2. It will be\n        received before any data is returned from the socket. The request should be\n        retried with early data disabled.\n        See https://tools.ietf.org/html/rfc8446#appendix-D.3 for details."]
pub const ArkWeb_NetError_ARKWEB_ERR_WRONG_VERSION_ON_EARLY_DATA: ArkWeb_NetError = -179;
#[doc = " @error TLS 1.3 was enabled, but a lower version was negotiated and the server\n        returned a value indicating it supported TLS 1.3. This is part of a security\n        check in TLS 1.3, but it may also indicate the user is behind a buggy\n        TLS-terminating proxy which implemented TLS 1.2 incorrectly. (See\n        rhttps://crbug.com/boringssl/226.,"]
pub const ArkWeb_NetError_ARKWEB_ERR_TLS13_DOWNGRADE_DETECTED: ArkWeb_NetError = -180;
#[doc = " @error The server's certificate has a keyUsage extension incompatible with the\n        negotiated TLS key exchange method."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_KEY_USAGE_INCOMPATIBLE: ArkWeb_NetError = -181;
#[doc = " @error The ECHConfigList fetched over DNS cannot be parsed."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_ECH_CONFIG_LIST: ArkWeb_NetError = -182;
#[doc = " @error ECH was enabled, but the server was unable to decrypt the encrypted\n        ClientHello."]
pub const ArkWeb_NetError_ARKWEB_ERR_ECH_NOT_NEGOTIATED: ArkWeb_NetError = -183;
#[doc = " @error ECH was enabled, the server was unable to decrypt the encrypted ClientHello,\n        and additionally did not present a certificate valid for the public name."]
pub const ArkWeb_NetError_ARKWEB_ERR_ECH_FALLBACK_CERTIFICATE_INVALID: ArkWeb_NetError = -184;
#[doc = " @error The server responded with a certificate whose common name did not match\n        the host name.  This could mean:\n        1. An attacker has redirected our traffic to their server and is\n           presenting a certificate for which they know the private key.\n        2. The server is misconfigured and responding with the wrong cert.\n        3. The user is on a wireless network and is being redirected to the\n           network's login page.\n        4. The OS has used a DNS search suffix and the server doesn't have\n           a certificate for the abbreviated name in the address bar."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_COMMON_NAME_INVALID: ArkWeb_NetError = -200;
#[doc = " @error The server responded with a certificate that, by our clock, appears to\n        either not yet be valid or to have expired.  This could mean:\n        1. An attacker is presenting an old certificate for which they have\n           managed to obtain the private key.\n        2. The server is misconfigured and is not presenting a valid cert.\n        3. Our clock is wrong."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_DATE_INVALID: ArkWeb_NetError = -201;
#[doc = " @error The server responded with a certificate that is signed by an authority\n        we don't trust.  The could mean:\n        1. An attacker has substituted the real certificate for a cert that\n           contains their public key and is signed by their cousin.\n        2. The server operator has a legitimate certificate from a CA we don't\n           know about, but should trust.\n        3. The server is presenting a self-signed certificate, providing no\n           defense against active attackers (but foiling passive attackers)."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_AUTHORITY_INVALID: ArkWeb_NetError = -202;
#[doc = " @error The server responded with a certificate that contains errors.\n        This error is not recoverable.\n        MSDN describes this error as follows:\n           \"The SSL certificate contains errors.\"\n        NOTE: It's unclear how this differs from ERR_CERT_INVALID. For consistency,\n        use that code instead of this one from now on."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_CONTAINS_ERRORS: ArkWeb_NetError = -203;
#[doc = " @error The certificate has no mechanism for determining if it is revoked.  In\n        effect, this certificate cannot be revoked."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_NO_REVOCATION_MECHANISM: ArkWeb_NetError = -204;
#[doc = " @error Revocation information for the security certificate for this site is not\n        available.  This could mean:\n        1. An attacker has compromised the private key in the certificate and is\n           blocking our attempt to find out that the cert was revoked.\n        2. The certificate is unrevoked, but the revocation server is busy or\n           unavailable."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_UNABLE_TO_CHECK_REVOCATION: ArkWeb_NetError = -205;
#[doc = " @error The server responded with a certificate has been revoked.\n        We have the capability to ignore this error, but it is probably not the\n        thing to do."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_REVOKED: ArkWeb_NetError = -206;
#[doc = " @error The server responded with a certificate that is invalid.\n        This error is not recoverable.\n        MSDN describes this error as follows:\n           \"The SSL certificate is invalid.\""]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_INVALID: ArkWeb_NetError = -207;
#[doc = " @error The server responded with a certificate that is signed using a weak\n        signature algorithm."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_WEAK_SIGNATURE_ALGORITHM: ArkWeb_NetError = -208;
#[doc = " @error The host name specified in the certificate is not unique."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_NON_UNIQUE_NAME: ArkWeb_NetError = -210;
#[doc = " @error The server responded with a certificate that contains a weak key (e.g.\n        a too-small RSA key)."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_WEAK_KEY: ArkWeb_NetError = -211;
#[doc = " @error The certificate claimed DNS names that are in violation of name constraints."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_NAME_CONSTRAINT_VIOLATION: ArkWeb_NetError = -212;
#[doc = " @error The certificate's validity period is too long."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_VALIDITY_TOO_LONG: ArkWeb_NetError = -213;
#[doc = " @error Certificate Transparency was required for this connection, but the server\n        did not provide CT information that complied with the policy."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERTIFICATE_TRANSPARENCY_REQUIRED: ArkWeb_NetError = -214;
#[doc = " @error The certificate chained to a legacy Symantec root that is no longer trusted."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_SYMANTEC_LEGACY: ArkWeb_NetError = -215;
#[doc = " @error The certificate is known to be used for interception by an entity other\n        the device owner."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_KNOWN_INTERCEPTION_BLOCKED: ArkWeb_NetError = -217;
#[doc = " @error The connection uses an obsolete version of SSL/TLS or cipher."]
pub const ArkWeb_NetError_ARKWEB_ERR_SSL_OBSOLETE_VERSION_OR_CIPHER: ArkWeb_NetError = -218;
#[doc = " @error The value immediately past the last certificate error code."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_END: ArkWeb_NetError = -219;
#[doc = " @error The URL is invalid."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_URL: ArkWeb_NetError = -300;
#[doc = " @error The scheme of the URL is disallowed."]
pub const ArkWeb_NetError_ARKWEB_ERR_DISALLOWED_URL_SCHEME: ArkWeb_NetError = -301;
#[doc = " @error The scheme of the URL is unknown."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNKNOWN_URL_SCHEME: ArkWeb_NetError = -302;
#[doc = " @error Attempting to load an URL resulted in a redirect to an invalid URL."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_REDIRECT: ArkWeb_NetError = -303;
#[doc = " @error Attempting to load an URL resulted in too many redirects."]
pub const ArkWeb_NetError_ARKWEB_ERR_TOO_MANY_REDIRECTS: ArkWeb_NetError = -310;
#[doc = " @error Attempting to load an URL resulted in an unsafe redirect (e.g., a redirect\n        to file:// is considered unsafe)."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNSAFE_REDIRECT: ArkWeb_NetError = -311;
#[doc = " @error Attempting to load an URL with an unsafe port number."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNSAFE_PORT: ArkWeb_NetError = -312;
#[doc = " @error The server's response was invalid."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_RESPONSE: ArkWeb_NetError = -320;
#[doc = " @error Error in chunked transfer encoding."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_CHUNKED_ENCODING: ArkWeb_NetError = -321;
#[doc = " @error The server did not support the request method."]
pub const ArkWeb_NetError_ARKWEB_ERR_METHOD_UNSUPPORTED: ArkWeb_NetError = -322;
#[doc = " @error The response was 407 (Proxy Authentication Required,, yet we did not send\n        the request to a proxy."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNEXPECTED_PROXY_AUTH: ArkWeb_NetError = -323;
#[doc = " @error The server closed the connection without sending any data."]
pub const ArkWeb_NetError_ARKWEB_ERR_EMPTY_RESPONSE: ArkWeb_NetError = -324;
#[doc = " @error The headers section of the response is too large."]
pub const ArkWeb_NetError_ARKWEB_ERR_RESPONSE_HEADERS_TOO_BIG: ArkWeb_NetError = -325;
#[doc = " @error The evaluation of the PAC script failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_PAC_SCRIPT_FAILED: ArkWeb_NetError = -327;
#[doc = " @error The response was 416 (Requested range not satisfiable, and the server cannot\n        satisfy the range requested."]
pub const ArkWeb_NetError_ARKWEB_ERR_REQUEST_RANGE_NOT_SATISFIABLE: ArkWeb_NetError = -328;
#[doc = " @error The identity used for authentication is invalid."]
pub const ArkWeb_NetError_ARKWEB_ERR_MALFORMED_IDENTITY: ArkWeb_NetError = -329;
#[doc = " @error Content decoding of the response body failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONTENT_DECODING_FAILED: ArkWeb_NetError = -330;
#[doc = " @error An operation could not be completed because all network IO\n        is suspended."]
pub const ArkWeb_NetError_ARKWEB_ERR_NETWORK_IO_SUSPENDED: ArkWeb_NetError = -331;
#[doc = " @error FLIP data received without receiving a SYN_REPLY on the stream."]
pub const ArkWeb_NetError_ARKWEB_ERR_SYN_REPLY_NOT_RECEIVED: ArkWeb_NetError = -332;
#[doc = " @error Converting the response to target encoding failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_ENCODING_CONVERSION_FAILED: ArkWeb_NetError = -333;
#[doc = " @error The server sent an FTP directory listing in a format we do not understand."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNRECOGNIZED_FTP_DIRECTORY_LISTING_FORMAT: ArkWeb_NetError =
    -334;
#[doc = " @error There are no supported proxies in the provided list."]
pub const ArkWeb_NetError_ARKWEB_ERR_NO_SUPPORTED_PROXIES: ArkWeb_NetError = -336;
#[doc = " @error There is an HTTP/2 protocol error."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_PROTOCOL_ERROR: ArkWeb_NetError = -337;
#[doc = " @error Credentials could not be established during HTTP Authentication."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_AUTH_CREDENTIALS: ArkWeb_NetError = -338;
#[doc = " @error An HTTP Authentication scheme was tried which is not supported on this\n        machine."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNSUPPORTED_AUTH_SCHEME: ArkWeb_NetError = -339;
#[doc = " @error Detecting the encoding of the response failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_ENCODING_DETECTION_FAILED: ArkWeb_NetError = -340;
#[doc = " @error (GSSAPI, No Kerberos credentials were available during HTTP Authentication."]
pub const ArkWeb_NetError_ARKWEB_ERR_MISSING_AUTH_CREDENTIALS: ArkWeb_NetError = -341;
#[doc = " @error An unexpected, but documented, SSPI or GSSAPI status code was returned."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNEXPECTED_SECURITY_LIBRARY_STATUS: ArkWeb_NetError = -342;
#[doc = " @error The environment was not set up correctly for authentication (for\n        example, no KDC could be found or the principal is unknown."]
pub const ArkWeb_NetError_ARKWEB_ERR_MISCONFIGURED_AUTH_ENVIRONMENT: ArkWeb_NetError = -343;
#[doc = " @error An undocumented SSPI or GSSAPI status code was returned."]
pub const ArkWeb_NetError_ARKWEB_ERR_UNDOCUMENTED_SECURITY_LIBRARY_STATUS: ArkWeb_NetError = -344;
#[doc = " @error The HTTP response was too big to drain."]
pub const ArkWeb_NetError_ARKWEB_ERR_RESPONSE_BODY_TOO_BIG_TO_DRAIN: ArkWeb_NetError = -345;
#[doc = " @error The HTTP response contained multiple distinct Content-Length headers."]
pub const ArkWeb_NetError_ARKWEB_ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH: ArkWeb_NetError =
    -346;
#[doc = " @error HTTP/2 headers have been received, but not all of them - status or version\n        headers are missing, so we're expecting additional frames to complete them."]
pub const ArkWeb_NetError_ARKWEB_ERR_INCOMPLETE_HTTP2_HEADERS: ArkWeb_NetError = -347;
#[doc = " @error No PAC URL configuration could be retrieved from DHCP. This can indicate\n        either a failure to retrieve the DHCP configuration, or that there was no\n        PAC URL configured in DHCP."]
pub const ArkWeb_NetError_ARKWEB_ERR_PAC_NOT_IN_DHCP: ArkWeb_NetError = -348;
#[doc = " @error The HTTP response contained multiple Content-Disposition headers."]
pub const ArkWeb_NetError_ARKWEB_ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_DISPOSITION:
    ArkWeb_NetError = -349;
#[doc = " @error The HTTP response contained multiple Location headers."]
pub const ArkWeb_NetError_ARKWEB_ERR_RESPONSE_HEADERS_MULTIPLE_LOCATION: ArkWeb_NetError = -350;
#[doc = " @error HTTP/2 server refused the request without processing, and sent either a\n        GOAWAY frame with error code NO_ERROR and Last-Stream-ID lower than the\n        stream id corresponding to the request indicating that this request has not\n        been processed yet, or a RST_STREAM frame with error code REFUSED_STREAM.\n        Client MAY retry (on a different connection).  See RFC7540 Section 8.1.4."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_SERVER_REFUSED_STREAM: ArkWeb_NetError = -351;
#[doc = " @error HTTP/2 server didn't respond to the PING message."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_PING_FAILED: ArkWeb_NetError = -352;
#[doc = " @error The HTTP response body transferred fewer bytes than were advertised by the\n        Content-Length header when the connection is closed."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONTENT_LENGTH_MISMATCH: ArkWeb_NetError = -354;
#[doc = " @error The HTTP response body is transferred with Chunked-Encoding, but the\n        terminating zero-length chunk was never sent when the connection is closed."]
pub const ArkWeb_NetError_ARKWEB_ERR_INCOMPLETE_CHUNKED_ENCODING: ArkWeb_NetError = -355;
#[doc = " @error There is a QUIC protocol error."]
pub const ArkWeb_NetError_ARKWEB_ERR_QUIC_PROTOCOL_ERROR: ArkWeb_NetError = -356;
#[doc = " @error The HTTP headers were truncated by an EOF."]
pub const ArkWeb_NetError_ARKWEB_ERR_RESPONSE_HEADERS_TRUNCATED: ArkWeb_NetError = -357;
#[doc = " @error The QUIC crypto handshake failed.  This means that the server was unable\n        to read any requests sent, so they may be resent."]
pub const ArkWeb_NetError_ARKWEB_ERR_QUIC_HANDSHAKE_FAILED: ArkWeb_NetError = -358;
#[doc = " @error Transport security is inadequate for the HTTP/2 version."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_INADEQUATE_TRANSPORT_SECURITY: ArkWeb_NetError = -360;
#[doc = " @error The peer violated HTTP/2 flow control."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_FLOW_CONTROL_ERROR: ArkWeb_NetError = -361;
#[doc = " @error The peer sent an improperly sized HTTP/2 frame."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_FRAME_SIZE_ERROR: ArkWeb_NetError = -362;
#[doc = " @error Decoding or encoding of compressed HTTP/2 headers failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_COMPRESSION_ERROR: ArkWeb_NetError = -363;
#[doc = " @error Proxy Auth Requested without a valid Client Socket Handle."]
pub const ArkWeb_NetError_ARKWEB_ERR_PROXY_AUTH_REQUESTED_WITH_NO_CONNECTION: ArkWeb_NetError =
    -364;
#[doc = " @error HTTP_1_1_REQUIRED error code received on HTTP/2 session."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP_1_1_REQUIRED: ArkWeb_NetError = -365;
#[doc = " @error HTTP_1_1_REQUIRED error code received on HTTP/2 session to proxy."]
pub const ArkWeb_NetError_ARKWEB_ERR_PROXY_HTTP_1_1_REQUIRED: ArkWeb_NetError = -366;
#[doc = " @error The PAC script terminated fatally and must be reloaded."]
pub const ArkWeb_NetError_ARKWEB_ERR_PAC_SCRIPT_TERMINATED: ArkWeb_NetError = -367;
#[doc = " @error The server was expected to return an HTTP/1.x response, but did not. Rather\n        than treat it as HTTP/0.9, this error is returned."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_HTTP_RESPONSE: ArkWeb_NetError = -370;
#[doc = " @error Initializing content decoding failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_CONTENT_DECODING_INIT_FAILED: ArkWeb_NetError = -371;
#[doc = " @error Received HTTP/2 RST_STREAM frame with NO_ERROR error code.  This error should\n        be handled internally by HTTP/2 code, and should not make it above the\n        SpdyStream layer."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_RST_STREAM_NO_ERROR_RECEIVED: ArkWeb_NetError = -372;
#[doc = " @error The pushed stream claimed by the request is no longer available."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_PUSHED_STREAM_NOT_AVAILABLE: ArkWeb_NetError = -373;
#[doc = " @error A pushed stream was claimed and later reset by the server. When this happens,\n        the request should be retried."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_CLAIMED_PUSHED_STREAM_RESET_BY_SERVER: ArkWeb_NetError =
    -374;
#[doc = " @error An HTTP transaction was retried too many times due for authentication or\n        invalid certificates."]
pub const ArkWeb_NetError_ARKWEB_ERR_TOO_MANY_RETRIES: ArkWeb_NetError = -375;
#[doc = " @error Received an HTTP/2 frame on a closed stream."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_STREAM_CLOSED: ArkWeb_NetError = -376;
#[doc = " @error Client is refusing an HTTP/2 stream."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_CLIENT_REFUSED_STREAM: ArkWeb_NetError = -377;
#[doc = " @error A pushed HTTP/2 stream was claimed by a request based on matching URL and\n        request headers, but the pushed response headers do not match the request."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP2_PUSHED_RESPONSE_DOES_NOT_MATCH: ArkWeb_NetError = -378;
#[doc = " @error The server returned a non-2xx HTTP response code."]
pub const ArkWeb_NetError_ARKWEB_ERR_HTTP_RESPONSE_CODE_FAILURE: ArkWeb_NetError = -379;
#[doc = " @error The certificate presented on a QUIC connection does not chain to a known root\n        and the origin connected to is not on a list of domains where unknown roots\n        are allowed."]
pub const ArkWeb_NetError_ARKWEB_ERR_QUIC_UNKNOWN_CERT_ROOT: ArkWeb_NetError = -380;
#[doc = " @error A GOAWAY frame has been received indicating that the request has not been\n        processed and is therefore safe to retry on a different connection."]
pub const ArkWeb_NetError_ARKWEB_ERR_QUIC_GOAWAY_REQUEST_CAN_BE_RETRIED: ArkWeb_NetError = -381;
#[doc = " @error The ACCEPT_CH restart has been triggered too many times."]
pub const ArkWeb_NetError_ARKWEB_ERR_TOO_MANY_ACCEPT_CH_RESTARTS: ArkWeb_NetError = -382;
#[doc = " @error The IP address space of the remote endpoint differed from the previous\n        observed value during the same request. Any cache entry for the affected\n        request should be invalidated."]
pub const ArkWeb_NetError_ARKWEB_ERR_INCONSISTENT_IP_ADDRESS_SPACE: ArkWeb_NetError = -383;
#[doc = " @error The IP address space of the cached remote endpoint is blocked by local\n        network access check."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHED_IP_ADDRESS_SPACE_BLOCKED_BY_LOCAL_NETWORK_ACCESS_POLICY : ArkWeb_NetError = - 384 ;
#[doc = " @error The cache does not have the requested entry."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_MISS: ArkWeb_NetError = -400;
#[doc = " @error Unable to read from the disk cache."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_READ_FAILURE: ArkWeb_NetError = -401;
#[doc = " @error Unable to write to the disk cache."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_WRITE_FAILURE: ArkWeb_NetError = -402;
#[doc = " @error The operation is not supported for this entry."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_OPERATION_UNSUPPORTED: ArkWeb_NetError = -403;
#[doc = " @error The disk cache is unable to open this entry."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_OPEN_FAILURE: ArkWeb_NetError = -404;
#[doc = " @error The disk cache is unable to create this entry."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_CREATE_FAILURE: ArkWeb_NetError = -405;
#[doc = " @error Multiple transactions are racing to create disk cache entries."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_RACE: ArkWeb_NetError = -406;
#[doc = " @error The cache was unable to read a checksum record on an entry."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_CHECKSUM_READ_FAILURE: ArkWeb_NetError = -407;
#[doc = " @error The cache found an entry with an invalid checksum."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_CHECKSUM_MISMATCH: ArkWeb_NetError = -408;
#[doc = " @error Internal error code for the HTTP cache."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_LOCK_TIMEOUT: ArkWeb_NetError = -409;
#[doc = " @error Received a challenge after the transaction has read some data, and the\n        credentials aren't available."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_AUTH_FAILURE_AFTER_READ: ArkWeb_NetError = -410;
#[doc = " @error Internal not-quite error code for the HTTP cache."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_ENTRY_NOT_SUITABLE: ArkWeb_NetError = -411;
#[doc = " @error The disk cache is unable to doom this entry."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_DOOM_FAILURE: ArkWeb_NetError = -412;
#[doc = " @error The disk cache is unable to open or create this entry."]
pub const ArkWeb_NetError_ARKWEB_ERR_CACHE_OPEN_OR_CREATE_FAILURE: ArkWeb_NetError = -413;
#[doc = " @error The server's response was insecure (e.g. there was a cert error)."]
pub const ArkWeb_NetError_ARKWEB_ERR_INSECURE_RESPONSE: ArkWeb_NetError = -501;
#[doc = " @error An attempt to import a client certificate failed, as the user's key\n        database lacked a corresponding private key."]
pub const ArkWeb_NetError_ARKWEB_ERR_NO_PRIVATE_KEY_FOR_CERT: ArkWeb_NetError = -502;
#[doc = " @error An error adding a certificate to the OS certificate database."]
pub const ArkWeb_NetError_ARKWEB_ERR_ADD_USER_CERT_FAILED: ArkWeb_NetError = -503;
#[doc = " @error An error occurred while handling a signed exchange."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_SIGNED_EXCHANGE: ArkWeb_NetError = -504;
#[doc = " @error An error occurred while handling a Web Bundle source."]
pub const ArkWeb_NetError_ARKWEB_ERR_INVALID_WEB_BUNDLE: ArkWeb_NetError = -505;
#[doc = " @error A Trust Tokens protocol operation-executing request failed for one of a\n        number of reasons (precondition failure, internal error, bad response)."]
pub const ArkWeb_NetError_ARKWEB_ERR_TRUST_TOKEN_OPERATION_FAILED: ArkWeb_NetError = -506;
#[doc = " @error When handling a Trust Tokens protocol operation-executing request, the system\n        was able to execute the request's Trust Tokens operation without sending the\n        request to its destination."]
pub const ArkWeb_NetError_ARKWEB_ERR_TRUST_TOKEN_OPERATION_SUCCESS_WITHOUT_SENDING_REQUEST:
    ArkWeb_NetError = -507;
#[doc = " @error A generic error for failed FTP control connection command.\n        If possible, please use or add a more specific error code."]
pub const ArkWeb_NetError_ARKWEB_ERR_FTP_FAILED: ArkWeb_NetError = -601;
#[doc = " @error The server cannot fulfill the request at this point. This is a temporary error.\n        FTP response code 421."]
pub const ArkWeb_NetError_ARKWEB_ERR_FTP_SERVICE_UNAVAILABLE: ArkWeb_NetError = -602;
#[doc = " @error The server has aborted the transfer.\n        FTP response code 426."]
pub const ArkWeb_NetError_ARKWEB_ERR_FTP_TRANSFER_ABORTED: ArkWeb_NetError = -603;
#[doc = " @error The file is busy, or some other temporary error condition on opening the file.\n        FTP response code 450."]
pub const ArkWeb_NetError_ARKWEB_ERR_FTP_FILE_BUSY: ArkWeb_NetError = -604;
#[doc = " @error Server rejected our command because of syntax errors.\n        FTP response codes 500, 501."]
pub const ArkWeb_NetError_ARKWEB_ERR_FTP_SYNTAX_ERROR: ArkWeb_NetError = -605;
#[doc = " @error Server does not support the command we issued.\n        FTP response codes 502, 504."]
pub const ArkWeb_NetError_ARKWEB_ERR_FTP_COMMAND_UNSUPPORTED: ArkWeb_NetError = -606;
#[doc = " @error Server rejected our command because we didn't issue the commands in right order.\n        FTP response code 503."]
pub const ArkWeb_NetError_ARKWEB_ERR_FTP_BAD_COMMAND_SEQUENCE: ArkWeb_NetError = -607;
#[doc = " @error PKCS #12 import failed due to incorrect password."]
pub const ArkWeb_NetError_ARKWEB_ERR_PKCS12_IMPORT_BAD_PASSWORD: ArkWeb_NetError = -701;
#[doc = " @error PKCS #12 import failed due to other error."]
pub const ArkWeb_NetError_ARKWEB_ERR_PKCS12_IMPORT_FAILED: ArkWeb_NetError = -702;
#[doc = " @error CA import failed - not a CA cert."]
pub const ArkWeb_NetError_ARKWEB_ERR_IMPORT_CA_CERT_NOT_CA: ArkWeb_NetError = -703;
#[doc = " @error Import failed - certificate already exists in database."]
pub const ArkWeb_NetError_ARKWEB_ERR_IMPORT_CERT_ALREADY_EXISTS: ArkWeb_NetError = -704;
#[doc = " @error CA import failed due to some other error."]
pub const ArkWeb_NetError_ARKWEB_ERR_IMPORT_CA_CERT_FAILED: ArkWeb_NetError = -705;
#[doc = " @error Server certificate import failed due to some internal error."]
pub const ArkWeb_NetError_ARKWEB_ERR_IMPORT_SERVER_CERT_FAILED: ArkWeb_NetError = -706;
#[doc = " @error PKCS #12 import failed due to invalid MAC."]
pub const ArkWeb_NetError_ARKWEB_ERR_PKCS12_IMPORT_INVALID_MAC: ArkWeb_NetError = -707;
#[doc = " @error PKCS #12 import failed due to invalid/corrupt file."]
pub const ArkWeb_NetError_ARKWEB_ERR_PKCS12_IMPORT_INVALID_FILE: ArkWeb_NetError = -708;
#[doc = " @error PKCS #12 import failed due to unsupported features."]
pub const ArkWeb_NetError_ARKWEB_ERR_PKCS12_IMPORT_UNSUPPORTED: ArkWeb_NetError = -709;
#[doc = " @error Key generation failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_KEY_GENERATION_FAILED: ArkWeb_NetError = -710;
#[doc = " @error Failure to export private key."]
pub const ArkWeb_NetError_ARKWEB_ERR_PRIVATE_KEY_EXPORT_FAILED: ArkWeb_NetError = -712;
#[doc = " @error Self-signed certificate generation failed."]
pub const ArkWeb_NetError_ARKWEB_ERR_SELF_SIGNED_CERT_GENERATION_FAILED: ArkWeb_NetError = -713;
#[doc = " @error The certificate database changed in some way."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_DATABASE_CHANGED: ArkWeb_NetError = -714;
#[doc = " @error The certificate verifier configuration changed in some way."]
pub const ArkWeb_NetError_ARKWEB_ERR_CERT_VERIFIER_CHANGED: ArkWeb_NetError = -716;
#[doc = " @error DNS resolver received a malformed response."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_MALFORMED_RESPONSE: ArkWeb_NetError = -800;
#[doc = " @error DNS server requires TCP."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_SERVER_REQUIRES_TCP: ArkWeb_NetError = -801;
#[doc = " @error DNS server failed.  This error is returned for all of the following\n        error conditions:\n        1 - Format error - The name server was unable to interpret the query.\n        2 - Server failure - The name server was unable to process this query\n            due to a problem with the name server.\n        4 - Not Implemented - The name server does not support the requested\n            kind of query.\n        5 - Refused - The name server refuses to perform the specified\n            operation for policy reasons."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_SERVER_FAILED: ArkWeb_NetError = -802;
#[doc = " @error DNS transaction timed out."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_TIMED_OUT: ArkWeb_NetError = -803;
#[doc = " @error The entry was not found in cache or other local sources, for lookups where\n        only local sources were queried."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_CACHE_MISS: ArkWeb_NetError = -804;
#[doc = " @error Suffix search list rules prevent resolution of the given host name."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_SEARCH_EMPTY: ArkWeb_NetError = -805;
#[doc = " @error Failed to sort addresses according to RFC3484."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_SORT_ERROR: ArkWeb_NetError = -806;
#[doc = " @error Failed to resolve the hostname of a DNS-over-HTTPS server."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_SECURE_RESOLVER_HOSTNAME_RESOLUTION_FAILED:
    ArkWeb_NetError = -808;
#[doc = " @error DNS identified the request as disallowed for insecure connection (http/ws).\n        Error should be handled as if an HTTP redirect was received to redirect to\n        https or wss."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_NAME_HTTPS_ONLY: ArkWeb_NetError = -809;
#[doc = " @error All DNS requests associated with this job have been cancelled."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_REQUEST_CANCELED: ArkWeb_NetError = -810;
#[doc = " @error The hostname resolution of HTTPS record was expected to be resolved with\n        alpn values of supported protocols, but did not."]
pub const ArkWeb_NetError_ARKWEB_ERR_DNS_NO_MATCHING_SUPPORTED_ALPN: ArkWeb_NetError = -811;
pub type ArkWeb_NetError = ::std::os::raw::c_int;
pub const ArkWeb_CustomSchemeOption_OH_ARKWEB_SCHEME_OPTION_NONE: ArkWeb_CustomSchemeOption = 0;
#[doc = " If ARKWEB_SCHEME_OPTION_STANDARD is set, the scheme will be handled as a standard scheme. The standard\n  schemes need to comply with the URL normalization and parsing rules defined in Section 3.1 of RFC 1738,\n  which can be found in the http://www.ietf.org/rfc/rfc1738.txt."]
pub const ArkWeb_CustomSchemeOption_ARKWEB_SCHEME_OPTION_STANDARD: ArkWeb_CustomSchemeOption = 1;
#[doc = " If ARKWEB_SCHEME_OPTION_LOCAL is set, the same security rules as those applied to the \"file\" URL will be\n  used to handle the scheme."]
pub const ArkWeb_CustomSchemeOption_ARKWEB_SCHEME_OPTION_LOCAL: ArkWeb_CustomSchemeOption = 2;
#[doc = " If ARKWEB_SCHEME_OPTION_DISPLAY_ISOLATED is set, then the scheme can only be displayed from other content\n  hosted using the same scheme."]
pub const ArkWeb_CustomSchemeOption_ARKWEB_SCHEME_OPTION_DISPLAY_ISOLATED:
    ArkWeb_CustomSchemeOption = 4;
#[doc = " If ARKWEB_SCHEME_OPTION_SECURE is set, the same security rules as those applied to the \"https\" URL will be\n  used to handle the scheme."]
pub const ArkWeb_CustomSchemeOption_ARKWEB_SCHEME_OPTION_SECURE: ArkWeb_CustomSchemeOption = 8;
#[doc = " If ARKWEB_SCHEME_OPTION_CORS_ENABLED is set, then the scheme can be sent CORS requests. In most cases this\n  value should be set when ARKWEB_SCHEME_OPTION_STANDARD is set."]
pub const ArkWeb_CustomSchemeOption_ARKWEB_SCHEME_OPTION_CORS_ENABLED: ArkWeb_CustomSchemeOption =
    16;
#[doc = " If ARKWEB_SCHEME_OPTION_CSP_BYPASSING is set, then this scheme can bypass Content Security Policy (CSP)\n  checks. In most cases, this value should not be set when ARKWEB_SCHEME_OPTION_STANDARD is set."]
pub const ArkWeb_CustomSchemeOption_ARKWEB_SCHEME_OPTION_CSP_BYPASSING: ArkWeb_CustomSchemeOption =
    32;
#[doc = " If ARKWEB_SCHEME_OPTION_FETCH_ENABLED is set, then this scheme can perform FETCH API requests."]
pub const ArkWeb_CustomSchemeOption_ARKWEB_SCHEME_OPTION_FETCH_ENABLED: ArkWeb_CustomSchemeOption =
    64;
#[doc = " If ARKWEB_SCHEME_OPTION_CODE_CACHE_ENABLED is set, then the js of this scheme can generate code cache."]
pub const ArkWeb_CustomSchemeOption_ARKWEB_SCHEME_OPTION_CODE_CACHE_ENABLED:
    ArkWeb_CustomSchemeOption = 128;
#[doc = " @brief Configuration information for custom schemes.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_CustomSchemeOption = ::std::os::raw::c_uint;
#[doc = " Top level page."]
pub const ArkWeb_ResourceType_MAIN_FRAME: ArkWeb_ResourceType = 0;
#[doc = " Frame or Iframe."]
pub const ArkWeb_ResourceType_SUB_FRAME: ArkWeb_ResourceType = 1;
#[doc = " CSS stylesheet."]
pub const ArkWeb_ResourceType_STYLE_SHEET: ArkWeb_ResourceType = 2;
#[doc = " External script."]
pub const ArkWeb_ResourceType_SCRIPT: ArkWeb_ResourceType = 3;
#[doc = " Image(jpg/gif/png/etc)."]
pub const ArkWeb_ResourceType_IMAGE: ArkWeb_ResourceType = 4;
#[doc = " Font."]
pub const ArkWeb_ResourceType_FONT_RESOURCE: ArkWeb_ResourceType = 5;
#[doc = " Some other subresource. This is the default type if the actual type is unknown."]
pub const ArkWeb_ResourceType_SUB_RESOURCE: ArkWeb_ResourceType = 6;
#[doc = " Object (or embed) tag for a plugin, or a resource that a plugin requested."]
pub const ArkWeb_ResourceType_OBJECT: ArkWeb_ResourceType = 7;
#[doc = " Media resource."]
pub const ArkWeb_ResourceType_MEDIA: ArkWeb_ResourceType = 8;
#[doc = " Main resource of a dedicated worker."]
pub const ArkWeb_ResourceType_WORKER: ArkWeb_ResourceType = 9;
#[doc = " Main resource of a shared worker."]
pub const ArkWeb_ResourceType_SHARED_WORKER: ArkWeb_ResourceType = 10;
#[doc = " Explicitly requested prefetch."]
pub const ArkWeb_ResourceType_PREFETCH: ArkWeb_ResourceType = 11;
#[doc = " Favicon."]
pub const ArkWeb_ResourceType_FAVICON: ArkWeb_ResourceType = 12;
#[doc = " XMLHttpRequest."]
pub const ArkWeb_ResourceType_XHR: ArkWeb_ResourceType = 13;
#[doc = " Ping request for <a ping>/sendBeacon."]
pub const ArkWeb_ResourceType_PING: ArkWeb_ResourceType = 14;
#[doc = " The main resource of a service worker."]
pub const ArkWeb_ResourceType_SERVICE_WORKER: ArkWeb_ResourceType = 15;
#[doc = " Report of Content Security Policy violations."]
pub const ArkWeb_ResourceType_CSP_REPORT: ArkWeb_ResourceType = 16;
#[doc = " Resource that a plugin requested."]
pub const ArkWeb_ResourceType_PLUGIN_RESOURCE: ArkWeb_ResourceType = 17;
#[doc = " A main-frame service worker navigation preload request."]
pub const ArkWeb_ResourceType_NAVIGATION_PRELOAD_MAIN_FRAME: ArkWeb_ResourceType = 19;
#[doc = " A sub-frame service worker navigation preload request."]
pub const ArkWeb_ResourceType_NAVIGATION_PRELOAD_SUB_FRAME: ArkWeb_ResourceType = 20;
#[doc = " @brief Resource type for a request.\n\n These constants match their equivalents in Chromium's ResourceType and should not be renumbered.\\n\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_ResourceType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_SchemeHandler_ {
    _unused: [u8; 0],
}
#[doc = " @brief This class is used to intercept requests for a specified scheme.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_SchemeHandler = ArkWeb_SchemeHandler_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_ResourceHandler_ {
    _unused: [u8; 0],
}
#[doc = " @brief Used to intercept url requests.\n\n Response headers and body can be sent through ArkWeb_ResourceHandler.\\n\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_ResourceHandler = ArkWeb_ResourceHandler_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_Response_ {
    _unused: [u8; 0],
}
#[doc = " @brief The response of the intercepted request.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_Response = ArkWeb_Response_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_ResourceRequest_ {
    _unused: [u8; 0],
}
#[doc = " @brief The info of the request.\n\n You can obtain the requested URL, method, post data, and other information through OH_ArkWeb_ResourceRequest.\\n\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_ResourceRequest = ArkWeb_ResourceRequest_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_RequestHeaderList_ {
    _unused: [u8; 0],
}
#[doc = " @brief The request headers of the request.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_RequestHeaderList = ArkWeb_RequestHeaderList_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_HttpBodyStream_ {
    _unused: [u8; 0],
}
#[doc = " @brief The http body of the request.\n\n Use OH_ArkWebHttpBodyStream_* interface to read the body.\\n\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_HttpBodyStream = ArkWeb_HttpBodyStream_;
#[doc = " @brief Callback for handling the request.\n\n This will be called on the IO thread.\\n\n\n @param schemeHandler The ArkWeb_SchemeHandler.\n @param resourceRequest Obtain request's information through this.\n @param resourceHandler The ArkWeb_ResourceHandler for the request. It should not be used if intercept is set to\n                        false.\n @param intercept If true will intercept the request, if false otherwise.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_OnRequestStart = ::std::option::Option<
    unsafe extern "C" fn(
        schemeHandler: *const ArkWeb_SchemeHandler,
        resourceRequest: *mut ArkWeb_ResourceRequest,
        resourceHandler: *const ArkWeb_ResourceHandler,
        intercept: *mut bool,
    ),
>;
#[doc = " @brief Callback when the request is completed.\n\n This will be called on the IO thread.\\n\n Should destory the resourceRequest by ArkWeb_ResourceRequest_Destroy and use ArkWeb_ResourceHandler_Destroy\\n\n destroy the ArkWeb_ResourceHandler received in ArkWeb_OnRequestStart.\\n\n\n @param schemeHandler The ArkWeb_SchemeHandler.\n @param resourceRequest The ArkWeb_ResourceRequest.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_OnRequestStop = ::std::option::Option<
    unsafe extern "C" fn(
        schemeHandler: *const ArkWeb_SchemeHandler,
        resourceRequest: *const ArkWeb_ResourceRequest,
    ),
>;
#[doc = " @brief Callback when the read operation done.\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @param buffer The buffer to receive data.\n @param bytesRead Callback after OH_ArkWebHttpBodyStream_Read. bytesRead greater than 0 means that the buffer is\n                  filled with data of bytesRead size. Caller can read from the buffer, and if\n                  OH_ArkWebHttpBodyStream_IsEOF is false, caller can continue to read the remaining data.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_HttpBodyStreamReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        httpBodyStream: *const ArkWeb_HttpBodyStream,
        buffer: *mut u8,
        bytesRead: ::std::os::raw::c_int,
    ),
>;
#[cfg(feature = "api-20")]
#[doc = " @brief Callback when the read operation done.\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @param buffer The buffer to receive data.\n @param bytesRead Callback after OH_ArkWebHttpBodyStream_AsyncRead. bytesRead greater than 0 means that\n                  the buffer is filled with data of bytesRead size. Caller can read from the buffer, and if\n                  OH_ArkWebHttpBodyStream_IsEOF is false, caller can continue to read the remaining data.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 20"]
pub type ArkWeb_HttpBodyStreamAsyncReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        httpBodyStream: *const ArkWeb_HttpBodyStream,
        buffer: *mut u8,
        bytesRead: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief  Callback when the init operation done.\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @param result {@link ARKWEB_NET_OK} on success otherwise refer to arkweb_net_error_list.h.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
pub type ArkWeb_HttpBodyStreamInitCallback = ::std::option::Option<
    unsafe extern "C" fn(httpBodyStream: *const ArkWeb_HttpBodyStream, result: ArkWeb_NetError),
>;
extern "C" {
    #[doc = " @brief Destroy the ArkWeb_RequestHeaderList.\n @param requestHeaderList The ArkWeb_RequestHeaderList to be destroyed.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebRequestHeaderList_Destroy(requestHeaderList: *mut ArkWeb_RequestHeaderList);
}
extern "C" {
    #[doc = " @brief Get the request headers size.\n @param requestHeaderList The list of request header.\n @return The size of request headers. -1 if requestHeaderList is invalid.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebRequestHeaderList_GetSize(
        requestHeaderList: *const ArkWeb_RequestHeaderList,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the specified request header.\n @param requestHeaderList The list of request header.\n @param index The index of request header.\n @param key The header key. Caller must release the string by OH_ArkWeb_ReleaseString.\n @param value The header value. Caller must release the string by OH_ArkWeb_ReleaseString.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebRequestHeaderList_GetHeader(
        requestHeaderList: *const ArkWeb_RequestHeaderList,
        index: i32,
        key: *mut *mut ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set a user data to ArkWeb_ResourceRequest.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @param userData The user data to set.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_SetUserData(
        resourceRequest: *mut ArkWeb_ResourceRequest,
        userData: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the user data from ArkWeb_ResourceRequest.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @return The set user data.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_GetUserData(
        resourceRequest: *const ArkWeb_ResourceRequest,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Get the method of request.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @param method The request's http method. This function will allocate memory for the method string and caller must\n               release the string by OH_ArkWeb_ReleaseString.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_GetMethod(
        resourceRequest: *const ArkWeb_ResourceRequest,
        method: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Get the url of request.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @param url The request's url. This function will allocate memory for the url string and caller must release the\n            string by OH_ArkWeb_ReleaseString.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_GetUrl(
        resourceRequest: *const ArkWeb_ResourceRequest,
        url: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Create a ArkWeb_HttpBodyStream which used to read the http body.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @param httpBodyStream The request's http body. This function will allocate memory for the http body stream and\n                       caller must release the httpBodyStream by OH_ArkWebResourceRequest_DestroyHttpBodyStream.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_GetHttpBodyStream(
        resourceRequest: *const ArkWeb_ResourceRequest,
        httpBodyStream: *mut *mut ArkWeb_HttpBodyStream,
    );
}
extern "C" {
    #[doc = " @brief Destroy the http body stream.\n @param httpBodyStream The httpBodyStream to be destroyed.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_DestroyHttpBodyStream(
        httpBodyStream: *mut ArkWeb_HttpBodyStream,
    );
}
extern "C" {
    #[doc = " @brief Get the resource type of request.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @return The resource type of request. -1 if resourceRequest is invalid.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_GetResourceType(
        resourceRequest: *const ArkWeb_ResourceRequest,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the url of frame which trigger this request.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @param frameUrl The url of frame which trigger this request. This function will allocate memory for the url string\n            and caller must release the string by OH_ArkWeb_ReleaseString.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_GetFrameUrl(
        resourceRequest: *const ArkWeb_ResourceRequest,
        frameUrl: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set a user data to ArkWeb_HttpBodyStream.\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @param userData The user data to set.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_SetUserData(
        httpBodyStream: *mut ArkWeb_HttpBodyStream,
        userData: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the user data from ArkWeb_HttpBodyStream.\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @return The set user data.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_GetUserData(
        httpBodyStream: *const ArkWeb_HttpBodyStream,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Set the callback for OH_ArkWebHttpBodyStream_Read.\n\n The result of OH_ArkWebHttpBodyStream_Read will be notified to caller through the readCallback.\\n\n The callback will run in the same thread as OH_ArkWebHttpBodyStream_Read.\\n\n\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @param readCallback The callback of read function.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_SetReadCallback(
        httpBodyStream: *mut ArkWeb_HttpBodyStream,
        readCallback: ArkWeb_HttpBodyStreamReadCallback,
    ) -> i32;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Set the callback for OH_ArkWebHttpBodyStream_AsyncRead.\n\n The result of OH_ArkWebHttpBodyStream_AsyncRead will be notified to caller through the\\n\n readCallback. The callback will runs in the ArkWeb worker thread.\\n\n\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @param readCallback The callback of read function.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 20"]
    pub fn OH_ArkWebHttpBodyStream_SetAsyncReadCallback(
        httpBodyStream: *mut ArkWeb_HttpBodyStream,
        readCallback: ArkWeb_HttpBodyStreamAsyncReadCallback,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Init the http body stream.\n\n This function must be called before calling any other functions.\\n\n\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @param initCallback The callback of init.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_Init(
        httpBodyStream: *mut ArkWeb_HttpBodyStream,
        initCallback: ArkWeb_HttpBodyStreamInitCallback,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Read the http body to the buffer.\n\n The buffer must be larger than the bufLen. We will be reading data from a worker thread to the buffer,\\n\n so should not use the buffer in other threads before the callback to avoid concurrency issues.\\n\n\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @param buffer The buffer to receive data.\n @param bufLen The size of bytes to read.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_Read(
        httpBodyStream: *const ArkWeb_HttpBodyStream,
        buffer: *mut u8,
        bufLen: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Read the http body to the buffer.\n\n The buffer must be larger than the bufLen. We will read data from a worker thread to the buffer,\\n\n so should not use the buffer in other threads before the callback to avoid concurrency issues.\\n\n\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @param buffer The buffer to receive data.\n @param bufLen The size of bytes to read.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 20"]
    pub fn OH_ArkWebHttpBodyStream_AsyncRead(
        httpBodyStream: *const ArkWeb_HttpBodyStream,
        buffer: *mut u8,
        bufLen: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Get the total size of the data stream.\n\n When data is chunked or httpBodyStream is invalid, always return zero.\\n\n\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @return The size of data stream.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_GetSize(httpBodyStream: *const ArkWeb_HttpBodyStream) -> u64;
}
extern "C" {
    #[doc = " @brief Get the current position of the data stream.\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @return The current position of data stream. 0 if httpBodyStream is invalid.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_GetPosition(httpBodyStream: *const ArkWeb_HttpBodyStream)
        -> u64;
}
extern "C" {
    #[doc = " @brief Get if the data stream is chunked.\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @return True if is chunked; false otherwise.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_IsChunked(httpBodyStream: *const ArkWeb_HttpBodyStream) -> bool;
}
extern "C" {
    #[doc = " @brief Returns true if all data has been consumed from this upload data stream.\n\n For chunked uploads, returns false until the first read attempt.\\n\n\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @return True if all data has been consumed; false otherwise.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_IsEof(httpBodyStream: *const ArkWeb_HttpBodyStream) -> bool;
}
extern "C" {
    #[doc = " @brief Returns true if the upload data in the stream is entirely in memory,\n        and all read requests will succeed synchronously.\n\n Expected to return false for chunked requests.\\n\n\n @param httpBodyStream The ArkWeb_HttpBodyStream.\n @return True if the upload data is in memory; false otherwise.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebHttpBodyStream_IsInMemory(httpBodyStream: *const ArkWeb_HttpBodyStream)
        -> bool;
}
extern "C" {
    #[doc = " @brief Destroy the ArkWeb_ResourceRequest.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_Destroy(resourceRequest: *const ArkWeb_ResourceRequest) -> i32;
}
extern "C" {
    #[doc = " @brief Get the referrer of request.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @param referrer The request's referrer. This function will allocate memory for the post data string and caller\n                 must release the string by OH_ArkWeb_ReleaseString.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_GetReferrer(
        resourceRequest: *const ArkWeb_ResourceRequest,
        referrer: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Get the OH_ArkWeb_RequestHeaderList of the request.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @param requestHeaderList The RequestHeaderList of request.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_GetRequestHeaders(
        resourceRequest: *const ArkWeb_ResourceRequest,
        requestHeaderList: *mut *mut ArkWeb_RequestHeaderList,
    );
}
extern "C" {
    #[doc = " @brief Get if this is a redirect request.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @return True if this is a redirect; false otherwise.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_IsRedirect(
        resourceRequest: *const ArkWeb_ResourceRequest,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get if this is a request from main frame.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @return True if this is from main frame; false otherwise.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_IsMainFrame(
        resourceRequest: *const ArkWeb_ResourceRequest,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get if this is a request is triggered by user gesutre.\n @param resourceRequest The ArkWeb_ResourceRequest.\n @return True if this is triggered by user gesture; false otherwise.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceRequest_HasGesture(
        resourceRequest: *const ArkWeb_ResourceRequest,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Register custom scheme to the ArkWeb.\n\n Should not be called for built-in HTTP, HTTPS, FILE, FTP, ABOUT and DATA schemes.\\n\n This function should be called on main thread.\\n\n\n @param scheme The scheme to regist.\n @param option The configuration of the scheme.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_ERROR_UNKNOWN} 17100100 - Unknown error.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n         {@link ARKWEB_SCHEME_REGISTER_FAILED} 17100102 - Register custom schemes should be called\n                                                          before create any ArkWeb.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_RegisterCustomSchemes(
        scheme: *const ::std::os::raw::c_char,
        option: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set a ArkWeb_SchemeHandler for a specific scheme to intercept requests of that scheme type.\n\n SchemeHandler should be set after the BrowserContext created.\\n\n Use WebviewController.initializeWebEngine to initialize the BrowserContext without create a ArkWeb.\\n\n\n @param scheme Scheme that need to be intercepted.\n @param schemeHandler The SchemeHandler for the scheme. Only requests triggered by ServiceWorker will be notified\n                      through this handler.\n @return Return true if set SchemeHandler for specific scheme successful, return false otherwise.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebServiceWorker_SetSchemeHandler(
        scheme: *const ::std::os::raw::c_char,
        schemeHandler: *mut ArkWeb_SchemeHandler,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set a ArkWeb_SchemeHandler for a specific scheme to intercept requests of that scheme type.\n\n SchemeHandler should be set after the BrowserContext created.\\n\n Use WebviewController.initializeWebEngine to initialize the BrowserContext without create a ArkWeb.\\n\n\n @param scheme Scheme that need to be intercepted.\n @param webTag The name of the web component.\n @param schemeHandler The SchemeHandler for the scheme. Only requests triggered from the specified web will be\n                      notified through this handler.\n @return Return true if set SchemeHandler for specific scheme successful, return false otherwise.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_SetSchemeHandler(
        scheme: *const ::std::os::raw::c_char,
        webTag: *const ::std::os::raw::c_char,
        schemeHandler: *mut ArkWeb_SchemeHandler,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Clear the handler registered on the specified web for service worker.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebServiceWorker_ClearSchemeHandlers() -> i32;
}
extern "C" {
    #[doc = " @brief Clear the handler registered on the specified web.\n @param webTag The name of the web component.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_ClearSchemeHandlers(webTag: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " @brief Create a SchemeHandler.\n @param schemeHandler Return the created SchemeHandler. Use OH_ArkWeb_DestroySchemeHandler destroy it when donn't\n                      need it.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_CreateSchemeHandler(schemeHandler: *mut *mut ArkWeb_SchemeHandler);
}
extern "C" {
    #[doc = " @brief Destroy a SchemeHandler.\n @param schemeHandler The ArkWeb_SchemeHandler to be destroy.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_DestroySchemeHandler(schemeHandler: *mut ArkWeb_SchemeHandler);
}
extern "C" {
    #[doc = " @brief Set a user data to ArkWeb_SchemeHandler.\n @param schemeHandler The ArkWeb_SchemeHandler.\n @param userData The user data to set.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebSchemeHandler_SetUserData(
        schemeHandler: *mut ArkWeb_SchemeHandler,
        userData: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the user data from ArkWeb_SchemeHandler.\n @param schemeHandler The ArkWeb_SchemeHandler.\n @return The set user data.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebSchemeHandler_GetUserData(
        schemeHandler: *const ArkWeb_SchemeHandler,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Set the OnRequestStart callback for SchemeHandler.\n @param schemeHandler The SchemeHandler for the scheme.\n @param onRequestStart The OnRequestStart callback.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebSchemeHandler_SetOnRequestStart(
        schemeHandler: *mut ArkWeb_SchemeHandler,
        onRequestStart: ArkWeb_OnRequestStart,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Set the OnRequestStop callback for SchemeHandler.\n @param schemeHandler The SchemeHandler for the scheme.\n @param onRequestStop The OnRequestStop callback.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebSchemeHandler_SetOnRequestStop(
        schemeHandler: *mut ArkWeb_SchemeHandler,
        onRequestStop: ArkWeb_OnRequestStop,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Create a Response for a request.\n @param response The created Response. Use OH_ArkWeb_DestroyResponse to destroy when donn't need it.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_CreateResponse(response: *mut *mut ArkWeb_Response);
}
extern "C" {
    #[doc = " @brief Destroy the Reponse.\n @param response The Response needs destroy.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_DestroyResponse(response: *mut ArkWeb_Response);
}
extern "C" {
    #[doc = " @brief Set the resolved URL after redirects or changed as a result of HSTS.\n @param response The ArkWeb_Response.\n @param url The resolved URL.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_SetUrl(
        response: *mut ArkWeb_Response,
        url: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the resolved URL after redirects or changed as a result of HSTS.\n @param response The ArkWeb_Response.\n @param url The resolved URL.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_GetUrl(
        response: *const ArkWeb_Response,
        url: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set a error code to ArkWeb_Response.\n @param response The ArkWeb_Response.\n @param errorCode The error code for the failed request.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_SetError(
        response: *mut ArkWeb_Response,
        errorCode: ArkWeb_NetError,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the response's error code.\n @param response The ArkWeb_Response.\n @return The response's error code.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_GetError(response: *const ArkWeb_Response) -> ArkWeb_NetError;
}
extern "C" {
    #[doc = " @brief Set a status code to ArkWebResponse.\n @param response The ArkWeb_Response.\n @param status The http status code for the request.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_SetStatus(
        response: *mut ArkWeb_Response,
        status: ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the response's status code.\n @param response The ArkWeb_Response.\n @return The response's http status code. -1 if response is invalid.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_GetStatus(response: *const ArkWeb_Response) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set a status text to ArkWebResponse.\n @param response The ArkWeb_Response.\n @param statusText The status text for the request.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_SetStatusText(
        response: *mut ArkWeb_Response,
        statusText: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the response's status text.\n @param response The ArkWeb_Response.\n @param statusText Return the response's statusText. This function will allocate memory for the statusText string and\n                   caller must release the string by OH_ArkWeb_ReleaseString.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_GetStatusText(
        response: *const ArkWeb_Response,
        statusText: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set mime type to ArkWebResponse.\n @param response The ArkWeb_Response.\n @param mimeType The mime type for the request.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_SetMimeType(
        response: *mut ArkWeb_Response,
        mimeType: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the response's mime type.\n @param response The ArkWeb_Response.\n @param mimeType Return the response's mime type. This function will allocate memory for the mime type string and\n                 caller must release the string by OH_ArkWeb_ReleaseString.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_GetMimeType(
        response: *const ArkWeb_Response,
        mimeType: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set charset to ArkWeb_Response.\n @param response The ArkWeb_Response.\n @param charset The charset for the request.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_SetCharset(
        response: *mut ArkWeb_Response,
        charset: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the response's charset.\n @param response The ArkWeb_Response.\n @param charset Return the response's charset. This function will allocate memory for the charset string and caller\n                must release the string by OH_ArkWeb_ReleaseString.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_GetCharset(
        response: *const ArkWeb_Response,
        charset: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set a header to ArkWeb_Response.\n @param response The ArkWeb_Response.\n @param name The name of the header.\n @param value The value of the header.\n @param overwirte If true will overwrite the exsits header, if false otherwise.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_SetHeaderByName(
        response: *mut ArkWeb_Response,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        overwrite: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Get the header from the response.\n @param response The ArkWeb_Response.\n @param name The name of the header.\n @param value Return the header's value. This function will allocate memory for the value string and caller must\n              release the string by OH_ArkWeb_ReleaseString.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResponse_GetHeaderByName(
        response: *const ArkWeb_Response,
        name: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Destroy the ArkWeb_ResourceHandler.\n @param resourceHandler The ArkWeb_ResourceHandler.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceHandler_Destroy(resourceHandler: *const ArkWeb_ResourceHandler) -> i32;
}
extern "C" {
    #[doc = " @brief Pass response headers to intercepted requests.\n @param resourceHandler The ArkWeb_ResourceHandler for the request.\n @param response The ArkWeb_Response for the intercepting requests.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceHandler_DidReceiveResponse(
        resourceHandler: *const ArkWeb_ResourceHandler,
        response: *const ArkWeb_Response,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Pass response body data to intercepted requests.\n @param resourceHandler The ArkWeb_ResourceHandler for the request.\n @param buffer Buffer data to send.\n @param bufLen The size of buffer.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceHandler_DidReceiveData(
        resourceHandler: *const ArkWeb_ResourceHandler,
        buffer: *const u8,
        bufLen: i64,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Notify the ArkWeb that this request should be finished and there is no more data available.\n @param resourceHandler The ArkWeb_ResourceHandler for the request.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceHandler_DidFinish(
        resourceHandler: *const ArkWeb_ResourceHandler,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Notify the ArkWeb that this request should be failed.\n @param resourceHandler The ArkWeb_ResourceHandler for the request.\n @param errorCode The error code for this request. Refer to arkweb_net_error_list.h.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWebResourceHandler_DidFailWithError(
        resourceHandler: *const ArkWeb_ResourceHandler,
        errorCode: ArkWeb_NetError,
    ) -> i32;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Notify the ArkWeb that this request should be failed.\n @param resourceHandler The ArkWeb_ResourceHandler for the request.\n @param errorCode The error code for this request. Refer to arkweb_net_error_list.h.\n @param completeIfNoResponse If completeIfNoResponse is true, when DidFailWithErrorV2 is called,\n        if DidReceiveResponse has not been called,\n        a response is automatically constructed and the current request is terminated.\n @return {@link ARKWEB_NET_OK} 0 - Success.\n         {@link ARKWEB_INVALID_PARAM} 17100101 - Invalid param, the resourceHandler is nullptr.\n @since 20"]
    pub fn OH_ArkWebResourceHandler_DidFailWithErrorV2(
        resourceHandler: *const ArkWeb_ResourceHandler,
        errorCode: ArkWeb_NetError,
        completeIfNoResponse: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Release the string acquired by native function.\n @param string The string to be released.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_ReleaseString(string: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Release the byte array acquired by native function.\n @param byteArray The byte array to be released.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 12"]
    pub fn OH_ArkWeb_ReleaseByteArray(byteArray: *mut u8);
}
#[doc = " @brief Defines the javascript callback of the web component.\n\n @since 11"]
pub type NativeArkWeb_OnJavaScriptCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
#[doc = " @brief Defines the javascript proxy callback of the web component.\n\n @since 11"]
pub type NativeArkWeb_OnJavaScriptProxyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        argv: *mut *const ::std::os::raw::c_char,
        argc: i32,
    ) -> *mut ::std::os::raw::c_char,
>;
#[doc = " @brief Defines the valid callback of the web component.\n\n @since 11"]
pub type NativeArkWeb_OnValidCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
#[doc = " @brief Defines the destroy callback of the web component.\n\n @since 11"]
pub type NativeArkWeb_OnDestroyCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
#[cfg(feature = "api-20")]
#[doc = " @brief Defines the callback of save cookie.\n @param errorCode {@link ARKWEB_SUCCESS} Save cookie success.\n                  {@link ARKWEB_COOKIE_MANAGER_INITIALIZE_FAILED} Cookie manager initialize failed.\n                  {@link ARKWEB_COOKIE_SAVE_FAILED} Save cookie failed.\n @since 20"]
pub type OH_ArkWeb_OnCookieSaveCallback =
    ::std::option::Option<unsafe extern "C" fn(errorCode: ArkWeb_ErrorCode)>;
#[cfg(feature = "api-20")]
#[doc = " @brief Defines the blankless information.\n\n @since 20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArkWeb_BlanklessInfo {
    #[doc = " The errCode of the blankless."]
    pub errCode: ArkWeb_BlanklessErrorCode,
    #[doc = " The estimated similarity of the history snapshots."]
    pub similarity: f64,
    #[doc = " The loadingTime of the history loading."]
    pub loadingTime: i32,
}
#[cfg(feature = "api-20")]
#[doc = " the system default ArkWeb engine.\n @since 20"]
pub const ArkWebEngineVersion_SYSTEM_DEFAULT: ArkWebEngineVersion = 0;
#[cfg(feature = "api-20")]
#[doc = " ArkWeb M114 version.\n @since 20"]
pub const ArkWebEngineVersion_ARKWEB_M114: ArkWebEngineVersion = 1;
#[cfg(feature = "api-20")]
#[doc = " ArkWeb M132 version.\n @since 20"]
pub const ArkWebEngineVersion_ARKWEB_M132: ArkWebEngineVersion = 2;
#[cfg(feature = "api-20")]
#[doc = " @brief ArkWeb Engine Version.\n\n <strong>ArkWeb Dual Web Engine Versioning Convention</strong>:\n <p>See [ArkWeb Dual Web Engine Versioning Convention] for switching between Legacy and Evergreen Web Engine.\n\n @since 20"]
pub type ArkWebEngineVersion = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Loads a piece of code and execute JS code in the context of the currently displayed page.\n\n @param webTag The name of the web component.\n @param jsCode a piece of javascript code.\n @param callback Callbacks execute JavaScript script results.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 11"]
    pub fn OH_NativeArkWeb_RunJavaScript(
        webTag: *const ::std::os::raw::c_char,
        jsCode: *const ::std::os::raw::c_char,
        callback: NativeArkWeb_OnJavaScriptCallback,
    );
}
extern "C" {
    #[doc = " @brief Registers the JavaScript object and method list.\n\n @param webTag The name of the web component.\n @param objName The name of the registered object.\n @param methodList The method of the application side JavaScript object participating in the registration.\n @param callback The callback function registered by developer is called back when HTML side uses.\n @param size The size of the callback.\n @param needRefresh if web need refresh.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 11"]
    pub fn OH_NativeArkWeb_RegisterJavaScriptProxy(
        webTag: *const ::std::os::raw::c_char,
        objName: *const ::std::os::raw::c_char,
        methodList: *mut *const ::std::os::raw::c_char,
        callback: *mut NativeArkWeb_OnJavaScriptProxyCallback,
        size: i32,
        needRefresh: bool,
    );
}
extern "C" {
    #[doc = " @brief Deletes the registered object which th given name.\n\n @param webTag The name of the web component.\n @param objName The name of the registered object.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 11"]
    pub fn OH_NativeArkWeb_UnregisterJavaScriptProxy(
        webTag: *const ::std::os::raw::c_char,
        objName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Registers the valid callback.\n\n @param webTag The name of the web component.\n @param callback The callback in which we can register object.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 11"]
    pub fn OH_NativeArkWeb_SetJavaScriptProxyValidCallback(
        webTag: *const ::std::os::raw::c_char,
        callback: NativeArkWeb_OnValidCallback,
    );
}
extern "C" {
    #[doc = " @brief Get the valid callback.\n\n @param webTag The name of the web component.\n @return Return the valid callback function registered. If the valid callback function\n         specified by the parameter webTag is not set, a null pointer is returned.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 11"]
    pub fn OH_NativeArkWeb_GetJavaScriptProxyValidCallback(
        webTag: *const ::std::os::raw::c_char,
    ) -> NativeArkWeb_OnValidCallback;
}
extern "C" {
    #[doc = " @brief Registers the destroy callback.\n\n @param webTag The name of the web component.\n @param callback the destroy callback.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 11"]
    pub fn OH_NativeArkWeb_SetDestroyCallback(
        webTag: *const ::std::os::raw::c_char,
        callback: NativeArkWeb_OnDestroyCallback,
    );
}
extern "C" {
    #[doc = " @brief Get the destroy callback.\n\n @param webTag The name of the web component.\n @return Return the destroy callback function registered. If the destroy callback\n         function specified by the parameter webTag is not set,\n         a null pointer is returned.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 11"]
    pub fn OH_NativeArkWeb_GetDestroyCallback(
        webTag: *const ::std::os::raw::c_char,
    ) -> NativeArkWeb_OnDestroyCallback;
}
extern "C" {
    #[cfg(feature = "api-15")]
    #[doc = " @brief Loads the data or URL.\n        This function should be called on main thread.\n\n @param webTag The name of the web component.\n @param data A string encoded according to \"Base64\" or \"URL\", should not be NULL.\n @param mimeType Media type. For example: \"text/html\", should not be NULL.\n @param encoding Encoding type. For example: \"UTF-8\", should not be NULL.\n @param baseUrl A specified URL path (\"http\"/\"https\"/\"data\" protocol),\n                which is assigned to window.origin by the Web component.\n @param historyUrl History URL. When it is not empty, it can be managed by\n                   history records to realize the back and forth function.\n @return LoadData result code.\n         {@link ARKWEB_SUCCESS} load data success.\n         {@link ARKWEB_INVALID_PARAM} Mandatory parameters are left unspecified or\n                                      Incorrect parameter types or Parameter verification failed.\n         {@link ARKWEB_INIT_ERROR} Initialization error, can't get a valid Web for the webTag.\n         {@link ARKWEB_LIBRARY_OPEN_FAILURE} Failed to open the library.\n         {@link ARKWEB_LIBRARY_SYMBOL_NOT_FOUND} The required symbol was not found in the library.\n\n @syscap SystemCapability.Web.Webview.Core\n @since 15"]
    pub fn OH_NativeArkWeb_LoadData(
        webTag: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
        mimeType: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
        baseUrl: *const ::std::os::raw::c_char,
        historyUrl: *const ::std::os::raw::c_char,
    ) -> ArkWeb_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Registers a JavaScript object with callback methods, which may return values. This object will be injected\n        into all frames of the current page, including all iframes, and will be accessible using the specified\n        name in ArkWeb_ProxyObjectWithResult. The object will only be available in JavaScript after the next\n        load or reload.\n        These methods will be executed in the ArkWeb worker thread.\n\n @param webTag Name of the web component.\n @param proxyObject JavaScript object to register, the object has callback functions with return value.\n @param permission Optional JSON string(default is null) for JSBridge permission control,\n                   allowing URL whitelist configuration at object-level and method-level.\n @syscap SystemCapability.Web.Webview.Core\n @since 20"]
    pub fn OH_NativeArkWeb_RegisterAsyncThreadJavaScriptProxy(
        webTag: *const ::std::os::raw::c_char,
        proxyObject: *const ArkWeb_ProxyObjectWithResult,
        permission: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Sets whether to enable blankless page loading. This API must be used in pair with the\n OH_NativeArkWeb_GetBlanklessInfoWithKey API.\n\n @param webTag webTag used when the webviewController is created.\n @param key Key value that uniquely identifies the current page. It must be the same as the key value of the\n OH_NativeArkWeb_GetBlanklessInfoWithKey API.\n @param isStarted Whether to enable frame interpolation. The value true indicates to enable frame\n interpolation, and the value false indicates the opposite.\n The default value is false.\n The value can be true or false.\n Action for setting an invalid value: N/A.\n @return Whether the API is successfully called. For details, see ArkWeb_BlanklessErrorCode.\n @since 20"]
    pub fn OH_NativeArkWeb_SetBlanklessLoadingWithKey(
        webTag: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        isStarted: bool,
    ) -> ArkWeb_BlanklessErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Clears the blankless loading cache of the page with a specified key value.\n\n @param key The list of key values of pages cached in the blankless loading solution. These key values are\n specified in OH_NativeArkWeb_GetBlanklessInfoWithKey.\n The default value is the list of key values of all pages cached in the blankless loading solution.\n The key length cannot exceed 2048 characters, and the number of keys must be less than or equal to 100. The\n URL is the same as that input to the Web component during page loading.\n When the key length exceeds 2048 characters, the key does not take effect. When the number of keys exceeds\n 100, the first 100 keys are used. If this parameter is set to NULL, the default value is used.\n @param size Size of the key list.\n @since 20"]
    pub fn OH_NativeArkWeb_ClearBlanklessLoadingCache(
        key: *mut *const ::std::os::raw::c_char,
        size: u32,
    );
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Obtains the prediction information about the blankless loading solution and enables the generation\n of the transition frame for the current loading. The application determines whether to enable the blankless\n loading solution based on the information.\n This API applies to pages in an applet or web application whose URLs are not fixed or cannot be uniquely\n identified.\n\n @param webTag webTag used when the webviewController is created.\n Default value: N/A.\n The value cannot be empty.\n When an invalid value is set, the error code is returned, and the API does not take effect.\n @param key Key value that uniquely identifies the current page.\n @return Return value of the ArkWeb_BlanklessInfo type.\n @since 20"]
    pub fn OH_NativeArkWeb_GetBlanklessInfoWithKey(
        webTag: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> ArkWeb_BlanklessInfo;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Sets the cache capacity of the blankless loading solution and returns the value that takes effect.\n\n @param capacity Cache capacity, in MB. The maximum value is 100 MB.\n The default value is 30 MB.\n The value ranges from 0 to 100. If this parameter is set to 0, no cache capacity is available and the\n functionality is disabled globally.\n When the value is set to a number smaller than 0, the value 0 takes effect. When the value is set to a\n number greater than 100, the value 100 takes effect.\n @return The effective value that ranges from 0 MB to 100 MB.\n @since 20"]
    pub fn OH_NativeArkWeb_SetBlanklessLoadingCacheCapacity(capacity: u32) -> u32;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Ensure that all cookies currently accessible via the CookieManager API have been persisted to disk.\n        If you want to use this interface in a non-UI thread, you need to initialize the CookieManager interface\n        using OH_ArkWeb_GetNativeAPI first.\n @return Save cookie result code.\n         {@link ARKWEB_SUCCESS} Save cookie success.\n         {@link ARKWEB_COOKIE_SAVE_FAILED} Save cookie failed.\n         {@link ARKWEB_COOKIE_MANAGER_INITIALIZE_FAILED} The CookieManager initialize failed.\n         {@link ARKWEB_COOKIE_MANAGER_NOT_INITIALIZED} It is not allowed to call on a non-UI thread without\n                                                       initializing the CookieManager interface. please\n   \t\t\t\t\t\t\t\t\t\t\t\t\t initialize the CookieManager interface using\n  \t\t\t\t\t\t\t\t\t\t\t\t\t OH_ArkWeb_GetNativeAPI first.\n @since 20"]
    pub fn OH_ArkWebCookieManager_SaveCookieSync() -> ArkWeb_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Ensure that all cookies currently accessible via the CookieManager API have been persisted to disk.\n        Without initializing the CookieManager interface, this call will automatically be executed on the UI thread.\n @param callback Callback execute when save cookie done.\n @since 20"]
    pub fn OH_ArkWebCookieManager_SaveCookieAsync(callback: OH_ArkWeb_OnCookieSaveCallback);
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " Set active ArkWeb engine version.\n If the system does not support the specified version, it will not take effect.\n\n This is a global static API that must be called before initializeWebEngine, and it will have no effect if any\n Web components are loaded.\n\n <strong>Legacy Web Engine Compatibility Note</strong>:\n <p>When using legacy ArkWeb Engine, some ArkWeb newly created API will not take effect,<br>\n see [Compatible with Legacy Web Engine in release note] for compatibility guidelines.\n </p>\n\n @param { ArkWebEngineVersion } webEngineVersion - the ArkWebEngineVersion\n @since 20"]
    pub fn OH_NativeArkWeb_SetActiveWebEngineVersion(webEngineVersion: ArkWebEngineVersion);
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " Get currently active ArkWeb engine version.\n @return { ArkWebEngineVersion } Active ArkWeb Engine version as defined by ArkWebEngineVersion\n @since 20"]
    pub fn OH_NativeArkWeb_GetActiveWebEngineVersion() -> ArkWebEngineVersion;
}
