/* automatically generated by rust-bindgen 0.65.1 */

#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(clippy::missing_safety_doc)]


#[link(name = "qos")]
unsafe extern "C" {}

#[doc = " @brief Means the QoS level is background."]
pub const QoS_Level_QOS_BACKGROUND: QoS_Level = 0;
#[doc = " @brief Means the QoS level is utility."]
pub const QoS_Level_QOS_UTILITY: QoS_Level = 1;
#[doc = " @brief Means the QoS level is default."]
pub const QoS_Level_QOS_DEFAULT: QoS_Level = 2;
#[doc = " @brief Means the QoS level is user-initiated."]
pub const QoS_Level_QOS_USER_INITIATED: QoS_Level = 3;
#[doc = " @brief Means the QoS level is user-request."]
pub const QoS_Level_QOS_DEADLINE_REQUEST: QoS_Level = 4;
#[doc = " @brief Means the QoS level is user-interactive."]
pub const QoS_Level_QOS_USER_INTERACTIVE: QoS_Level = 5;
#[doc = " @brief Describes the level of QoS.\n\n @since 12"]
pub type QoS_Level = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Set the QoS level of the current thread.\n\n @param level Indicates the level to set. Specific level can be referenced {@link QoS_Level}.\n @return Returns 0 if the operation is successful; returns -1 if level is out of range or\n         internal error failed.\n @see QoS_Level\n @since 12"]
    pub fn OH_QoS_SetThreadQoS(level: QoS_Level) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Cancel the QoS level of the current thread.\n\n @return Returns 0 if the operation is successful; returns -1 if not set QoS for current thread\n        or internal error failed.\n @see QoS_Level\n @since 12"]
    pub fn OH_QoS_ResetThreadQoS() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Obtains the QoS level of the current thread.\n\n @param level This parameter is the output parameter,\n and the QoS level of the thread as a {@link QoS_Level} is written to this variable.\n @return Returns 0 if the operation is successful; returns -1 if level is null, not\n         set QoS for current thread or internal error failed.\n @see QoS_Level\n @since 12"]
    pub fn OH_QoS_GetThreadQoS(level: *mut QoS_Level) -> ::std::os::raw::c_int;
}
#[cfg(feature = "api-20")]
#[doc = " @brief Session id\n\n @since 20"]
pub type OH_QoS_GewuSession = ::std::os::raw::c_uint;
#[cfg(feature = "api-20")]
#[doc = " @brief Request id\n\n @since 20"]
pub type OH_QoS_GewuRequest = ::std::os::raw::c_uint;
#[cfg(feature = "api-20")]
pub const OH_QoS_GewuErrorCode_OH_QOS_GEWU_OK: OH_QoS_GewuErrorCode = 0;
#[cfg(feature = "api-20")]
pub const OH_QoS_GewuErrorCode_OH_QOS_GEWU_NOPERM: OH_QoS_GewuErrorCode = 201;
#[cfg(feature = "api-20")]
pub const OH_QoS_GewuErrorCode_OH_QOS_GEWU_NOMEM: OH_QoS_GewuErrorCode = 203;
#[cfg(feature = "api-20")]
pub const OH_QoS_GewuErrorCode_OH_QOS_GEWU_INVAL: OH_QoS_GewuErrorCode = 401;
#[cfg(feature = "api-20")]
pub const OH_QoS_GewuErrorCode_OH_QOS_GEWU_EXIST: OH_QoS_GewuErrorCode = 501;
#[cfg(feature = "api-20")]
pub const OH_QoS_GewuErrorCode_OH_QOS_GEWU_NOENT: OH_QoS_GewuErrorCode = 502;
#[cfg(feature = "api-20")]
pub const OH_QoS_GewuErrorCode_OH_QOS_GEWU_NOSYS: OH_QoS_GewuErrorCode = 801;
#[cfg(feature = "api-20")]
pub const OH_QoS_GewuErrorCode_OH_QOS_GEWU_FAULT: OH_QoS_GewuErrorCode = 901;
#[cfg(feature = "api-20")]
#[doc = " @brief Gewu error codes.\n\n @since 20"]
pub type OH_QoS_GewuErrorCode = ::std::os::raw::c_uint;
#[cfg(feature = "api-20")]
#[doc = " @param session The created session id\n @param error Error code of CreateSession\n              - OH_QOS_GEWU_OK will be returned if the session is created successfully.\n              - OH_QOS_GEWU_NOMEM will be returned if the system does not have sufficient memory to\n                create the session.\n\n @since 20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_QoS_GewuCreateSessionResult {
    pub session: OH_QoS_GewuSession,
    pub error: OH_QoS_GewuErrorCode,
}
#[cfg(feature = "api-20")]
#[doc = " @param request The created request id\n @param error Error code of request submission.\n              - OH_QOS_GEWU_OK will be returned if the request is submitted successfully.\n              - OH_QOS_GEWU_NOMEM will be returned if the system does not have sufficient memory to\n                submit the request.\n\n @since 20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_QoS_GewuSubmitRequestResult {
    pub request: OH_QoS_GewuRequest,
    pub error: OH_QoS_GewuErrorCode,
}
#[cfg(feature = "api-20")]
#[doc = " @brief Callback to receive response of the request.\n\n @param context The user context specified when submitting the request.\n @param reponse The json string of the response, including the following parameters:\n        - message: A message that contains the following fields.\n            - role: string. Must be \"assistant\".\n            - content: string. The message generated by the model in response to user messages.\n        - finish_reason: string or null. The reason the inference stopped. Possible values:\n            - null: Not finished yet, only present in streaming mode.\n            - \"stop\": The model stopped natually.\n            - \"abort\": The inference request was aborted.\n            - \"length\": The generated tokens reached the limit.\n\n @since 20"]
pub type OH_QoS_GewuOnResponse = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        response: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Create a gewu session for inference.\n The lifecycle of the returned session object spans from the return of CreateSession\n to the call to DestroySession.\n\n json string of session attributes.\n\n The json string of session attributes include the following parameters\n     - model: string. The directory of the model of the session.\n\n An example of json string of session attributes:\n @code{.json}\n {\n     \"model\": \"/data/storage/el2/base/files/qwen2/\"\n }\n @endcode\n\n @param attributes The json string of session attributes.\n\n @return Result of CreateSession.\n\n @since 20"]
    pub fn OH_QoS_GewuCreateSession(
        attributes: *const ::std::os::raw::c_char,
    ) -> OH_QoS_GewuCreateSessionResult;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Destroy the specified session.\n It is recommended that the client shall wait until all ongoing requests are done before calling\n this interface to destroy the session. If there are remaining requests in the session when this\n interface is called, those requests will be aborted and no further responses for those requests\n will be sent to the client.\n Note that after calling this function successfully, the session cannot be used by the user code\n any more.\n\n @param session The session that will be destroyed.\n\n @return Error code.\n         - OH_QOS_GEWU_OK will be returned if the session is destroyed successfully.\n         - OH_QOS_GEWU_NOENT will be returned if the session is not found.\n\n @since 20"]
    pub fn OH_QoS_GewuDestroySession(session: OH_QoS_GewuSession) -> OH_QoS_GewuErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Abort the specified request.\n Note that after calling this function successfully, the client will not receive further responses\n for this request, and the request object cannot be used by the user code any more.\n\n @param session The session that the request was submitted through.\n @param request The request object.\n\n @return Error code.\n         - OH_QOS_GEWU_OK will be returned if the request is aborted successfully.\n         - OH_QOS_GEWU_NOENT will be returned if the request is not found.\n\n @since 20"]
    pub fn OH_QoS_GewuAbortRequest(
        session: OH_QoS_GewuSession,
        request: OH_QoS_GewuRequest,
    ) -> OH_QoS_GewuErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Submit a request.\n\n json string of completion request.\n Completion request is a json string that specifies the following parameters:\n     - messages: array. A list of messages. Each message contains the following fields:\n         - role: string. The message type, which could be one of the following:\n             - \"developer\": Developer-provided instructions.\n             - \"user\": User-provided instructions.\n             - \"assistant\": Message generated by the model in response to user messages.\n         - content: string. The message content.\n     - stream: boolean or null; optional. Enable streaming mode or not. If set to true, partial\n       responses will be sent. If null or not set, defaults to nonstreaming mode.\n\n An example of completion request:\n @code{.json}\n {\n      \"messages\": [\n          {\n              \"role\": \"developer\",\n              \"content\": \"Your are a helpful assistant.\"\n          },\n          {\n              \"role\": \"user\",\n              \"content\": \"What is OpenHarmony\"\n          }\n      ],\n      \"stream\": true\n }\n @endcode\n\n @param session The session object that the request should be submitted through.\n @param request The json string of request.\n @param callback The callback to receive response.\n @param context The user context that should be passed to the response callback.\n\n @return Gewu request submission result.\n         - OH_QOS_GEWU_OK will be returned if the request is accepted.\n         - OH_QOS_GEWU_NOMEM will be returned if the system does not have sufficient memory\n           to accept the request.\n\n @since 20"]
    pub fn OH_QoS_GewuSubmitRequest(
        session: OH_QoS_GewuSession,
        request: *const ::std::os::raw::c_char,
        callback: OH_QoS_GewuOnResponse,
        context: *mut ::std::os::raw::c_void,
    ) -> OH_QoS_GewuSubmitRequestResult;
}