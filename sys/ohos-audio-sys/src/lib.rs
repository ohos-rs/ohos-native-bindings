/* automatically generated by rust-bindgen 0.65.1 */

#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(clippy::missing_safety_doc)]

#[link(name = "ohaudio")]
unsafe extern "C" {}

pub type clockid_t = ::std::os::raw::c_int;
#[doc = " Channel set For FRONT-LEFT position"]
pub const OH_AudioChannelSet_CH_SET_FRONT_LEFT: OH_AudioChannelSet = 1;
#[doc = " Channel set For FRONT_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_FRONT_RIGHT: OH_AudioChannelSet = 2;
#[doc = " Channel set For FRONT_CENTER position"]
pub const OH_AudioChannelSet_CH_SET_FRONT_CENTER: OH_AudioChannelSet = 4;
#[doc = " Channel set For LOW_FREQUENCY position"]
pub const OH_AudioChannelSet_CH_SET_LOW_FREQUENCY: OH_AudioChannelSet = 8;
#[doc = " Channel set For BACK_LEFT position"]
pub const OH_AudioChannelSet_CH_SET_BACK_LEFT: OH_AudioChannelSet = 16;
#[doc = " Channel set For BACK_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_BACK_RIGHT: OH_AudioChannelSet = 32;
#[doc = " Channel set For FRONT_LEFT_OF_CENTER position"]
pub const OH_AudioChannelSet_CH_SET_FRONT_LEFT_OF_CENTER: OH_AudioChannelSet = 64;
#[doc = " Channel set For FRONT_RIGHT_OF_CENTER position"]
pub const OH_AudioChannelSet_CH_SET_FRONT_RIGHT_OF_CENTER: OH_AudioChannelSet = 128;
#[doc = " Channel set For BACK_CENTER position"]
pub const OH_AudioChannelSet_CH_SET_BACK_CENTER: OH_AudioChannelSet = 256;
#[doc = " Channel set For SIDE_LEFT position"]
pub const OH_AudioChannelSet_CH_SET_SIDE_LEFT: OH_AudioChannelSet = 512;
#[doc = " Channel set For SIDE_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_SIDE_RIGHT: OH_AudioChannelSet = 1024;
#[doc = " Channel set For TOP_CENTER position"]
pub const OH_AudioChannelSet_CH_SET_TOP_CENTER: OH_AudioChannelSet = 2048;
#[doc = " Channel set For TOP_FRONT_LEFT position"]
pub const OH_AudioChannelSet_CH_SET_TOP_FRONT_LEFT: OH_AudioChannelSet = 4096;
#[doc = " Channel set For TOP_FRONT_CENTER position"]
pub const OH_AudioChannelSet_CH_SET_TOP_FRONT_CENTER: OH_AudioChannelSet = 8192;
#[doc = " Channel set For TOP_FRONT_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_TOP_FRONT_RIGHT: OH_AudioChannelSet = 16384;
#[doc = " Channel set For TOP_BACK_LEFT position"]
pub const OH_AudioChannelSet_CH_SET_TOP_BACK_LEFT: OH_AudioChannelSet = 32768;
#[doc = " Channel set For TOP_BACK_CENTER position"]
pub const OH_AudioChannelSet_CH_SET_TOP_BACK_CENTER: OH_AudioChannelSet = 65536;
#[doc = " Channel set For TOP_BACK_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_TOP_BACK_RIGHT: OH_AudioChannelSet = 131072;
#[doc = " Channel set For STEREO_LEFT position"]
pub const OH_AudioChannelSet_CH_SET_STEREO_LEFT: OH_AudioChannelSet = 536870912;
#[doc = " Channel set For STEREO_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_STEREO_RIGHT: OH_AudioChannelSet = 1073741824;
#[doc = " Channel set For WIDE_LEFT position"]
pub const OH_AudioChannelSet_CH_SET_WIDE_LEFT: OH_AudioChannelSet = 2147483648;
#[doc = " Channel set For WIDE_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_WIDE_RIGHT: OH_AudioChannelSet = 4294967296;
#[doc = " Channel set For SURROUND_DIRECT_LEFT position"]
pub const OH_AudioChannelSet_CH_SET_SURROUND_DIRECT_LEFT: OH_AudioChannelSet = 8589934592;
#[doc = " Channel set For SURROUND_DIRECT_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_SURROUND_DIRECT_RIGHT: OH_AudioChannelSet = 17179869184;
#[doc = " Channel set For LOW_FREQUENCY_2 position"]
pub const OH_AudioChannelSet_CH_SET_LOW_FREQUENCY_2: OH_AudioChannelSet = 34359738368;
#[doc = " Channel set For TOP_SIDE_LEFT position"]
pub const OH_AudioChannelSet_CH_SET_TOP_SIDE_LEFT: OH_AudioChannelSet = 68719476736;
#[doc = " Channel set For TOP_SIDE_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_TOP_SIDE_RIGHT: OH_AudioChannelSet = 137438953472;
#[doc = " Channel set For BOTTOM_FRONT_CENTER position"]
pub const OH_AudioChannelSet_CH_SET_BOTTOM_FRONT_CENTER: OH_AudioChannelSet = 274877906944;
#[doc = " Channel set For BOTTOM_FRONT_LEFT position"]
pub const OH_AudioChannelSet_CH_SET_BOTTOM_FRONT_LEFT: OH_AudioChannelSet = 549755813888;
#[doc = " Channel set For BOTTOM_FRONT_RIGHT position"]
pub const OH_AudioChannelSet_CH_SET_BOTTOM_FRONT_RIGHT: OH_AudioChannelSet = 1099511627776;
#[doc = " @brief Audio Channel Set\n\n A 64-bit integer with bits set for each channel.\n @syscap SystemCapability.Multimedia.Media.Core\n @since 11"]
pub type OH_AudioChannelSet = u64;
#[doc = " Ambisonic attribute: order 1"]
pub const OH_AmbAttributeSet_AMB_ORD_1: OH_AmbAttributeSet = 1;
#[doc = " Ambisonic attribute: order 2"]
pub const OH_AmbAttributeSet_AMB_ORD_2: OH_AmbAttributeSet = 2;
#[doc = " Ambisonic attribute: order 3"]
pub const OH_AmbAttributeSet_AMB_ORD_3: OH_AmbAttributeSet = 3;
#[doc = " Ambisonic attribute: ACN Component Ordering"]
pub const OH_AmbAttributeSet_AMB_COM_ACN: OH_AmbAttributeSet = 0;
#[doc = " Ambisonic attribute: FUMA Component Ordering"]
pub const OH_AmbAttributeSet_AMB_COM_FUMA: OH_AmbAttributeSet = 256;
#[doc = " Ambisonic attribute: N3D Normalization"]
pub const OH_AmbAttributeSet_AMB_NOR_N3D: OH_AmbAttributeSet = 0;
#[doc = " Ambisonic attribute: SN3D Normalization"]
pub const OH_AmbAttributeSet_AMB_NOR_SN3D: OH_AmbAttributeSet = 4096;
#[doc = " Channel layout: Ambisonic mode"]
pub const OH_AmbAttributeSet_AMB_MODE: OH_AmbAttributeSet = 17592186044416;
#[doc = " @brief Ambisonic attribute set.\n\n A set of 64-bit integers indicate the ambisonic attributes.\n @syscap SystemCapability.Multimedia.Media.Core\n @since 11"]
pub type OH_AmbAttributeSet = u64;
#[doc = " Unknown Channel Layout"]
pub const OH_AudioChannelLayout_CH_LAYOUT_UNKNOWN: OH_AudioChannelLayout = 0;
#[doc = " Channel Layout For Mono, 1 channel in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_MONO: OH_AudioChannelLayout = 4;
#[doc = " Channel Layout For Stereo, 2 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_STEREO: OH_AudioChannelLayout = 3;
#[doc = " Channel Layout For Stereo-Downmix, 2 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_STEREO_DOWNMIX: OH_AudioChannelLayout = 1610612736;
#[doc = " Channel Layout For 2.1, 3 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_2POINT1: OH_AudioChannelLayout = 11;
#[doc = " Channel Layout For 3.0, 3 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_3POINT0: OH_AudioChannelLayout = 259;
#[doc = " Channel Layout For Surround, 3 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_SURROUND: OH_AudioChannelLayout = 7;
#[doc = " Channel Layout For 3.1, 4 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_3POINT1: OH_AudioChannelLayout = 15;
#[doc = " Channel Layout For 4.0, 4 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_4POINT0: OH_AudioChannelLayout = 263;
#[doc = " Channel Layout For Quad-Side, 4 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_QUAD_SIDE: OH_AudioChannelLayout = 1539;
#[doc = " Channel Layout For Quad, 4 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_QUAD: OH_AudioChannelLayout = 51;
#[doc = " Channel Layout For 2.0.2, 4 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_2POINT0POINT2: OH_AudioChannelLayout = 206158430211;
#[doc = " Channel Layout For ORDER1-ACN-N3D First Order Ambisonic(FOA), 4 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_AMB_ORDER1_ACN_N3D: OH_AudioChannelLayout =
    17592186044417;
#[doc = " Channel Layout For ORDER1-ACN-SN3D FOA, 4 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_AMB_ORDER1_ACN_SN3D: OH_AudioChannelLayout =
    17592186048513;
#[doc = " Channel Layout For ORDER1-FUMA FOA, 4 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_AMB_ORDER1_FUMA: OH_AudioChannelLayout = 17592186044673;
#[doc = " Channel Layout For 4.1, 5 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_4POINT1: OH_AudioChannelLayout = 271;
#[doc = " Channel Layout For 5.0, 5 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_5POINT0: OH_AudioChannelLayout = 1543;
#[doc = " Channel Layout For 5.0-Back, 5 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_5POINT0_BACK: OH_AudioChannelLayout = 55;
#[doc = " Channel Layout For 2.1.2, 5 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_2POINT1POINT2: OH_AudioChannelLayout = 206158430219;
#[doc = " Channel Layout For 3.0.2, 5 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_3POINT0POINT2: OH_AudioChannelLayout = 206158430215;
#[doc = " Channel Layout For 5.1, 6 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_5POINT1: OH_AudioChannelLayout = 1551;
#[doc = " Channel Layout For 5.1-Back, 6 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_5POINT1_BACK: OH_AudioChannelLayout = 63;
#[doc = " Channel Layout For 6.0, 6 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_6POINT0: OH_AudioChannelLayout = 1799;
#[doc = " Channel Layout For 3.1.2, 6 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_3POINT1POINT2: OH_AudioChannelLayout = 20495;
#[doc = " Channel Layout For 6.0-Front, 6 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_6POINT0_FRONT: OH_AudioChannelLayout = 1731;
#[doc = " Channel Layout For Hexagonal, 6 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_HEXAGONAL: OH_AudioChannelLayout = 311;
#[doc = " Channel Layout For 6.1, 7 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_6POINT1: OH_AudioChannelLayout = 1807;
#[doc = " Channel Layout For 6.1-Back, 7 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_6POINT1_BACK: OH_AudioChannelLayout = 319;
#[doc = " Channel Layout For 6.1-Front, 7 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_6POINT1_FRONT: OH_AudioChannelLayout = 1739;
#[doc = " Channel Layout For 7.0, 7 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_7POINT0: OH_AudioChannelLayout = 1591;
#[doc = " Channel Layout For 7.0-Front, 7 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_7POINT0_FRONT: OH_AudioChannelLayout = 1735;
#[doc = " Channel Layout For 7.1, 8 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_7POINT1: OH_AudioChannelLayout = 1599;
#[doc = " Channel Layout For Octagonal, 8 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_OCTAGONAL: OH_AudioChannelLayout = 1847;
#[doc = " Channel Layout For 5.1.2, 8 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_5POINT1POINT2: OH_AudioChannelLayout = 206158431759;
#[doc = " Channel Layout For 7.1-Wide, 8 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_7POINT1_WIDE: OH_AudioChannelLayout = 1743;
#[doc = " Channel Layout For 7.1-Wide-Back, 8 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_7POINT1_WIDE_BACK: OH_AudioChannelLayout = 255;
#[doc = " Channel Layout For ORDER2-ACN-N3D Higher Order Ambisonics(HOA), 9 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_AMB_ORDER2_ACN_N3D: OH_AudioChannelLayout =
    17592186044418;
#[doc = " Channel Layout For ORDER2-ACN-SN3D HOA, 9 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_AMB_ORDER2_ACN_SN3D: OH_AudioChannelLayout =
    17592186048514;
#[doc = " Channel Layout For ORDER2-FUMA HOA, 9 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_AMB_ORDER2_FUMA: OH_AudioChannelLayout = 17592186044674;
#[doc = " Channel Layout For 5.1.4, 10 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_5POINT1POINT4: OH_AudioChannelLayout = 185871;
#[doc = " Channel Layout For 7.1.2, 10 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_7POINT1POINT2: OH_AudioChannelLayout = 206158431807;
#[doc = " Channel Layout For 7.1.4, 12 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_7POINT1POINT4: OH_AudioChannelLayout = 185919;
#[doc = " Channel Layout For 10.2, 12 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_10POINT2: OH_AudioChannelLayout = 6442473271;
#[doc = " Channel Layout For 9.1.4, 14 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_9POINT1POINT4: OH_AudioChannelLayout = 6442636863;
#[doc = " Channel Layout For 9.1.6, 16 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_9POINT1POINT6: OH_AudioChannelLayout = 212601067071;
#[doc = " Channel Layout For Hexadecagonal, 16 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_HEXADECAGONAL: OH_AudioChannelLayout = 6442710839;
#[doc = " Channel Layout For ORDER3-ACN-N3D HOA, 16 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_AMB_ORDER3_ACN_N3D: OH_AudioChannelLayout =
    17592186044419;
#[doc = " Channel Layout For ORDER3-ACN-SN3D HOA, 16 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_AMB_ORDER3_ACN_SN3D: OH_AudioChannelLayout =
    17592186048515;
#[doc = " Channel Layout For ORDER3-FUMA HOA, 16 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_AMB_ORDER3_FUMA: OH_AudioChannelLayout = 17592186044675;
#[doc = " Channel Layout For 22.2, 24 channels in total"]
pub const OH_AudioChannelLayout_CH_LAYOUT_22POINT2: OH_AudioChannelLayout = 2164663779327;
#[doc = " @brief Audio Channel Layout\n\n A 64-bit integer indicates that the appearance and order of the speakers for recording or playback.\n @syscap SystemCapability.Multimedia.Media.Core\n @since 11"]
pub type OH_AudioChannelLayout = u64;
#[doc = " @error The call was successful.\n\n @since 10"]
pub const OH_AudioStream_Result_AUDIOSTREAM_SUCCESS: OH_AudioStream_Result = 0;
#[doc = " @error This means that the function was executed with an invalid input parameter.\n\n @since 10"]
pub const OH_AudioStream_Result_AUDIOSTREAM_ERROR_INVALID_PARAM: OH_AudioStream_Result = 1;
#[doc = " @error Execution status exception.\n\n @since 10"]
pub const OH_AudioStream_Result_AUDIOSTREAM_ERROR_ILLEGAL_STATE: OH_AudioStream_Result = 2;
#[doc = " @error An system error has occurred.\n\n @since 10"]
pub const OH_AudioStream_Result_AUDIOSTREAM_ERROR_SYSTEM: OH_AudioStream_Result = 3;
#[doc = " @error Unsupported audio format, such as unsupported encoding type, sample format etc.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioStream_Result_AUDIOSTREAM_ERROR_UNSUPPORTED_FORMAT: OH_AudioStream_Result = 4;
#[doc = " @brief Define the result of the function execution.\n\n @since 10"]
pub type OH_AudioStream_Result = u32;
#[doc = " The type for audio stream is renderer.\n\n @since 10"]
pub const OH_AudioStream_Type_AUDIOSTREAM_TYPE_RENDERER: OH_AudioStream_Type = 1;
#[doc = " The type for audio stream is capturer.\n\n @since 10"]
pub const OH_AudioStream_Type_AUDIOSTREAM_TYPE_CAPTURER: OH_AudioStream_Type = 2;
#[doc = " @brief Define the audio stream type.\n\n @since 10"]
pub type OH_AudioStream_Type = u32;
#[doc = " Unsigned 8 format.\n\n @since 10"]
pub const OH_AudioStream_SampleFormat_AUDIOSTREAM_SAMPLE_U8: OH_AudioStream_SampleFormat = 0;
#[doc = " Signed 16 bit integer, little endian.\n\n @since 10"]
pub const OH_AudioStream_SampleFormat_AUDIOSTREAM_SAMPLE_S16LE: OH_AudioStream_SampleFormat = 1;
#[doc = " Signed 24 bit integer, little endian.\n\n @since 10"]
pub const OH_AudioStream_SampleFormat_AUDIOSTREAM_SAMPLE_S24LE: OH_AudioStream_SampleFormat = 2;
#[doc = " Signed 32 bit integer, little endian.\n\n @since 10"]
pub const OH_AudioStream_SampleFormat_AUDIOSTREAM_SAMPLE_S32LE: OH_AudioStream_SampleFormat = 3;
#[doc = " Float 32, little endian.\n\n @since 17"]
#[cfg(feature = "api-17")]
pub const OH_AudioStream_SampleFormat_AUDIOSTREAM_SAMPLE_F32LE: OH_AudioStream_SampleFormat = 4;
#[doc = " @brief Define the audio stream sample format.\n\n @since 10"]
pub type OH_AudioStream_SampleFormat = u32;
#[doc = " PCM encoding type.\n\n @since 10"]
pub const OH_AudioStream_EncodingType_AUDIOSTREAM_ENCODING_TYPE_RAW: OH_AudioStream_EncodingType =
    0;
#[doc = " AudioVivid encoding type.\n\n @since 12"]
pub const OH_AudioStream_EncodingType_AUDIOSTREAM_ENCODING_TYPE_AUDIOVIVID:
    OH_AudioStream_EncodingType = 1;
#[doc = " E_AC3 encoding type.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioStream_EncodingType_AUDIOSTREAM_ENCODING_TYPE_E_AC3: OH_AudioStream_EncodingType =
    2;
#[doc = " @brief Define the audio encoding type.\n\n @since 10"]
pub type OH_AudioStream_EncodingType = u32;
#[doc = " @brief Define the audio stream info structure, used to describe basic audio format.\n\n @since 19"]
#[cfg(feature = "api-19")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioStreamInfo {
    #[doc = " @brief Audio sampling rate.\n\n @since 19"]
    pub samplingRate: i32,
    #[doc = " @brief Audio channel layout.\n\n @since 19"]
    pub channelLayout: OH_AudioChannelLayout,
    #[doc = " @brief Audio encoding format type.\n\n @since 19"]
    pub encodingType: OH_AudioStream_EncodingType,
    #[doc = " @brief Audio sample format.\n\n @since 19"]
    pub sampleFormat: OH_AudioStream_SampleFormat,
}
#[doc = " Unknown usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_UNKNOWN: OH_AudioStream_Usage = 0;
#[doc = " Music usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_MUSIC: OH_AudioStream_Usage = 1;
#[doc = " Voice communication usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_VOICE_COMMUNICATION: OH_AudioStream_Usage = 2;
#[doc = " Voice assistant usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_VOICE_ASSISTANT: OH_AudioStream_Usage = 3;
#[doc = " Alarm usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_ALARM: OH_AudioStream_Usage = 4;
#[doc = " Voice message usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_VOICE_MESSAGE: OH_AudioStream_Usage = 5;
#[doc = " Ringtone usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_RINGTONE: OH_AudioStream_Usage = 6;
#[doc = " Notification usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_NOTIFICATION: OH_AudioStream_Usage = 7;
#[doc = " Accessibility usage, such as screen reader.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_ACCESSIBILITY: OH_AudioStream_Usage = 8;
#[doc = " Movie or video usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_MOVIE: OH_AudioStream_Usage = 10;
#[doc = " Game sound effect usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_GAME: OH_AudioStream_Usage = 11;
#[doc = " Audiobook usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_AUDIOBOOK: OH_AudioStream_Usage = 12;
#[doc = " Navigation usage.\n\n @since 10"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_NAVIGATION: OH_AudioStream_Usage = 13;
#[doc = " Video call usage.\n\n @since 12"]
pub const OH_AudioStream_Usage_AUDIOSTREAM_USAGE_VIDEO_COMMUNICATION: OH_AudioStream_Usage = 17;
#[doc = " @brief Define the audio stream usage.\n Audio stream usage is used to describe what work scenario\n the current stream is used for.\n\n @since 10"]
pub type OH_AudioStream_Usage = u32;
#[doc = " This is a normal audio scene.\n\n @since 10"]
pub const OH_AudioStream_LatencyMode_AUDIOSTREAM_LATENCY_MODE_NORMAL: OH_AudioStream_LatencyMode =
    0;
#[doc = " This is a low latency audio scene.\n\n @since 10"]
pub const OH_AudioStream_LatencyMode_AUDIOSTREAM_LATENCY_MODE_FAST: OH_AudioStream_LatencyMode = 1;
#[doc = " @brief Define the audio latency mode.\n\n @since 10"]
pub type OH_AudioStream_LatencyMode = u32;
#[doc = " Direct playback is not supported.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioStream_DirectPlaybackMode_AUDIOSTREAM_DIRECT_PLAYBACK_NOT_SUPPORTED:
    OH_AudioStream_DirectPlaybackMode = 0;
#[doc = " Direct playback mode which is bitstream pass-through such as compressed pass-through.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioStream_DirectPlaybackMode_AUDIOSTREAM_DIRECT_PLAYBACK_BITSTREAM_SUPPORTED:
    OH_AudioStream_DirectPlaybackMode = 1;
#[doc = " Direct playback mode of pcm.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioStream_DirectPlaybackMode_AUDIOSTREAM_DIRECT_PLAYBACK_PCM_SUPPORTED:
    OH_AudioStream_DirectPlaybackMode = 2;
#[doc = " @brief Enumerates audio direct playback modes.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub type OH_AudioStream_DirectPlaybackMode = u32;
#[doc = " The routing of the audio has changed.\n\n @deprecated since 20\n @useinstead OH_AudioRenderer_OutputDeviceChangeCallback.\n @since 10"]
pub const OH_AudioStream_Event_AUDIOSTREAM_EVENT_ROUTING_CHANGED: OH_AudioStream_Event = 0;
#[doc = " @brief Define the audio event.\n\n @deprecated since 20\n @useinstead OH_AudioRenderer_OutputDeviceChangeCallback.\n @since 10"]
pub type OH_AudioStream_Event = u32;
#[doc = " The invalid state.\n\n @since 10"]
pub const OH_AudioStream_State_AUDIOSTREAM_STATE_INVALID: OH_AudioStream_State = -1;
#[doc = " Create new instance state.\n\n @since 10"]
pub const OH_AudioStream_State_AUDIOSTREAM_STATE_NEW: OH_AudioStream_State = 0;
#[doc = " The prepared state.\n\n @since 10"]
pub const OH_AudioStream_State_AUDIOSTREAM_STATE_PREPARED: OH_AudioStream_State = 1;
#[doc = " The stream is running.\n\n @since 10"]
pub const OH_AudioStream_State_AUDIOSTREAM_STATE_RUNNING: OH_AudioStream_State = 2;
#[doc = " The stream is stopped.\n\n @since 10"]
pub const OH_AudioStream_State_AUDIOSTREAM_STATE_STOPPED: OH_AudioStream_State = 3;
#[doc = " The stream is released.\n\n @since 10"]
pub const OH_AudioStream_State_AUDIOSTREAM_STATE_RELEASED: OH_AudioStream_State = 4;
#[doc = " The stream is paused.\n\n @since 10"]
pub const OH_AudioStream_State_AUDIOSTREAM_STATE_PAUSED: OH_AudioStream_State = 5;
#[doc = " @brief The audio stream states\n\n @since 10"]
pub type OH_AudioStream_State = i32;
#[doc = " Force type, system change audio state.\n\n @since 10"]
pub const OH_AudioInterrupt_ForceType_AUDIOSTREAM_INTERRUPT_FORCE: OH_AudioInterrupt_ForceType = 0;
#[doc = " Share type, application change audio state.\n\n @since 10"]
pub const OH_AudioInterrupt_ForceType_AUDIOSTREAM_INTERRUPT_SHARE: OH_AudioInterrupt_ForceType = 1;
#[doc = " @brief Defines the audio interrupt type.\n\n @since 10"]
pub type OH_AudioInterrupt_ForceType = u32;
#[doc = " None.\n\n @since 10"]
pub const OH_AudioInterrupt_Hint_AUDIOSTREAM_INTERRUPT_HINT_NONE: OH_AudioInterrupt_Hint = 0;
#[doc = " Resume the stream.\n\n @since 10"]
pub const OH_AudioInterrupt_Hint_AUDIOSTREAM_INTERRUPT_HINT_RESUME: OH_AudioInterrupt_Hint = 1;
#[doc = " Pause the stream.\n\n @since 10"]
pub const OH_AudioInterrupt_Hint_AUDIOSTREAM_INTERRUPT_HINT_PAUSE: OH_AudioInterrupt_Hint = 2;
#[doc = " Stop the stream.\n\n @since 10"]
pub const OH_AudioInterrupt_Hint_AUDIOSTREAM_INTERRUPT_HINT_STOP: OH_AudioInterrupt_Hint = 3;
#[doc = " Ducked the stream.\n\n @since 10"]
pub const OH_AudioInterrupt_Hint_AUDIOSTREAM_INTERRUPT_HINT_DUCK: OH_AudioInterrupt_Hint = 4;
#[doc = " Unducked the stream.\n\n @since 10"]
pub const OH_AudioInterrupt_Hint_AUDIOSTREAM_INTERRUPT_HINT_UNDUCK: OH_AudioInterrupt_Hint = 5;
#[doc = " Mute the stream.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioInterrupt_Hint_AUDIOSTREAM_INTERRUPT_HINT_MUTE: OH_AudioInterrupt_Hint = 6;
#[doc = " Unmute the stream.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioInterrupt_Hint_AUDIOSTREAM_INTERRUPT_HINT_UNMUTE: OH_AudioInterrupt_Hint = 7;
#[doc = " @brief Defines the audio interrupt hint type.\n\n @since 10"]
pub type OH_AudioInterrupt_Hint = u32;
#[doc = " Invalid type.\n\n @since 10"]
pub const OH_AudioStream_SourceType_AUDIOSTREAM_SOURCE_TYPE_INVALID: OH_AudioStream_SourceType = -1;
#[doc = " Mic source type.\n\n @since 10"]
pub const OH_AudioStream_SourceType_AUDIOSTREAM_SOURCE_TYPE_MIC: OH_AudioStream_SourceType = 0;
#[doc = " Voice recognition source type.\n\n @since 10"]
pub const OH_AudioStream_SourceType_AUDIOSTREAM_SOURCE_TYPE_VOICE_RECOGNITION:
    OH_AudioStream_SourceType = 1;
#[doc = " Playback capture source type.\n\n @deprecated since 12\n @useinstead OH_AVScreenCapture in native interface.\n @since 10"]
pub const OH_AudioStream_SourceType_AUDIOSTREAM_SOURCE_TYPE_PLAYBACK_CAPTURE:
    OH_AudioStream_SourceType = 2;
#[doc = " Voice communication source type.\n\n @since 10"]
pub const OH_AudioStream_SourceType_AUDIOSTREAM_SOURCE_TYPE_VOICE_COMMUNICATION:
    OH_AudioStream_SourceType = 7;
#[doc = " Voice message source type.\n\n @since 12"]
pub const OH_AudioStream_SourceType_AUDIOSTREAM_SOURCE_TYPE_VOICE_MESSAGE:
    OH_AudioStream_SourceType = 10;
#[doc = " Camcorder source type.\n\n @since 13"]
#[cfg(feature = "api-13")]
pub const OH_AudioStream_SourceType_AUDIOSTREAM_SOURCE_TYPE_CAMCORDER: OH_AudioStream_SourceType =
    13;
#[doc = " Unprocessed source type.\n\n @since 14"]
#[cfg(feature = "api-14")]
pub const OH_AudioStream_SourceType_AUDIOSTREAM_SOURCE_TYPE_UNPROCESSED: OH_AudioStream_SourceType =
    14;
#[doc = " Live Broadcast source type.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioStream_SourceType_AUDIOSTREAM_SOURCE_TYPE_LIVE: OH_AudioStream_SourceType = 17;
#[doc = " @brief Defines the audio source type.\n\n @since 10"]
pub type OH_AudioStream_SourceType = i32;
#[doc = " Share mode"]
pub const OH_AudioInterrupt_Mode_AUDIOSTREAM_INTERRUPT_MODE_SHARE: OH_AudioInterrupt_Mode = 0;
#[doc = " Independent mode"]
pub const OH_AudioInterrupt_Mode_AUDIOSTREAM_INTERRUPT_MODE_INDEPENDENT: OH_AudioInterrupt_Mode = 1;
#[doc = " @brief Defines the audio interrupt mode.\n\n @since 12"]
pub type OH_AudioInterrupt_Mode = u32;
#[doc = " Audio Effect Mode effect none.\n\n @since 12"]
pub const OH_AudioStream_AudioEffectMode_EFFECT_NONE: OH_AudioStream_AudioEffectMode = 0;
#[doc = " Audio Effect Mode effect default.\n\n @since 12"]
pub const OH_AudioStream_AudioEffectMode_EFFECT_DEFAULT: OH_AudioStream_AudioEffectMode = 1;
#[doc = " @brief Defines the audio effect mode.\n\n @since 12"]
pub type OH_AudioStream_AudioEffectMode = u32;
#[doc = " normal status"]
#[cfg(feature = "api-20")]
pub const OH_AudioStream_FastStatus_AUDIOSTREAM_FASTSTATUS_NORMAL: OH_AudioStream_FastStatus = 0;
#[doc = " fast status"]
#[cfg(feature = "api-20")]
pub const OH_AudioStream_FastStatus_AUDIOSTREAM_FASTSTATUS_FAST: OH_AudioStream_FastStatus = 1;
#[doc = " @brief Defines the fast status.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioStream_FastStatus = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioStreamBuilderStruct {
    _unused: [u8; 0],
}
#[doc = " @brief Declaring the audio stream builder.\n The instance of builder is used for creating audio stream.\n\n @since 10"]
pub type OH_AudioStreamBuilder = OH_AudioStreamBuilderStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioRendererStruct {
    _unused: [u8; 0],
}
#[doc = " @brief Declaring the audio renderer stream.\n The instance of renderer stream is used for playing audio data.\n\n @since 10"]
pub type OH_AudioRenderer = OH_AudioRendererStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioCapturerStruct {
    _unused: [u8; 0],
}
#[doc = " @brief Declaring the audio capturer stream.\n The instance of renderer stream is used for capturing audio data.\n\n @since 10"]
pub type OH_AudioCapturer = OH_AudioCapturerStruct;
#[doc = " @brief Declaring the callback struct for renderer stream.\n\n @deprecated since 20\n @useinstead Use the callback type: OH_AudioRenderer_OnWriteDataCallback, OH_AudioRenderer_OutputDeviceChangeCallback,\n OH_AudioRenderer_OnInterruptEvent, OH_AudioRenderer_OnErrorCallback separately.\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioRenderer_Callbacks_Struct {
    #[doc = " This function pointer will point to the callback function that\n is used to write audio data\n\n @deprecated since 20\n @useinstead OH_AudioRenderer_OnWriteDataCallback.\n @since 10"]
    pub OH_AudioRenderer_OnWriteData: ::std::option::Option<
        unsafe extern "C" fn(
            renderer: *mut OH_AudioRenderer,
            userData: *mut ::std::os::raw::c_void,
            buffer: *mut ::std::os::raw::c_void,
            length: i32,
        ) -> i32,
    >,
    #[doc = " This function pointer will point to the callback function that\n is used to handle audio renderer stream events.\n\n @deprecated since 20\n @useinstead OH_AudioRenderer_OutputDeviceChangeCallback.\n @since 10"]
    pub OH_AudioRenderer_OnStreamEvent: ::std::option::Option<
        unsafe extern "C" fn(
            renderer: *mut OH_AudioRenderer,
            userData: *mut ::std::os::raw::c_void,
            event: OH_AudioStream_Event,
        ) -> i32,
    >,
    #[doc = " This function pointer will point to the callback function that\n is used to handle audio interrupt events.\n\n @deprecated since 20\n @useinstead OH_AudioRenderer_OnInterruptCallback.\n @since 10"]
    pub OH_AudioRenderer_OnInterruptEvent: ::std::option::Option<
        unsafe extern "C" fn(
            renderer: *mut OH_AudioRenderer,
            userData: *mut ::std::os::raw::c_void,
            type_: OH_AudioInterrupt_ForceType,
            hint: OH_AudioInterrupt_Hint,
        ) -> i32,
    >,
    #[doc = " This function pointer will point to the callback function that\n is used to handle audio error result.\n\n @deprecated since 20\n @useinstead OH_AudioRenderer_OnErrorCallback.\n @since 10"]
    pub OH_AudioRenderer_OnError: ::std::option::Option<
        unsafe extern "C" fn(
            renderer: *mut OH_AudioRenderer,
            userData: *mut ::std::os::raw::c_void,
            error: OH_AudioStream_Result,
        ) -> i32,
    >,
}
#[doc = " @brief Declaring the callback struct for renderer stream.\n\n @deprecated since 20\n @useinstead Use the callback type: OH_AudioRenderer_OnWriteDataCallback, OH_AudioRenderer_OutputDeviceChangeCallback,\n OH_AudioRenderer_OnInterruptEvent, OH_AudioRenderer_OnErrorCallback separately.\n @since 10"]
pub type OH_AudioRenderer_Callbacks = OH_AudioRenderer_Callbacks_Struct;
#[doc = " @brief Declaring the callback struct for capturer stream.\n\n @deprecated since 20\n @useinstead Use the callback type: OH_AudioCapturer_OnReadDataCallback, OH_AudioCapturer_OnDeviceChangeCallback,\n OH_AudioCapturer_OnInterruptCallback and OH_AudioCapturer_OnErrorCallback separately.\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioCapturer_Callbacks_Struct {
    #[doc = " This function pointer will point to the callback function that\n is used to read audio data.\n\n @deprecated since 20\n @useinstead OH_AudioCapturer_OnReadDataCallback\n @since 10"]
    pub OH_AudioCapturer_OnReadData: ::std::option::Option<
        unsafe extern "C" fn(
            capturer: *mut OH_AudioCapturer,
            userData: *mut ::std::os::raw::c_void,
            buffer: *mut ::std::os::raw::c_void,
            length: i32,
        ) -> i32,
    >,
    #[doc = " This function pointer will point to the callback function that\n is used to handle audio capturer stream events.\n\n @deprecated since 20\n @useinstead OH_AudioRenderer_OutputDeviceChangeCallback\n @since 10"]
    pub OH_AudioCapturer_OnStreamEvent: ::std::option::Option<
        unsafe extern "C" fn(
            capturer: *mut OH_AudioCapturer,
            userData: *mut ::std::os::raw::c_void,
            event: OH_AudioStream_Event,
        ) -> i32,
    >,
    #[doc = " This function pointer will point to the callback function that\n is used to handle audio interrupt events.\n\n @deprecated since 20\n @useinstead OH_AudioCapturer_OnInterruptCallback\n @since 10"]
    pub OH_AudioCapturer_OnInterruptEvent: ::std::option::Option<
        unsafe extern "C" fn(
            capturer: *mut OH_AudioCapturer,
            userData: *mut ::std::os::raw::c_void,
            type_: OH_AudioInterrupt_ForceType,
            hint: OH_AudioInterrupt_Hint,
        ) -> i32,
    >,
    #[doc = " This function pointer will point to the callback function that\n is used to handle audio error result.\n\n @deprecated since 20\n @useinstead OH_AudioCapturer_OnErrorCallback\n @since 10"]
    pub OH_AudioCapturer_OnError: ::std::option::Option<
        unsafe extern "C" fn(
            capturer: *mut OH_AudioCapturer,
            userData: *mut ::std::os::raw::c_void,
            error: OH_AudioStream_Result,
        ) -> i32,
    >,
}
#[doc = " @brief Declaring the callback struct for capturer stream.\n\n @deprecated since 20\n @useinstead Use the callback type: OH_AudioCapturer_OnReadDataCallback, OH_AudioCapturer_OnDeviceChangeCallback,\n OH_AudioCapturer_OnInterruptCallback and OH_AudioCapturer_OnErrorCallback separately.\n @since 10"]
pub type OH_AudioCapturer_Callbacks = OH_AudioCapturer_Callbacks_Struct;
pub const OH_AudioStream_DeviceChangeReason_REASON_UNKNOWN: OH_AudioStream_DeviceChangeReason = 0;
pub const OH_AudioStream_DeviceChangeReason_REASON_NEW_DEVICE_AVAILABLE:
    OH_AudioStream_DeviceChangeReason = 1;
pub const OH_AudioStream_DeviceChangeReason_REASON_OLD_DEVICE_UNAVAILABLE:
    OH_AudioStream_DeviceChangeReason = 2;
pub const OH_AudioStream_DeviceChangeReason_REASON_OVERRODE: OH_AudioStream_DeviceChangeReason = 3;
#[doc = " @brief Device information when the audio session is activated.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioStream_DeviceChangeReason_REASON_SESSION_ACTIVATED:
    OH_AudioStream_DeviceChangeReason = 4;
#[doc = " @brief There is a higher-priority stream, causing the system device to change.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioStream_DeviceChangeReason_REASON_STREAM_PRIORITY_CHANGED:
    OH_AudioStream_DeviceChangeReason = 5;
#[doc = " @brief Defines reason for device changes of one audio stream.\n\n @since 11"]
pub type OH_AudioStream_DeviceChangeReason = u32;
#[doc = " @brief Callback when the output device of an audio renderer changed.\n\n @param renderer AudioRenderer where this event occurs.\n @param userData User data which is passed by user.\n @param reason Indicates that why does the output device changes.\n @since 11"]
pub type OH_AudioRenderer_OutputDeviceChangeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *mut OH_AudioRenderer,
        userData: *mut ::std::os::raw::c_void,
        reason: OH_AudioStream_DeviceChangeReason,
    ),
>;
#[doc = " @brief Callback when the mark position reached.\n\n @param renderer AudioRenderer where this event occurs.\n @param samplePos Mark position in samples.\n @param userData User data which is passed by user.\n @since 12"]
pub type OH_AudioRenderer_OnMarkReachedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *mut OH_AudioRenderer,
        samplePos: u32,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief This function pointer will point to the callback function that\n is used to write audio data with metadata\n\n @param renderer AudioRenderer where this event occurs.\n @param userData User data which is passed by user.\n @param audioData Audio data which is written by user.\n @param audioDataSize Audio data size which is the size of audio data written by user.\n @param metadata Metadata which is written by user.\n @param metadataSize Metadata size which is the size of metadata written by user.\n @return Error code of the callback function returned by user.\n @since 12"]
pub type OH_AudioRenderer_WriteDataWithMetadataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *mut OH_AudioRenderer,
        userData: *mut ::std::os::raw::c_void,
        audioData: *mut ::std::os::raw::c_void,
        audioDataSize: i32,
        metadata: *mut ::std::os::raw::c_void,
        metadataSize: i32,
    ) -> i32,
>;
#[doc = " Privacy type that stream can be captured by third party applications.\n @since 12"]
pub const OH_AudioStream_PrivacyType_AUDIO_STREAM_PRIVACY_TYPE_PUBLIC: OH_AudioStream_PrivacyType =
    0;
#[doc = " Privacy type that stream can not be captured.\n @since 12"]
pub const OH_AudioStream_PrivacyType_AUDIO_STREAM_PRIVACY_TYPE_PRIVATE: OH_AudioStream_PrivacyType =
    1;
#[doc = " Privacy type that stream can be safely captured and screen casting.\n For example,{@link OH_AudioStream_Usage#AUDIOSTREAM_USAGE_VOICE_COMMUNICATION} will not be\n captured or screen casted by third party applications under AUDIO_STREAM_PRIVACY_TYPE_PUBLIC policy.\n However, the internal capture is allowed under the AUDIO_STREAM_PRIVACY_TYPE_SHARED policy.\n @since 21"]
#[cfg(feature = "api-21")]
pub const OH_AudioStream_PrivacyType_AUDIO_STREAM_PRIVACY_TYPE_SHARED: OH_AudioStream_PrivacyType =
    2;
#[doc = " @brief Defines Enumeration of audio stream privacy type for playback capture.\n\n @since 12"]
pub type OH_AudioStream_PrivacyType = u32;
#[doc = " Result of audio data callabck is invalid."]
pub const OH_AudioData_Callback_Result_AUDIO_DATA_CALLBACK_RESULT_INVALID:
    OH_AudioData_Callback_Result = -1;
#[doc = " Result of audio data callabck is valid."]
pub const OH_AudioData_Callback_Result_AUDIO_DATA_CALLBACK_RESULT_VALID:
    OH_AudioData_Callback_Result = 0;
#[doc = " @brief Defines enumeration of audio data callback result.\n\n @since 12"]
pub type OH_AudioData_Callback_Result = i32;
#[doc = " @brief Callback function of  write data.\n\n This function is similar with OH_AudioRenderer_Callbacks_Struct.OH_AudioRenderer_OnWriteData instead of the return\n value. The return result of this function indicates whether the data filled in the buffer is valid or invalid. If\n result is invalid, the data filled by user will not be played.\n\n @param renderer AudioRenderer where this callback occurs.\n @param userData User data which is passed by user.\n @param audioData Audio data pointer, where user should fill in audio data.\n @param audioDataSize Size of audio data that user should fill in.\n @return Audio Data callback result.\n @see OH_AudioRenderer_Callbacks_Struct.OH_AudioRenderer_OnWriteData\n @since 12"]
pub type OH_AudioRenderer_OnWriteDataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *mut OH_AudioRenderer,
        userData: *mut ::std::os::raw::c_void,
        audioData: *mut ::std::os::raw::c_void,
        audioDataSize: i32,
    ) -> OH_AudioData_Callback_Result,
>;
#[doc = " Indicates this audio stream volume will be affected by system volume, also the default behavior.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioStream_VolumeMode_AUDIOSTREAM_VOLUMEMODE_SYSTEM_GLOBAL:
    OH_AudioStream_VolumeMode = 0;
#[doc = " Indicates this audio stream volume will be affected by app's individual volume percentage which set by yourself\n using the app volume api.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioStream_VolumeMode_AUDIOSTREAM_VOLUMEMODE_APP_INDIVIDUAL:
    OH_AudioStream_VolumeMode = 1;
#[doc = " @brief Define the audio stream volume mode.\n\n @since 19"]
#[cfg(feature = "api-19")]
pub type OH_AudioStream_VolumeMode = u32;
#[doc = " @error The call was successful."]
pub const OH_AudioCommon_Result_AUDIOCOMMON_RESULT_SUCCESS: OH_AudioCommon_Result = 0;
#[doc = " @error This means that the input parameter is invalid."]
pub const OH_AudioCommon_Result_AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM: OH_AudioCommon_Result =
    6800101;
#[doc = " @error This means there is no memory left."]
pub const OH_AudioCommon_Result_AUDIOCOMMON_RESULT_ERROR_NO_MEMORY: OH_AudioCommon_Result = 6800102;
#[doc = " @error Execution status exception."]
pub const OH_AudioCommon_Result_AUDIOCOMMON_RESULT_ERROR_ILLEGAL_STATE: OH_AudioCommon_Result =
    6800103;
#[doc = " @error This means the operation is unsupported."]
pub const OH_AudioCommon_Result_AUDIOCOMMON_RESULT_ERROR_UNSUPPORTED: OH_AudioCommon_Result =
    6800104;
#[doc = " @error This means the operation is timeout."]
pub const OH_AudioCommon_Result_AUDIOCOMMON_RESULT_ERROR_TIMEOUT: OH_AudioCommon_Result = 6800105;
#[doc = " @error This means reached stream limit."]
pub const OH_AudioCommon_Result_AUDIOCOMMON_RESULT_ERROR_STREAM_LIMIT: OH_AudioCommon_Result =
    6800201;
#[doc = " @error An system error has occurred."]
pub const OH_AudioCommon_Result_AUDIOCOMMON_RESULT_ERROR_SYSTEM: OH_AudioCommon_Result = 6800301;
#[doc = " @brief Define the result of the function execution.\n\n @since 12"]
pub type OH_AudioCommon_Result = u32;
#[doc = " Default audio scene.\n\n @since 12"]
pub const OH_AudioScene_AUDIO_SCENE_DEFAULT: OH_AudioScene = 0;
#[doc = " Ringing scene.\n\n @since 12"]
pub const OH_AudioScene_AUDIO_SCENE_RINGING: OH_AudioScene = 1;
#[doc = " Phone call scene.\n\n @since 12"]
pub const OH_AudioScene_AUDIO_SCENE_PHONE_CALL: OH_AudioScene = 2;
#[doc = " Voice chat scene.\n\n @since 12"]
pub const OH_AudioScene_AUDIO_SCENE_VOICE_CHAT: OH_AudioScene = 3;
#[doc = " @brief Defines the audio scene.\n\n @since 12"]
pub type OH_AudioScene = u32;
#[doc = " Silent ringer mode.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioRingerMode_AUDIO_RINGER_MODE_SILENT: OH_AudioRingerMode = 0;
#[doc = " Vibrate ringer mode.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioRingerMode_AUDIO_RINGER_MODE_VIBRATE: OH_AudioRingerMode = 1;
#[doc = " Normal ringer mode.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioRingerMode_AUDIO_RINGER_MODE_NORMAL: OH_AudioRingerMode = 2;
#[doc = " @brief Defines the ringer mode.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioRingerMode = u32;
#[doc = " @brief Device connection."]
pub const OH_AudioDevice_ChangeType_AUDIO_DEVICE_CHANGE_TYPE_CONNECT: OH_AudioDevice_ChangeType = 0;
#[doc = " @brief Device disconnection."]
pub const OH_AudioDevice_ChangeType_AUDIO_DEVICE_CHANGE_TYPE_DISCONNECT: OH_AudioDevice_ChangeType =
    1;
#[doc = " @brief Defines the audio device change type.\n\n @since 12"]
pub type OH_AudioDevice_ChangeType = u32;
#[doc = " @brief Input role."]
pub const OH_AudioDevice_Role_AUDIO_DEVICE_ROLE_INPUT: OH_AudioDevice_Role = 1;
#[doc = " @brief Output role."]
pub const OH_AudioDevice_Role_AUDIO_DEVICE_ROLE_OUTPUT: OH_AudioDevice_Role = 2;
#[doc = " @brief Defines the audio device device role.\n\n @since 12"]
pub type OH_AudioDevice_Role = u32;
#[doc = " @brief Invalid device."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_INVALID: OH_AudioDevice_Type = 0;
#[doc = " @brief Built-in earpiece."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_EARPIECE: OH_AudioDevice_Type = 1;
#[doc = " @brief Built-in speaker."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_SPEAKER: OH_AudioDevice_Type = 2;
#[doc = " @brief Wired headset, which is a combination of a pair of earpieces and a microphone."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_WIRED_HEADSET: OH_AudioDevice_Type = 3;
#[doc = " @brief A pair of wired headphones."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_WIRED_HEADPHONES: OH_AudioDevice_Type = 4;
#[doc = " @brief Bluetooth device using the synchronous connection oriented link (SCO)."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_BLUETOOTH_SCO: OH_AudioDevice_Type = 7;
#[doc = " @brief Bluetooth device using advanced audio distibution profile (A2DP)."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_BLUETOOTH_A2DP: OH_AudioDevice_Type = 8;
#[doc = " @brief Built-in microphone."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_MIC: OH_AudioDevice_Type = 15;
#[doc = " @brief USB audio headset."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_USB_HEADSET: OH_AudioDevice_Type = 22;
#[doc = " @brief Display port device."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_DISPLAY_PORT: OH_AudioDevice_Type = 23;
#[doc = " @brief Device type for rerouting audio to other remote devices by system application."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_REMOTE_CAST: OH_AudioDevice_Type = 24;
#[doc = " @brief Usb audio device.\n\n @since 18"]
#[cfg(feature = "api-18")]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_USB_DEVICE: OH_AudioDevice_Type = 25;
#[doc = " @brief Accessory device, such as the microphone on a remote control.\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_ACCESSORY: OH_AudioDevice_Type = 26;
#[doc = " @brief HDMI device, such as a device connected through an HDMI, ARC, or eARC interface.\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_HDMI: OH_AudioDevice_Type = 27;
#[doc = " @brief Line-connected, digital audio output device, such as an S/PDIF device.\n @since 19"]
#[cfg(feature = "api-19")]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_LINE_DIGITAL: OH_AudioDevice_Type = 28;
#[doc = " @brief Hearing aid device.\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_HEARING_AID: OH_AudioDevice_Type = 30;
#[doc = " @brief Nearlink device.\n @since 20"]
#[cfg(feature = "api-20")]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_NEARLINK: OH_AudioDevice_Type = 31;
#[doc = " @brief Default device type."]
pub const OH_AudioDevice_Type_AUDIO_DEVICE_TYPE_DEFAULT: OH_AudioDevice_Type = 1000;
#[doc = " @brief Defines the audio device device type.\n\n @since 12"]
pub type OH_AudioDevice_Type = u32;
#[doc = " @brief None device."]
pub const OH_AudioDevice_Flag_AUDIO_DEVICE_FLAG_NONE: OH_AudioDevice_Flag = 0;
#[doc = " @brief Output device."]
pub const OH_AudioDevice_Flag_AUDIO_DEVICE_FLAG_OUTPUT: OH_AudioDevice_Flag = 1;
#[doc = " @brief Input device."]
pub const OH_AudioDevice_Flag_AUDIO_DEVICE_FLAG_INPUT: OH_AudioDevice_Flag = 2;
#[doc = " @brief All device."]
pub const OH_AudioDevice_Flag_AUDIO_DEVICE_FLAG_ALL: OH_AudioDevice_Flag = 3;
#[doc = " @brief Defines the audio device flag.\n\n @since 12"]
pub type OH_AudioDevice_Flag = u32;
#[doc = " @brief Device used for media ouput.\n\n @since 12"]
pub const OH_AudioDevice_Usage_AUDIO_DEVICE_USAGE_MEDIA_OUTPUT: OH_AudioDevice_Usage = 1;
#[doc = " @brief Device used for media input.\n\n @since 12"]
pub const OH_AudioDevice_Usage_AUDIO_DEVICE_USAGE_MEDIA_INPUT: OH_AudioDevice_Usage = 2;
#[doc = " @brief Device used for media, including input and output.\n\n @since 12"]
pub const OH_AudioDevice_Usage_AUDIO_DEVICE_USAGE_MEDIA_ALL: OH_AudioDevice_Usage = 3;
#[doc = " @brief Device used for call output.\n\n @since 12"]
pub const OH_AudioDevice_Usage_AUDIO_DEVICE_USAGE_CALL_OUTPUT: OH_AudioDevice_Usage = 4;
#[doc = " @brief Device used for call input.\n\n @since 12"]
pub const OH_AudioDevice_Usage_AUDIO_DEVICE_USAGE_CALL_INPUT: OH_AudioDevice_Usage = 8;
#[doc = " @brief Device used for call, including input and output.\n\n @since 12"]
pub const OH_AudioDevice_Usage_AUDIO_DEVICE_USAGE_CALL_ALL: OH_AudioDevice_Usage = 12;
#[doc = " @brief Defines the audio device usage.\n\n @since 12"]
pub type OH_AudioDevice_Usage = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioDeviceDescriptor {
    _unused: [u8; 0],
}
#[doc = " @brief Declaring the audio device descriptor array.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioDeviceDescriptorArray {
    #[doc = " @brief Audio device descriptor array size."]
    pub size: u32,
    #[doc = " @brief Audio device descriptor array."]
    pub descriptors: *mut *mut OH_AudioDeviceDescriptor,
}
#[doc = " @brief Audio device is unblocked.\n\n @since 13"]
#[cfg(feature = "api-13")]
pub const OH_AudioDevice_BlockStatus_AUDIO_DEVICE_UNBLOCKED: OH_AudioDevice_BlockStatus = 0;
#[doc = " @brief Audio Device is blocked.\n\n @since 13"]
#[cfg(feature = "api-13")]
pub const OH_AudioDevice_BlockStatus_AUDIO_DEVICE_BLOCKED: OH_AudioDevice_BlockStatus = 1;
#[doc = " @brief Declaring the audio device blocked status. By default, the audio device is considered as unbloked.\n\n @since 13"]
#[cfg(feature = "api-13")]
pub type OH_AudioDevice_BlockStatus = u32;
extern "C" {
    #[doc = " @brief Query the device role of the target audio device descriptor.\n\n @param audioDeviceDescriptor reference returned by {@link OH_AudioRoutingManager_GetDevices} or\n {@link OH_AudioRouterManager_OnDeviceChangedCallback}.\n @param deviceRole the pointer {@link OH_AudioDevice_DeviceRole} variable that will be set the device role value.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}.\n @since 12"]
    pub fn OH_AudioDeviceDescriptor_GetDeviceRole(
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
        deviceRole: *mut OH_AudioDevice_Role,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query the device type of the target audio device descriptor.\n\n @param audioDeviceDescriptor reference returned by {@link OH_AudioRoutingManager_GetDevices} or\n {@link OH_AudioRouterManager_OnDeviceChangedCallback}.\n @param deviceType the pointer {@link OH_AudioDevice_DeviceType}\n pointer variable that will be set the device type value.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}.\n @since 12"]
    pub fn OH_AudioDeviceDescriptor_GetDeviceType(
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
        deviceType: *mut OH_AudioDevice_Type,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query the device id of the target audio device descriptor.\n\n @param audioDeviceDescriptor reference returned by {@link OH_AudioRoutingManager_GetDevices} or\n {@link OH_AudioRouterManager_OnDeviceChangedCallback}.\n @param id pointer variable that will be set the device id value.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}.\n @since 12"]
    pub fn OH_AudioDeviceDescriptor_GetDeviceId(
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
        id: *mut u32,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query the device name of the target audio device descriptor.\n\n @param audioDeviceDescriptor reference returned by {@link OH_AudioRoutingManager_GetDevices} or\n {@link OH_AudioRouterManager_OnDeviceChangedCallback}.\n @param name pointer variable that will be set the device name value.\n Do not release the name pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}.\n @since 12"]
    pub fn OH_AudioDeviceDescriptor_GetDeviceName(
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
        name: *mut *mut ::std::os::raw::c_char,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query the device address of the target audio device descriptor.\n\n @param audioDeviceDescriptor reference returned by {@link OH_AudioRoutingManager_GetDevices} or\n {@link OH_AudioRouterManager_OnDeviceChangedCallback}.\n @param address pointer variable that will be set the device address value.\n Do not release the address pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}.\n @since 12"]
    pub fn OH_AudioDeviceDescriptor_GetDeviceAddress(
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
        address: *mut *mut ::std::os::raw::c_char,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query the sample rate array of the target audio device descriptor.\n\n @param audioDeviceDescriptor reference returned by {@link OH_AudioRoutingManager_GetDevices} or\n {@link OH_AudioRouterManager_OnDeviceChangedCallback}.\n @param sampleRates array pointer variable that will be set the sample rate array value.\n Do not release the sampleRates pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @param size pointer variable that will be set the sample rate size value.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}.\n @since 12"]
    pub fn OH_AudioDeviceDescriptor_GetDeviceSampleRates(
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
        sampleRates: *mut *mut u32,
        size: *mut u32,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query the device channel count array of the target audio device descriptor.\n\n @param audioDeviceDescriptor reference returned by {@link OH_AudioRoutingManager_GetDevices} or\n {@link OH_AudioRouterManager_OnDeviceChangedCallback}.\n @param channelCounts array pointer variable that will be set the channel count array value.\n Do not release the channelCounts pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @param size pointer variable that will be set the channel count size value.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}.\n @since 12"]
    pub fn OH_AudioDeviceDescriptor_GetDeviceChannelCounts(
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
        channelCounts: *mut *mut u32,
        size: *mut u32,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query the display name of the target audio device descriptor.\n\n @param audioDeviceDescriptor reference returned by {@link OH_AudioRoutingManager_GetDevices} or\n {@link OH_AudioRouterManager_OnDeviceChangedCallback}.\n @param displayName pointer variable that will be set the display name value.\n Do not release the displayName pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}.\n @since 12"]
    pub fn OH_AudioDeviceDescriptor_GetDeviceDisplayName(
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
        displayName: *mut *mut ::std::os::raw::c_char,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query the encoding type array of the target audio device descriptor.\n\n @param audioDeviceDescriptor reference returned by {@link OH_AudioRoutingManager_GetDevices} or\n {@link OH_AudioRouterManager_OnDeviceChangedCallback}.\n @param encodingTypes the {@link OH_AudioStream_EncodingType}\n Do not release the encodingTypes pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @param size pointer variable that will be set the encoding type size value.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}.\n @since 12"]
    pub fn OH_AudioDeviceDescriptor_GetDeviceEncodingTypes(
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
        encodingTypes: *mut *mut OH_AudioStream_EncodingType,
        size: *mut u32,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " Request to release the capturer stream.\n\n @since 10\n @permission ohos.permission.MICROPHONE\n\n @param capturer reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioCapturer_Release(capturer: *mut OH_AudioCapturer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Request to start the capturer stream.\n\n @since 10\n @permission ohos.permission.MICROPHONE\n\n @param capturer reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioCapturer_Start(capturer: *mut OH_AudioCapturer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Request to pause the capturer stream.\n\n @since 10\n @permission ohos.permission.MICROPHONE\n\n @param capturer reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioCapturer_Pause(capturer: *mut OH_AudioCapturer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Request to stop the capturer stream.\n\n @since 10\n @permission ohos.permission.MICROPHONE\n\n @param capturer reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioCapturer_Stop(capturer: *mut OH_AudioCapturer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Request to flush the capturer stream.\n\n @since 10\n\n @param capturer reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioCapturer_Flush(capturer: *mut OH_AudioCapturer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the current state of the capturer client.\n\n This function will return the capturer state without updating the state.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param state Pointer to a variable that will be set for the state value.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetCurrentState(
        capturer: *mut OH_AudioCapturer,
        state: *mut OH_AudioStream_State,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the latency mode of the capturer client.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param latencyMode Pointer to a variable that will be set for the latency mode.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetLatencyMode(
        capturer: *mut OH_AudioCapturer,
        latencyMode: *mut OH_AudioStream_LatencyMode,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the stream id of the capturer client.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param streamId Pointer to a variable that will be set for the stream id.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetStreamId(
        capturer: *mut OH_AudioCapturer,
        streamId: *mut u32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the sample rate value of the capturer client.\n\n This function will return the capturer sample rate value without updating the state.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param rate The state value to be updated\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetSamplingRate(
        capturer: *mut OH_AudioCapturer,
        rate: *mut i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the channel count of the capturer client.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param channelCount Pointer to a variable that will be set for the channel count.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetChannelCount(
        capturer: *mut OH_AudioCapturer,
        channelCount: *mut i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the sample format of the capturer client.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param sampleFormat Pointer to a variable that will be set for the sample format.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetSampleFormat(
        capturer: *mut OH_AudioCapturer,
        sampleFormat: *mut OH_AudioStream_SampleFormat,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the encoding type of the capturer client.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param encodingType Pointer to a variable that will be set for the encoding type.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetEncodingType(
        capturer: *mut OH_AudioCapturer,
        encodingType: *mut OH_AudioStream_EncodingType,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the capturer info of the capturer client.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param sourceType Pointer to a variable that will be set for the stream sourceType.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetCapturerInfo(
        capturer: *mut OH_AudioCapturer,
        sourceType: *mut OH_AudioStream_SourceType,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the frame size in callback, it is a fixed length of the buffer returned by each callback.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param frameSize Pointer to a variable that will be set for the frame size.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioCapturer_GetFrameSizeInCallback(
        capturer: *mut OH_AudioCapturer,
        frameSize: *mut i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the the time at which a particular frame was presented\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param clockId {@link #CLOCK_MONOTONIC}\n @param framePosition Pointer to a variable to receive the position\n @param timestamp Pointer to a variable to receive the timestamp\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of capturer is nullptr;\n                                                 2.The param of clockId invalid.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioCapturer_GetTimestamp(
        capturer: *mut OH_AudioCapturer,
        clockId: clockid_t,
        framePosition: *mut i64,
        timestamp: *mut i64,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the the number of frames that have been read since the stream was created.\n\n @since 10\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer()\n @param frames Pointer to a variable that will be set for the frame count number.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetFramesRead(
        capturer: *mut OH_AudioCapturer,
        frames: *mut i64,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Gets the overflow count on this stream.\n\n @since 12\n\n @param capturer Capturer generated by OH_AudioStreamBuilder_GenerateCapturer()\n @param count Pointer to a variable that will be set for the overflow count number.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of capturer is nullptr."]
    pub fn OH_AudioCapturer_GetOverflowCount(
        capturer: *mut OH_AudioCapturer,
        count: *mut u32,
    ) -> OH_AudioStream_Result;
}
#[doc = " @brief Called when audio data is available to read. This function is similar to\n OH_AudioCapturer_Callbacks_Struct.OH_AudioCapturer_OnReadData.\n\n @param capturer Pointer to the AudioCapturer instance that triggers the callback.\n @param userData Pointer to the user data passed when setting the callback via\n OH_AudioStreamBuilder_SetCapturerReadDataCallback.\n @param audioData Pointer to the available audio data.\n @param audioDataSize Size of the available audio data.\n @see OH_AudioCapturer_Callbacks_Struct.OH_AudioCapturer_OnReadData\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioCapturer_OnReadDataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        capturer: *mut OH_AudioCapturer,
        userData: *mut ::std::os::raw::c_void,
        audioData: *mut ::std::os::raw::c_void,
        audioDataSize: i32,
    ),
>;
#[doc = " @brief Called when the input device of an AudioCapturer instance changes.\n This function is similar to OH_AudioCapturer_Callbacks_Struct.OH_AudioCapturer_OnStreamEvent.\n\n @param capturer Pointer to the AudioCapturer instance that triggers the callback.\n @param userData Pointer to the user data passed when setting the callback via\n OH_AudioStreamBuilder_SetCapturerDeviceChangeCallback.\n @param deviceArray Pointer to an array of the new input devices.\n @see OH_AudioCapturer_Callbacks_Struct.OH_AudioCapturer_OnStreamEvent\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioCapturer_OnDeviceChangeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        capturer: *mut OH_AudioCapturer,
        userData: *mut ::std::os::raw::c_void,
        deviceArray: *mut OH_AudioDeviceDescriptorArray,
    ),
>;
#[doc = " @brief Called when an interrupt event occurs in an AudioCapturer instance.\n This function is similar to OH_AudioCapturer_Callbacks_Struct.OH_AudioCapturer_OnInterruptEvent.\n\n @param capturer Pointer to the AudioCapturer instance that triggers the callback.\n @param userData Pointer to the user data passed when setting the callback via\n OH_AudioStreamBuilder_SetCapturerInterruptCallback.\n @param type Type of force that causes the interrupt event.\n @param hint Hint provided along with the interrupt event.\n @see OH_AudioCapturer_Callbacks_Struct.OH_AudioCapturer_OnInterruptEvent.\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioCapturer_OnInterruptCallback = ::std::option::Option<
    unsafe extern "C" fn(
        capturer: *mut OH_AudioCapturer,
        userData: *mut ::std::os::raw::c_void,
        type_: OH_AudioInterrupt_ForceType,
        hint: OH_AudioInterrupt_Hint,
    ),
>;
#[doc = " @brief Called when an error event occurs in an AudioCapturer instance.\n This function is similar to OH_AudioCapturer_Callbacks_Struct.OH_AudioCapturer_OnError.\n\n @param capturer Pointer to the AudioCapturer instance that triggers the callback.\n @param userData Pointer to the user data passed when setting the callback via\n OH_AudioStreamBuilder_SetCapturerErrorCallback.\n @param error Specific error information.\n @see OH_AudioCapturer_Callbacks_Struct.OH_AudioCapturer_OnError\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioCapturer_OnErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        capturer: *mut OH_AudioCapturer,
        userData: *mut ::std::os::raw::c_void,
        error: OH_AudioStream_Result,
    ),
>;
extern "C" {
    #[doc = " @brief Gets audio capturer running status, check if it works in fast status.\n\n @param capturer Reference created by OH_AudioStreamBuilder_GenerateCapturer.\n @param status Pointer to a variable to receive the status.\n @return\n     {@link AUDIOSTREAM_SUCCESS} if the execution is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} the param of capturer is nullptr.\n     {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} function called in invalid state, only available before release state.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioCapturer_GetFastStatus(
        capturer: *mut OH_AudioCapturer,
        status: *mut OH_AudioStream_FastStatus,
    ) -> OH_AudioStream_Result;
}
#[doc = " @brief Callback function of fast status change event for audio capturer.\n\n @param capturer Pointer to an audio capturer instance for which this callback occurs.\n @param userData Userdata which is passed by register.\n @param status Current fast status.\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioCapturer_OnFastStatusChange = ::std::option::Option<
    unsafe extern "C" fn(
        capturer: *mut OH_AudioCapturer,
        userData: *mut ::std::os::raw::c_void,
        status: OH_AudioStream_FastStatus,
    ),
>;
extern "C" {
    #[doc = " Request to release the renderer stream.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioRenderer_Release(renderer: *mut OH_AudioRenderer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Request to start the renderer stream.\n\n @since 10\n\n @param renderer reference created by OH_AudioStreamBuilder\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioRenderer_Start(renderer: *mut OH_AudioRenderer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Request to pause the renderer stream.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioRenderer_Pause(renderer: *mut OH_AudioRenderer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Request to stop renderer stream.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioRenderer_Stop(renderer: *mut OH_AudioRenderer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Request to flush the renderer stream.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioRenderer_Flush(renderer: *mut OH_AudioRenderer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the current state of the renderer client.\n\n This function will return the renderer state without updating the state.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param state Pointer to a variable that will be set for the state value.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetCurrentState(
        renderer: *mut OH_AudioRenderer,
        state: *mut OH_AudioStream_State,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the sample rate value of the renderer client\n\n This function will return the renderer sample rate value without updating the state.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param rate The state value to be updated\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetSamplingRate(
        renderer: *mut OH_AudioRenderer,
        rate: *mut i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the stream id of the renderer client.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param streamId Pointer to a variable that will be set for the stream id.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetStreamId(
        renderer: *mut OH_AudioRenderer,
        streamId: *mut u32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the channel count of the renderer client.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param channelCount Pointer to a variable that will be set for the channel count.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetChannelCount(
        renderer: *mut OH_AudioRenderer,
        channelCount: *mut i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the sample format of the renderer client.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param sampleFormat Pointer to a variable that will be set for the sample format.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetSampleFormat(
        renderer: *mut OH_AudioRenderer,
        sampleFormat: *mut OH_AudioStream_SampleFormat,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the latency mode of the renderer client.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param latencyMode Pointer to a variable that will be set for the latency mode.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetLatencyMode(
        renderer: *mut OH_AudioRenderer,
        latencyMode: *mut OH_AudioStream_LatencyMode,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the renderer info of the renderer client.\n\n The rendere info includes {@link OH_AudioStream_Usage} value.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param usage Pointer to a variable that will be set for the stream usage.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetRendererInfo(
        renderer: *mut OH_AudioRenderer,
        usage: *mut OH_AudioStream_Usage,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the encoding type of the renderer client.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param encodingType Pointer to a variable that will be set for the encoding type.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetEncodingType(
        renderer: *mut OH_AudioRenderer,
        encodingType: *mut OH_AudioStream_EncodingType,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the the number of frames that have been written since the stream was created.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param frames Pointer to a variable that will be set for the frame count number.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetFramesWritten(
        renderer: *mut OH_AudioRenderer,
        frames: *mut i64,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the the time at which a particular frame was presented.\n\n It is recommended to use new api {@link OH_AudioRenderer_GetAudioTimestampInfo}\n because it adapts to playback speed change, but current api does not. The\n increasing speed for position will not change when speed become fast.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param clockId {@link #CLOCK_MONOTONIC}\n @param framePosition Pointer to a variable to receive the position\n @param timestamp Pointer to a variable to receive the timestamp\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of renderer is nullptr;\n                                                 2.The param of clockId invalid.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioRenderer_GetTimestamp(
        renderer: *mut OH_AudioRenderer,
        clockId: clockid_t,
        framePosition: *mut i64,
        timestamp: *mut i64,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the frame size in callback, it is a fixed length that the stream want to be filled for each callback.\n\n @since 10\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param frameSize Pointer to a variable that will be set for the frame size.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetFrameSizeInCallback(
        renderer: *mut OH_AudioRenderer,
        frameSize: *mut i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Query the playback speed of the stream client\n\n @since 11\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param speed Pointer to a variable to receive the playback speed.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetSpeed(
        renderer: *mut OH_AudioRenderer,
        speed: *mut f32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the playback speed of the stream client\n\n @since 11\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param speed The playback speed, form 0.25 to 4.0.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_SetSpeed(
        renderer: *mut OH_AudioRenderer,
        speed: f32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set volume of current renderer.\n\n @since 12\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param volume Volume to set which changes from 0.0 to 1.0.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of renderer is nullptr;\n                                                 2.The param of volume invalid.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception.\n         {@link AUDIOSTREAM_ERROR_SYSTEM} An system error has occurred."]
    pub fn OH_AudioRenderer_SetVolume(
        renderer: *mut OH_AudioRenderer,
        volume: f32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Changes the volume with ramp for a duration.\n\n @since 12\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param volume Volume to set which changes from 0.0 to 1.0.\n @param durationMs Duration for volume ramp, in millisecond.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of renderer is nullptr;\n                                                 2.The param of volume invalid.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception.\n         {@link AUDIOSTREAM_ERROR_SYSTEM} An system error has occurred."]
    pub fn OH_AudioRenderer_SetVolumeWithRamp(
        renderer: *mut OH_AudioRenderer,
        volume: f32,
        durationMs: i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Get Volume of current renderer.\n\n @since 12\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param volume Pointer to a variable to receive the volume.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of renderer is nullptr;\n                                                 2.The param of volume is nullptr."]
    pub fn OH_AudioRenderer_GetVolume(
        renderer: *mut OH_AudioRenderer,
        volume: *mut f32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set mark position on current renderer. Calling this function will overwrite the mark postion which has already\n set.\n\n @since 12\n\n @param renderer Renderer generated by OH_AudioStreamBuilder_GenerateRenderer()\n @param samplePos Mark position in samples.\n @param callback Callback used when the samplePos has reached.\n @param userData User data which is passed by user.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of renderer is nullptr;\n                                                 2.The param of samplePos invalid.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception.\n         {@link AUDIOSTREAM_ERROR_SYSTEM} An system error has occurred."]
    pub fn OH_AudioRenderer_SetMarkPosition(
        renderer: *mut OH_AudioRenderer,
        samplePos: u32,
        callback: OH_AudioRenderer_OnMarkReachedCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Cancel mark which has set by {@link #OH_AudioRenderer_SetMarkPosition}.\n\n @since 12\n\n @param renderer Renderer generated by OH_AudioStreamBuilder_GenerateRenderer()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_CancelMark(renderer: *mut OH_AudioRenderer) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Gets the underflow count on this stream.\n\n @since 12\n\n @param renderer Renderer generated by OH_AudioStreamBuilder_GenerateRenderer()\n @param count Pointer to a variable to receive the underflow count number.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of renderer is nullptr;\n                                                 2.The param of count is nullptr."]
    pub fn OH_AudioRenderer_GetUnderflowCount(
        renderer: *mut OH_AudioRenderer,
        count: *mut u32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Query the channel layout of the renderer client.\n\n @since 12\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param channelLayout Pointer to a variable to receive the channel layout\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetChannelLayout(
        renderer: *mut OH_AudioRenderer,
        channelLayout: *mut OH_AudioChannelLayout,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Query current audio effect mode.\n\n @since 12\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param effectMode Pointer to a variable to receive current audio effect mode\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetEffectMode(
        renderer: *mut OH_AudioRenderer,
        effectMode: *mut OH_AudioStream_AudioEffectMode,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set current audio effect mode.\n\n @since 12\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param effectMode Audio effect mode that will be set for the stream\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_SetEffectMode(
        renderer: *mut OH_AudioRenderer,
        effectMode: OH_AudioStream_AudioEffectMode,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Get the privacy of this stream.\n\n @since 12\n\n @param renderer Renderer generated by OH_AudioStreamBuilder_GenerateRenderer()\n @param privacy Pointer to a variable which receives the results.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of renderer is nullptr."]
    pub fn OH_AudioRenderer_GetRendererPrivacy(
        renderer: *mut OH_AudioRenderer,
        privacy: *mut OH_AudioStream_PrivacyType,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set silent and mix with other streams for this stream.\n\n @param renderer Renderer generated by OH_AudioStreamBuilder_GenerateRenderer()\n @param on The silent and mix with other streams mode.\n     true: set the slient mode and mix with other streams.\n     false: unset the slient mode, current stream will trigger the audio focus internally.\n @return result code for this function.\n     {@link #AUDIOSTREAM_SUCCESS} succeed in setting to the silent and mix with other streams.\n     {@link #AUDIOSTREAM_ERROR_ILLEGAL_STATE} this stream is not allowed to set/unset the silent mode.\n @since 12"]
    pub fn OH_AudioRenderer_SetSilentModeAndMixWithOthers(
        renderer: *mut OH_AudioRenderer,
        on: bool,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Query silent and mix with other streams status for this stream.\n\n @param renderer Renderer generated by OH_AudioStreamBuilder_GenerateRenderer()\n @param on Pointer to the silent and mix with other streams status.\n @return result code for this function.\n     {@link #AUDIOSTREAM_SUCCESS} succeed in getting silent and mix with other streams status\n     {@link #AUDIOSTREAM_ERROR_SYSTEM} system error when calling this function.\n @since 12"]
    pub fn OH_AudioRenderer_GetSilentModeAndMixWithOthers(
        renderer: *mut OH_AudioRenderer,
        on: *mut bool,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Temporarily changes the current audio device\n        This function applys on audiorenderers whose StreamUsage are\n        STREAM_USAGE_VOICE_COMMUNICATIN/STREAM_USAGE_VIDEO_COMMUNICATION/STREAM_USAGE_VOICE_MESSAGE.\n        Setting the device will only takes effect if no other accessory such as headphones are in use.\n\n @param renderer Renderer generated by OH_AudioStreamBuilder_GenerateRenderer()\n @param deviceType The target device. The available deviceTypes are:\n                                             EARPIECE: Built-in earpiece\n                                             SPEAKER: Built-in speaker\n                                             DEFAULT: System default output device\n @return result code for this function.\n         {@link #AUDIOSTREAM_SUCCESS} succeed in setting the default output device\n         {@link #AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of renderer is nullptr;\n                                                 2.The param of deviceType is not valid\n         {@link #AUDIOSTREAM_ERROR_ILLEGAL_STATE} This audiorenderer can not reset the output device\n         {@link #AUDIOSTREAM_ERROR_SYSTEM} system error when calling this function.\n @since 12"]
    pub fn OH_AudioRenderer_SetDefaultOutputDevice(
        renderer: *mut OH_AudioRenderer,
        deviceType: OH_AudioDevice_Type,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Query the timestamp at which a particular frame was presented in clock monotonic timebase,\n        the frame at the returned position was just committed to hardware. This is often used in\n        video synchronization and recording stream alignment.\n\n        Position is 0 and timestamp is fixed until stream really runs and frame is committed. Position\n        will also be reset while flush function is called. When a audio route change happens, like in\n        device or output type change situations, the position may also be reset but timestamp remains\n        monotonically increasing.\n        So it is better to use the values until they becomes regularly after the change.\n        This interface also adapts to playback speed change. For example, the increseing speed for\n        position will be double for 2x speed playback.\n\n        For video synchronization usage, there is a best practice document for developer to refer\n        **AV Synchronization**.\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer()\n @param framePosition Pointer to a variable to receive the position\n @param timestamp Pointer to a variable to receive the timestamp\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                         1.The param of renderer is nullptr;\n                                         2.The param of framePosition or timestamp is nullptr;\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE}:\n                                         1.Only running state is legal for getting audio timestamp.\n         {@link AUDIOSTREAM_ERROR_SYSTEM}:\n                                         1.Crash or blocking occurs in system process.\n                                         2.Other unexpected error from internal system.\n @since 15"]
    #[cfg(feature = "api-15")]
    pub fn OH_AudioRenderer_GetAudioTimestampInfo(
        renderer: *mut OH_AudioRenderer,
        framePosition: *mut i64,
        timestamp: *mut i64,
    ) -> OH_AudioStream_Result;
}
#[doc = " @brief Called when an interrupt event occurs in an AudioRenderer instance.\n This function is similar to OH_AudioRenderer_Callbacks_Struct.OH_AudioRenderer_OnInterruptEvent.\n\n @param renderer Pointer to the AudioRenderer instance that triggers the callback.\n @param userData Pointer to the user data passed when setting the callback via\n OH_AudioStreamBuilder_SetRendererInterruptCallback.\n @param type Type of force that causes the interrupt event.\n @param hint Hint provided along with the interrupt event.\n @see OH_AudioRenderer_Callbacks_Struct.OH_AudioRenderer_OnInterruptEvent.\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioRenderer_OnInterruptCallback = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *mut OH_AudioRenderer,
        userData: *mut ::std::os::raw::c_void,
        type_: OH_AudioInterrupt_ForceType,
        hint: OH_AudioInterrupt_Hint,
    ),
>;
#[doc = " @brief Called when an error event occurs in an AudioRenderer instance.\n This function is similar to OH_AudioRenderer_Callbacks_Struct.OH_AudioRenderer_OnError.\n\n @param renderer Pointer to the AudioRenderer instance that triggers the callback.\n @param userData Pointer to the user data passed when setting the callback via\n OH_AudioStreamBuilder_SetRendererErrorCallback.\n @param error Specific error information.\n @see OH_AudioRenderer_Callbacks_Struct.OH_AudioRenderer_OnError\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioRenderer_OnErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *mut OH_AudioRenderer,
        userData: *mut ::std::os::raw::c_void,
        error: OH_AudioStream_Result,
    ),
>;
extern "C" {
    #[doc = " @brief Gets audio renderer running status, check if it works in fast status.\n\n @param renderer Reference created by OH_AudioStreamBuilder_GenerateRenderer.\n @param status Pointer to a variable to receive the status.\n @return\n     {@link AUDIOSTREAM_SUCCESS} if the execution is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} the param of renderer is nullptr.\n     {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} function called in invalid state, only available before release state.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioRenderer_GetFastStatus(
        renderer: *mut OH_AudioRenderer,
        status: *mut OH_AudioStream_FastStatus,
    ) -> OH_AudioStream_Result;
}
#[doc = " @brief Callback function of fast status change event for audio renderer.\n\n @param renderer Pointer to an audio renderer instance for which this callback occurs.\n @param userData Userdata which is passed by register.\n @param status Current fast status.\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioRenderer_OnFastStatusChange = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *mut OH_AudioRenderer,
        userData: *mut ::std::os::raw::c_void,
        status: OH_AudioStream_FastStatus,
    ),
>;
extern "C" {
    #[doc = " @brief Sets the loudness gain of current renderer.\n The default loudness gain is 0.0dB. The stream usage of the audio renderer must be\n {@link OH_AudioStream_Usage#AUDIOSTREAM_USAGE_MUSIC}, {@link OH_AudioStream_Usage#AUDIOSTREAM_USAGE_MOVIE}\n or {@link OH_AudioStream_Usage#AUDIOSTREAM_USAGE_AUDIOBOOK}.\n The latency mode of the audio renderer must be {@link OH_AudioStream_LatencyMode#AUDIOSTREAM_LATENCY_MODE_NORMAL}.\n If AudioRenderer is played through the high-resolution pipe, this operation is not supported.\n\n @param renderer AudioRender created by OH_AudioStreamBuilder_GenerateRenderer()\n @param loudnessGain Loudness gain to set which changes from -90.0 to 24.0, expressing in dB.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of renderer is nullptr or not supported to set gain;\n                                                 2.The param of loudnessGain is invalid.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioRenderer_SetLoudnessGain(
        renderer: *mut OH_AudioRenderer,
        loudnessGain: f32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Get the loudness gain of current renderer.\n\n @param renderer AudioRender created by OH_AudioStreamBuilder_GenerateRenderer()\n @param loudnessGain Pointer to a variable to receive the loudness gain.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of renderer is nullptr;\n                                                 2.The param of loudnessGain is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioRenderer_GetLoudnessGain(
        renderer: *mut OH_AudioRenderer,
        loudnessGain: *mut f32,
    ) -> OH_AudioStream_Result;
}
#[doc = " @brief Callback function of write data on Render.\n\n Different with OH_AudioRenderer_OnWriteDataCallback, this function allows the caller to write partial data which\n ranges from 0 to the callback buffer size. If 0 is returned, the callback thread will sleep for a while. Otherwise,\n the system may callback again immediately.\n\n @param renderer AudioRenderer where this callback occurs.\n @param userData User data which is passed by user.\n @param audioData Audio data pointer, where user should fill in audio data.\n @param audioDataSize Size of audio data that user should fill in.\n @return Length of the valid data that has written into audioData buffer. The return value must be in range of\n [0, audioDataSize]. If the return value is less than 0, the system changes it to 0. And, if the return value is\n greater than audioDataSize, the system changes it to audioDataSize. Note that the length of the returned buffer\n must be an integer multiple of the length of the single sample data. For example, for 2 channels and S16 format\n audio data, it must be an integer multiple of 4(2*16/8). Otherwise, it may cause noise during playback.\n @see OH_AudioRenderer_OnWriteDataCallback\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioRenderer_OnWriteDataCallbackAdvanced = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *mut OH_AudioRenderer,
        userData: *mut ::std::os::raw::c_void,
        audioData: *mut ::std::os::raw::c_void,
        audioDataSize: i32,
    ) -> i32,
>;
extern "C" {
    #[doc = " Create a stremBuilder can be used to open a renderer or capturer client.\n\n OH_AudioStreamBuilder_Destroy() must be called when you are done using the builder.\n\n @since 10\n\n @param builder The builder reference to the created result.\n @param type The stream type to be created. {@link #AUDIOSTREAM_TYPE_RENDERER} or {@link #AUDIOSTREAM_TYPE_CAPTURER}\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful."]
    pub fn OH_AudioStreamBuilder_Create(
        builder: *mut *mut OH_AudioStreamBuilder,
        type_: OH_AudioStream_Type,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Destroy a streamBulder.\n\n This function must be called when you are done using the builder.\n\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of builder is nullptr.\n         {@link AUDIOSTREAM_ERROR_ILLEGAL_STATE} Execution status exception."]
    pub fn OH_AudioStreamBuilder_Destroy(
        builder: *mut OH_AudioStreamBuilder,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the channel count of the capturer client\n\n @since 10\n\n @param builder Reference created by OH_AudioStreamBuilder\n @param rate Pointer to a variable that will be set for the channel count.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.The param of rate invalid."]
    pub fn OH_AudioStreamBuilder_SetSamplingRate(
        builder: *mut OH_AudioStreamBuilder,
        rate: i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the channel count of the stream client\n\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param channelCount The channel count.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.The param of channelCount invalid."]
    pub fn OH_AudioStreamBuilder_SetChannelCount(
        builder: *mut OH_AudioStreamBuilder,
        channelCount: i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the sample format of the stream client\n\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param format Sample data format.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of builder is nullptr."]
    pub fn OH_AudioStreamBuilder_SetSampleFormat(
        builder: *mut OH_AudioStreamBuilder,
        format: OH_AudioStream_SampleFormat,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the encoding type of the stream client\n\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param encodingType Encoding type for the stream client, {@link #AUDIOSTREAM_ENCODING_PCM}\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of builder is nullptr."]
    pub fn OH_AudioStreamBuilder_SetEncodingType(
        builder: *mut OH_AudioStreamBuilder,
        encodingType: OH_AudioStream_EncodingType,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the latency mode of the stream client\n\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param latencyMode Latency mode for the stream client.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of builder is nullptr."]
    pub fn OH_AudioStreamBuilder_SetLatencyMode(
        builder: *mut OH_AudioStreamBuilder,
        latencyMode: OH_AudioStream_LatencyMode,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set the channel layout to the stream client\n\n @since 12\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param channelLayout is the layout of the speaker.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of builder is nullptr."]
    pub fn OH_AudioStreamBuilder_SetChannelLayout(
        builder: *mut OH_AudioStreamBuilder,
        channelLayout: OH_AudioChannelLayout,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the renderer information of the stream client\n\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param usage Set the stream usage for the renderer client.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.The param of usage invalid."]
    pub fn OH_AudioStreamBuilder_SetRendererInfo(
        builder: *mut OH_AudioStreamBuilder,
        usage: OH_AudioStream_Usage,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the capturer information of the stream client\n\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param sourceType Set the source type for the capturer client.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.The param of sourceType invalid."]
    pub fn OH_AudioStreamBuilder_SetCapturerInfo(
        builder: *mut OH_AudioStreamBuilder,
        sourceType: OH_AudioStream_SourceType,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the callbacks for the renderer client\n\n @deprecated since 20\n @useinstead Set the callback functions separately using OH_AudioStreamBuilder_SetRendererWriteDataCallback,\n OH_AudioStreamBuilder_SetRendererInterruptCallback, OH_AudioStreamBuilder_SetRendererOutputDeviceChangeCallback\n and OH_AudioStreamBuilder_SetRendererErrorCallback.\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param callbacks Callbacks to the functions that will process renderer stream.\n @param userData Pointer to an application data structure that will be passed to the callback functions.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.StreamType invalid."]
    pub fn OH_AudioStreamBuilder_SetRendererCallback(
        builder: *mut OH_AudioStreamBuilder,
        callbacks: OH_AudioRenderer_Callbacks,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set the callback when the output device of an audio renderer changed.\n\n @since 11\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param callback Callback to the function that will process this device change event.\n @param userData Pointer to an application data structure that will be passed to the callback functions.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.StreamType invalid."]
    pub fn OH_AudioStreamBuilder_SetRendererOutputDeviceChangeCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioRenderer_OutputDeviceChangeCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set the privacy of audio render.\n\n @since 12\n\n @param builder Builder provided by OH_AudioStreamBuilder_Create()\n @param privacy Privacy type.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.StreamType invalid."]
    pub fn OH_AudioStreamBuilder_SetRendererPrivacy(
        builder: *mut OH_AudioStreamBuilder,
        privacy: OH_AudioStream_PrivacyType,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the callbacks for the capturer client\n\n @deprecated since 20\n @useinstead Set the callback functions separately using OH_AudioStreamBuilder_SetCapturerReadDataCallback,\n OH_AudioStreamBuilder_SetCapturerDeviceChangeCallback, OH_AudioStreamBuilder_SetCapturerInterruptCallback\n and OH_AudioStreamBuilder_SetCapturerErrorCallback.\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param callbacks Callbacks to the functions that will process capturer stream.\n @param userData Pointer to an application data structure that will be passed to the callback functions.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.StreamType invalid."]
    pub fn OH_AudioStreamBuilder_SetCapturerCallback(
        builder: *mut OH_AudioStreamBuilder,
        callbacks: OH_AudioCapturer_Callbacks,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Create the audio renderer client.\n\n The AudioRenderer instance is used to play streaming audio data.\n When using AudioRenderer apis, there are many instructions for application\n to achieve better performance and lower power consumption:\n In music or audiobook background playback situation, you can have low power\n consumption by following this best practices document **Low-Power Rules in Music Playback Scenarios**.\n And for navigation situation, you can follow **Low-Power Rules in Navigation and Positioning Scenarios**.\n\n Application developer should also be careful when app goes to background, please check if your audio playback\n is still needed, see **Audio Resources** in best practices document.\n And avoiding to send silence audio data continuously to waste system resources, otherwise system will take\n control measures when this behavior is detected, see **Audio Playback** in best practices document.\n\n If you want to use AudioRenderer api to implement a music playback application, there are also many interactive\n scenes to consider, see **Developing an Audio Application** in best practices document.\n\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param audioRenderer Pointer to a viriable to receive the stream client.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.StreamType invalid;\n                                                 3.Create OHAudioRenderer failed."]
    pub fn OH_AudioStreamBuilder_GenerateRenderer(
        builder: *mut OH_AudioStreamBuilder,
        audioRenderer: *mut *mut OH_AudioRenderer,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Create the audio capturer client.\n\n @since 10\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param audioCapturer Pointer to a viriable to receive the stream client.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.StreamType invalid;\n                                                 3.Create OHAudioCapturer failed."]
    pub fn OH_AudioStreamBuilder_GenerateCapturer(
        builder: *mut OH_AudioStreamBuilder,
        audioCapturer: *mut *mut OH_AudioCapturer,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the data frame size for each callback, use this function if the application requires a specific number\n of frames for processing.\n The frame size should be at least the size device process at one time, and less than half the internal\n buffer capacity.\n\n @since 11\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param frameSize  The data frame size for each callback.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM} The param of builder is nullptr."]
    pub fn OH_AudioStreamBuilder_SetFrameSizeInCallback(
        builder: *mut OH_AudioStreamBuilder,
        frameSize: i32,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set the callback of writing metadata to the renderer client\n\n @since 12\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param callback Callback to the functions that will write audio data with metadata to the renderer.\n @param userData Pointer to an application data structure that will be passed to the callback functions.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.StreamType invalid."]
    pub fn OH_AudioStreamBuilder_SetWriteDataWithMetadataCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioRenderer_WriteDataWithMetadataCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set the interrupt mode of the stream client\n\n @since 12\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param mode The audio interrupt mode\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.The param of mode invalid;\n                                                 3.StreamType invalid."]
    pub fn OH_AudioStreamBuilder_SetRendererInterruptMode(
        builder: *mut OH_AudioStreamBuilder,
        mode: OH_AudioInterrupt_Mode,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set the callback of writing data to renderer client.\n\n This function is similar with {@link OH_AudioStreamBuilder_SetRendererCallback}. Only the last callback set by\n OH_AudioStreamBuilder_SetRendererCallback or this function will become effective.\n\n @param builder Builder provided by OH_AudioStreamBuilder_Create()\n @param callback Callback to functions that will write audio data to renderer client.\n @param userData Pointer to an application data structure that will be passed to the callback functions.\n @return Result code.\n     {@link AUDIOSTREAM_SUCCESS} Success.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} Parameter is invalid, e.g. builder is nullptr, e.t.c.\n @since 12"]
    pub fn OH_AudioStreamBuilder_SetRendererWriteDataCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioRenderer_OnWriteDataCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set the callback of writing data to renderer client.\n\n This function is similar with {@link OH_AudioStreamBuilder_SetRendererWriteDataCallback}. Only the last callback set\n by OH_AudioStreamBuilder_SetRendererWriteDataCallback or this function will become effective. Different with\n OH_AudioStreamBuilder_SetRendererWriteDataCallback, the callback in this function can return audio data of any\n length.\n\n @param builder Builder provided by OH_AudioStreamBuilder_Create()\n @param callback Callback to functions that will write audio data to renderer client.\n @param userData Pointer to an application data structure that will be passed to the callback functions.\n @return Result code.\n     {@link AUDIOSTREAM_SUCCESS} Success.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} Parameter is invalid, e.g. builder is nullptr, e.t.c.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetRendererWriteDataCallbackAdvanced(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioRenderer_OnWriteDataCallbackAdvanced,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " Set the renderer volume mode of the stream client\n\n @param builder Reference provided by OH_AudioStreamBuilder_Create()\n @param volumeMode Set the volume mode for the renderer client.\n @return Function result code:\n         {@link AUDIOSTREAM_SUCCESS} If the execution is successful.\n         {@link AUDIOSTREAM_ERROR_INVALID_PARAM}:\n                                                 1.The param of builder is nullptr;\n                                                 2.The param of volumeMode invalid.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_AudioStreamBuilder_SetVolumeMode(
        builder: *mut OH_AudioStreamBuilder,
        volumeMode: OH_AudioStream_VolumeMode,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Sets a callback to handle interrupt events for an AudioRenderer instance. This function is similar to\n {@link OH_AudioStreamBuilder_SetRendererCallback}. If both OH_AudioStreamBuilder_SetRendererCallback and this\n function are called, the most recently set callback takes effect.\n\n @param builder Builder instance, which is generated by OH_AudioStreamBuilder_Create().\n @param callback Callback used to handle the interrupt events.\n @param userData Pointer to user-defined data, which will be passed back to the application in the callback.\n @return Result code.\n     {@link AUDIOSTREAM_SUCCESS} is returned if the operation is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} is returned if a parameter is invalid, for example, if builder\n is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetRendererInterruptCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioRenderer_OnInterruptCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Sets a callback to handle error events for an AudioRenderer instance.\n This function is similar to {@link OH_AudioStreamBuilder_SetRendererCallback}. If both\n OH_AudioStreamBuilder_SetRendererCallback and this function are called, the most recently set callback takes\n effect.\n\n @param builder Builder instance, which is generated by OH_AudioStreamBuilder_Create().\n @param callback Callback used to handle the error events.\n @param userData Pointer to user-defined data, which will be passed back to the application in the callback.\n @return Result code.\n     {@link AUDIOSTREAM_SUCCESS} is returned if the operation is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} is returned if a parameter is invalid, for example, if builder\n is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetRendererErrorCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioRenderer_OnErrorCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Sets a callback to handle audio data read events for an AudioCapturer instance. This function is\n similar to {@link OH_AudioStreamBuilder_SetCapturerCallback}. If both {@link\n OH_AudioStreamBuilder_SetCapturerCallback} and this function are called, the most recently set callback takes\n effect.\n\n @param builder Builder instance, which is generated by OH_AudioStreamBuilder_Create().\n @param callback Callback used to handle incoming audio data.\n @param userData Pointer to user-defined data, which will be passed back to the application in the callback.\n @return Result code.\n     {@link AUDIOSTREAM_SUCCESS} is returned if the operation is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} is returned if a parameter is invalid, for example, if builder\n is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetCapturerReadDataCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioCapturer_OnReadDataCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Sets a callback to handle device change events for an AudioCapturer instance. This function is\n similar to {@link OH_AudioStreamBuilder_SetCapturerCallback}. If both OH_AudioStreamBuilder_SetCapturerCallback\n and this function are called, the most recently set callback takes effect.\n\n @param builder Builder instance, which is generated by OH_AudioStreamBuilder_Create().\n @param callback Callback used to handle the device change events.\n @param userData Pointer to user-defined data, which will be passed back to the application in the callback.\n @return Result code.\n     {@link AUDIOSTREAM_SUCCESS} is returned if the operation is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} is returned if a parameter is invalid, for example, if builder\n is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetCapturerDeviceChangeCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioCapturer_OnDeviceChangeCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Sets a callback to handle interrupt events for an AudioCapturer instance.\n This function is similar to {@link OH_AudioStreamBuilder_SetCapturerCallback}. If both\n OH_AudioStreamBuilder_SetCapturerCallback and this function are called, the most recently set callback takes\n effect.\n\n @param builder Builder instance, which is generated by OH_AudioStreamBuilder_Create().\n @param callback Callback used to handle the interrupt events.\n @param userData Pointer to user-defined data, which will be passed back to the application in the callback.\n @return Result code.\n     {@link AUDIOSTREAM_SUCCESS} is returned if the operation is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} is returned if a parameter is invalid, for example, if builder\n is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetCapturerInterruptCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioCapturer_OnInterruptCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Sets a callback to handle error events for an AudioCapturer instance. This function is similar to\n {@link OH_AudioStreamBuilder_SetCapturerCallback}. If both OH_AudioStreamBuilder_SetCapturerCallback and this\n function are called, the most recently set callback takes effect.\n\n @param builder Builder instance, which is generated by OH_AudioStreamBuilder_Create().\n @param callback Callback used to handle the error events.\n @param userData Pointer to user-defined data, which will be passed back to the application in the callback.\n @return Result code.\n     {@link AUDIOSTREAM_SUCCESS} is returned if the operation is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} is returned if a parameter is invalid, for example, if builder\n is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetCapturerErrorCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioCapturer_OnErrorCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set audio capturer configuration, if app want its recorder only to be muted instead of interrupted.\n\n @param builder reference provided by OH_AudioStreamBuilder_Create()\n @param muteWhenInterrupted use {@code true} if application want to be muted instead of interrupted.\n @return function result code:\n     {@link AUDIOSTREAM_SUCCESS} if the execution is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} the param of builder is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetCapturerWillMuteWhenInterrupted(
        builder: *mut OH_AudioStreamBuilder,
        muteWhenInterrupted: bool,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set the callback of fast status change event for audio renderer.\n\n @param builder Builder provided by OH_AudioStreamBuilder_Create()\n @param callback Callback function that will recevie the fast status change event.\n @param userData Pointer to an application data structure that will be passed to the callback functions.\n @return\n     {@link AUDIOSTREAM_SUCCESS} if the execution is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} the param of builder or callback is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetRendererFastStatusChangeCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioRenderer_OnFastStatusChange,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
extern "C" {
    #[doc = " @brief Set the callback of fast status change event for audio capturer.\n\n @param builder Builder provided by OH_AudioStreamBuilder_Create()\n @param callback Callback function that will recevie the fast status change event.\n @param userData Pointer to an application data structure that will be passed to the callback functions.\n @return\n     {@link AUDIOSTREAM_SUCCESS} if the execution is successful.\n     {@link AUDIOSTREAM_ERROR_INVALID_PARAM} the param of builder or callback is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamBuilder_SetCapturerFastStatusChangeCallback(
        builder: *mut OH_AudioStreamBuilder,
        callback: OH_AudioCapturer_OnFastStatusChange,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioStream_Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioManager {
    _unused: [u8; 0],
}
#[doc = " @brief Prototype for the audio scene change function that is passed to\n     {@link OH_AudioManager_RegisterAudioSceneChangeCallback}.\n\n @param userData userdata which is passed by register.\n @param scene the latest audio scene.\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioManager_OnAudioSceneChangeCallback = ::std::option::Option<
    unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, scene: OH_AudioScene),
>;
extern "C" {
    #[doc = " @brief Get audio manager handle.\n\n @param audioManager the {@link OH_AudioManager} handle received from this function.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioManager is nullptr;\n @since 12"]
    pub fn OH_GetAudioManager(audioManager: *mut *mut OH_AudioManager) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Get audio scene.\n\n @param manager the {@link OH_AudioManager} handle received from {@link OH_GetAudioManager}.\n @param scene the {@link OH_AudioScene} pointer to receive the result.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioManager is nullptr;\n                                                        2.The param of scene is nullptr.\n @since 12"]
    pub fn OH_GetAudioScene(
        manager: *mut OH_AudioManager,
        scene: *mut OH_AudioScene,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Register callback to receive audio scene changed events.\n\n @param manager {@link OH_AudioManager} handle received from {@link OH_GetAudioManager}.\n @param callback callback function which will be called when audio scene changed.\n @param userData pointer to a data structure that will be passed to the callback functions.\n @return\n     {@link AUDIOCOMMON_RESULT_SUCCESS} if the execution is successful\n     {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}\n                                                   1.param of manager is nullptr\n                                                   2.param of callback is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioManager_RegisterAudioSceneChangeCallback(
        manager: *mut OH_AudioManager,
        callback: OH_AudioManager_OnAudioSceneChangeCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Unregister audio scene change callback.\n\n @param manager {@link OH_AudioManager} handle received from {@link OH_GetAudioManager}.\n @param callback callback function which registered in {@link OH_AudioManager_RegisterAudioSceneChangeCallback}.\n @return\n     {@link AUDIOCOMMON_RESULT_SUCCESS} if the execution is successful\n     {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}\n                                                   1.param of manager is nullptr\n                                                   2.param of callback is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioManager_UnregisterAudioSceneChangeCallback(
        manager: *mut OH_AudioManager,
        callback: OH_AudioManager_OnAudioSceneChangeCallback,
    ) -> OH_AudioCommon_Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioResourceManager {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Fetch the audio resource manager handle, which is a singleton.\n\n @param resourceManager output parameter to get {@link #OH_AudioResourceManager}.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioManager_GetAudioResourceManager(
        resourceManager: *mut *mut OH_AudioResourceManager,
    ) -> OH_AudioCommon_Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioWorkgroup {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create a workgroup for audio data processing threads in application.\n     System manages cpu resources by workgroup configuration.\n\n @param resourceManager {@link OH_AudioResourceManager} handle\n     provided by {@link OH_AudioManager_GetAudioRoutingManager}.\n @param name workgroup name\n @param group {@link OH_AudioWorkgroup} handle for managing audio data processing threads.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_NO_MEMORY} out of workgroup resources\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioResourceManager_CreateWorkgroup(
        resourceManager: *mut OH_AudioResourceManager,
        name: *const ::std::os::raw::c_char,
        group: *mut *mut OH_AudioWorkgroup,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Release the workgroup created before.\n\n @param resourceManager {@link OH_AudioResourceManager} handle\n     provided by {@link OH_AudioManager_GetAudioRoutingManager}.\n @param group {@link OH_AudioWorkgroup} handle provided by {@link OH_AudioResourceManager_CreateWorkgroup}.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioResourceManager_ReleaseWorkgroup(
        resourceManager: *mut OH_AudioResourceManager,
        group: *mut OH_AudioWorkgroup,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Add current thread into a specified audio workgroup as audio data processing thread.\n\n @param group {@link OH_AudioWorkgroup} handle provided by {@link OH_AudioResourceManager_CreateWorkgroup}.\n @param tokenId a token id that represent the thread added.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_NO_MEMORY} out of resources for the new thread\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioWorkgroup_AddCurrentThread(
        group: *mut OH_AudioWorkgroup,
        tokenId: *mut i32,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Remove the thread from a specified audio workgroup.\n\n @param group {@link OH_AudioWorkgroup} handle provided by {@link OH_AudioResourceManager_CreateWorkgroup}.\n @param tokenId id for thread returned by {link OH_AudioWorkgroup_AddCurrentThread}\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr or token id is invalid\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioWorkgroup_RemoveThread(
        group: *mut OH_AudioWorkgroup,
        tokenId: i32,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Notify system the audio workgroup start working. Call this function before processing the audio frame.\n\n @param group {@link OH_AudioWorkgroup} handle provided by {@link OH_AudioResourceManager_CreateWorkgroup}.\n @param startTime the time when audio thread start working, using system time. The unit of time is milliseconds.\n @param deadlineTime the time before which audio work should be finished, otherwise underrun may happens.\n     The unit of time is milliseconds.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr, or time is invalid\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioWorkgroup_Start(
        group: *mut OH_AudioWorkgroup,
        startTime: u64,
        deadlineTime: u64,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Notify system the audio workgroup stop working. Call this function after the audio frame processing\n     is completed.\n\n @param group {@link OH_AudioWorkgroup} handle provided by {@link OH_AudioResourceManager_CreateWorkgroup}.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioWorkgroup_Stop(group: *mut OH_AudioWorkgroup) -> OH_AudioCommon_Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioRoutingManager {
    _unused: [u8; 0],
}
#[doc = " @brief This function pointer will point to the callback function that\n is used to return the changing audio device descriptors.\n There may be more than one audio device descriptor returned.\n\n @param type the {@link OH_AudioDevice_ChangeType} is connect or disconnect.\n @param audioDeviceDescriptorArray the {@link OH_AudioDeviceDescriptorArray}\n pointer variable which will be set the audio device descriptors value.\n Do not release the audioDeviceDescriptorArray pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @since 12"]
pub type OH_AudioRoutingManager_OnDeviceChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        type_: OH_AudioDevice_ChangeType,
        audioDeviceDescriptorArray: *mut OH_AudioDeviceDescriptorArray,
    ) -> i32,
>;
extern "C" {
    #[doc = " @brief Query the audio routing manager handle.\n which should be set as the first parameter in routing releated functions.\n\n @param audioRoutingManager the {@link OH_AudioRoutingManager}\n handle returned by {@link OH_AudioManager_GetAudioRoutingManager}.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n @since 12"]
    pub fn OH_AudioManager_GetAudioRoutingManager(
        audioRoutingManager: *mut *mut OH_AudioRoutingManager,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query the available devices according to the input deviceFlag.\n\n @param audioRoutingManager the {@link OH_AudioRoutingManager}\n handle returned by {@link OH_AudioManager_GetAudioRoutingManager}.\n @param deviceFlag the {@link OH_AudioDevice_DeviceFlag} which is used as\n the filter parameter for selecting the target devices.\n @param audioDeviceDescriptorArray the {@link OH_AudioDeviceDescriptorArray}\n pointer variable which will be set the audio device descriptors value\n Do not release the audioDeviceDescriptorArray pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioRoutingManager is nullptr;\n                                                        2.The param of deviceFlag invalid;\n                                                        3.The param of audioDeviceDescriptorArray is nullptr.\n         {@link AUDIOCOMMON_RESULT_ERROR_NO_MEMORY} The param of audioDeviceDescriptorArray is nullptr.\n @since 12"]
    pub fn OH_AudioRoutingManager_GetDevices(
        audioRoutingManager: *mut OH_AudioRoutingManager,
        deviceFlag: OH_AudioDevice_Flag,
        audioDeviceDescriptorArray: *mut *mut OH_AudioDeviceDescriptorArray,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Get available devices by device usage.\n\n @param audioRoutingManager the {@link OH_AudioRoutingManager} handle returned\n by {@link OH_AudioManager_GetAudioRoutingManager}.\n @param deviceUsage the {@link OH_AudioDevice_Usage}.\n @param audioDeviceDescriptorArray the {@link OH_AudioDeviceDescriptorArray}\n pointer variable which will be set the audio device descriptors value\n Do not release the audioDeviceDescriptorArray pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioRoutingManager is nullptr;\n                                                        2.The param of deviceUsage is invalid;\n                                                        3.The param of audioDeviceDescriptorArray is nullptr.\n         {@link AUDIOCOMMON_RESULT_ERROR_NO_MEMORY} No memory error.\n @since 12"]
    pub fn OH_AudioRoutingManager_GetAvailableDevices(
        audioRoutingManager: *mut OH_AudioRoutingManager,
        deviceUsage: OH_AudioDevice_Usage,
        audioDeviceDescriptorArray: *mut *mut OH_AudioDeviceDescriptorArray,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Get preferred ouput devices by audio usage.\n\n @param audioRoutingManager the {@link OH_AudioRoutingManager} handle returned\n by {@link OH_AudioManager_GetAudioRoutingManager}.\n @param streamUsage the {@link OH_AudioStream_Usage}.\n @param audioDeviceDescriptorArray the {@link OH_AudioDeviceDescriptorArray}\n pointer variable which will be set the audio device descriptors value\n Do not release the audioDeviceDescriptorArray pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioRoutingManager is nullptr;\n                                                        2.The param of streamUsage is invalid;\n                                                        3.The param of audioDeviceDescriptorArray is nullptr.\n         {@link AUDIOCOMMON_RESULT_ERROR_NO_MEMORY} No memory error.\n @since 12"]
    pub fn OH_AudioRoutingManager_GetPreferredOutputDevice(
        audioRoutingManager: *mut OH_AudioRoutingManager,
        streamUsage: OH_AudioStream_Usage,
        audioDeviceDescriptorArray: *mut *mut OH_AudioDeviceDescriptorArray,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Get preferred input devices by audio source type.\n @param audioRoutingManager the {@link OH_AudioRoutingManager} handle returned\n by {@link OH_AudioManager_GetAudioRoutingManager}.\n @param sourceType the {@link OH_AudioStream_SourceType}.\n @param audioDeviceDescriptorArray the {@link OH_AudioDeviceDescriptorArray}\n pointer variable which will be set the audio device descriptors value\n Do not release the audioDeviceDescriptorArray pointer separately\n instead call {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array\n when it is no use anymore.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioRoutingManager is nullptr;\n                                                        2.The param of sourceType is invalid;\n                                                        3.The param of audioDeviceDescriptorArray is nullptr.\n         {@link AUDIOCOMMON_RESULT_ERROR_NO_MEMORY} No memory error.\n @since 12"]
    pub fn OH_AudioRoutingManager_GetPreferredInputDevice(
        audioRoutingManager: *mut OH_AudioRoutingManager,
        sourceType: OH_AudioStream_SourceType,
        audioDeviceDescriptorArray: *mut *mut OH_AudioDeviceDescriptorArray,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Register the device change callback of the audio routing manager.\n\n @param audioRoutingManager the {@link OH_AudioRoutingManager}\n handle returned by {@link OH_AudioManager_GetAudioRoutingManager}.\n @param deviceFlag the {@link OH_AudioDevice_DeviceFlag} which is used to register callback.\n @param callback the {@link OH_AudioRoutingManager_OnDeviceChangedCallback}\n Callback function which will be called when devices changed.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioRoutingManager is nullptr;\n                                                        2.The param of deviceFlag invalid;\n                                                        3.The param of callback is nullptr.\n @since 12"]
    pub fn OH_AudioRoutingManager_RegisterDeviceChangeCallback(
        audioRoutingManager: *mut OH_AudioRoutingManager,
        deviceFlag: OH_AudioDevice_Flag,
        callback: OH_AudioRoutingManager_OnDeviceChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Unregister the device change callback of the audio routing manager.\n\n @param audioRoutingManager the {@link OH_AudioRoutingManager}\n handle returned by {@link OH_AudioManager_GetAudioRoutingManager}.\n @param callback the {@link OH_AudioRoutingManager_OnDeviceChangedCallback}\n Callback function which will be called when devices changed.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioRoutingManager is nullptr;\n                                                        2.The param of callback is nullptr.\n @since 12"]
    pub fn OH_AudioRoutingManager_UnregisterDeviceChangeCallback(
        audioRoutingManager: *mut OH_AudioRoutingManager,
        callback: OH_AudioRoutingManager_OnDeviceChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Release the audio device descriptor array object.\n\n @param audioRoutingManager the {@link OH_AudioRoutingManager}\n handle returned by {@link OH_AudioManager_GetAudioRoutingManager}.\n @param audioDeviceDescriptorArray Audio device descriptors should be released.\n and get from {@link OH_AudioRoutingManager_GetDevices}\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioRoutingManager is nullptr;\n                                                        2.The param of audioDeviceDescriptorArray is nullptr.\n @since 12"]
    pub fn OH_AudioRoutingManager_ReleaseDevices(
        audioRoutingManager: *mut OH_AudioRoutingManager,
        audioDeviceDescriptorArray: *mut OH_AudioDeviceDescriptorArray,
    ) -> OH_AudioCommon_Result;
}
#[doc = " @brief This type defines the callback function that is used to receive the audio devices' block status.\n\n @param audioDeviceDescriptorArray The {@link OH_AudioDeviceDescriptorArray}\n pointer variable which will be set the audio device descriptors value.\n Do not release the audioDeviceDescriptorArray pointer separately instead of calling\n {@link OH_AudioRoutingManager_ReleaseDevices} to release the DeviceDescriptor array when it is no use anymore.\n @param status The {@link OH_AudioDevice_BlockStatus} is the block status.\n @param userData User data which is passed by user.\n @since 13"]
#[cfg(feature = "api-13")]
pub type OH_AudioRoutingManager_OnDeviceBlockStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(
        audioDeviceDescriptorArray: *mut OH_AudioDeviceDescriptorArray,
        status: OH_AudioDevice_BlockStatus,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Query whether microphone block detection is supported on current device.\n\n @param audioRoutingManager the {@link OH_AudioRoutingManager} handle returned by\n {@link OH_AudioManager_GetAudioRoutingManager}.\n @param supported query result.\n @return Function result code:\n     {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n     {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                    1.The param of audioRoutingManager is nullptr;\n                                                    2.The param of supported is nullptr.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_AudioRoutingManager_IsMicBlockDetectionSupported(
        audioRoutingManager: *mut OH_AudioRoutingManager,
        supported: *mut bool,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Set the microphone block status callback. Before using this function, users should query whether block\n detection is supported on current device. The caller will receive the callback only when it is recording\n and the used microphones' block status have changed. Currently, block detecting is only support for microphones\n located on the local device.\n\n @param audioRoutingManager The {@link OH_AudioRoutingManager} handle returned by\n {@link OH_AudioManager_GetAudioRoutingManager}.\n @param callback The function pointer will point to the callback function that is used to receive the block status.\n @param userData User data which is passed by user.\n @return Function result code:\n     {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n     {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                    1.The param of audioRoutingManager is nullptr;\n                                                    2.The param of callback is nullptr.\n @since 13"]
    #[cfg(feature = "api-13")]
    pub fn OH_AudioRoutingManager_SetMicBlockStatusCallback(
        audioRoutingManager: *mut OH_AudioRoutingManager,
        callback: OH_AudioRoutingManager_OnDeviceBlockStatusCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioCommon_Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioSessionManager {
    _unused: [u8; 0],
}
#[doc = " @brief default mode"]
pub const OH_AudioSession_ConcurrencyMode_CONCURRENCY_DEFAULT: OH_AudioSession_ConcurrencyMode = 0;
#[doc = " @brief mix with others mode"]
pub const OH_AudioSession_ConcurrencyMode_CONCURRENCY_MIX_WITH_OTHERS:
    OH_AudioSession_ConcurrencyMode = 1;
#[doc = " @brief duck others mode"]
pub const OH_AudioSession_ConcurrencyMode_CONCURRENCY_DUCK_OTHERS: OH_AudioSession_ConcurrencyMode =
    2;
#[doc = " @brief pause others mode"]
pub const OH_AudioSession_ConcurrencyMode_CONCURRENCY_PAUSE_OTHERS:
    OH_AudioSession_ConcurrencyMode = 3;
#[doc = " @brief Declare the audio concurrency modes.\n\n @since 12"]
pub type OH_AudioSession_ConcurrencyMode = u32;
#[doc = " @brief scene for media"]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_Scene_AUDIO_SESSION_SCENE_MEDIA: OH_AudioSession_Scene = 0;
#[doc = " @brief scene for game"]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_Scene_AUDIO_SESSION_SCENE_GAME: OH_AudioSession_Scene = 1;
#[doc = " @brief scene for voice communication"]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_Scene_AUDIO_SESSION_SCENE_VOICE_COMMUNICATION: OH_AudioSession_Scene = 2;
#[doc = " @brief Declare the audio session scene.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioSession_Scene = u32;
#[doc = " @brief Resume the playback"]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_StateChangeHint_AUDIO_SESSION_STATE_CHANGE_HINT_RESUME:
    OH_AudioSession_StateChangeHint = 0;
#[doc = " @brief paused/pause the playback"]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_StateChangeHint_AUDIO_SESSION_STATE_CHANGE_HINT_PAUSE:
    OH_AudioSession_StateChangeHint = 1;
#[doc = " @brief stopped/stop the playback."]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_StateChangeHint_AUDIO_SESSION_STATE_CHANGE_HINT_STOP:
    OH_AudioSession_StateChangeHint = 2;
#[doc = " @brief stopped/stop the playback due to no audio stream for a long time."]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_StateChangeHint_AUDIO_SESSION_STATE_CHANGE_HINT_TIME_OUT_STOP:
    OH_AudioSession_StateChangeHint = 3;
#[doc = " @brief Ducked the playback. (In ducking, the audio volume is reduced, but not silenced.)"]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_StateChangeHint_AUDIO_SESSION_STATE_CHANGE_HINT_DUCK:
    OH_AudioSession_StateChangeHint = 4;
#[doc = " @brief Unducked the playback."]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_StateChangeHint_AUDIO_SESSION_STATE_CHANGE_HINT_UNDUCK:
    OH_AudioSession_StateChangeHint = 5;
#[doc = " @brief Declare the audio session state change hints.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioSession_StateChangeHint = u32;
#[doc = " @brief Recommend to continue the playback."]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_OutputDeviceChangeRecommendedAction_DEVICE_CHANGE_RECOMMEND_TO_CONTINUE : OH_AudioSession_OutputDeviceChangeRecommendedAction = 0 ;
#[doc = " @brief recommend to stop the playback."]
#[cfg(feature = "api-20")]
pub const OH_AudioSession_OutputDeviceChangeRecommendedAction_DEVICE_CHANGE_RECOMMEND_TO_STOP:
    OH_AudioSession_OutputDeviceChangeRecommendedAction = 1;
#[doc = " @brief Declare the recommend action when device change.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioSession_OutputDeviceChangeRecommendedAction = u32;
#[doc = " @brief deactivated because of lower priority"]
pub const OH_AudioSession_DeactivatedReason_DEACTIVATED_LOWER_PRIORITY:
    OH_AudioSession_DeactivatedReason = 0;
#[doc = " @brief deactivated because of timing out"]
pub const OH_AudioSession_DeactivatedReason_DEACTIVATED_TIMEOUT: OH_AudioSession_DeactivatedReason =
    1;
#[doc = " @brief Declare the audio deactivated reasons.\n\n @since 12"]
pub type OH_AudioSession_DeactivatedReason = u32;
#[doc = " @brief Not prefer to use bluetooth and nearlink record."]
#[cfg(feature = "api-21")]
pub const OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory_PREFERRED_NONE:
    OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory = 0;
#[doc = " @brief Prefer to use bluetooth and nearlink record.\n However, whether to use low latency or high quality recording\n depends on system."]
#[cfg(feature = "api-21")]
pub const OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory_PREFERRED_DEFAULT:
    OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory = 1;
#[doc = " @brief Prefer to use bluetooth and nearlink low latency mode to record."]
#[cfg(feature = "api-21")]
pub const OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory_PREFERRED_LOW_LATENCY:
    OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory = 2;
#[doc = " @brief Prefer to use bluetooth and nearlink high quality mode to record."]
#[cfg(feature = "api-21")]
pub const OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory_PREFERRED_HIGH_QUALITY:
    OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory = 3;
#[doc = " @brief Enumerates the categories application prefer to use\n when recording with bluetooth and nearlink.\n\n @since 21"]
#[cfg(feature = "api-21")]
pub type OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory = u32;
#[doc = " @brief declare the audio session strategy\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioSession_Strategy {
    #[doc = " @brief audio session concurrency mode"]
    pub concurrencyMode: OH_AudioSession_ConcurrencyMode,
}
#[doc = " @brief declare the audio session deactivated event\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioSession_DeactivatedEvent {
    #[doc = " @brief audio session deactivated reason"]
    pub reason: OH_AudioSession_DeactivatedReason,
}
#[doc = " @brief declare the audio session state change event\n\n @since 20"]
#[cfg(feature = "api-20")]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioSession_StateChangedEvent {
    #[doc = " @brief audio session state change hints."]
    pub stateChangeHint: OH_AudioSession_StateChangeHint,
}
#[doc = " @brief This function pointer will point to the callback function that\n is used to return the audio session state change event.\n\n @param event the {@link #OH_AudioSession_StateChangedEvent} state change triggering event.\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioSession_StateChangedCallback =
    ::std::option::Option<unsafe extern "C" fn(event: OH_AudioSession_StateChangedEvent)>;
#[doc = " @brief This function pointer will point to the callback function that\n     is used to return the changing audio device descriptors.\n     There may be more than one audio device descriptor returned.\n\n @param type the {@link OH_AudioDevice_ChangeType} is connect or disconnect.\n @param audioDeviceDescriptorArray the {@link OH_AudioDeviceDescriptorArray}\n     pointer variable which will be set the audio device descriptors value.\n     Do not release the audioDeviceDescriptorArray pointer separately\n     instead call {@link OH_AudioSessionManager_ReleaseDevices} to release the DeviceDescriptor array\n     when it is no use anymore.\n @since 21"]
#[cfg(feature = "api-21")]
pub type OH_AudioSession_AvailableDeviceChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        type_: OH_AudioDevice_ChangeType,
        audioDeviceDescriptorArray: *mut OH_AudioDeviceDescriptorArray,
    ),
>;
#[doc = " @brief This function pointer will point to the callback function that\n     is used to return the audio session input device change event.\n\n @param audioDeviceDescriptorArray the {@link OH_AudioDeviceDescriptorArray}\n     pointer variable which will be set the audio input device descriptors value.\n     Do not release the audioDeviceDescriptorArray pointer separately\n     instead call {@link OH_AudioSessionManager_ReleaseDevices}\n     to release the DeviceDescriptor array when it is no use anymore.\n @param changeReason the {@link #OH_AudioStream_DeviceChangeReason} indicates\n     that why does the input device changes.\n @since 21"]
#[cfg(feature = "api-21")]
pub type OH_AudioSession_CurrentInputDeviceChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        devices: *mut OH_AudioDeviceDescriptorArray,
        changeReason: OH_AudioStream_DeviceChangeReason,
    ),
>;
#[doc = " @brief This function pointer will point to the callback function that\n is used to return the audio session device change event.\n\n @param audioDeviceDescriptorArray the {@link OH_AudioDeviceDescriptorArray}\n pointer variable which will be set the audio device descriptors value.\n Do not release the audioDeviceDescriptorArray pointer separately\n instead call {@link OH_AudioSessionManager_ReleaseDevices}\n to release the DeviceDescriptor array when it is no use anymore.\n @param changeReason the {@link #OH_AudioStream_DeviceChangeReason} indicates that why does the device changes.\n @param recommendedAction the {@link #OH_AudioSession_OutputDeviceChangeRecommendedAction}\n recommend action when device change.\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioSession_CurrentOutputDeviceChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        devices: *mut OH_AudioDeviceDescriptorArray,
        changeReason: OH_AudioStream_DeviceChangeReason,
        recommendedAction: OH_AudioSession_OutputDeviceChangeRecommendedAction,
    ),
>;
#[doc = " @brief This function pointer will point to the callback function that\n is used to return the audio session deactivated event.\n\n @param event the {@link #OH_AudioSession_DeactivatedEvent} deactivated triggering event.\n @since 12"]
pub type OH_AudioSession_DeactivatedCallback =
    ::std::option::Option<unsafe extern "C" fn(event: OH_AudioSession_DeactivatedEvent) -> i32>;
extern "C" {
    #[doc = " @brief Fetch the audio session manager handle.\n The audio session manager handle should be the first parameter in audio session related functions\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n which will be returned as the output parameter\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} if system state error\n @since 12"]
    pub fn OH_AudioManager_GetAudioSessionManager(
        audioSessionManager: *mut *mut OH_AudioSessionManager,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Activate the audio session for the current pid application.\n If {@link #OH_AudioSessionManager_SetScene} is called, it will take focus when calling this method.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param strategy pointer of {@link #OH_AudioSession_Strategy}\n which is used for setting audio session strategy\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_REULT_INVALID_PARAM} if parameter validation fails\n or {@link #AUDIOCOMMON_RESULT_ERROR_ILLEGAL_STATE} if system illegal state\n @since 12"]
    pub fn OH_AudioSessionManager_ActivateAudioSession(
        audioSessionManager: *mut OH_AudioSessionManager,
        strategy: *const OH_AudioSession_Strategy,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Deactivate the audio session for the current pid application.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_REULT_INVALID_PARAM} if parameter validation fails\n or {@link #AUDIOCOMMON_RESULT_ERROR_ILLEGAL_STATE} if system illegal state\n @since 12"]
    pub fn OH_AudioSessionManager_DeactivateAudioSession(
        audioSessionManager: *mut OH_AudioSessionManager,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Querying whether the current pid application has an activated audio session.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @return True when the current pid application has an activated audio session\n False when it does not\n @since 12"]
    pub fn OH_AudioSessionManager_IsAudioSessionActivated(
        audioSessionManager: *mut OH_AudioSessionManager,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Register the audio session deactivated event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param callback the {@link #OH_AudioSession_DeactivatedCallback} which is used\n to receive the deactivated event\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n @since 12"]
    pub fn OH_AudioSessionManager_RegisterSessionDeactivatedCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        callback: OH_AudioSession_DeactivatedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Unregister the audio session deactivated event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param callback the {@link #OH_AudioSession_DeactivatedCallback} which is used\n to receive the deactivated event\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n @since 12"]
    pub fn OH_AudioSessionManager_UnregisterSessionDeactivatedCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        callback: OH_AudioSession_DeactivatedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Set scene for audio session.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param scene the {@link #OH_AudioSession_Scene}\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n or {@link #AUDIOCOMMON_RESULT_ERROR_ILLEGAL_STATE} if system illegal state\n or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} if system state error\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioSessionManager_SetScene(
        audioSessionManager: *mut OH_AudioSessionManager,
        scene: OH_AudioSession_Scene,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Register the audio session state change event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param callback the {@link #OH_AudioSession_StateChangedCallback} which is used\n to receive the state change event\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n or {@link AUDIOCOMMON_RESULT_ERROR_NO_MEMORY} No memory error\n or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} if system state error\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioSessionManager_RegisterStateChangeCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        callback: OH_AudioSession_StateChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Unregister the audio session state change event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param callback the {@link #OH_AudioSession_StateChangedCallback} which is used\n to receive the state change event\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} if system state error\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioSessionManager_UnregisterStateChangeCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        callback: OH_AudioSession_StateChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Sets the default output device.\n This function applys on audiorenderers whose StreamUsage are\n STREAM_USAGE_VOICE_COMMUNICATION/STREAM_USAGE_VIDEO_COMMUNICATION/STREAM_USAGE_VOICE_MESSAGE.\n Setting the device will only takes effect if no other accessory such as headphones are in use\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param deviceType The target device. The available deviceTypes are:\n                                          EARPIECE: Built-in earpiece\n                                          SPEAKER: Built-in speaker\n                                          DEFAULT: System default output device\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} if system state error\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioSessionManager_SetDefaultOutputDevice(
        audioSessionManager: *mut OH_AudioSessionManager,
        deviceType: OH_AudioDevice_Type,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Gets the default output device.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param deviceType The target device.The available deviceTypes are:\n                                          EARPIECE: Built-in earpiece\n                                          SPEAKER: Built-in speaker\n                                          DEFAULT: System default output device\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n or {@link #AUDIOCOMMON_RESULT_ERROR_ILLEGAL_STATE} if system illegal state\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioSessionManager_GetDefaultOutputDevice(
        audioSessionManager: *mut OH_AudioSessionManager,
        deviceType: *mut OH_AudioDevice_Type,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Release the audio device descriptor array object.\n\n @param audioSessionManager the {@link OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param audioDeviceDescriptorArray Audio device descriptors should be released.\n @return {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n or {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n              1.The param of audioSessionManager is nullptr;\n              2.The param of audioDeviceDescriptorArray is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioSessionManager_ReleaseDevices(
        audioSessionManager: *mut OH_AudioSessionManager,
        audioDeviceDescriptorArray: *mut OH_AudioDeviceDescriptorArray,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Register the audio session device change event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param callback the {@link #OH_AudioSession_CurrentOutputDeviceChangedCallback} which is used\n to receive the device change event\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n or {@link AUDIOCOMMON_RESULT_ERROR_NO_MEMORY} No memory error\n or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} if system state error\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioSessionManager_RegisterCurrentOutputDeviceChangeCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        callback: OH_AudioSession_CurrentOutputDeviceChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Unregister the audio session device change event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param callback the {@link #OH_AudioSession_CurrentOutputDeviceChangedCallback} which is used\n to receive the device change event\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} if system state error\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioSessionManager_UnregisterCurrentOutputDeviceChangeCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        callback: OH_AudioSession_CurrentOutputDeviceChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Get available devices by device usage.\n\n @param audioSessionManager the {@link OH_AudioSessionManager} handle returned\n     by {@link OH_AudioManager_GetAudioSessionManager}.\n @param deviceUsage the {@link OH_AudioDevice_Usage} which is used as\n     the filter parameter for get the available devices.\n @param audioDeviceDescriptorArray the {@link OH_AudioDeviceDescriptorArray}\n     pointer variable which will be set the audio device descriptors value\n     Do not release the audioDeviceDescriptorArray pointer separately\n     instead call {@link OH_AudioSessionManager_ReleaseDevices} to release the DeviceDescriptor array\n     when it is no use anymore.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} Audio client call audio service error, System error.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_GetAvailableDevices(
        audioSessionManager: *mut OH_AudioSessionManager,
        deviceUsage: OH_AudioDevice_Usage,
        audioDeviceDescriptorArray: *mut *mut OH_AudioDeviceDescriptorArray,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Register available device change event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n     returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param deviceUsage the {@link OH_AudioDevice_Usage} which is used as\n     the filter parameter for register the available devices change event.\n @param callback the {@link #OH_AudioSession_AvailableDeviceChangedCallback} which is used\n     to receive available device change event.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} Audio client call audio service error, System error.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_RegisterAvailableDevicesChangeCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        deviceUsage: OH_AudioDevice_Usage,
        callback: OH_AudioSession_AvailableDeviceChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Unregister available device change event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n     returned by the {@link #OH_AudioManager_GetAudioSessionManager}.\n @param callback the {@link #OH_AudioSession_AvailableDeviceChangedCallback} which is used\n     to receive the device change event.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} Audio client call audio service error, System error.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_UnregisterAvailableDevicesChangeCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        callback: OH_AudioSession_AvailableDeviceChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Sets the media input device.\n     This function is not valid for call recording, whose SourceType is\n     SOURCE_TYPE_VOICE_CALL or SOURCE_TYPE_VOICE_COMMUNICATION.\n     In scenarios where there are concurrent recording streams with higher priority,\n     the actual input device used by the application may differ from the selected one.\n     The application can use {@link OH_AudioSessionManager_RegisterCurrentInputDeviceChangeCallback}\n     to register a callback to listen for the actual input device.\n\n @param audioSessionManager the {@link OH_AudioSessionManager} handle returned\n     by {@link OH_AudioManager_GetAudioSessionManager}.\n @param deviceDescriptor The target device. The available device must be in the array returned\n     by {@link OH_AudioSessionManager_GetAvailableDevices}.\n     When the nullptr is passed, system will clear the last selection.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} Audio client call audio service error, System error.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_SelectMediaInputDevice(
        audioSessionManager: *mut OH_AudioSessionManager,
        deviceDescriptor: *mut OH_AudioDeviceDescriptor,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Gets the selected media input device.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n     returned by the {@link #OH_AudioManager_GetAudioSessionManager}.\n @param audioDeviceDescriptor The target device set by\n     {@link OH_AudioSessionManager_SelectMediaInputDevice} or\n     device with AUDIO_DEVICE_TYPE_INVALID if not set yet.\n     Do not release the audioDeviceDescriptor pointer separately,\n     instead call {@link OH_AudioSessionManager_ReleaseDevice} to release it\n     when it is no use anymore.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} Audio client call audio service error, System error.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_GetSelectedMediaInputDevice(
        audioSessionManager: *mut OH_AudioSessionManager,
        audioDeviceDescriptor: *mut *mut OH_AudioDeviceDescriptor,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Sets the prefered record category with bluetooth and nearlink device.\n     The application can set this category before bluetooth and nearlink connected, and the system will\n     prefer to use bluetooth and nearlink to record when the device connected.\n     In scenarios where there are concurrent recording streams with higher priority,\n     the actual input device used by the application may differ from the prefered one.\n     The application can use {@link OH_AudioSessionManager_RegisterCurrentInputDeviceChangeCallback}\n     to register a callback to listen for the actual input device.\n\n @param audioSessionManager the {@link OH_AudioSessionManager} handle returned\n     by {@link OH_AudioManager_GetAudioSessionManager}.\n @param category The category application prefer to use when recording with bluetooth and nearlink.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} Audio client call audio service error, System error.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_SetBluetoothAndNearlinkPreferredRecordCategory(
        audioSessionManager: *mut OH_AudioSessionManager,
        category: OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Gets the prefered record category with bluetooth and nearlink device.\n\n @param audioSessionManager the {@link OH_AudioSessionManager} handle returned\n     by {@link OH_AudioManager_GetAudioSessionManager}.\n @param category The category application prefer to use when recording with bluetooth and nearlink.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} Audio client call audio service error, System error.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_GetBluetoothAndNearlinkPreferredRecordCategory(
        audioSessionManager: *mut OH_AudioSessionManager,
        category: *mut OH_AudioSession_BluetoothAndNearlinkPreferredRecordCategory,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Register the audio session input device change event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n     returned by the {@link #OH_AudioManager_GetAudioSessionManager}.\n @param callback the {@link #OH_AudioSession_CurrentInputDeviceChangedCallback} which is used\n     to receive the input device change event.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails.\n     or {@link AUDIOCOMMON_RESULT_ERROR_NO_MEMORY} No memory error.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} Audio client call audio service error, System error.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_RegisterCurrentInputDeviceChangeCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        callback: OH_AudioSession_CurrentInputDeviceChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Unregister the audio session input device change event callback.\n\n @param audioSessionManager the {@link #OH_AudioSessionManager}\n     returned by the {@link #OH_AudioManager_GetAudioSessionManager}.\n @param callback the {@link #OH_AudioSession_CurrentInputDeviceChangedCallback} which is used\n     to receive the input device change event.\n @return {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails.\n     or {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} Audio client call audio service error, System error.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_UnregisterCurrentInputDeviceChangeCallback(
        audioSessionManager: *mut OH_AudioSessionManager,
        callback: OH_AudioSession_CurrentInputDeviceChangedCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Release the audio device descriptor object.\n\n @param audioSessionManager the {@link OH_AudioSessionManager}\n     returned by the {@link #OH_AudioManager_GetAudioSessionManager}\n @param audioDeviceDescriptor Audio device descriptor to release.\n @return {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n     or {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if parameter validation fails\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioSessionManager_ReleaseDevice(
        audioSessionManager: *mut OH_AudioSessionManager,
        audioDeviceDescriptor: *mut OH_AudioDeviceDescriptor,
    ) -> OH_AudioCommon_Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioStreamManager {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Fetch the audio streammanager handle, which is a singleton.\n\n @param streamManager output parameter to get the {@link #OH_AudioStreamManager}.\n @return\n         {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n         {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} if system state error\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_AudioManager_GetAudioStreamManager(
        streamManager: *mut *mut OH_AudioStreamManager,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Gets the mode of direct playback available for a given audio format with current active device.\n\n @param audioStreamManager the {@link OH_AudioStreamManager} handle provided by\n {@link OH_AudioManager_GetAudioStreamManager}.\n @param streamInfo the {@link OH_AudioStreamInfo}.\n @param usage the {@link OH_AudioStream_Usage}.\n @param directPlaybackMode the {@link OH_AudioStream_DirectPlaybackMode} pointer to a variable which receives the\n result.\n @return Function result code:\n         {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n         {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                        1.The param of audioStreamManager is nullptr;\n                                                        2.The param of streamInfo is nullptr;\n                                                        3.The param of usage invalid;\n                                                        4.The param of directPlaybackMode is nullptr.\n @since 19"]
    #[cfg(feature = "api-19")]
    pub fn OH_AudioStreamManager_GetDirectPlaybackSupport(
        audioStreamManager: *mut OH_AudioStreamManager,
        streamInfo: *mut OH_AudioStreamInfo,
        usage: OH_AudioStream_Usage,
        directPlaybackMode: *mut OH_AudioStream_DirectPlaybackMode,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Query whether acoustic echo canceler is supported by input source.\n\n @param streamManager The {@link OH_AudioStreamManager} handle provided\n by {@link OH_AudioManager_GetAudioStreamManager}.\n @param sourceType Related source type.\n @param supported Pointer to get the result.\n @return Function result code:\n     {@link AUDIOCOMMON_RESULT_SUCCESS} If the execution is successful.\n     {@link AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM}:\n                                                    1.The input param streamManager is nullptr;\n                                                    2.Source type is invalid.\n                                                    3.The input param supported is nullptr.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamManager_IsAcousticEchoCancelerSupported(
        streamManager: *mut OH_AudioStreamManager,
        sourceType: OH_AudioStream_SourceType,
        supported: *mut bool,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Return if fast playback is supported for the specific audio stream info and usage type\n     in current device situation.\n\n @param streamManager {@link OH_AudioStreamManager} handle\n     provided by {@link OH_AudioManager_GetAudioStreamManager}.\n @param streamInfo reference of stream info structure to describe basic audio format.\n @param usage stream usage type used to decide the audio device and pipe type selection result.\n @return {@code true} if fast playback is supported in this situation.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamManager_IsFastPlaybackSupported(
        streamManager: *mut OH_AudioStreamManager,
        streamInfo: *mut OH_AudioStreamInfo,
        usage: OH_AudioStream_Usage,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Return if fast recording is supported for the specific audio stream info and source type\n     in current device situation.\n\n @param streamManager {@link OH_AudioStreamManager} handle\n     provided by {@link OH_AudioManager_GetAudioStreamManager}.\n @param streamInfo reference of stream info structure to describe basic audio format.\n @param source stream source type used to decide the audio device and pipe type selection result.\n @return {@code true} if fast recording is supported in this situation.\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioStreamManager_IsFastRecordingSupported(
        streamManager: *mut OH_AudioStreamManager,
        streamInfo: *mut OH_AudioStreamInfo,
        source: OH_AudioStream_SourceType,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Return if the system recording enables intelligent noise reduction for current device.\n\n @param streamManager {@link OH_AudioStreamManager} handle\n     provided by {@link OH_AudioManager_GetAudioStreamManager}.\n @param source stream source type used to decide the audio device and pipe type selection result.\n @return {@code true} if the system recording enables intelligent noise reduction for current device.\n @since 21"]
    #[cfg(feature = "api-21")]
    pub fn OH_AudioStreamManager_IsIntelligentNoiseReductionEnabledForCurrentDevice(
        streamManager: *mut OH_AudioStreamManager,
        source: OH_AudioStream_SourceType,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AudioVolumeManager {
    _unused: [u8; 0],
}
#[doc = " @brief Prototype for the volume change function that is passed to\n     {@link OH_AudioVolumeManager_RegisterStreamVolumeChangeCallback}.\n\n @param userData userdata which is passed by register.\n @param usage the stream usage type for which volume changed.\n @param volumeLevel the latest volume level.\n @param updateUi whether to show the volume change in UI.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioVolumeManager_OnStreamVolumeChangeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        userData: *mut ::std::os::raw::c_void,
        usage: OH_AudioStream_Usage,
        volumeLevel: i32,
        updateUi: bool,
    ),
>;
#[doc = " @brief Prototype for the volume change function that is passed to\n     {@link OH_AudioVolumeManager_RegisterStreamVolumeChangeCallback}.\n\n @param userData userdata which is passed by register.\n @param ringerMode the latest ringer mode.\n\n @since 20"]
#[cfg(feature = "api-20")]
pub type OH_AudioVolumeManager_OnRingerModeChangeCallback = ::std::option::Option<
    unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, ringerMode: OH_AudioRingerMode),
>;
extern "C" {
    #[doc = " @brief Fetch the audio volume manager handle, which is a singleton.\n\n @param volumeManager output parameter to get {@link OH_AudioVolumeManager} instance.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioManager_GetAudioVolumeManager(
        volumeManager: *mut *mut OH_AudioVolumeManager,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Obtains the maximum volume level for a specific stream usage type.\n\n @param volumeManager {@link OH_AudioVolumeManager} handle\n     provided by {@link OH_AudioManager_GetAudioVolumeManager}.\n @param usage the stream usage type used to map a specific volume type.\n @param maxVolumeLevel output parameter to get maximum volume level.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr or invalid\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioVolumeManager_GetMaxVolumeByUsage(
        volumeManager: *mut OH_AudioVolumeManager,
        usage: OH_AudioStream_Usage,
        maxVolumeLevel: *mut i32,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Obtains the minimum volume level for a specific stream usage type.\n\n @param volumeManager {@link OH_AudioVolumeManager} handle\n     provided by {@link OH_AudioManager_GetAudioVolumeManager}.\n @param usage the stream usage type used to map a specific volume type.\n @param minVolumeLevel output parameter to get minimum volume level.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr or invalid\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioVolumeManager_GetMinVolumeByUsage(
        volumeManager: *mut OH_AudioVolumeManager,
        usage: OH_AudioStream_Usage,
        minVolumeLevel: *mut i32,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Obtains the system volume level for a specific stream usage type.\n\n @param volumeManager {@link OH_AudioVolumeManager} handle\n     provided by {@link OH_AudioManager_GetAudioVolumeManager}.\n @param usage the stream usage type used to map a specific volume type.\n @param volumeLevel output parameter to get system volume level.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr or invalid\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioVolumeManager_GetVolumeByUsage(
        volumeManager: *mut OH_AudioVolumeManager,
        usage: OH_AudioStream_Usage,
        volumeLevel: *mut i32,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Checks whether a stream is muted for a specific stream usage type.\n\n @param volumeManager {@link OH_AudioVolumeManager} handle\n     provided by {@link OH_AudioManager_GetAudioVolumeManager}.\n @param usage the stream usage type used to map a specific volume type.\n @param muted output parameter to get whether the stream of this usage is muted.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr or invalid\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioVolumeManager_IsMuteByUsage(
        volumeManager: *mut OH_AudioVolumeManager,
        usage: OH_AudioStream_Usage,
        muted: *mut bool,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Register callback to receive stream volume changed events.\n\n @param volumeManager {@link OH_AudioVolumeManager} handle\n     provided by {@link OH_AudioManager_GetAudioVolumeManager}.\n @param usage the stream usage type used to map a specific volume type which caller want to listen.\n @param callback callback function which will be called when stream volume changed.\n @param userData pointer to a data structure that will be passed to the callback functions.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr or invalid\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioVolumeManager_RegisterStreamVolumeChangeCallback(
        volumeManager: *mut OH_AudioVolumeManager,
        usage: OH_AudioStream_Usage,
        callback: OH_AudioVolumeManager_OnStreamVolumeChangeCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Unregister stream volume change callback.\n\n @param volumeManager {@link OH_AudioVolumeManager} handle\n     provided by {@link OH_AudioManager_GetAudioVolumeManager}.\n @param callback callback function which registered in\n     {@link OH_AudioVolumeManager_RegisterStreamVolumeChangeCallback}.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioVolumeManager_UnregisterStreamVolumeChangeCallback(
        volumeManager: *mut OH_AudioVolumeManager,
        callback: OH_AudioVolumeManager_OnStreamVolumeChangeCallback,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Get current ringer mode.\n\n @param volumeManager {@link OH_AudioVolumeManager} handle\n     provided by {@link OH_AudioManager_GetAudioVolumeManager}.\n @param ringerMode output parameter to get the ringer mode.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioVolumeManager_GetRingerMode(
        volumeManager: *mut OH_AudioVolumeManager,
        ringerMode: *mut OH_AudioRingerMode,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Register callback to receive ringer mode changed events.\n\n @param volumeManager {@link OH_AudioVolumeManager} handle\n     provided by {@link OH_AudioManager_GetAudioVolumeManager}.\n @param callback callback function which will be called when ringer mode changed.\n @param userData pointer to a data structure that will be passed to the callback functions.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioVolumeManager_RegisterRingerModeChangeCallback(
        volumeManager: *mut OH_AudioVolumeManager,
        callback: OH_AudioVolumeManager_OnRingerModeChangeCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OH_AudioCommon_Result;
}
extern "C" {
    #[doc = " @brief Unregister ringer mode change callback.\n\n @param volumeManager {@link OH_AudioVolumeManager} handle\n     provided by {@link OH_AudioManager_GetAudioVolumeManager}.\n @param callback callback function which registered in\n     {@link OH_AudioVolumeManager_RegisterRingerModeChangeCallback}.\n @return\n     {@link #AUDIOCOMMON_RESULT_SUCCESS} if execution succeeds\n     {@link #AUDIOCOMMON_RESULT_ERROR_INVALID_PARAM} if input param is nullptr\n     {@link #AUDIOCOMMON_RESULT_ERROR_SYSTEM} system process error occurs\n\n @since 20"]
    #[cfg(feature = "api-20")]
    pub fn OH_AudioVolumeManager_UnregisterRingerModeChangeCallback(
        volumeManager: *mut OH_AudioVolumeManager,
        callback: OH_AudioVolumeManager_OnRingerModeChangeCallback,
    ) -> OH_AudioCommon_Result;
}
