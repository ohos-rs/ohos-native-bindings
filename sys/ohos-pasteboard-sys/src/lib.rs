/* automatically generated by rust-bindgen 0.65.1 */


#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(clippy::missing_safety_doc)]


use ohos_udmf_sys::*;

#[doc = " @brief Defines the region of the image source to decode.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_Region {
    #[doc = " X coordinate of the start point, in pixels."]
    pub x: u32,
    #[doc = " Y coordinate of the start point, in pixels."]
    pub y: u32,
    #[doc = " Width of the region, in pixels."]
    pub width: u32,
    #[doc = " Height of the region, in pixels."]
    pub height: u32,
}
#[doc = " @brief Defines the region of the image source to decode.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_String {
    #[doc = " data for string type"]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = " data lenth for string type"]
    pub size: usize,
}
#[doc = " @brief Define a PictureMetadata struct type, used for picture metadata.\n\n @since 13"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PictureMetadata {
    _unused: [u8; 0],
}
#[doc = " operation success"]
pub const Image_ErrorCode_IMAGE_SUCCESS: Image_ErrorCode = 0;
#[doc = " invalid parameter"]
pub const Image_ErrorCode_IMAGE_BAD_PARAMETER: Image_ErrorCode = 401;
#[doc = " unsupported mime type"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_MIME_TYPE: Image_ErrorCode = 7600101;
#[doc = " unknown mime type"]
pub const Image_ErrorCode_IMAGE_UNKNOWN_MIME_TYPE: Image_ErrorCode = 7600102;
#[doc = " too large data or image"]
pub const Image_ErrorCode_IMAGE_TOO_LARGE: Image_ErrorCode = 7600103;
#[doc = " @error DMA memory does not exist"]
pub const Image_ErrorCode_IMAGE_DMA_NOT_EXIST: Image_ErrorCode = 7600173;
#[doc = " @error DMA operation failed"]
pub const Image_ErrorCode_IMAGE_DMA_OPERATION_FAILED: Image_ErrorCode = 7600174;
#[doc = " unsupported operations"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_OPERATION: Image_ErrorCode = 7600201;
#[doc = " unsupported metadata"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_METADATA: Image_ErrorCode = 7600202;
#[doc = " unsupported conversion"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_CONVERSION: Image_ErrorCode = 7600203;
#[doc = " invalid region"]
pub const Image_ErrorCode_IMAGE_INVALID_REGION: Image_ErrorCode = 7600204;
#[doc = "  @error unsupported memory format\n  @since 13"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_MEMORY_FORMAT: Image_ErrorCode = 7600205;
#[doc = " failed to allocate memory"]
pub const Image_ErrorCode_IMAGE_ALLOC_FAILED: Image_ErrorCode = 7600301;
#[doc = " memory copy failed"]
pub const Image_ErrorCode_IMAGE_COPY_FAILED: Image_ErrorCode = 7600302;
#[doc = " @error memory lock or unlock failed\n @since 15"]
pub const Image_ErrorCode_IMAGE_LOCK_UNLOCK_FAILED: Image_ErrorCode = 7600303;
#[doc = " unknown error"]
pub const Image_ErrorCode_IMAGE_UNKNOWN_ERROR: Image_ErrorCode = 7600901;
#[doc = " decode data source exception"]
pub const Image_ErrorCode_IMAGE_BAD_SOURCE: Image_ErrorCode = 7700101;
#[doc = " @error unsupported mime type\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_MIME_TYPE: Image_ErrorCode = 7700102;
#[doc = " @error image to large\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_TOO_LARGE: Image_ErrorCode = 7700103;
#[doc = " @error unsupported allocator type, e.g., use share memory to decode a HDR image as only\n DMA supported hdr metadata.\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_ALLOCATOR_TYPE: Image_ErrorCode = 7700201;
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_OPTIONS: Image_ErrorCode = 7700203;
#[doc = " decode failed"]
pub const Image_ErrorCode_IMAGE_DECODE_FAILED: Image_ErrorCode = 7700301;
#[doc = " @error memory allocation failed\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_ALLOC_FAILED: Image_ErrorCode = 7700302;
#[doc = " encode failed"]
pub const Image_ErrorCode_IMAGE_ENCODE_FAILED: Image_ErrorCode = 7800301;
#[doc = " @brief Enumerates the return values that may be used by the interface.\n\n @since 12"]
pub type Image_ErrorCode = ::std::os::raw::c_uint;
pub const Image_MetadataType_EXIF_METADATA: Image_MetadataType = 1;
pub const Image_MetadataType_FRAGMENT_METADATA: Image_MetadataType = 2;
#[doc = " @brief Define the metadata type.\n\n @since 13"]
pub type Image_MetadataType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Creates a <b>PictureMetadata</b> object.\n\n @param metadataType The type of metadata.\n @param metadata The PictureMetadata pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n @since 13"]
    pub fn OH_PictureMetadata_Create(
        metadataType: Image_MetadataType,
        metadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the property of picture metadata.\n\n @param metadata The PictureMetadata pointer will be operated.\n @param key The property's key.\n @param value The property's value.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    pub fn OH_PictureMetadata_GetProperty(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set picture metadata property.\n\n @param metadata The PictureMetadata pointer will be operated.\n @param key The property's key.\n @param value The property's value.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    pub fn OH_PictureMetadata_SetProperty(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases this PictureMetadata object.\n\n @param metadata The PictureMetadata pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n @since 13"]
    pub fn OH_PictureMetadata_Release(metadata: *mut OH_PictureMetadata) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains a clone of metadata.\n\n @param oldMetadata The PictureMetadata pointer will be operated.\n @param newMetadata The PictureMetadata pointer will be cloned.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n         {@link IMAGE_ALLOC_FAILED} memory alloc failed.\n         {@link IMAGE_COPY_FAILED} memory copy failed.\n @since 13"]
    pub fn OH_PictureMetadata_Clone(
        oldMetadata: *mut OH_PictureMetadata,
        newMetadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_env__ {
    _unused: [u8; 0],
}
pub type napi_env = *mut napi_env__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct napi_value__ {
    _unused: [u8; 0],
}
pub type napi_value = *mut napi_value__;
#[doc = " @brief Define a Pixelmap struct type, used for pixelmap pointer controls.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PixelmapNative {
    _unused: [u8; 0],
}
#[doc = " @brief Define a native buffer type, used for retrieving a native buffer.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_NativeBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_NativeColorSpaceManager {
    _unused: [u8; 0],
}
#[doc = " Nearest-neighbor interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_NONE:
    OH_PixelmapNative_AntiAliasingLevel = 0;
#[doc = " Bilinear interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_LOW:
    OH_PixelmapNative_AntiAliasingLevel = 1;
#[doc = " Bilinear interpolation algorithm with mipmap linear filtering"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_MEDIUM:
    OH_PixelmapNative_AntiAliasingLevel = 2;
#[doc = " Cubic interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_HIGH:
    OH_PixelmapNative_AntiAliasingLevel = 3;
#[doc = " @brief Defines the anti-aliasing level.\n\n @since 12"]
pub type OH_PixelmapNative_AntiAliasingLevel = ::std::os::raw::c_uint;
#[doc = " Indicate the types of metadata that image needs to use."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_METADATA_TYPE: OH_Pixelmap_HdrMetadataKey = 0;
#[doc = " Static metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_STATIC_METADATA: OH_Pixelmap_HdrMetadataKey = 1;
#[doc = " Dynamic metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_DYNAMIC_METADATA: OH_Pixelmap_HdrMetadataKey = 2;
#[doc = " Gainmap metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_GAINMAP_METADATA: OH_Pixelmap_HdrMetadataKey = 3;
#[doc = " @brief Enumerates the HDR metadata types that need to be stored in Pixelmap.\n\n @since 12"]
pub type OH_Pixelmap_HdrMetadataKey = ::std::os::raw::c_uint;
#[doc = " No metadata."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_NONE: OH_Pixelmap_HdrMetadataType = 0;
#[doc = " Indicates that metadata will be used for the base image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_BASE: OH_Pixelmap_HdrMetadataType = 1;
#[doc = " Indicates that metadata will be used for the gainmap image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_GAINMAP: OH_Pixelmap_HdrMetadataType = 2;
#[doc = " Indicates that metadata will be used for the alternate image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_ALTERNATE: OH_Pixelmap_HdrMetadataType = 3;
#[doc = " @brief Value for HDR_METADATA_TYPE.\n\n @since 12"]
pub type OH_Pixelmap_HdrMetadataType = ::std::os::raw::c_uint;
#[doc = " @brief Value for HDR_STATIC_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrStaticMetadata {
    #[doc = " The X-coordinate of the primary colors. The length of the array is three. Store in the order of r, g, b."]
    pub displayPrimariesX: [f32; 3usize],
    #[doc = " The Y-coordinate of the primary colors. The length of the array is three. Store in the order of r, g, b."]
    pub displayPrimariesY: [f32; 3usize],
    #[doc = " The X-coordinate of the white point value."]
    pub whitePointX: f32,
    #[doc = " The Y-coordinate of the white point value."]
    pub whitePointY: f32,
    #[doc = " Max luminance."]
    pub maxLuminance: f32,
    #[doc = " Min luminance."]
    pub minLuminance: f32,
    #[doc = " Maximum brightness of displayed content."]
    pub maxContentLightLevel: f32,
    #[doc = " Maximum average brightness of displayed content."]
    pub maxFrameAverageLightLevel: f32,
}
#[doc = " @brief Value for HDR_DYNAMIC_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrDynamicMetadata {
    #[doc = " The value of dynamic metadata."]
    pub data: *mut u8,
    #[doc = " The length of dynamic metadata."]
    pub length: u32,
}
#[doc = " @brief Value for HDR_GAINMAP_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrGainmapMetadata {
    #[doc = " The version used by the writer."]
    pub writerVersion: u16,
    #[doc = " The minimum version a parser needs to understand."]
    pub miniVersion: u16,
    #[doc = " The number of gain map channels, with a value of 1 or 3."]
    pub gainmapChannelNum: u8,
    #[doc = " Indicate whether to use the color space of the base image."]
    pub useBaseColorFlag: bool,
    #[doc = " The baseline hdr headroom."]
    pub baseHeadroom: f32,
    #[doc = " The alternate hdr headroom."]
    pub alternateHeadroom: f32,
    #[doc = " The per-component max gain map values."]
    pub gainmapMax: [f32; 3usize],
    #[doc = " The per-component min gain map values."]
    pub gainmapMin: [f32; 3usize],
    #[doc = " The per-component gamma values."]
    pub gamma: [f32; 3usize],
    #[doc = " The per-component baseline offset."]
    pub baselineOffset: [f32; 3usize],
    #[doc = " The per-component alternate offset."]
    pub alternateOffset: [f32; 3usize],
}
#[doc = " @brief Value for HDR_METADATA_KEY. Corresponding relationship with HDR_METADATA_KEY.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrMetadataValue {
    #[doc = " The value corresponding to the HDR_METADATA_TYPE key"]
    pub type_: OH_Pixelmap_HdrMetadataType,
    #[doc = " The value corresponding to the HDR_STATIC_METADATA key"]
    pub staticMetadata: OH_Pixelmap_HdrStaticMetadata,
    #[doc = " The value corresponding to the HDR_DYNAMIC_METADATA key"]
    pub dynamicMetadata: OH_Pixelmap_HdrDynamicMetadata,
    #[doc = " The value corresponding to the HDR_GAINMAP_METADATA key"]
    pub gainmapMetadata: OH_Pixelmap_HdrGainmapMetadata,
}
#[doc = " @brief Defines the options used for creating a pixel map.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_InitializationOptions {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create a for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_Create(
        options: *mut *mut OH_Pixelmap_InitializationOptions,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get width number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param width the number of image width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetWidth(
        options: *mut OH_Pixelmap_InitializationOptions,
        width: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set width number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param width the number of image width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetWidth(
        options: *mut OH_Pixelmap_InitializationOptions,
        width: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get height number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param height the number of image height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetHeight(
        options: *mut OH_Pixelmap_InitializationOptions,
        height: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set height number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param height the number of image height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetHeight(
        options: *mut OH_Pixelmap_InitializationOptions,
        height: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelFormat: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param srcpixelFormat the number of image srcpixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetSrcPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        srcpixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param srcpixelFormat the number of image srcpixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetSrcPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        srcpixelFormat: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get rowStride for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param rowStride the rowStride of image buffer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if rowStride is null.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe options is released.\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetRowStride(
        options: *mut OH_Pixelmap_InitializationOptions,
        rowStride: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set rowStride number for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param rowStride the rowStride of image buffer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if rowStride does not match width.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe options is released.\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetRowStride(
        options: *mut OH_Pixelmap_InitializationOptions,
        rowStride: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get alphaType number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param alphaType the number of image alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetAlphaType(
        options: *mut OH_Pixelmap_InitializationOptions,
        alphaType: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set alphaType number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param alphaType the number of image alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetAlphaType(
        options: *mut OH_Pixelmap_InitializationOptions,
        alphaType: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief delete InitializationOtions pointer.\n\n @param options The InitializationOtions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_Release(
        options: *mut OH_Pixelmap_InitializationOptions,
    ) -> Image_ErrorCode;
}
#[doc = " @brief Defines the pixel map information.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_ImageInfo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create imageinfo struct  .\n\n @param info The imageinfo pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_Create(info: *mut *mut OH_Pixelmap_ImageInfo) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get width number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param width The number of imageinfo width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetWidth(
        info: *mut OH_Pixelmap_ImageInfo,
        width: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get height number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param height The number of imageinfo height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetHeight(
        info: *mut OH_Pixelmap_ImageInfo,
        height: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get rowStride number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param rowStride The number of imageinfo rowStride.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetRowStride(
        info: *mut OH_Pixelmap_ImageInfo,
        rowStride: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param pixelFormat The number of imageinfo pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetPixelFormat(
        info: *mut OH_Pixelmap_ImageInfo,
        pixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get alphaType number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param alphaType The number of imageinfo alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetAlphaType(
        info: *mut OH_Pixelmap_ImageInfo,
        alphaType: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get isHdr boolean for imageinfo struct.\n\n @param info The imageinfo pointer will be operated. Pointer connot be null.\n @param isHdr Whether the image has a high dynamic range.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetDynamicRange(
        info: *mut OH_Pixelmap_ImageInfo,
        isHdr: *mut bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Delete imageinfo struct pointer.\n\n @param info The imageinfo pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_Release(info: *mut OH_Pixelmap_ImageInfo) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a <b>PixelMap</b> object.\n\n @param data Color buffer in BGRA_8888 format.\n @param dataLength Color buffer size in BGRA_8888 format.\n @param options IPixel properties, including the alpha type, size, pixel format, and editable.\n @param pixelmap Pixelmap pointer for created.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_CreatePixelmap(
        data: *mut u8,
        dataLength: usize,
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert a native <b>PixelMap</b> object to <b>PixelMap</b> napi object.\n\n @param env Indicates the NAPI environment pointer.\n @param pixelmapNative Indicates a pointer to the <b>PixelMap</b> object created at the native layer.\n @param pixelmapNapi the <b>PixelMap</b> pointer will be converted.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} pixelmapNative is nullptr\n @since 12"]
    pub fn OH_PixelmapNative_ConvertPixelmapNativeToNapi(
        env: napi_env,
        pixelmapNative: *mut OH_PixelmapNative,
        pixelmapNapi: *mut napi_value,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert a <b>PixelMap</b> napi object to native <b>PixelMap</b> object.\n\n @param env Indicates the NAPI environment pointer.\n @param pixelmapNapi Indicates napi <b>PixelMap</b> object.\n @param pixelmapNative Indicates native <b>PixelMap</b> pointer to created.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} pixelmapNative is nullptr, or pixelmapNapi is not a PixelMap\n @since 12"]
    pub fn OH_PixelmapNative_ConvertPixelmapNativeFromNapi(
        env: napi_env,
        pixelmapNapi: napi_value,
        pixelmapNative: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Reads data of this pixel map to an Buffer. If this pixel map is created in the BGRA_8888 format,\n the data read is the same as the original data.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param destination Buffer to which the image pixel map data will be written.\n @param bufferSize Buffer size to which the image pixel map data will be written.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_ReadPixels(
        pixelmap: *mut OH_PixelmapNative,
        destination: *mut u8,
        bufferSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Reads image data in an Buffer and writes the data to a Pixelmap object.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param source Buffer from which the image data will be read.\n @param bufferSize Buffer size from which the image data will be read.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_WritePixels(
        pixelmap: *mut OH_PixelmapNative,
        source: *mut u8,
        bufferSize: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get argb pixel buffer from pixelmap.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param destination Buffer to which the image pixel map data will be written.\n @param bufferSize Buffer size to which the image pixel map data will be written.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, destination and bufferSize are incorrect.\n         {@link IMAGE_UNSUPPORTED_CONVERSION} If format does not support conversion to argb or conversion failed.\n         {@link IMAGE_ALLOC_FAILED} If device has no memory.\n         {@link IMAGE_COPY_FAILED} If memory copy failed.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_GetArgbPixels(
        pixelmap: *mut OH_PixelmapNative,
        destination: *mut u8,
        bufferSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert {@link OH_PixelmapNative} to standard dynamic range.\n\n @param pixelmap The Pixelmap pointer will be operated. Pointer connot be null.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n returns {@link Image_ErrorCode} IMAGE_UNSUPPORTED_OPERATION - Unsupported operation.Pixelmap can't be converted.\n @since 12"]
    pub fn OH_PixelmapNative_ToSdr(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains pixel map information of this image.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param imageInfo Indicates the pointer to the image information.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_GetImageInfo(
        pixelmap: *mut OH_PixelmapNative,
        imageInfo: *mut OH_Pixelmap_ImageInfo,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets an opacity rate for this image pixel map.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param rate Opacity rate to set. The value ranges from 0 to 1.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Opacity(
        pixelmap: *mut OH_PixelmapNative,
        rate: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Scales this image based on the input width and height.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Scale(
        pixelmap: *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Scales this image based on the input width and height with anti-aliasing.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @param level The anti-aliasing algorithm to be used.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, x and y are incorrect.\n returns {@link Image_ErrorCode} IMAGE_TOO_LARGE - if image is too large.\n returns {@link Image_ErrorCode} IMAGE_ALLOC_FAILED - if device has no memory.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe source pixelmap is released.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_ScaleWithAntiAliasing(
        pixelmap: *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
        level: OH_PixelmapNative_AntiAliasingLevel,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Translates this image based on the input coordinates.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param x The distance to be translate in the X direction.\n @param y The distance to be translate in the Y direction.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Translate(
        pixelmap: *mut OH_PixelmapNative,
        x: f32,
        y: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Rotates this image based on the input angle.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param angle Angle to rotate.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Rotate(
        pixelmap: *mut OH_PixelmapNative,
        angle: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Flips this image horizontally or vertically, or both.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param shouldFilpHorizontally Whether to flip the image horizontally.\n @param shouldFilpVertically Whether to flip the image vertically.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Flip(
        pixelmap: *mut OH_PixelmapNative,
        shouldFilpHorizontally: bool,
        shouldFilpVertically: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Crops this image based on the input size.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param region Area size, read according to area.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Crop(
        pixelmap: *mut OH_PixelmapNative,
        region: *mut Image_Region,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases an <b>OH_Pixelmap</b> object.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Release(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Converting images to alpha format\n\n @param srcpixelmap The source pixel map pointer will be operated.\n @param dstpixelmap The destination pixel map pointer will be operated.\n @param isPremul Whether it is pre-multiplied, true for prediction, false for non-pre-multiplied.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_ConvertAlphaFormat(
        srcpixelmap: *mut OH_PixelmapNative,
        dstpixelmap: *mut OH_PixelmapNative,
        isPremul: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Create a empty <b>PixelMap</b> object.\n\n @param options IPixel properties, including the alpha type, size, pixel format, and editable.\n @param pixelmap Pixelmap pointer for created.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_CreateEmptyPixelmap(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get metadata.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param key Type of metadata.\n @param value Value of metadata.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, key and value are incorrect.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory does not exist.\n returns {@link Image_ErrorCode} IMAGE_COPY_FAILED - if memory copy failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_GetMetadata(
        pixelmap: *mut OH_PixelmapNative,
        key: OH_Pixelmap_HdrMetadataKey,
        value: *mut *mut OH_Pixelmap_HdrMetadataValue,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set metadata.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param key Type of metadata.\n @param value Value of metadata.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, key and value are incorrect.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory does not exist.\n returns {@link Image_ErrorCode} IMAGE_COPY_FAILED - if memory copy failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_SetMetadata(
        pixelmap: *mut OH_PixelmapNative,
        key: OH_Pixelmap_HdrMetadataKey,
        value: *mut OH_Pixelmap_HdrMetadataValue,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the native buffer from the PixelMap.\n\n @param pixelmap The PixelMap to get the native buffer from.\n @param nativeBuffer The native buffer to retrieve.\n @return Returns {@link Image_ErrorCode} IMAGE_RESULT_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, pixelmap or nativeBuffer is null.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory dose not exist.\n returns {@link Image_ErrorCode} IMAGE_DMA_OPERATION_FAILED - if operations related to DMA memory has failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_GetNativeBuffer(
        pixelmap: *mut OH_PixelmapNative,
        nativeBuffer: *mut *mut OH_NativeBuffer,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the native colorspace from the PixelMap.\n\n @param pixelmap The native pixelmap to get the native colorspace from.\n @param colorSpaceNative The native colorspace to retrieve.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} The param of pixelmap or colorSpaceNative is nullptr or invalid.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_GetColorSpaceNative(
        pixelmap: *mut OH_PixelmapNative,
        colorSpaceNative: *mut *mut OH_NativeColorSpaceManager,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set the native colorspace for the PixelMap.\n\n @param pixelmap The native pixelmap to set the native colorspace for.\n @param colorSpaceNative The native colorspace to set.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} The param of pixelmap or colorSpaceNative is nullptr or invalid.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_SetColorSpaceNative(
        pixelmap: *mut OH_PixelmapNative,
        colorSpaceNative: *mut OH_NativeColorSpaceManager,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelmap memory name.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param name The pointer of name that needs to be set.\n @param size The size of name size that needs to be set.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, name and size are incorrect.\n         {@link IMAGE_UNSUPPORTED_MEMORY_FORMAT} If memory format is unsupported.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_SetMemoryName(
        pixelmap: *mut OH_PixelmapNative,
        name: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the memory address of a PixelMap and locks the memory.\n        When the memory is locked, any operation that modifies or releases the PixelMap will fail and return\n        {@link IMAGE_BAD_PARAMETER}.\n\n @param pixelmap The PixelMap pointer to be operated.\n @param addr The double pointer to the memory address of the PixelMap.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap or addr are invalid.\n         {@link IMAGE_LOCK_UNLOCK_FAILED} If memory failed to be locked.\n @see OH_PixelmapNative\n @since 15"]
    pub fn OH_PixelmapNative_AccessPixels(
        pixelmap: *mut OH_PixelmapNative,
        addr: *mut *mut ::std::os::raw::c_void,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Unlocks the memory of the PixelMap data.\n        This function is used with {@link OH_PixelmapNative_AccessPixels} in pairs.\n\n @param pixelmap The PixelMap pointer to be operated.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap is invalid.\n         {@link IMAGE_LOCK_UNLOCK_FAILED} If memory failed to be unlocked.\n @see OH_PixelmapNative\n @since 15"]
    pub fn OH_PixelmapNative_UnaccessPixels(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
#[doc = " @brief The intention is drag."]
pub const Udmf_Intention_UDMF_INTENTION_DRAG: Udmf_Intention = 0;
#[doc = " @brief The intention is pasteboard."]
pub const Udmf_Intention_UDMF_INTENTION_PASTEBOARD: Udmf_Intention = 1;
#[doc = " @brief Describe the intention type of the udmf.\n\n @since 12"]
pub type Udmf_Intention = ::std::os::raw::c_uint;
#[doc = " @brief Invalid share option."]
pub const Udmf_ShareOption_SHARE_OPTIONS_INVALID: Udmf_ShareOption = 0;
#[doc = " @brief Allowed to be used in the same application on this device."]
pub const Udmf_ShareOption_SHARE_OPTIONS_IN_APP: Udmf_ShareOption = 1;
#[doc = " @brief Allowed to be used in the cross application on this device."]
pub const Udmf_ShareOption_SHARE_OPTIONS_CROSS_APP: Udmf_ShareOption = 2;
#[doc = " @brief Describe intra-device usage range type enumeration.\n\n @since 12"]
pub type Udmf_ShareOption = ::std::os::raw::c_uint;
#[doc = " @brief Overwrite when dest uri has file with same name."]
pub const Udmf_FileConflictOptions_UDMF_OVERWRITE: Udmf_FileConflictOptions = 0;
#[doc = " @brief Skip when dest uri has file with same name."]
pub const Udmf_FileConflictOptions_UDMF_SKIP: Udmf_FileConflictOptions = 1;
#[doc = " @brief Describe the types of file conflict options when getting data from the udmf.\n\n @since 15"]
pub type Udmf_FileConflictOptions = ::std::os::raw::c_uint;
#[doc = " @brief Getting data without system default progress indicator."]
pub const Udmf_ProgressIndicator_UDMF_NONE: Udmf_ProgressIndicator = 0;
#[doc = " @brief Getting data with system default progress indicator."]
pub const Udmf_ProgressIndicator_UDMF_DEFAULT: Udmf_ProgressIndicator = 1;
#[doc = " @brief Describe the types of progress indicator when getting data from the udmf.\n\n @since 15"]
pub type Udmf_ProgressIndicator = ::std::os::raw::c_uint;
#[doc = " @brief Defines the callback function used free the context.\n @param context Pointer to the context which is to be free.\n @since 13"]
pub type UdmfData_Finalize =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Change of the Pasteboard data in the local device."]
pub const Pasteboard_NotifyType_NOTIFY_LOCAL_DATA_CHANGE: Pasteboard_NotifyType = 1;
#[doc = " @brief Change of the Pasteboard data in the remote devices."]
pub const Pasteboard_NotifyType_NOTIFY_REMOTE_DATA_CHANGE: Pasteboard_NotifyType = 2;
#[doc = " @brief Enumerates the types of data changes that can be observed.\n\n @since 13"]
pub type Pasteboard_NotifyType = ::std::os::raw::c_uint;
#[doc = " @brief Overwrite when destUir has file with same name."]
pub const Pasteboard_FileConflictOptions_PASTEBOARD_OVERWRITE: Pasteboard_FileConflictOptions = 0;
#[doc = " @brief Skip when destUir has file with same name."]
pub const Pasteboard_FileConflictOptions_PASTEBOARD_SKIP: Pasteboard_FileConflictOptions = 1;
#[doc = " @brief Enumerates the types of file confilct options when getting data from the Pastedboard.\n\n @since 15"]
pub type Pasteboard_FileConflictOptions = ::std::os::raw::c_uint;
#[doc = " @brief Getting data without system default progress indicator."]
pub const Pasteboard_ProgressIndicator_PASTEBOARD_NONE: Pasteboard_ProgressIndicator = 0;
#[doc = " @brief Getting data with system default progress indicator."]
pub const Pasteboard_ProgressIndicator_PASTEBOARD_DEFAULT: Pasteboard_ProgressIndicator = 1;
#[doc = " @brief Enumerates the types of progress indicator when getting data from the Pastedboard.\n\n @since 15"]
pub type Pasteboard_ProgressIndicator = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pasteboard_ProgressInfo {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the callback function used to return the progress information when getting PasteData.\n\n @param progressInfo The progress information notified to Application.\n @since 15"]
pub type OH_Pasteboard_ProgressListener =
    ::std::option::Option<unsafe extern "C" fn(progressInfo: *mut Pasteboard_ProgressInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pasteboard_GetDataParams {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the callback function used to return the Pasteboard data changed.\n\n @param context The context set by {@link OH_PasteboardObserver_SetData} function.\n @param type The types of data changes. For details, see {@link Pasteboard_NotifyType}.\n @since 13"]
pub type Pasteboard_Notify = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, type_: Pasteboard_NotifyType),
>;
#[doc = " @brief Defines the callback function used free the context.\n @param context Pointer to the context which is to be free.\n @since 13"]
pub type Pasteboard_Finalize =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PasteboardObserver {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates a {@link OH_PasteboardObserver} instance.\n\n @return Returns the pointer to the {@link OH_PasteboardObserver} instance created if the operation is successful.\n Returns nullptr if the operation is failed.\n @see OH_PasteboardObserver.\n @since 13"]
    pub fn OH_PasteboardObserver_Create() -> *mut OH_PasteboardObserver;
}
extern "C" {
    #[doc = " @brief Destroy a {@link OH_PasteboardObserver} instance.\n\n @param observer Pointer to the {@link OH_PasteboardObserver} instance to destroy.\n @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.\n         Returns {@link ERR_OK} if the operation is successful.\n         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.\n @see OH_PasteboardObserver PASTEBOARD_ErrCode.\n @since 13"]
    pub fn OH_PasteboardObserver_Destroy(
        observer: *mut OH_PasteboardObserver,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets a callback function to return the Pasteboard data changed.\n\n @param observer Pointer to the {@link OH_PasteboardObserver} instance.\n @param context Pointer to the context set, which is the first parameter in Pasteboard_Notify.\n @param callback Callback to set. For details, see {@link Pasteboard_Notify}.\n @param finalize Optional callback that can free context when destroy observer.\n         For details, see {@link Pasteboard_Finalize}.\n @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.\n         Returns {@link ERR_OK} if the operation is successful.\n         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.\n @see OH_PasteboardObserver Pasteboard_Notify PASTEBOARD_ErrCode.\n @since 13"]
    pub fn OH_PasteboardObserver_SetData(
        observer: *mut OH_PasteboardObserver,
        context: *mut ::std::os::raw::c_void,
        callback: Pasteboard_Notify,
        finalize: Pasteboard_Finalize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pasteboard {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates a {@link OH_Pasteboard} instance.\n\n @return Returns the pointer to the {@link OH_Pasteboard} instance created if the operation is successful.\n Returns nullptr if the memory is not enough.\n @see OH_Pasteboard.\n @since 13"]
    pub fn OH_Pasteboard_Create() -> *mut OH_Pasteboard;
}
extern "C" {
    #[doc = " @brief Destroy a {@link OH_Pasteboard} instance.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance to destroy.\n @see OH_Pasteboard.\n @since 13"]
    pub fn OH_Pasteboard_Destroy(pasteboard: *mut OH_Pasteboard);
}
extern "C" {
    #[doc = " @brief Subscribes to the Pasteboard data change.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @param type Event type to subscribe to.\n @param observer - Pointer to the observer information, which specifies the callback used to\n reporting the pasteboard data change. For details, see {@link OH_PasteboardObserver}.\n @return Returns the status code of the execution. For details, {@link PASTEBOARD_ErrCode}.\n         Returns {@link ERR_OK} if the operation is successful.\n         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.\n @see OH_Pasteboard OH_PasteboardObserver PASTEBOARD_ErrCode.\n @since 13"]
    pub fn OH_Pasteboard_Subscribe(
        pasteboard: *mut OH_Pasteboard,
        type_: ::std::os::raw::c_int,
        observer: *const OH_PasteboardObserver,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Unsubscribes from the Pasteboard data change.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @param type Event type to subscribe to.\n @param observer - Pointer to the observer information, which specifies the callback used to\n reporting the pasteboard data change. For details, see {@link OH_PasteboardObserver}.\n @return Returns the status code of the execution. For details, {@link PASTEBOARD_ErrCode}.\n         Returns {@link ERR_OK} if the operation is successful.\n         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.\n @see OH_Pasteboard OH_PasteboardObserver PASTEBOARD_ErrCode.\n @since 13"]
    pub fn OH_Pasteboard_Unsubscribe(
        pasteboard: *mut OH_Pasteboard,
        type_: ::std::os::raw::c_int,
        observer: *const OH_PasteboardObserver,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Checks whether the Pasteboard data is from a remote device.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @return Returns a boolean value, which indicates whether the the data is from a remote device.\n         The value {@code false} means Pasteboard data is not from a remote device.\n         The value {@code true} means the opposite.\n @see OH_Pasteboard.\n @since 13"]
    pub fn OH_Pasteboard_IsRemoteData(pasteboard: *mut OH_Pasteboard) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains the source of Pasteboard data.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @param source Pointer to the source data.\n @param len Length of the source data.\n @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.\n         Returns {@link ERR_OK} if the operation is successful.\n         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.\n @see OH_Pasteboard PASTEBOARD_ErrCode.\n @since 13"]
    pub fn OH_Pasteboard_GetDataSource(
        pasteboard: *mut OH_Pasteboard,
        source: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Checks whether the Pasteboard has the specified type of data.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @param type Poniter to the type of data to check.\n @return Returns a boolean value, which indicates whether the Pasteboard has the specified type of data.\n         The value {@code true} means the Pasteboard has the specified type of data.\n         The value {@code false} means the opposite.\n @see OH_Pasteboard.\n @since 13"]
    pub fn OH_Pasteboard_HasType(
        pasteboard: *mut OH_Pasteboard,
        type_: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Checks whether there is data in the Pasteboard.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @return Returns a boolean value, which indicates whether there is data in the Pasteboard.\n         The value {@code true} means there is data in Pasteboard.\n         The value {@code false} means the opposite.\n @see OH_Pasteboard.\n @since 13"]
    pub fn OH_Pasteboard_HasData(pasteboard: *mut OH_Pasteboard) -> bool;
}
extern "C" {
    #[doc = " @brief Obtains data from the Pasteboard.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @param status The status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.\n @return Returns the pointer to the {@link OH_UdmfData} instance.\n @see OH_Pasteboard OH_UdmfData PASTEBOARD_ErrCode.\n @since 13"]
    pub fn OH_Pasteboard_GetData(
        pasteboard: *mut OH_Pasteboard,
        status: *mut ::std::os::raw::c_int,
    ) -> *mut OH_UdmfData;
}
extern "C" {
    #[doc = " @brief Writes data to the Pasteboard.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @param data Pointer to the {@link OH_UdmfData} instance.\n @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.\n         Returns {@link ERR_OK} if the operation is successful.\n         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.\n @see OH_Pasteboard OH_UdmfData PASTEBOARD_ErrCode.\n @since 13"]
    pub fn OH_Pasteboard_SetData(
        pasteboard: *mut OH_Pasteboard,
        data: *mut OH_UdmfData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Clears the data in the Pastedboard.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @return Returns the status code of the execution. For details, see {@link PASTEBOARD_ErrCode}.\n         Returns {@link ERR_OK} if the operation is successful.\n         Returns {@link ERR_INVALID_PARAMETER} if invalid args are detected.\n @see OH_Pasteboard PASTEBOARD_ErrCode.\n @since 13"]
    pub fn OH_Pasteboard_ClearData(pasteboard: *mut OH_Pasteboard) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Obtains all MIME types of Pasteboard data.\n\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @param count Poniter to the count of MIME types.\n @return Returns char array of MIME types in the Pasteboard.\n Returns nullptr if the operation is failed.\n @see OH_Pasteboard.\n @since 14"]
    pub fn OH_Pasteboard_GetMimeTypes(
        pasteboard: *mut OH_Pasteboard,
        count: *mut ::std::os::raw::c_uint,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Create a pointer to the instance of the {@link Pasteboard_GetDataParams}.\n\n @return If the operation is successful, a pointer to the instance of the {@link Pasteboard_GetDataParams}\n structure is returned. If the operation is failed, nullptr is returned.\n @see Pasteboard_GetDataParams\n @since 15"]
    pub fn OH_Pasteboard_GetDataParams_Create() -> *mut Pasteboard_GetDataParams;
}
extern "C" {
    #[doc = " @brief Destroy a pointer that points to an instance of {@link Pasteboard_GetDataParams}.\n\n @param params Represents a pointer to an instance of {@link Pasteboard_GetDataParams}.\n @see Pasteboard_GetDataParams\n @since 15"]
    pub fn OH_Pasteboard_GetDataParams_Destroy(params: *mut Pasteboard_GetDataParams);
}
extern "C" {
    #[doc = " @brief Set the progress indicator to the {@link Pasteboard_GetDataParams}.\n\n @param params Represents a pointer to an instance of {@link Pasteboard_GetDataParams}.\n @param progressIndicator Represents to the progress indicator.\n @see Pasteboard_GetDataParams Pasteboard_ProgressIndicator\n @since 15"]
    pub fn OH_Pasteboard_GetDataParams_SetProgressIndicator(
        params: *mut Pasteboard_GetDataParams,
        progressIndicator: Pasteboard_ProgressIndicator,
    );
}
extern "C" {
    #[doc = " @brief Set the destination uri to the {@link Pasteboard_GetDataParams}.\n\n @param params Represents a pointer to an instance of {@link Pasteboard_GetDataParams}.\n @param destUri Pointer to a destination uri.\n @param destUriLen Indicates the length of destination uri.\n @see Pasteboard_GetDataParams\n @since 15"]
    pub fn OH_Pasteboard_GetDataParams_SetDestUri(
        params: *mut Pasteboard_GetDataParams,
        destUri: *const ::std::os::raw::c_char,
        destUriLen: u32,
    );
}
extern "C" {
    #[doc = " @brief Set the file conflict options to the {@link Pasteboard_GetDataParams}.\n\n @param params Represents a pointer to an instance of {@link Pasteboard_GetDataParams}.\n @param option Represents to the file conflict options.\n @see Pasteboard_GetDataParams Pasteboard_FileConflictOptions\n @since 15"]
    pub fn OH_Pasteboard_GetDataParams_SetFileConflictOptions(
        params: *mut Pasteboard_GetDataParams,
        option: Pasteboard_FileConflictOptions,
    );
}
extern "C" {
    #[doc = " @brief Set the progress indicator to the {@link Pasteboard_GetDataParams}.\n\n @param params Represents a pointer to an instance of {@link Pasteboard_GetDataParams}.\n @param listener Represents to the data progress listener.\n @see Pasteboard_GetDataParams OH_Pasteboard_ProgressListener\n @since 15"]
    pub fn OH_Pasteboard_GetDataParams_SetProgressListener(
        params: *mut Pasteboard_GetDataParams,
        listener: OH_Pasteboard_ProgressListener,
    );
}
extern "C" {
    #[doc = " @brief Get the progress from the {@link Pasteboard_ProgressInfo}.\n\n @param progressInfo Represents a pointer to an instance of {@link Pasteboard_ProgressInfo}.\n @return Returns the progress.\n @see Pasteboard_ProgressInfo\n @since 15"]
    pub fn OH_Pasteboard_ProgressInfo_GetProgress(
        progressInfo: *mut Pasteboard_ProgressInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Defines the cancel function used to cancel the progress when getting PasteData.\n\n @param params Pointer to indicates the {@link Pasteboard_GetDataParams}.\n @see Pasteboard_GetDataParams.\n @since 15"]
    pub fn OH_Pasteboard_ProgressCancel(params: *mut Pasteboard_GetDataParams);
}
extern "C" {
    #[doc = " @brief Obtains data from the Pasteboard with system progress indicator.\n\n @permission ohos.permission.READ_PASTEBOARD\n @param pasteboard Pointer to the {@link OH_Pasteboard} instance.\n @param params Pointer to indicates the  {@link OH_Pasteboard_GetDataParams}.\n @param status The status code of the execution. For details, see {@link PASTEBOARD_Errcode}.\n @return Returns the pointer to the {@link OH_PasteData} instance.\n @see OH_Pasteboard OH_PasteData PASTEBOARD_ErrCode.\n @since 15"]
    pub fn OH_Pasteboard_GetDataWithProgress(
        pasteboard: *mut OH_Pasteboard,
        params: *mut Pasteboard_GetDataParams,
        status: *mut ::std::os::raw::c_int,
    ) -> *mut OH_UdmfData;
}
