/* automatically generated by rust-bindgen 0.65.1 */

#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(clippy::missing_safety_doc)]

use napi_sys_ohos::*;
use ohos_native_buffer_sys::*;
use ohos_resource_manager_sys::*;

#[link(name = "image_ndk.z")]
#[link(name = "image_packer_ndk.z")]
#[link(name = "pixelmap_ndk.z")]
#[link(name = "image_receiver_ndk.z")]
#[link(name = "image_source_ndk.z")]
unsafe extern "C" {}

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[doc = " @brief Defines the image size.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_Size {
    #[doc = " Image width, in pixels."]
    pub width: u32,
    #[doc = " Image height, in pixels."]
    pub height: u32,
}
#[doc = " @brief Defines the region of the image source to decode.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_Region {
    #[doc = " X coordinate of the start point, in pixels."]
    pub x: u32,
    #[doc = " Y coordinate of the start point, in pixels."]
    pub y: u32,
    #[doc = " Width of the region, in pixels."]
    pub width: u32,
    #[doc = " Height of the region, in pixels."]
    pub height: u32,
}
#[doc = " @brief Defines the region of the image source to decode.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image_String {
    #[doc = " data for string type"]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = " data lenth for string type"]
    pub size: usize,
}
#[cfg(feature = "api-13")]
#[doc = " @brief Define a PictureMetadata struct type, used for picture metadata.\n\n @since 13"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PictureMetadata {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the image encode format.\n\n @since 12"]
pub type Image_MimeType = Image_String;
#[doc = " operation success"]
pub const Image_ErrorCode_IMAGE_SUCCESS: Image_ErrorCode = 0;
#[doc = " invalid parameter"]
pub const Image_ErrorCode_IMAGE_BAD_PARAMETER: Image_ErrorCode = 401;
#[doc = " unsupported mime type"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_MIME_TYPE: Image_ErrorCode = 7600101;
#[doc = " unknown mime type"]
pub const Image_ErrorCode_IMAGE_UNKNOWN_MIME_TYPE: Image_ErrorCode = 7600102;
#[doc = " too large data or image"]
pub const Image_ErrorCode_IMAGE_TOO_LARGE: Image_ErrorCode = 7600103;
#[doc = " @error DMA memory does not exist"]
pub const Image_ErrorCode_IMAGE_DMA_NOT_EXIST: Image_ErrorCode = 7600173;
#[doc = " @error DMA operation failed"]
pub const Image_ErrorCode_IMAGE_DMA_OPERATION_FAILED: Image_ErrorCode = 7600174;
#[doc = " unsupported operations"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_OPERATION: Image_ErrorCode = 7600201;
#[doc = " unsupported metadata"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_METADATA: Image_ErrorCode = 7600202;
#[doc = " unsupported conversion"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_CONVERSION: Image_ErrorCode = 7600203;
#[doc = " invalid region"]
pub const Image_ErrorCode_IMAGE_INVALID_REGION: Image_ErrorCode = 7600204;
#[cfg(feature = "api-13")]
#[doc = "  @error unsupported memory format\n  @since 13"]
pub const Image_ErrorCode_IMAGE_UNSUPPORTED_MEMORY_FORMAT: Image_ErrorCode = 7600205;
#[cfg(feature = "api-19")]
#[doc = " @error Invalid parameter.\n @since 19"]
pub const Image_ErrorCode_IMAGE_INVALID_PARAMETER: Image_ErrorCode = 7600206;
#[doc = " failed to allocate memory"]
pub const Image_ErrorCode_IMAGE_ALLOC_FAILED: Image_ErrorCode = 7600301;
#[doc = " memory copy failed"]
pub const Image_ErrorCode_IMAGE_COPY_FAILED: Image_ErrorCode = 7600302;
#[cfg(feature = "api-15")]
#[doc = " @error memory lock or unlock failed\n @since 15"]
pub const Image_ErrorCode_IMAGE_LOCK_UNLOCK_FAILED: Image_ErrorCode = 7600303;
#[cfg(feature = "api-20")]
#[doc = " @error unsupported allocator mode, e.g., use share memory to create a HDR image as only\n DMA supported hdr metadata.\n @since 20"]
pub const Image_ErrorCode_IMAGE_ALLOCATOR_MODE_UNSUPPORTED: Image_ErrorCode = 7600501;
#[doc = " unknown error"]
pub const Image_ErrorCode_IMAGE_UNKNOWN_ERROR: Image_ErrorCode = 7600901;
#[doc = " decode data source exception"]
pub const Image_ErrorCode_IMAGE_BAD_SOURCE: Image_ErrorCode = 7700101;
#[cfg(feature = "api-15")]
#[doc = " @error unsupported mime type\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_MIME_TYPE: Image_ErrorCode = 7700102;
#[cfg(feature = "api-15")]
#[doc = " @error image to large\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_TOO_LARGE: Image_ErrorCode = 7700103;
#[cfg(feature = "api-15")]
#[doc = " @error unsupported allocator type, e.g., use share memory to decode a HDR image as only\n DMA supported hdr metadata.\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_ALLOCATOR_TYPE: Image_ErrorCode = 7700201;
pub const Image_ErrorCode_IMAGE_SOURCE_UNSUPPORTED_OPTIONS: Image_ErrorCode = 7700203;
#[cfg(feature = "api-19")]
#[doc = " @error Invalid parameter.\n @since 19"]
pub const Image_ErrorCode_IMAGE_SOURCE_INVALID_PARAMETER: Image_ErrorCode = 7700204;
#[doc = " decode failed"]
pub const Image_ErrorCode_IMAGE_DECODE_FAILED: Image_ErrorCode = 7700301;
#[cfg(feature = "api-15")]
#[doc = " @error memory allocation failed\n @since 15"]
pub const Image_ErrorCode_IMAGE_SOURCE_ALLOC_FAILED: Image_ErrorCode = 7700302;
#[cfg(feature = "api-19")]
#[doc = " @error Invalid parameter for ImagePacker.\n @since 19"]
pub const Image_ErrorCode_IMAGE_PACKER_INVALID_PARAMETER: Image_ErrorCode = 7800202;
#[doc = " encode failed"]
pub const Image_ErrorCode_IMAGE_ENCODE_FAILED: Image_ErrorCode = 7800301;
#[cfg(feature = "api-20")]
#[doc = " @error Invalid parameter for ImageReceiver.\n @since 20"]
pub const Image_ErrorCode_IMAGE_RECEIVER_INVALID_PARAMETER: Image_ErrorCode = 7900201;
#[doc = " @brief Enumerates the return values that may be used by the interface.\n\n @since 12"]
pub type Image_ErrorCode = ::std::os::raw::c_uint;
#[doc = " EXIF metadata."]
#[cfg(feature = "api-13")]
pub const Image_MetadataType_EXIF_METADATA: Image_MetadataType = 1;
#[doc = " Fragment metadata."]
#[cfg(feature = "api-13")]
pub const Image_MetadataType_FRAGMENT_METADATA: Image_MetadataType = 2;
#[cfg(feature = "api-20")]
#[doc = " Metadata of a GIF image.\n\n @since 20"]
pub const Image_MetadataType_GIF_METADATA: Image_MetadataType = 5;
#[cfg(feature = "api-13")]
#[doc = " @brief Define the metadata type.\n\n @since 13"]
pub type Image_MetadataType = ::std::os::raw::c_uint;
#[cfg(feature = "api-20")]
#[doc = " The system determines which memory to use to create the PixelMap.\n\n @since 20"]
pub const IMAGE_ALLOCATOR_MODE_IMAGE_ALLOCATOR_MODE_AUTO: IMAGE_ALLOCATOR_MODE = 0;
#[cfg(feature = "api-20")]
#[doc = " Use DMA buffer to create the PixelMap.\n\n @since 20"]
pub const IMAGE_ALLOCATOR_MODE_IMAGE_ALLOCATOR_MODE_DMA: IMAGE_ALLOCATOR_MODE = 1;
#[cfg(feature = "api-20")]
#[doc = " Use share memory to create the PixelMap.\n\n @since 20"]
pub const IMAGE_ALLOCATOR_MODE_IMAGE_ALLOCATOR_MODE_SHARED_MEMORY: IMAGE_ALLOCATOR_MODE = 2;
#[cfg(feature = "api-20")]
#[doc = " @brief Type of allocator used to allocate memory of a PixelMap.\n\n @since 20"]
pub type IMAGE_ALLOCATOR_MODE = ::std::os::raw::c_uint;
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Creates a <b>PictureMetadata</b> object.\n\n @param metadataType The type of metadata.\n @param metadata The PictureMetadata pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n @since 13"]
    pub fn OH_PictureMetadata_Create(
        metadataType: Image_MetadataType,
        metadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the property of picture metadata.\n\n @param metadata The PictureMetadata pointer will be operated.\n @param key The property's key.\n @param value The property's value.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    pub fn OH_PictureMetadata_GetProperty(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set picture metadata property.\n\n @param metadata The PictureMetadata pointer will be operated.\n @param key The property's key.\n @param value The property's value.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    pub fn OH_PictureMetadata_SetProperty(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-19")]
    #[doc = " @brief Obtains the property of picture metadata. The output value.data is null-terminated.\n\n @param metadata Pointer to OH_PictureMetadata.\n @param key Pointer to property's key.\n @param value Pointer to property's value. Output parameter.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_INVALID_PARAMETER} metadata is nullptr, or key is nullptr, or value is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 19"]
    pub fn OH_PictureMetadata_GetPropertyWithNull(
        metadata: *mut OH_PictureMetadata,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Releases this PictureMetadata object.\n\n @param metadata The PictureMetadata pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n @since 13"]
    pub fn OH_PictureMetadata_Release(metadata: *mut OH_PictureMetadata) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains a clone of metadata.\n\n @param oldMetadata The PictureMetadata pointer will be operated.\n @param newMetadata The PictureMetadata pointer will be cloned.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} metadata is nullptr.\n         {@link IMAGE_ALLOC_FAILED} memory alloc failed.\n         {@link IMAGE_COPY_FAILED} memory copy failed.\n @since 13"]
    pub fn OH_PictureMetadata_Clone(
        oldMetadata: *mut OH_PictureMetadata,
        newMetadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OHIPCParcel {
    _unused: [u8; 0],
}
#[doc = " if rects is nullptr, fill the Buffer dirty size by default"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Region_Rect {
    pub x: i32,
    pub y: i32,
    pub w: u32,
    pub h: u32,
}
#[doc = " the window content is not updated until a buffer of\n the window size is received"]
pub const OHScalingMode_OH_SCALING_MODE_FREEZE: OHScalingMode = 0;
#[doc = " the buffer is scaled in two dimensions to match the window size"]
pub const OHScalingMode_OH_SCALING_MODE_SCALE_TO_WINDOW: OHScalingMode = 1;
#[doc = " the buffer is uniformly scaled so that the smaller size of\n the buffer matches the window size"]
pub const OHScalingMode_OH_SCALING_MODE_SCALE_CROP: OHScalingMode = 2;
#[doc = " the window is clipped to the size of the buffer's clipping rectangle\n pixels outside the clipping rectangle are considered fully transparent."]
pub const OHScalingMode_OH_SCALING_MODE_NO_SCALE_CROP: OHScalingMode = 3;
#[doc = " @brief Indicates Scaling Mode.\n @since 9\n @deprecated(since = \"10\")\n @useinstead OHScalingModeV2"]
pub type OHScalingMode = ::std::os::raw::c_uint;
#[doc = " the window content is not updated until a buffer of\n the window size is received"]
pub const OHScalingModeV2_OH_SCALING_MODE_FREEZE_V2: OHScalingModeV2 = 0;
#[doc = " the buffer is scaled in two dimensions to match the window size"]
pub const OHScalingModeV2_OH_SCALING_MODE_SCALE_TO_WINDOW_V2: OHScalingModeV2 = 1;
#[doc = " the buffer is uniformly scaled so that the smaller size of\n the buffer matches the window size"]
pub const OHScalingModeV2_OH_SCALING_MODE_SCALE_CROP_V2: OHScalingModeV2 = 2;
#[doc = " the window is clipped to the size of the buffer's clipping rectangle\n pixels outside the clipping rectangle are considered fully transparent."]
pub const OHScalingModeV2_OH_SCALING_MODE_NO_SCALE_CROP_V2: OHScalingModeV2 = 3;
#[doc = " Adapt to the buffer and scale proportionally to the buffer size. Prioritize displaying all buffer content.\n If the size is not the same as the window size, fill the unfilled area of the window with a background color."]
pub const OHScalingModeV2_OH_SCALING_MODE_SCALE_FIT_V2: OHScalingModeV2 = 4;
#[doc = " @brief Indicates Scaling Mode.\n @since 12"]
pub type OHScalingModeV2 = ::std::os::raw::c_uint;
pub const OHHDRMetadataKey_OH_METAKEY_RED_PRIMARY_X: OHHDRMetadataKey = 0;
pub const OHHDRMetadataKey_OH_METAKEY_RED_PRIMARY_Y: OHHDRMetadataKey = 1;
pub const OHHDRMetadataKey_OH_METAKEY_GREEN_PRIMARY_X: OHHDRMetadataKey = 2;
pub const OHHDRMetadataKey_OH_METAKEY_GREEN_PRIMARY_Y: OHHDRMetadataKey = 3;
pub const OHHDRMetadataKey_OH_METAKEY_BLUE_PRIMARY_X: OHHDRMetadataKey = 4;
pub const OHHDRMetadataKey_OH_METAKEY_BLUE_PRIMARY_Y: OHHDRMetadataKey = 5;
pub const OHHDRMetadataKey_OH_METAKEY_WHITE_PRIMARY_X: OHHDRMetadataKey = 6;
pub const OHHDRMetadataKey_OH_METAKEY_WHITE_PRIMARY_Y: OHHDRMetadataKey = 7;
pub const OHHDRMetadataKey_OH_METAKEY_MAX_LUMINANCE: OHHDRMetadataKey = 8;
pub const OHHDRMetadataKey_OH_METAKEY_MIN_LUMINANCE: OHHDRMetadataKey = 9;
pub const OHHDRMetadataKey_OH_METAKEY_MAX_CONTENT_LIGHT_LEVEL: OHHDRMetadataKey = 10;
pub const OHHDRMetadataKey_OH_METAKEY_MAX_FRAME_AVERAGE_LIGHT_LEVEL: OHHDRMetadataKey = 11;
pub const OHHDRMetadataKey_OH_METAKEY_HDR10_PLUS: OHHDRMetadataKey = 12;
pub const OHHDRMetadataKey_OH_METAKEY_HDR_VIVID: OHHDRMetadataKey = 13;
#[doc = " @brief Enumerates the HDR metadata keys.\n @since 9\n @deprecated(since = \"10\")"]
pub type OHHDRMetadataKey = ::std::os::raw::c_uint;
#[doc = " @brief Defines the HDR metadata.\n @since 9\n @deprecated(since = \"10\")"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OHHDRMetaData {
    pub key: OHHDRMetadataKey,
    pub value: f32,
}
#[doc = " @brief Defines the ExtData Handle\n @since 9\n @deprecated(since = \"10\")"]
#[repr(C)]
#[derive(Debug)]
pub struct OHExtDataHandle {
    pub fd: i32,
    pub reserveInts: u32,
    pub reserve: __IncompleteArrayField<i32>,
}
#[doc = " @brief Defines an <b>OH_ImageNative</b> object.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_ImageNative {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Obtains {@link Image_Size} of an {@link OH_ImageNative} object.\n\n @param image Indicates the pointer to an {@link OH_ImageNative} object.\n @param size Indicates the pointer to the {@link Image_Size} object obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error.\n @since 12"]
    pub fn OH_ImageNative_GetImageSize(
        image: *mut OH_ImageNative,
        size: *mut Image_Size,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get type arry from an {@link OH_ImageNative} object.\n\n @param image Indicates the pointer to an {@link OH_ImageNative} object.\n @param types Indicates the pointer to an {@link OH_ImageNative} component arry obtained.\n @param typeSize Indicates the pointer to the {@link OH_ImageNative} component arry size obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageNative_GetComponentTypes(
        image: *mut OH_ImageNative,
        types: *mut *mut u32,
        typeSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get byte buffer from an {@link OH_ImageNative} object by the component type.\n\n @param image Indicates the pointer to an {@link OH_ImageNative} object.\n @param componentType Indicates the type of component.\n @param nativeBuffer Indicates the pointer to the component buffer obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageNative_GetByteBuffer(
        image: *mut OH_ImageNative,
        componentType: u32,
        nativeBuffer: *mut *mut OH_NativeBuffer,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get size of buffer from an {@link OH_ImageNative} object by the component type.\n\n @param image Indicates the pointer to an {@link OH_ImageNative} object.\n @param componentType Indicates the type of component.\n @param size Indicates the pointer to the size of buffer obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageNative_GetBufferSize(
        image: *mut OH_ImageNative,
        componentType: u32,
        size: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get row stride from an {@link OH_ImageNative} object by the component type.\n\n @param image Indicates the pointer to an {@link OH_ImageNative} object.\n @param componentType Indicates the type of component.\n @param rowStride Indicates the pointer to the row stride obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageNative_GetRowStride(
        image: *mut OH_ImageNative,
        componentType: u32,
        rowStride: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixel stride from an {@link OH_ImageNative} object by the component type.\n\n @param image Indicates the pointer to an {@link OH_ImageNative} object.\n @param componentType Indicates the type of component.\n @param pixelStride Indicates the pointer to the pixel stride obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageNative_GetPixelStride(
        image: *mut OH_ImageNative,
        componentType: u32,
        pixelStride: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get timestamp from an {@link OH_ImageNative} object.\n\n @param image Indicates the pointer to an {@link OH_ImageNative} object.\n @param timestamp Indicates the pointer to the timestamp obtained.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} if the input parameter is invalid.\n @since 12"]
    pub fn OH_ImageNative_GetTimestamp(
        image: *mut OH_ImageNative,
        timestamp: *mut i64,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases an {@link OH_ImageNative} object.\n It is used to release the object {@link OH_ImageNative}.\n\n @param image Indicates the pointer to an {@link OH_ImageNative} object.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageNative_Release(image: *mut OH_ImageNative) -> Image_ErrorCode;
}
#[doc = " @brief Define a Pixelmap struct type, used for pixelmap pointer controls.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PixelmapNative {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_NativeColorSpaceManager {
    _unused: [u8; 0],
}
pub const PIXEL_FORMAT_PIXEL_FORMAT_UNKNOWN: PIXEL_FORMAT = 0;
pub const PIXEL_FORMAT_PIXEL_FORMAT_RGB_565: PIXEL_FORMAT = 2;
pub const PIXEL_FORMAT_PIXEL_FORMAT_RGBA_8888: PIXEL_FORMAT = 3;
pub const PIXEL_FORMAT_PIXEL_FORMAT_BGRA_8888: PIXEL_FORMAT = 4;
pub const PIXEL_FORMAT_PIXEL_FORMAT_RGB_888: PIXEL_FORMAT = 5;
pub const PIXEL_FORMAT_PIXEL_FORMAT_ALPHA_8: PIXEL_FORMAT = 6;
pub const PIXEL_FORMAT_PIXEL_FORMAT_RGBA_F16: PIXEL_FORMAT = 7;
pub const PIXEL_FORMAT_PIXEL_FORMAT_NV21: PIXEL_FORMAT = 8;
pub const PIXEL_FORMAT_PIXEL_FORMAT_NV12: PIXEL_FORMAT = 9;
pub const PIXEL_FORMAT_PIXEL_FORMAT_RGBA_1010102: PIXEL_FORMAT = 10;
pub const PIXEL_FORMAT_PIXEL_FORMAT_YCBCR_P010: PIXEL_FORMAT = 11;
pub const PIXEL_FORMAT_PIXEL_FORMAT_YCRCB_P010: PIXEL_FORMAT = 12;
pub type PIXEL_FORMAT = ::std::os::raw::c_uint;
#[doc = " Nearest-neighbor interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_NONE:
    OH_PixelmapNative_AntiAliasingLevel = 0;
#[doc = " Bilinear interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_LOW:
    OH_PixelmapNative_AntiAliasingLevel = 1;
#[doc = " Bilinear interpolation algorithm with mipmap linear filtering"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_MEDIUM:
    OH_PixelmapNative_AntiAliasingLevel = 2;
#[doc = " Cubic interpolation algorithm"]
pub const OH_PixelmapNative_AntiAliasingLevel_OH_PixelmapNative_AntiAliasing_HIGH:
    OH_PixelmapNative_AntiAliasingLevel = 3;
#[doc = " @brief Defines the anti-aliasing level.\n\n @since 12"]
pub type OH_PixelmapNative_AntiAliasingLevel = ::std::os::raw::c_uint;
#[doc = " Indicate the types of metadata that image needs to use."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_METADATA_TYPE: OH_Pixelmap_HdrMetadataKey = 0;
#[doc = " Static metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_STATIC_METADATA: OH_Pixelmap_HdrMetadataKey = 1;
#[doc = " Dynamic metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_DYNAMIC_METADATA: OH_Pixelmap_HdrMetadataKey = 2;
#[doc = " Gainmap metadata key."]
pub const OH_Pixelmap_HdrMetadataKey_HDR_GAINMAP_METADATA: OH_Pixelmap_HdrMetadataKey = 3;
#[doc = " @brief Enumerates the HDR metadata types that need to be stored in Pixelmap.\n\n @since 12"]
pub type OH_Pixelmap_HdrMetadataKey = ::std::os::raw::c_uint;
#[doc = " No metadata."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_NONE: OH_Pixelmap_HdrMetadataType = 0;
#[doc = " Indicates that metadata will be used for the base image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_BASE: OH_Pixelmap_HdrMetadataType = 1;
#[doc = " Indicates that metadata will be used for the gainmap image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_GAINMAP: OH_Pixelmap_HdrMetadataType = 2;
#[doc = " Indicates that metadata will be used for the alternate image."]
pub const OH_Pixelmap_HdrMetadataType_HDR_METADATA_TYPE_ALTERNATE: OH_Pixelmap_HdrMetadataType = 3;
#[doc = " @brief Value for HDR_METADATA_TYPE.\n\n @since 12"]
pub type OH_Pixelmap_HdrMetadataType = ::std::os::raw::c_uint;
#[doc = " @brief Value for HDR_STATIC_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrStaticMetadata {
    #[doc = " The X-coordinate of the primary colors. The length of the array is three. Store in the order of r, g, b."]
    pub displayPrimariesX: [f32; 3usize],
    #[doc = " The Y-coordinate of the primary colors. The length of the array is three. Store in the order of r, g, b."]
    pub displayPrimariesY: [f32; 3usize],
    #[doc = " The X-coordinate of the white point value."]
    pub whitePointX: f32,
    #[doc = " The Y-coordinate of the white point value."]
    pub whitePointY: f32,
    #[doc = " Max luminance."]
    pub maxLuminance: f32,
    #[doc = " Min luminance."]
    pub minLuminance: f32,
    #[doc = " Maximum brightness of displayed content."]
    pub maxContentLightLevel: f32,
    #[doc = " Maximum average brightness of displayed content."]
    pub maxFrameAverageLightLevel: f32,
}
#[doc = " @brief Value for HDR_DYNAMIC_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrDynamicMetadata {
    #[doc = " The value of dynamic metadata."]
    pub data: *mut u8,
    #[doc = " The length of dynamic metadata."]
    pub length: u32,
}
#[doc = " @brief Value for HDR_GAINMAP_METADATA.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrGainmapMetadata {
    #[doc = " The version used by the writer."]
    pub writerVersion: u16,
    #[doc = " The minimum version a parser needs to understand."]
    pub miniVersion: u16,
    #[doc = " The number of gain map channels, with a value of 1 or 3."]
    pub gainmapChannelNum: u8,
    #[doc = " Indicate whether to use the color space of the base image."]
    pub useBaseColorFlag: bool,
    #[doc = " The baseline hdr headroom."]
    pub baseHeadroom: f32,
    #[doc = " The alternate hdr headroom."]
    pub alternateHeadroom: f32,
    #[doc = " The per-component max gain map values."]
    pub gainmapMax: [f32; 3usize],
    #[doc = " The per-component min gain map values."]
    pub gainmapMin: [f32; 3usize],
    #[doc = " The per-component gamma values."]
    pub gamma: [f32; 3usize],
    #[doc = " The per-component baseline offset."]
    pub baselineOffset: [f32; 3usize],
    #[doc = " The per-component alternate offset."]
    pub alternateOffset: [f32; 3usize],
}
#[doc = " @brief Value for HDR_METADATA_KEY. Corresponding relationship with HDR_METADATA_KEY.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_HdrMetadataValue {
    #[doc = " The value corresponding to the HDR_METADATA_TYPE key"]
    pub type_: OH_Pixelmap_HdrMetadataType,
    #[doc = " The value corresponding to the HDR_STATIC_METADATA key"]
    pub staticMetadata: OH_Pixelmap_HdrStaticMetadata,
    #[doc = " The value corresponding to the HDR_DYNAMIC_METADATA key"]
    pub dynamicMetadata: OH_Pixelmap_HdrDynamicMetadata,
    #[doc = " The value corresponding to the HDR_GAINMAP_METADATA key"]
    pub gainmapMetadata: OH_Pixelmap_HdrGainmapMetadata,
}
#[doc = " @brief Defines the options used for creating a pixel map.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_InitializationOptions {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create a for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_Create(
        options: *mut *mut OH_Pixelmap_InitializationOptions,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get width number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param width the number of image width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetWidth(
        options: *mut OH_Pixelmap_InitializationOptions,
        width: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set width number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param width the number of image width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetWidth(
        options: *mut OH_Pixelmap_InitializationOptions,
        width: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get height number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param height the number of image height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetHeight(
        options: *mut OH_Pixelmap_InitializationOptions,
        height: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set height number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param height the number of image height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetHeight(
        options: *mut OH_Pixelmap_InitializationOptions,
        height: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelFormat: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param srcpixelFormat the number of image srcpixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetSrcPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        srcpixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelFormat number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param srcpixelFormat the number of image srcpixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetSrcPixelFormat(
        options: *mut OH_Pixelmap_InitializationOptions,
        srcpixelFormat: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get rowStride for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param rowStride the rowStride of image buffer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if rowStride is null.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe options is released.\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetRowStride(
        options: *mut OH_Pixelmap_InitializationOptions,
        rowStride: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set rowStride number for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param rowStride the rowStride of image buffer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if rowStride does not match width.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe options is released.\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetRowStride(
        options: *mut OH_Pixelmap_InitializationOptions,
        rowStride: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get alphaType number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param alphaType the number of image alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_GetAlphaType(
        options: *mut OH_Pixelmap_InitializationOptions,
        alphaType: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set alphaType number for InitializationOtions struct.\n\n @param options The InitializationOtions pointer will be operated.\n @param alphaType the number of image alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_SetAlphaType(
        options: *mut OH_Pixelmap_InitializationOptions,
        alphaType: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Get editable for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param editable The boolean value representing the editable status.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if options or editable is invalid.\n @since 18"]
    pub fn OH_PixelmapInitializationOptions_GetEditable(
        options: *mut OH_Pixelmap_InitializationOptions,
        editable: *mut bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Set editable for InitializationOptions struct.\n\n @param options The InitializationOptions pointer will be operated.\n @param editable The boolean value representing the editable status.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if options is invalid.\n @since 18"]
    pub fn OH_PixelmapInitializationOptions_SetEditable(
        options: *mut OH_Pixelmap_InitializationOptions,
        editable: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief delete InitializationOtions pointer.\n\n @param options The InitializationOtions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapInitializationOptions_Release(
        options: *mut OH_Pixelmap_InitializationOptions,
    ) -> Image_ErrorCode;
}
#[doc = " @brief Defines the pixel map information.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Pixelmap_ImageInfo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create imageinfo struct  .\n\n @param info The imageinfo pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_Create(info: *mut *mut OH_Pixelmap_ImageInfo) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get width number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param width The number of imageinfo width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetWidth(
        info: *mut OH_Pixelmap_ImageInfo,
        width: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get height number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param height The number of imageinfo height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetHeight(
        info: *mut OH_Pixelmap_ImageInfo,
        height: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Get alphaMode number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param alphaMode The number of imageinfo alphaMode.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} info is nullptr, or alphaMode is nullptr.\n @since 20"]
    pub fn OH_PixelmapImageInfo_GetAlphaMode(
        info: *mut OH_Pixelmap_ImageInfo,
        alphaMode: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get rowStride number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param rowStride The number of imageinfo rowStride.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetRowStride(
        info: *mut OH_Pixelmap_ImageInfo,
        rowStride: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param pixelFormat The number of imageinfo pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetPixelFormat(
        info: *mut OH_Pixelmap_ImageInfo,
        pixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get alphaType number for imageinfo struct.\n\n @param info The imageinfo pointer will be operated.\n @param alphaType The number of imageinfo alphaType.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetAlphaType(
        info: *mut OH_Pixelmap_ImageInfo,
        alphaType: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get isHdr boolean for imageinfo struct.\n\n @param info The imageinfo pointer will be operated. Pointer connot be null.\n @param isHdr Whether the image has a high dynamic range.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n @since 12"]
    pub fn OH_PixelmapImageInfo_GetDynamicRange(
        info: *mut OH_Pixelmap_ImageInfo,
        isHdr: *mut bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Delete imageinfo struct pointer.\n\n @param info The imageinfo pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapImageInfo_Release(info: *mut OH_Pixelmap_ImageInfo) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates a <b>PixelMap</b> object.\n\n @param data Color buffer in BGRA_8888 format.\n @param dataLength Color buffer size in BGRA_8888 format.\n @param options IPixel properties, including the alpha type, size, pixel format, and editable.\n @param pixelmap Pixelmap pointer for created.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_CreatePixelmap(
        data: *mut u8,
        dataLength: usize,
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Creates a pixelmap based on options {@link OH_Pixelmap_InitializationOptions}, the memory type used by the\n pixelmap can be specified by allocatorType {@link IMAGE_ALLOCATOR_MODE}. By default, the system selects the memory\n type based on the image type, image size, platform capability, etc. When processing the pixelmap returned by this\n interface, please always consider the impact of stride.\n\n @param data Input color buffer in BGRA_8888 format by default.\n @param dataLength Length of input buffer in bytes.\n @param options Pixelmap initialization properties including size, pixel format, alpha type, and editable flags.\n @param allocator Indicate which memory type will be used by the returned pixelmap.\n @param pixelmap Output parameter receiving the created pixelmap object pointer.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If the param is nullptr or invalid.\n         {@link IMAGE_TOO_LARGE} too large data or image.\n         {@link IMAGE_UNSUPPORTED_OPERATION} unsupported operations.\n         {@link IMAGE_DMA_OPERATION_FAILED} DMA operation failed.\n         {@link IMAGE_ALLOCATOR_MODE_UNSUPPORTED} unsupported allocator mode, e.g.,\n         use share memory to create a HDR image as only DMA supported hdr metadata.\n @since 20"]
    pub fn OH_PixelmapNative_CreatePixelmapUsingAllocator(
        data: *mut u8,
        dataLength: usize,
        options: *mut OH_Pixelmap_InitializationOptions,
        allocator: IMAGE_ALLOCATOR_MODE,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert a native <b>PixelMap</b> object to <b>PixelMap</b> napi object.\n\n @param env Indicates the NAPI environment pointer.\n @param pixelmapNative Indicates a pointer to the <b>PixelMap</b> object created at the native layer.\n @param pixelmapNapi the <b>PixelMap</b> pointer will be converted.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} pixelmapNative is nullptr\n @since 12"]
    pub fn OH_PixelmapNative_ConvertPixelmapNativeToNapi(
        env: napi_env,
        pixelmapNative: *mut OH_PixelmapNative,
        pixelmapNapi: *mut napi_value,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert a <b>PixelMap</b> napi object to native <b>PixelMap</b> object.\n\n @param env Indicates the NAPI environment pointer.\n @param pixelmapNapi Indicates napi <b>PixelMap</b> object.\n @param pixelmapNative Indicates native <b>PixelMap</b> pointer to created.\n @return Image functions result code.\n     {@link IMAGE_SUCCESS} if the execution is successful.\n     {@link IMAGE_BAD_PARAMETER} pixelmapNative is nullptr, or pixelmapNapi is not a PixelMap\n @since 12"]
    pub fn OH_PixelmapNative_ConvertPixelmapNativeFromNapi(
        env: napi_env,
        pixelmapNapi: napi_value,
        pixelmapNative: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Reads data of this pixel map to an Buffer. If this pixel map is created in the BGRA_8888 format,\n the data read is the same as the original data.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param destination Buffer to which the image pixel map data will be written.\n @param bufferSize Buffer size to which the image pixel map data will be written.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_ReadPixels(
        pixelmap: *mut OH_PixelmapNative,
        destination: *mut u8,
        bufferSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Reads image data in an Buffer and writes the data to a Pixelmap object.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param source Buffer from which the image data will be read.\n @param bufferSize Buffer size from which the image data will be read.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_WritePixels(
        pixelmap: *mut OH_PixelmapNative,
        source: *mut u8,
        bufferSize: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Get argb pixel buffer from pixelmap.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param destination Buffer to which the image pixel map data will be written.\n @param bufferSize Buffer size to which the image pixel map data will be written.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, destination and bufferSize are incorrect.\n         {@link IMAGE_UNSUPPORTED_CONVERSION} If format does not support conversion to argb or conversion failed.\n         {@link IMAGE_ALLOC_FAILED} If device has no memory.\n         {@link IMAGE_COPY_FAILED} If memory copy failed.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_GetArgbPixels(
        pixelmap: *mut OH_PixelmapNative,
        destination: *mut u8,
        bufferSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Convert {@link OH_PixelmapNative} to standard dynamic range.\n\n @param pixelmap The Pixelmap pointer will be operated. Pointer connot be null.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n returns {@link Image_ErrorCode} IMAGE_UNSUPPORTED_OPERATION - Unsupported operation.Pixelmap can't be converted.\n @since 12"]
    pub fn OH_PixelmapNative_ToSdr(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains pixel map information of this image.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param imageInfo Indicates the pointer to the image information.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_GetImageInfo(
        pixelmap: *mut OH_PixelmapNative,
        imageInfo: *mut OH_Pixelmap_ImageInfo,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Sets an opacity rate for this image pixel map.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param rate Opacity rate to set. The value ranges from 0 to 1.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Opacity(
        pixelmap: *mut OH_PixelmapNative,
        rate: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Scales this image based on the input width and height.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Scale(
        pixelmap: *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Scales this image based on the input width and height with anti-aliasing.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @param level The anti-aliasing algorithm to be used.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, x and y are incorrect.\n returns {@link Image_ErrorCode} IMAGE_TOO_LARGE - if image is too large.\n returns {@link Image_ErrorCode} IMAGE_ALLOC_FAILED - if device has no memory.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error, maybe source pixelmap is released.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_ScaleWithAntiAliasing(
        pixelmap: *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
        level: OH_PixelmapNative_AntiAliasingLevel,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Create a scaled pixelmap based on the source pixelmap and the input width and height.\n\n @param srcPixelmap The source native pixelmap.\n @param dstPixelmap The destination native pixelmap for create.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} If the param is nullptr or invalid.\n @see OH_PixelmapNative\n @since 18"]
    pub fn OH_PixelmapNative_CreateScaledPixelMap(
        srcPixelmap: *mut OH_PixelmapNative,
        dstPixelmap: *mut *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Create a scaled pixelmap based on the source pixelmap and the input width and height with anti-aliasing.\n\n @param srcPixelmap The source native pixelmap.\n @param dstPixelmap The destination native pixelmap for create.\n @param scaleX Scaling ratio of the width.\n @param scaleY Scaling ratio of the height.\n @param level The anti-aliasing algorithm to be used.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} If the param is nullptr or invalid.\n         {@link IMAGE_TOO_LARGE} If image is too large.\n         {@link IMAGE_ALLOC_FAILED} If device has no memory.\n @see OH_PixelmapNative\n @since 18"]
    pub fn OH_PixelmapNative_CreateScaledPixelMapWithAntiAliasing(
        srcPixelmap: *mut OH_PixelmapNative,
        dstPixelmap: *mut *mut OH_PixelmapNative,
        scaleX: f32,
        scaleY: f32,
        level: OH_PixelmapNative_AntiAliasingLevel,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Translates this image based on the input coordinates.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param x The distance to be translate in the X direction.\n @param y The distance to be translate in the Y direction.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Translate(
        pixelmap: *mut OH_PixelmapNative,
        x: f32,
        y: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Rotates this image based on the input angle.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param angle Angle to rotate.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Rotate(
        pixelmap: *mut OH_PixelmapNative,
        angle: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Flips this image horizontally or vertically, or both.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param shouldFilpHorizontally Whether to flip the image horizontally.\n @param shouldFilpVertically Whether to flip the image vertically.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Flip(
        pixelmap: *mut OH_PixelmapNative,
        shouldFilpHorizontally: bool,
        shouldFilpVertically: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Crops this image based on the input size.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @param region Area size, read according to area.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Crop(
        pixelmap: *mut OH_PixelmapNative,
        region: *mut Image_Region,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases an <b>OH_Pixelmap</b> object.\n\n @param pixelmap The Pixelmap pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_Release(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Destroys an <b>OH_PixelmapNative</b> object and deallocates its resources.\n\n @param pixelmap A pointer to the OH_PixelmapNative pointer to destroy.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if pixelmap is null or *pixelmap is null.\n @since 18"]
    pub fn OH_PixelmapNative_Destroy(pixelmap: *mut *mut OH_PixelmapNative) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Converting images to alpha format\n\n @param srcpixelmap The source pixel map pointer will be operated.\n @param dstpixelmap The destination pixel map pointer will be operated.\n @param isPremul Whether it is pre-multiplied, true for prediction, false for non-pre-multiplied.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_ConvertAlphaFormat(
        srcpixelmap: *mut OH_PixelmapNative,
        dstpixelmap: *mut OH_PixelmapNative,
        isPremul: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Create a empty <b>PixelMap</b> object.\n\n @param options IPixel properties, including the alpha type, size, pixel format, and editable.\n @param pixelmap Pixelmap pointer for created.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PixelmapNative_CreateEmptyPixelmap(
        options: *mut OH_Pixelmap_InitializationOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Creates a empty pixelmap based on options {@link OH_Pixelmap_InitializationOptions}, the memory type used\n by the pixelmap can be specified by allocatorType {@link IMAGE_ALLOCATOR_MODE}. By default,\n the system selects the memory type based on the image type, image size, platform capability, etc. When processing\n the pixelmap returned by this interface, please always consider the impact of stride.\n\n @param options Pixelmap initialization properties including size, pixel format, alpha type, and editable flags.\n @param allocator Indicate which memory type will be used by the returned pixelmap.\n @param pixelmap Output parameter receiving the created pixelmap object pointer.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If the param is nullptr or invalid.\n         {@link IMAGE_TOO_LARGE} too large data or image.\n         {@link IMAGE_UNSUPPORTED_OPERATION} unsupported operations.\n         {@link IMAGE_ALLOCATOR_MODE_UNSUPPORTED} unsupported allocator mode, e.g., use\n         share memory to create a HDR image as only DMA supported hdr metadata.\n @since 20"]
    pub fn OH_PixelmapNative_CreateEmptyPixelmapUsingAllocator(
        options: *mut OH_Pixelmap_InitializationOptions,
        allocator: IMAGE_ALLOCATOR_MODE,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get metadata.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param key Type of metadata.\n @param value Value of metadata.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, key and value are incorrect.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory does not exist.\n returns {@link Image_ErrorCode} IMAGE_COPY_FAILED - if memory copy failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_GetMetadata(
        pixelmap: *mut OH_PixelmapNative,
        key: OH_Pixelmap_HdrMetadataKey,
        value: *mut *mut OH_Pixelmap_HdrMetadataValue,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set metadata.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param key Type of metadata.\n @param value Value of metadata.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, key and value are incorrect.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory does not exist.\n returns {@link Image_ErrorCode} IMAGE_COPY_FAILED - if memory copy failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_SetMetadata(
        pixelmap: *mut OH_PixelmapNative,
        key: OH_Pixelmap_HdrMetadataKey,
        value: *mut OH_Pixelmap_HdrMetadataValue,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get the native buffer from the PixelMap.\n\n @param pixelmap The PixelMap to get the native buffer from.\n @param nativeBuffer The native buffer to retrieve.\n @return Returns {@link Image_ErrorCode} IMAGE_RESULT_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if invalid parameter, pixelmap or nativeBuffer is null.\n returns {@link Image_ErrorCode} IMAGE_DMA_NOT_EXIST - if DMA memory dose not exist.\n returns {@link Image_ErrorCode} IMAGE_DMA_OPERATION_FAILED - if operations related to DMA memory has failed.\n @see OH_PixelmapNative\n @since 12"]
    pub fn OH_PixelmapNative_GetNativeBuffer(
        pixelmap: *mut OH_PixelmapNative,
        nativeBuffer: *mut *mut OH_NativeBuffer,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Get the native colorspace from the PixelMap.\n\n @param pixelmap The native pixelmap to get the native colorspace from.\n @param colorSpaceNative The native colorspace to retrieve.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} The param of pixelmap or colorSpaceNative is nullptr or invalid.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_GetColorSpaceNative(
        pixelmap: *mut OH_PixelmapNative,
        colorSpaceNative: *mut *mut OH_NativeColorSpaceManager,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set the native colorspace for the PixelMap.\n\n @param pixelmap The native pixelmap to set the native colorspace for.\n @param colorSpaceNative The native colorspace to set.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} The param of pixelmap or colorSpaceNative is nullptr or invalid.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_SetColorSpaceNative(
        pixelmap: *mut OH_PixelmapNative,
        colorSpaceNative: *mut OH_NativeColorSpaceManager,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set pixelmap memory name.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param name The pointer of name that needs to be set.\n @param size The size of name size that needs to be set.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, name and size are incorrect.\n         {@link IMAGE_UNSUPPORTED_MEMORY_FORMAT} If memory format is unsupported.\n @see OH_PixelmapNative\n @since 13"]
    pub fn OH_PixelmapNative_SetMemoryName(
        pixelmap: *mut OH_PixelmapNative,
        name: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Get the total number of bytes occupied by all pixels in the Pixelmap, without any padding.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param byteCount The total number of bytes to be retrieved.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap or byteCount are invalid.\n @see OH_PixelmapNative\n @since 18"]
    pub fn OH_PixelmapNative_GetByteCount(
        pixelmap: *mut OH_PixelmapNative,
        byteCount: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Get the size of the allocated memory used to store this pixelmap's pixels.\n\n @param pixelmap The Pixelmap pointer to be operated.\n @param allocationByteCount The size of the allocated memory.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap or allocationByteCount are invalid.\n @see OH_PixelmapNative\n @since 18"]
    pub fn OH_PixelmapNative_GetAllocationByteCount(
        pixelmap: *mut OH_PixelmapNative,
        allocationByteCount: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-15")]
    #[doc = " @brief Obtains the memory address of a PixelMap and locks the memory.\n        When the memory is locked, any operation that modifies or releases the PixelMap will fail and return\n        {@link IMAGE_BAD_PARAMETER}.\n\n @param pixelmap The PixelMap pointer to be operated.\n @param addr The double pointer to the memory address of the PixelMap.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap or addr are invalid.\n         {@link IMAGE_LOCK_UNLOCK_FAILED} If memory failed to be locked.\n @see OH_PixelmapNative\n @since 15"]
    pub fn OH_PixelmapNative_AccessPixels(
        pixelmap: *mut OH_PixelmapNative,
        addr: *mut *mut ::std::os::raw::c_void,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-15")]
    #[doc = " @brief Unlocks the memory of the PixelMap data.\n        This function is used with {@link OH_PixelmapNative_AccessPixels} in pairs.\n\n @param pixelmap The PixelMap pointer to be operated.\n @return Function result code:\n         {@link IMAGE_SUCCESS} If the operation is successful.\n         {@link IMAGE_BAD_PARAMETER} If invalid parameter, pixelmap is invalid.\n         {@link IMAGE_LOCK_UNLOCK_FAILED} If memory failed to be unlocked.\n @see OH_PixelmapNative\n @since 15"]
    pub fn OH_PixelmapNative_UnaccessPixels(pixelmap: *mut OH_PixelmapNative) -> Image_ErrorCode;
}
#[cfg(feature = "api-13")]
#[doc = " @brief Define a Picture struct type, used for picture pointer controls.\n\n @since 13"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PictureNative {
    _unused: [u8; 0],
}
#[cfg(feature = "api-13")]
#[doc = " @brief Define a AuxiliaryPicture struct type, used for auxiliary\n picture pointer controls.\n\n @since 13"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AuxiliaryPictureNative {
    _unused: [u8; 0],
}
#[cfg(feature = "api-13")]
#[doc = " @brief Define a AuxiliaryPictureInfo struct type, used for auxiliary\n picture info controls.\n\n @since 13"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AuxiliaryPictureInfo {
    _unused: [u8; 0],
}
#[cfg(feature = "api-13")]
pub const Image_AuxiliaryPictureType_AUXILIARY_PICTURE_TYPE_GAINMAP: Image_AuxiliaryPictureType = 1;
#[cfg(feature = "api-13")]
pub const Image_AuxiliaryPictureType_AUXILIARY_PICTURE_TYPE_DEPTH_MAP: Image_AuxiliaryPictureType =
    2;
#[cfg(feature = "api-13")]
pub const Image_AuxiliaryPictureType_AUXILIARY_PICTURE_TYPE_UNREFOCUS_MAP:
    Image_AuxiliaryPictureType = 3;
#[cfg(feature = "api-13")]
pub const Image_AuxiliaryPictureType_AUXILIARY_PICTURE_TYPE_LINEAR_MAP: Image_AuxiliaryPictureType =
    4;
#[cfg(feature = "api-13")]
pub const Image_AuxiliaryPictureType_AUXILIARY_PICTURE_TYPE_FRAGMENT_MAP:
    Image_AuxiliaryPictureType = 5;
#[cfg(feature = "api-13")]
#[doc = " @brief Define a auxiliary picture type.\n\n @since 13"]
pub type Image_AuxiliaryPictureType = ::std::os::raw::c_uint;
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Create a <b>Picture</b> object.\n\n @param mainPixelmap The pixel map of the main image.\n @param picture Picture pointer for created.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} mainPixelmap is nullptr, or picture is nullptr.\n @since 13"]
    pub fn OH_PictureNative_CreatePicture(
        mainPixelmap: *mut OH_PixelmapNative,
        picture: *mut *mut OH_PictureNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the pixel map of the main image.\n\n @param picture The Picture pointer will be operated.\n @param mainPixelmap Main pixel map pointer for obtained.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} picture is nullptr, or mainPixelmap is nullptr.\n @since 13"]
    pub fn OH_PictureNative_GetMainPixelmap(
        picture: *mut OH_PictureNative,
        mainPixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the hdr pixel map.\n\n @param picture The Picture pointer will be operated.\n @param hdrPixelmap Hdr pixel map pointer for obtained.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} picture is nullptr, or hdrPixelmap is nullptr.\n         {@link IMAGE_UNSUPPORTED_OPERATION} Unsupported operation, e.g. the picture does not has a gainmap\n @since 13"]
    pub fn OH_PictureNative_GetHdrComposedPixelmap(
        picture: *mut OH_PictureNative,
        hdrPixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the gainmap pixel map.\n\n @param picture The Picture pointer will be operated.\n @param gainmapPixelmap Gainmap pointer for obtained.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} picture is nullptr, or gainmapPixelmap is nullptr.\n @since 13"]
    pub fn OH_PictureNative_GetGainmapPixelmap(
        picture: *mut OH_PictureNative,
        gainmapPixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set auxiliary picture.\n\n @param picture The Picture pointer will be operated.\n @param type The type of auxiliary picture.\n @param auxiliaryPicture AuxiliaryPicture object.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} picture is nullptr, or auxiliaryPicture is nullptr, or the type is invalid.\n @since 13"]
    pub fn OH_PictureNative_SetAuxiliaryPicture(
        picture: *mut OH_PictureNative,
        type_: Image_AuxiliaryPictureType,
        auxiliaryPicture: *mut OH_AuxiliaryPictureNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the auxiliary picture based on type.\n\n @param picture The Picture pointer will be operated.\n @param type The type of auxiliary picture.\n @param auxiliaryPicture AuxiliaryPicture pointer for obtained.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} picture is nullptr, or auxiliaryPicture is nullptr, or the type is invalid.\n @since 13"]
    pub fn OH_PictureNative_GetAuxiliaryPicture(
        picture: *mut OH_PictureNative,
        type_: Image_AuxiliaryPictureType,
        auxiliaryPicture: *mut *mut OH_AuxiliaryPictureNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the metadata of main picture.\n\n @param picture The Picture pointer will be operated.\n @param metadataType The type of metadata.\n @param metadata The metadata of main picture.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} picture is nullptr, or metadata is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type.\n @since 13"]
    pub fn OH_PictureNative_GetMetadata(
        picture: *mut OH_PictureNative,
        metadataType: Image_MetadataType,
        metadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set main picture metadata.\n\n @param picture The Picture pointer will be operated.\n @param metadataType The type of metadata.\n @param metadata The metadata will be set.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} picture is nullptr, or metadata is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type.\n @since 13"]
    pub fn OH_PictureNative_SetMetadata(
        picture: *mut OH_PictureNative,
        metadataType: Image_MetadataType,
        metadata: *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Releases this Picture object.\n\n @param picture The Picture pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} picture is nullptr.\n @since 13"]
    pub fn OH_PictureNative_Release(picture: *mut OH_PictureNative) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Create a <b>AuxiliaryPicture</b> object.\n\n @param data The image data buffer.\n @param dataLength The length of data.\n @param size The size of auxiliary picture.\n @param type The type of auxiliary picture.\n @param auxiliaryPicture AuxiliaryPicture pointer for created.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} data is nullptr, or dataLength is invalid, or size is nullptr, or the type\n         is invalid, or auxiliaryPicture is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureNative_Create(
        data: *mut u8,
        dataLength: usize,
        size: *mut Image_Size,
        type_: Image_AuxiliaryPictureType,
        auxiliaryPicture: *mut *mut OH_AuxiliaryPictureNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Write pixels to auxiliary picture.\n\n @param auxiliaryPicture The AuxiliaryPicture pointer will be operated.\n @param source The pixels will be written.\n @param bufferSize The size of pixels.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} auxiliaryPicture is nullptr, or source is nullptr, or the bufferSize is invalid.\n         {@link IMAGE_ALLOC_FAILED} memory alloc failed.\n         {@link IMAGE_COPY_FAILED} memory copy failed.\n @since 13"]
    pub fn OH_AuxiliaryPictureNative_WritePixels(
        auxiliaryPicture: *mut OH_AuxiliaryPictureNative,
        source: *mut u8,
        bufferSize: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Read pixels from auxiliary picture.\n\n @param auxiliaryPicture The AuxiliaryPicture pointer will be operated.\n @param destination The pixels will be read.\n @param bufferSize The size of pixels for reading.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} auxiliaryPicture is nullptr, or destination is nullptr,\n         or the bufferSize is invalid.\n         {@link IMAGE_ALLOC_FAILED} memory alloc failed.\n         {@link IMAGE_COPY_FAILED} memory copy failed.\n @since 13"]
    pub fn OH_AuxiliaryPictureNative_ReadPixels(
        auxiliaryPicture: *mut OH_AuxiliaryPictureNative,
        destination: *mut u8,
        bufferSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the type of auxiliary picture.\n\n @param auxiliaryPicture The AuxiliaryPicture pointer will be operated.\n @param type The type of auxiliary picture.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} auxiliaryPicture is nullptr, or type is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureNative_GetType(
        auxiliaryPicture: *mut OH_AuxiliaryPictureNative,
        type_: *mut Image_AuxiliaryPictureType,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the info of auxiliary picture.\n\n @param auxiliaryPicture The AuxiliaryPicture pointer will be operated.\n @param info The info of auxiliary picture.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} auxiliaryPicture is nullptr, or info is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureNative_GetInfo(
        auxiliaryPicture: *mut OH_AuxiliaryPictureNative,
        info: *mut *mut OH_AuxiliaryPictureInfo,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set auxiliary picture info.\n\n @param auxiliaryPicture The AuxiliaryPicture pointer will be operated.\n @param info The info will be set.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} auxiliaryPicture is nullptr, or info is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureNative_SetInfo(
        auxiliaryPicture: *mut OH_AuxiliaryPictureNative,
        info: *mut OH_AuxiliaryPictureInfo,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the metadata of auxiliary picture.\n\n @param auxiliaryPicture The AuxiliaryPicture pointer will be operated.\n @param metadataType The type of metadata.\n @param metadata The metadata of auxiliary picture.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} auxiliaryPicture is nullptr, or metadata is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    pub fn OH_AuxiliaryPictureNative_GetMetadata(
        auxiliaryPicture: *mut OH_AuxiliaryPictureNative,
        metadataType: Image_MetadataType,
        metadata: *mut *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set auxiliary picture metadata.\n\n @param auxiliaryPicture The AuxiliaryPicture pointer will be operated.\n @param metadataType The type of metadata.\n @param metadata The metadata will be set.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} auxiliaryPicture is nullptr, or metadata is nullptr.\n         {@link IMAGE_UNSUPPORTED_METADATA} unsupported metadata type, or the metadata type does not match the\n         auxiliary picture type.\n @since 13"]
    pub fn OH_AuxiliaryPictureNative_SetMetadata(
        auxiliaryPicture: *mut OH_AuxiliaryPictureNative,
        metadataType: Image_MetadataType,
        metadata: *mut OH_PictureMetadata,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Releases this AuxiliaryPicture object.\n\n @param picture The Picture pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} picture is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureNative_Release(
        picture: *mut OH_AuxiliaryPictureNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Create a <b>AuxiliaryPictureInfo</b> object.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_Create(
        info: *mut *mut OH_AuxiliaryPictureInfo,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the type of auxiliary picture info.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @param type The type of auxiliary picture info.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr, or type is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_GetType(
        info: *mut OH_AuxiliaryPictureInfo,
        type_: *mut Image_AuxiliaryPictureType,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set auxiliary picture info type.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @param type The type will be set.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr, or type is invalid.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_SetType(
        info: *mut OH_AuxiliaryPictureInfo,
        type_: Image_AuxiliaryPictureType,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the size of auxiliary picture info.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @param size The size of auxiliary picture info.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr, or size is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_GetSize(
        info: *mut OH_AuxiliaryPictureInfo,
        size: *mut Image_Size,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set auxiliary picture info size.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @param size The size will be set.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr, or size is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_SetSize(
        info: *mut OH_AuxiliaryPictureInfo,
        size: *mut Image_Size,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the rowStride of auxiliary picture info.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @param rowStride The rowStride of auxiliary picture info.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr, or rowStride is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_GetRowStride(
        info: *mut OH_AuxiliaryPictureInfo,
        rowStride: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set auxiliary picture info rowStride.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @param rowStride The rowStride will be set.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr, or rowStride is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_SetRowStride(
        info: *mut OH_AuxiliaryPictureInfo,
        rowStride: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the pixelFormat of auxiliary picture info.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @param pixelFormat The pixelFormat will be get.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr, or pixelFormat is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_GetPixelFormat(
        info: *mut OH_AuxiliaryPictureInfo,
        pixelFormat: *mut PIXEL_FORMAT,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set auxiliary picture info pixelFormat.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @param pixelFormat The pixelFormat will be set.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_SetPixelFormat(
        info: *mut OH_AuxiliaryPictureInfo,
        pixelFormat: PIXEL_FORMAT,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Releases this AuxiliaryPictureInfo object.\n\n @param info The AuxiliaryPictureInfo pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} info is nullptr.\n @since 13"]
    pub fn OH_AuxiliaryPictureInfo_Release(info: *mut OH_AuxiliaryPictureInfo) -> Image_ErrorCode;
}
#[doc = " @brief Defines an image source object for the image interface.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_ImageSourceNative {
    _unused: [u8; 0],
}
#[doc = " @brief Defines image source infomation\n {@link OH_ImageSourceInfo_Create}.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_ImageSource_Info {
    _unused: [u8; 0],
}
#[cfg(feature = "api-13")]
#[doc = " @brief Defines decoding options for picture\n {@link OH_DecodingOptionsForPicture_Create}.\n\n @since 13"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_DecodingOptionsForPicture {
    _unused: [u8; 0],
}
#[cfg(feature = "api-15")]
pub const IMAGE_ALLOCATOR_TYPE_IMAGE_ALLOCATOR_TYPE_AUTO: IMAGE_ALLOCATOR_TYPE = 0;
#[cfg(feature = "api-15")]
pub const IMAGE_ALLOCATOR_TYPE_IMAGE_ALLOCATOR_TYPE_DMA: IMAGE_ALLOCATOR_TYPE = 1;
#[cfg(feature = "api-15")]
pub const IMAGE_ALLOCATOR_TYPE_IMAGE_ALLOCATOR_TYPE_SHARE_MEMORY: IMAGE_ALLOCATOR_TYPE = 2;
#[cfg(feature = "api-15")]
#[doc = " @brief Type of allocator used to allocate memory of a PixelMap..\n\n @since 15"]
pub type IMAGE_ALLOCATOR_TYPE = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Create a pointer for OH_ImageSource_Info struct.\n\n @param info The OH_ImageSource_Info pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceInfo_Create(info: *mut *mut OH_ImageSource_Info) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get width number for OH_ImageSource_Info struct.\n\n @param info The OH_ImageSource_Info pointer will be operated.\n @param width the number of image width.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceInfo_GetWidth(
        info: *mut OH_ImageSource_Info,
        width: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get height number for OH_ImageSource_Info struct.\n\n @param info The OH_ImageSource_Info pointer will be operated.\n @param height the number of image height.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceInfo_GetHeight(
        info: *mut OH_ImageSource_Info,
        height: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get isHdr for OH_ImageSource_Info struct.\n\n @param info The OH_ImageSource_Info pointer will be operated. Pointer connot be null.\n @param isHdr Whether the image has a high dynamic range.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n @since 12"]
    pub fn OH_ImageSourceInfo_GetDynamicRange(
        info: *mut OH_ImageSource_Info,
        isHdr: *mut bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Obtains the MIME type of an image source.\n\n @param info Pointer to the OH_ImageSource_Info struct.\n @param mimetype Pointer to the MIME type of the image source.\n @return Returns one of the following result codes:\n {@link IMAGE_SUCCESS} if the execution is successful.\n {@link IMAGE_SOURCE_INVALID_PARAMETER} if info or mimetype is a null pointer.\n @since 20"]
    pub fn OH_ImageSourceInfo_GetMimeType(
        info: *mut OH_ImageSource_Info,
        mimetype: *mut Image_MimeType,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief delete OH_ImageSource_Info pointer.\n\n @param info The OH_ImageSource_Info pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceInfo_Release(info: *mut OH_ImageSource_Info) -> Image_ErrorCode;
}
#[doc = " @brief Defines the options for decoding the image source.\n It is used in {@link OH_ImageSourceNative_CreatePixelmap}.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_DecodingOptions {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create a pointer for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_Create(options: *mut *mut OH_DecodingOptions) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get pixelFormat number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_GetPixelFormat(
        options: *mut OH_DecodingOptions,
        pixelFormat: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set pixelFormat number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param pixelFormat the number of image pixelFormat.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_SetPixelFormat(
        options: *mut OH_DecodingOptions,
        pixelFormat: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get index number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param index the number of image index.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_GetIndex(
        options: *mut OH_DecodingOptions,
        index: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set index number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param index the number of image index.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_SetIndex(
        options: *mut OH_DecodingOptions,
        index: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get rotate number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param rotate the number of image rotate.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_GetRotate(
        options: *mut OH_DecodingOptions,
        rotate: *mut f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set rotate number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param rotate the number of image rotate.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_SetRotate(
        options: *mut OH_DecodingOptions,
        rotate: f32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get desiredSize number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param desiredSize the number of image desiredSize.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_GetDesiredSize(
        options: *mut OH_DecodingOptions,
        desiredSize: *mut Image_Size,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set desiredSize number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param desiredSize the number of image desiredSize.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_SetDesiredSize(
        options: *mut OH_DecodingOptions,
        desiredSize: *mut Image_Size,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set desiredRegion number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param desiredRegion the number of image desiredRegion.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_GetDesiredRegion(
        options: *mut OH_DecodingOptions,
        desiredRegion: *mut Image_Region,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set desiredRegion number for OH_DecodingOptions struct.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @param desiredRegion the number of image desiredRegion.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_SetDesiredRegion(
        options: *mut OH_DecodingOptions,
        desiredRegion: *mut Image_Region,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set desiredDynamicRange number for OH_DecodingOptions struct.\n\n @param options The OH_DecodingOptions pointer will be operated. Pointer connot be null.\n @param desiredDynamicRange the number of desired dynamic range {@link IMAGE_DYNAMIC_RANGE}. Pointer connot be null.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n @since 12"]
    pub fn OH_DecodingOptions_GetDesiredDynamicRange(
        options: *mut OH_DecodingOptions,
        desiredDynamicRange: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Sets a cropping and scaling strategy for decoding options.\n\n @param options Pointer to the decoding options.\n @param cropAndScaleStrategy Strategy for executing the cropping and scaling operations when both desiredSize and\n desiredRegion are specified.\n @return Returns one of the following result codes:\n {@link IMAGE_SUCCESS}: The execution is successful.\n {@link IMAGE_BAD_PARAMETER}: options is a null pointer or cropAndScaleStrategy is not in the range of\n Image_CropAndScaleStrategy.\n @since 18"]
    pub fn OH_DecodingOptions_SetCropAndScaleStrategy(
        options: *mut OH_DecodingOptions,
        cropAndScaleStrategy: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Obtains the cropping and scaling strategy of decoding options.\n\n @param options Pointer to the decoding options.\n @param cropAndScaleStrategy Pointer to the strategy for executing the cropping and scaling operations when both\n desiredSize and desiredRegion are specified.\n @return Returns one of the following result codes:\n {@link IMAGE_SUCCESS}: The execution is successful.\n {@link IMAGE_BAD_PARAMETER}: options or cropAndScaleStrategy is a null pointer.\n @since 18"]
    pub fn OH_DecodingOptions_GetCropAndScaleStrategy(
        options: *mut OH_DecodingOptions,
        cropAndScaleStrategy: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set desiredDynamicRange number for OH_DecodingOptions struct.\n\n @param options The OH_DecodingOptions pointer will be operated. Pointer connot be null.\n @param desiredDynamicRange the number of desired dynamic range {@link IMAGE_DYNAMIC_RANGE}.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n @since 12"]
    pub fn OH_DecodingOptions_SetDesiredDynamicRange(
        options: *mut OH_DecodingOptions,
        desiredDynamicRange: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Obtains the color space set in the decoding options.\n\n @param options Pointer to the decoding options.\n @param colorSpace Pointer to the color space.\n @return Returns one of the following result codes:\n {@link IMAGE_SUCCESS} if the execution is successful.\n {@link IMAGE_SOURCE_INVALID_PARAMETER} if options or colorSpace is null pointer.\n @since 20"]
    pub fn OH_DecodingOptions_GetDesiredColorSpace(
        options: *mut OH_DecodingOptions,
        colorSpace: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Sets the desired color space for the decoding options.\n\n @param options Pointer to the decoding options.\n @param colorSpace Desired color space.\n @return Returns one of the following result codes:\n {@link IMAGE_SUCCESS} if the execution is successful.\n {@link IMAGE_SOURCE_INVALID_PARAMETER} if options is a null pointer or colorSpace is not supported.\n @since 20"]
    pub fn OH_DecodingOptions_SetDesiredColorSpace(
        options: *mut OH_DecodingOptions,
        colorSpace: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-19")]
    #[doc = " @brief Sets the crop region for the decoding options.\n\n @param options Pointer to the decoding options.\n @param cropRegion The target region will be cropped from the image.\n @return Returns one of the following result codes:\n {@link IMAGE_SUCCESS} if the execution is successful.\n {@link IMAGE_SOURCE_INVALID_PARAMETER} if options or cropRegion is null pointer.\n @since 19"]
    pub fn OH_DecodingOptions_SetCropRegion(
        options: *mut OH_DecodingOptions,
        cropRegion: *mut Image_Region,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-19")]
    #[doc = " @brief Gets the crop region for the decoding options.\n\n @param options Pointer to the decoding options.\n @param cropRegion The target region will be cropped from the image.\n @return Returns one of the following result codes:\n {@link IMAGE_SUCCESS} if the execution is successful.\n {@link IMAGE_SOURCE_INVALID_PARAMETER} if options or cropRegion is null pointer.\n @since 19"]
    pub fn OH_DecodingOptions_GetCropRegion(
        options: *mut OH_DecodingOptions,
        cropRegion: *mut Image_Region,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief delete OH_DecodingOptions pointer.\n\n @param  options The OH_DecodingOptions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_DecodingOptions_Release(options: *mut OH_DecodingOptions) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates an ImageSource pointer.\n\n @param uri Indicates a pointer to the image source URI. Only a file URI or Base64 URI is accepted.\n @param uriSize Indicates the length of the image source URI.\n @param res Indicates a pointer to the <b>ImageSource</b> object created at the C++ native layer.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_CreateFromUri(
        uri: *mut ::std::os::raw::c_char,
        uriSize: usize,
        res: *mut *mut OH_ImageSourceNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates an void pointer\n\n @param fd Indicates the image source file descriptor.\n @param res Indicates a void pointer to the <b>ImageSource</b> object created at the C++ native layer.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_CreateFromFd(
        fd: i32,
        res: *mut *mut OH_ImageSourceNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates an void pointer\n\n @param data Indicates a pointer to the image source data. Only a formatted packet data or Base64 data is accepted.\n @param dataSize Indicates the size of the image source data.\n @param res Indicates a void pointer to the <b>ImageSource</b> object created at the C++ native layer.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_CreateFromData(
        data: *mut u8,
        dataSize: usize,
        res: *mut *mut OH_ImageSourceNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Create an image source from data buffer. The data buffer is directly accessed by the image source\n object, and therefore the data buffer must remain accessible within the lifecycle of the image source object.\n\n @param data Pointer to the data buffer.\n @param datalength Length of the data buffer.\n @param imageSource Double pointer to the image source.\n @return Result code.\n {@link IMAGE_SUCCESS} if the execution is successful.\n {@link IMAGE_SOURCE_INVALID_PARAMETER} if data or imageSource is a null pointer or if datalength is 0.\n @since 20"]
    pub fn OH_ImageSourceNative_CreateFromDataWithUserBuffer(
        data: *mut u8,
        datalength: usize,
        imageSource: *mut *mut OH_ImageSourceNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates an void pointer\n\n @param rawFile Indicates the raw file's file descriptor.\n @param res Indicates a void pointer to the <b>ImageSource</b> object created at the C++ native layer.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_CreateFromRawFile(
        rawFile: *mut RawFileDescriptor,
        res: *mut *mut OH_ImageSourceNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Decodes an void pointer\n based on the specified {@link OH_DecodingOptions} struct.\n\n @param source Indicates a void pointer(from ImageSource pointer convert).\n @param  options Indicates a pointer to the options for decoding the image source.\n For details, see {@link OH_DecodingOptions}.\n @param pixelmap Indicates a void pointer to the <b>Pixelmap</b> object obtained at the C++ native layer.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_CreatePixelmap(
        source: *mut OH_ImageSourceNative,
        options: *mut OH_DecodingOptions,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-15")]
    #[doc = " @brief Creates a PixelMap based on decoding parameters {@link OH_DecodingOptions}, the memory type used by the\n PixelMap can be specified by allocatorType {@link IMAGE_ALLOCATOR_TYPE}. By default, the system selects the memory\n type based on the image type, image size, platform capability, etc. When processing the PixelMap returned by this\n interface, please always consider the impact of stride.\n\n @param source Image Source.\n @param options Decoding parameters, such as the size, pixel format, and color space of the pixelMap.\n For details, see {@link OH_DecodingOptions}.\n @param allocator Indicate which memory type will be used by the returned PixelMap.\n @param pixelmap Decoded <b>Pixelmap</b> object.\n @return Error code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} source is nullptr, or picture is nullptr.\n         {@link IMAGE_BAD_SOURCE} data source exception.\n         {@link IMAGE_SOURCE_UNSUPPORTED_MIME_TYPE} unsupported mime type.\n         {@link IMAGE_SOURCE_TOO_LARGE} image to large.\n         {@link IMAGE_SOURCE_UNSUPPORTED_ALLOCATOR_TYPE} unsupported allocator type,\n         e.g., use share memory to decode a HDR image as only DMA supported hdr metadata.\n         {@link IMAGE_SOURCE_UNSUPPORTED_OPTIONS} unsupported options,\n         e.g, cannot convert image into desired pixel format.\n         {@link IMAGE_DECODE_FAILED} decode failed.\n         {@link IMAGE_SOURCE_ALLOC_FAILED} memory allocation failed.\n @since 15"]
    pub fn OH_ImageSourceNative_CreatePixelmapUsingAllocator(
        source: *mut OH_ImageSourceNative,
        options: *mut OH_DecodingOptions,
        allocator: IMAGE_ALLOCATOR_TYPE,
        pixelmap: *mut *mut OH_PixelmapNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Decodes an void pointer\n the <b>Pixelmap</b> objects at the C++ native layer\n based on the specified {@link OH_DecodingOptions} struct.\n\n @param source Indicates a void pointer(from ImageSource pointer convert).\n @param  options Indicates a pointer to the options for decoding the image source.\n For details, see {@link OH_DecodingOptions}.\n @param resVecPixMap Indicates a pointer array to the <b>Pixelmap</b> objects obtained at the C++ native layer.\n It cannot be a null pointer.\n @param size Indicates a size of resVecPixMap. User can get size from {@link OH_ImageSourceNative_GetFrameCount}.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_CreatePixelmapList(
        source: *mut OH_ImageSourceNative,
        options: *mut OH_DecodingOptions,
        resVecPixMap: *mut *mut OH_PixelmapNative,
        size: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Create Picture pointer from ImageSource\n based on the specified {@link OH_DecodingOptionsForPicture} struct.\n\n @param source Indicates a void pointer(from ImageSource pointer convert).\n @param options Indicates a pointer to the options for decoding the image source.\n For details, see {@link OH_DecodingOptionsForPicture}.\n @param picture Indicates a void pointer to the <b>Picture</b> object obtained at the C++ native layer.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} source is nullptr, or picture is nullptr.\n         {@link IMAGE_DECODE_FAILED} decode failed.\n @since 13"]
    pub fn OH_ImageSourceNative_CreatePicture(
        source: *mut OH_ImageSourceNative,
        options: *mut OH_DecodingOptionsForPicture,
        picture: *mut *mut OH_PictureNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Decodes an image at the specified index into a Picture object.\n\n @param source Pointer to the image source.\n @param index Image index.\n @param picture Double pointer to the Picture object obtained after decoding.\n @return Result code.\n {@link IMAGE_SUCCESS}: The execution is successful.\n {@link IMAGE_BAD_SOURCE}: The data source is abnormal.\n {@link IMAGE_SOURCE_UNSUPPORTED_MIMETYPE}: The image format is unsupported.\n {@link IMAGE_SOURCE_TOO_LARGE}: The image is too large.\n {@link IMAGE_SOURCE_UNSUPPORTED_OPTIONS}: The operation is not supported, for example, invalid index.\n {@link IMAGE_DECODE_FAILED}: Decoding fails.\n @since 20"]
    pub fn OH_ImageSourceNative_CreatePictureAtIndex(
        source: *mut OH_ImageSourceNative,
        index: u32,
        picture: *mut *mut OH_PictureNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the delay time list from some <b>ImageSource</b> objects (such as GIF image sources).\n\n @param source Indicates a void pointer(from ImageSource pointer convert).\n @param delayTimeList Indicates a pointer to the delay time list obtained. It cannot be a null pointer.\n @param size Indicates a size of delayTimeList. User can get size from {@link OH_ImageSourceNative_GetFrameCount}.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_GetDelayTimeList(
        source: *mut OH_ImageSourceNative,
        delayTimeList: *mut i32,
        size: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains image source information from an <b>ImageSource</b> object by index.\n\n @param source Indicates a void pointer(from ImageSource pointer convert).\n @param index Indicates the index of the frame.\n @param info Indicates a pointer to the image source information obtained.\n For details, see {@link OH_ImageSource_Info}.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_GetImageInfo(
        source: *mut OH_ImageSourceNative,
        index: i32,
        info: *mut OH_ImageSource_Info,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the value of an image property from an <b>ImageSource</b> object.\n\n @param source Indicates a void pointer(from ImageSource pointer convert).\n @param key Indicates a pointer to the property. For details, see {@link Image_String}., key is an exif constant.\n Release after use ImageSource, see {@link OH_ImageSourceNative_Release}.\n @param value Indicates a pointer to the value obtained.The user can pass in a null pointer and zero size,\n we will allocate memory, but user must free memory after use.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_GetImageProperty(
        source: *mut OH_ImageSourceNative,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-19")]
    #[doc = " @brief Obtains the value of an image property from an <b>ImageSource</b> object. The output value.data is null-terminated.\n\n @param source Pointer to ImageSource.\n @param key Pointer to the property key.\n @param value Pointer to the property value. Output Parameter.\n @return Returns One of the following result codes:\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_SOURCE_INVALID_PARAMETER} if source, key or value is nullptr.\n @since 19"]
    pub fn OH_ImageSourceNative_GetImagePropertyWithNull(
        source: *mut OH_ImageSourceNative,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Modifies the value of an image property of an <b>ImageSource</b> object.\n @param source Indicates a void pointer(from ImageSource pointer convert).\n @param key Indicates a pointer to the property. For details, see {@link Image_String}., key is an exif constant.\n Release after use ImageSource, see {@link OH_ImageSourceNative_Release}.\n @param value Indicates a pointer to the new value of the property.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_ModifyImageProperty(
        source: *mut OH_ImageSourceNative,
        key: *mut Image_String,
        value: *mut Image_String,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the number of frames from an <b>ImageSource</b> object.\n\n @param source Indicates a pointer to the {@link OH_ImageSource} object at the C++ native layer.\n @param frameCount The number of image frameCount.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_GetFrameCount(
        source: *mut OH_ImageSourceNative,
        frameCount: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases an <b>ImageSourc</b> object.\n\n @param source Indicates a ImageSource pointer.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImageSourceNative_Release(source: *mut OH_ImageSourceNative) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Create a pointer for OH_DecodingOptionsForPicture struct.\n\n @param options The OH_DecodingOptionsForPicture pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options is nullptr.\n @since 13"]
    pub fn OH_DecodingOptionsForPicture_Create(
        options: *mut *mut OH_DecodingOptionsForPicture,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Obtains the desired auxiliary pictures of decoding options.\n\n @param options The OH_DecodingOptionsForPicture pointer will be operated.\n @param desiredAuxiliaryPictures The desired auxiliary pictures in DecodingOptionsForPicture.\n @param length The length of desired auxiliary pictures.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options is nullptr, desiredAuxiliaryPictures is nullptr,\n         or length is invalid.\n @since 13"]
    pub fn OH_DecodingOptionsForPicture_GetDesiredAuxiliaryPictures(
        options: *mut OH_DecodingOptionsForPicture,
        desiredAuxiliaryPictures: *mut *mut Image_AuxiliaryPictureType,
        length: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Set decoding options desired auxiliary pictures.\n\n @param options The OH_DecodingOptionsForPicture pointer will be operated.\n @param desiredAuxiliaryPictures The desired auxiliary pictures will be set.\n @param length The length of desired auxiliary pictures.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options is nullptr, desiredAuxiliaryPictures is nullptr,\n         or length is invalid.\n @since 13"]
    pub fn OH_DecodingOptionsForPicture_SetDesiredAuxiliaryPictures(
        options: *mut OH_DecodingOptionsForPicture,
        desiredAuxiliaryPictures: *mut Image_AuxiliaryPictureType,
        length: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Releases an <b>DecodingOptionsForPicture</b> object.\n\n @param options Indicates a DecodingOptionsForPicture pointer.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options is nullptr.\n @since 13"]
    pub fn OH_DecodingOptionsForPicture_Release(
        options: *mut OH_DecodingOptionsForPicture,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Obtains the supported image formats that can be decoded.\n\n @param supportedFormats Double pointer to an array of the supported image formats.\n @param length Pointer to the length of the array.\n @return One of the following result codes:\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_SOURCE_INVALID_PARAMETER} if <b>supportedFormats</b> or <b>length</b> is empty.\n @since 20"]
    pub fn OH_ImageSourceNative_GetSupportedFormats(
        supportedFormats: *mut *mut Image_MimeType,
        length: *mut usize,
    ) -> Image_ErrorCode;
}
#[doc = " @brief Define a ImagePacker struct type, used for ImagePacker pointer controls.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_ImagePackerNative {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the image packing options.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PackingOptions {
    _unused: [u8; 0],
}
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the image sequence packing options.\n\n @since 18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_PackingOptionsForSequence {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Create a pointer for PackingOptions struct.\n\n @param options The PackingOptions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PackingOptions_Create(options: *mut *mut OH_PackingOptions) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get mime type for OH_PackingOptions struct.\n\n @param options The OH_PackingOptions pointer will be operated.\n @param format the number of image format.The user can pass in a null pointer and zero size, we will allocate memory,\n but user must free memory after use.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PackingOptions_GetMimeType(
        options: *mut OH_PackingOptions,
        format: *mut Image_MimeType,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-19")]
    #[doc = " @brief Gets MIME type from OH_PackingOptions. The output format.data is null-terminated.\n\n @param options The OH_PackingOptions pointer will be operated.\n @param format MimeType set in the OH_PackingOptions.\n @return Returns functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_PACKER_INVALID_PARAMETER} if options or format is nullptr.\n @since 19"]
    pub fn OH_PackingOptions_GetMimeTypeWithNull(
        options: *mut OH_PackingOptions,
        format: *mut Image_MimeType,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set format number for OH_PackingOptions struct.\n\n @param options The OH_PackingOptions pointer will be operated.\n @param format the number of image format.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PackingOptions_SetMimeType(
        options: *mut OH_PackingOptions,
        format: *mut Image_MimeType,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get quality for OH_PackingOptions struct.\n\n @param options The OH_PackingOptions pointer will be operated.\n @param quality The number of image quality.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PackingOptions_GetQuality(
        options: *mut OH_PackingOptions,
        quality: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set quality number for OH_PackingOptions struct.\n\n @param options The OH_PackingOptions pointer will be operated.\n @param quality The number of image quality.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PackingOptions_SetQuality(
        options: *mut OH_PackingOptions,
        quality: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get needsPackProperties for OH_PackingOptions struct.\n\n @param options The OH_PackingOptions pointer will be operated.\n @param needsPackProperties Whether the image properties can be saved, like Exif.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PackingOptions_GetNeedsPackProperties(
        options: *mut OH_PackingOptions,
        needsPackProperties: *mut bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set needsPackProperties for OH_PackingOptions struct.\n\n @param options The OH_PackingOptions pointer will be operated.\n @param needsPackProperties Whether the image properties can be saved, like Exif.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PackingOptions_SetNeedsPackProperties(
        options: *mut OH_PackingOptions,
        needsPackProperties: bool,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get desiredDynamicRange for PackingOptions struct.\n\n @param options The PackingOptions pointer will be operated. Pointer connot be null.\n @param desiredDynamicRange The number of dynamic range {@link IMAGE_PACKER_DYNAMIC_RANGE}. Pointer connot be null.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n @since 12"]
    pub fn OH_PackingOptions_GetDesiredDynamicRange(
        options: *mut OH_PackingOptions,
        desiredDynamicRange: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set desiredDynamicRange number for PackingOptions struct.\n\n @param options The PackingOptions pointer will be operated. Pointer connot be null.\n @param desiredDynamicRange The number of dynamic range {@link IMAGE_PACKER_DYNAMIC_RANGE}.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - The operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - Parameter error.Possible causes:Parameter verification failed.\n @since 12"]
    pub fn OH_PackingOptions_SetDesiredDynamicRange(
        options: *mut OH_PackingOptions,
        desiredDynamicRange: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief delete OH_PackingOptions pointer.\n\n @param options The OH_PackingOptions pointer will be operated.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_PackingOptions_Release(options: *mut OH_PackingOptions) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Create a pointer for OH_PackingOptionsForSequence struct.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_Create(
        options: *mut *mut OH_PackingOptionsForSequence,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Set FrameCount number for OH_PackingOptionsForSequence struct.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @param frameCount The number of image frameCount.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_SetFrameCount(
        options: *mut OH_PackingOptionsForSequence,
        frameCount: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Get FrameCount number for OH_PackingOptionsForSequence struct.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @param frameCount The number of image frameCount.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options or frameCount is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_GetFrameCount(
        options: *mut OH_PackingOptionsForSequence,
        frameCount: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Set DelayTimeList number for OH_PackingOptionsForSequence struct.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @param delayTimeList The pointer of image delayTime list.\n @param delayTimeListLength The number of image delayTimeListLength.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options or delayTimeList is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_SetDelayTimeList(
        options: *mut OH_PackingOptionsForSequence,
        delayTimeList: *mut i32,
        delayTimeListLength: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Get DelayTimeList number for OH_PackingOptionsForSequence struct.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @param delayTimeList The pointer of image delayTime list.\n @param delayTimeListLength The number of image delayTimeListLength.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options or delayTimeList is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_GetDelayTimeList(
        options: *mut OH_PackingOptionsForSequence,
        delayTimeList: *mut i32,
        delayTimeListLength: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Set DisposalTypes number for OH_PackingOptionsForSequence struct.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @param disposalTypes The pointer of image disposalTypes.\n @param disposalTypesLength The number of image disposalTypesLength.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options or disposalTypes is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_SetDisposalTypes(
        options: *mut OH_PackingOptionsForSequence,
        disposalTypes: *mut u32,
        disposalTypesLength: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Get DisposalTypes number for OH_PackingOptionsForSequence struct.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @param disposalTypes The pointer of image disposalTypes.\n @param disposalTypesLength The number of image disposalTypesLength.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options or disposalTypes is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_GetDisposalTypes(
        options: *mut OH_PackingOptionsForSequence,
        disposalTypes: *mut u32,
        disposalTypesLength: usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Set LoopCount number for OH_PackingOptionsForSequence struct.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @param loopCount The number of image loopCount.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_SetLoopCount(
        options: *mut OH_PackingOptionsForSequence,
        loopCount: u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Get LoopCount number for OH_PackingOptionsForSequence struct.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @param loopCount The number of image loopCount.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options or loopCount is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_GetLoopCount(
        options: *mut OH_PackingOptionsForSequence,
        loopCount: *mut u32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief delete OH_PackingOptionsForSequence pointer.\n\n @param options The OH_PackingOptionsForSequence pointer will be operated.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} options is nullptr.\n @since 18"]
    pub fn OH_PackingOptionsForSequence_Release(
        options: *mut OH_PackingOptionsForSequence,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Create a pointer for OH_ImagePackerNative struct.\n\n @param imagePacker The imagePacker to be created.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImagePackerNative_Create(
        imagePacker: *mut *mut OH_ImagePackerNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Encoding an <b>ImageSource</b> into the data with required format.\n\n @param imagePacker The imagePacker to use for packing.\n @param options Indicates the encoding {@link OH_PackingOptions}.\n @param imageSource The imageSource to be packed.\n @param outData The output data buffer to store the packed image.\n @param size A pointer to the size of the output data buffer.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImagePackerNative_PackToDataFromImageSource(
        imagePacker: *mut OH_ImagePackerNative,
        options: *mut OH_PackingOptions,
        imageSource: *mut OH_ImageSourceNative,
        outData: *mut u8,
        size: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Encoding a <b>Pixelmap</b> into the data with required format.\n\n @param imagePacker The imagePacker to use for packing.\n @param options Indicates the encoding {@link OH_PackingOptions}.\n @param pixelmap The pixelmap to be packed.\n @param outData The output data buffer to store the packed image.\n @param size A pointer to the size of the output data buffer.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImagePackerNative_PackToDataFromPixelmap(
        imagePacker: *mut OH_ImagePackerNative,
        options: *mut OH_PackingOptions,
        pixelmap: *mut OH_PixelmapNative,
        outData: *mut u8,
        size: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Encoding a <b>Picture</b> into the data with required format.\n\n @param imagePacker The imagePacker to use for packing.\n @param options Indicates the encoding {@link OH_PackingOptions}.\n @param picture The picture to be packed.\n @param outData The output data buffer to store the packed image.\n @param size A pointer to the size of the output data buffer.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} imagePacker is nullptr, or picture is nullptr, or outData is nullptr,\n         or size is invalid.\n         {@link IMAGE_ENCODE_FAILED} encode failed.\n @since 13"]
    pub fn OH_ImagePackerNative_PackToDataFromPicture(
        imagePacker: *mut OH_ImagePackerNative,
        options: *mut OH_PackingOptions,
        picture: *mut OH_PictureNative,
        outData: *mut u8,
        size: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Encoding a <b>PixelMap</b> sequence into the data\n\n @param imagePacker The imagePacker to use for packing.\n @param options Indicates the encoding {@link OH_PackingOptionsForSequence}.\n @param pixelmapSequence The pixelmap sequence to be packed.\n @param sequenceLength The pixelmap sequence size to be packed.\n @param outData The output data buffer to store the packed image.\n @param outDataSize A pointer to the size of the output data buffer.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} one of the pointer type parameters is nullptr, or size/length is invalid\n         {@link IMAGE_ENCODE_FAILED} encode failed.\n @since 18"]
    pub fn OH_ImagePackerNative_PackToDataFromPixelmapSequence(
        imagePacker: *mut OH_ImagePackerNative,
        options: *mut OH_PackingOptionsForSequence,
        pixelmapSequence: *mut *mut OH_PixelmapNative,
        sequenceLength: usize,
        outData: *mut u8,
        outDataSize: *mut usize,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Encoding an <b>ImageSource</b> into the a file with fd with required format.\n\n @param imagePacker The image packer to use for packing.\n @param options Indicates the encoding {@link OH_PackingOptions}.\n @param imageSource The imageSource to be packed.\n @param fd Indicates a writable file descriptor.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImagePackerNative_PackToFileFromImageSource(
        imagePacker: *mut OH_ImagePackerNative,
        options: *mut OH_PackingOptions,
        imageSource: *mut OH_ImageSourceNative,
        fd: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Encoding a <b>Pixelmap</b> into the a file with fd with required format\n\n @param imagePacker The image packer to use for packing.\n @param options Indicates the encoding {@link OH_PackingOptions}.\n @param pixelmap The pixelmap to be packed.\n @param fd Indicates a writable file descriptor.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImagePackerNative_PackToFileFromPixelmap(
        imagePacker: *mut OH_ImagePackerNative,
        options: *mut OH_PackingOptions,
        pixelmap: *mut OH_PixelmapNative,
        fd: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-13")]
    #[doc = " @brief Encoding a <b>Picture</b> into the a file with fd with required format.\n\n @param imagePacker The imagePacker to use for packing.\n @param options Indicates the encoding {@link OH_PackingOptions}.\n @param picture The picture to be packed.\n @param fd Indicates a writable file descriptor.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} imagePacker is nullptr, or picture is nullptr, or fd is invalid.\n         {@link IMAGE_ENCODE_FAILED} encode failed.\n @since 13"]
    pub fn OH_ImagePackerNative_PackToFileFromPicture(
        imagePacker: *mut OH_ImagePackerNative,
        options: *mut OH_PackingOptions,
        picture: *mut OH_PictureNative,
        fd: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Encoding a <b>PixelMap</b> sequence into the a file with fd\n\n @param imagePacker The image packer to use for packing.\n @param options Indicates the encoding {@link OH_PackingOptionsForSequence}.\n @param pixelmapSequence The pixelmap sequence to be packed.\n @param sequenceLength The pixelmap sequence size to be packed.\n @param fd Indicates a writable file descriptor.\n @return Image functions result code.\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_BAD_PARAMETER} one of the pointer type parameters is nullptr, or length is invalid\n         {@link IMAGE_ENCODE_FAILED} encode failed.\n @since 18"]
    pub fn OH_ImagePackerNative_PackToFileFromPixelmapSequence(
        imagePacker: *mut OH_ImagePackerNative,
        options: *mut OH_PackingOptionsForSequence,
        pixelmapSequence: *mut *mut OH_PixelmapNative,
        sequenceLength: usize,
        fd: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases an imagePacker object.\n\n @param imagePacker A pointer to the image packer object to be released.\n @return Returns {@link Image_ErrorCode}\n @since 12"]
    pub fn OH_ImagePackerNative_Release(imagePacker: *mut OH_ImagePackerNative) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Obtains the supported image formats that can be encoded.\n\n @param supportedFormats Double pointer to an array of the supported image formats.\n @param length Pointer to the length of the array.\n @return One of the following result codes:\n         {@link IMAGE_SUCCESS} if the execution is successful.\n         {@link IMAGE_PACKER_INVALID_PARAMETER} if <b>supportedFormats</b> or <b>length</b> is empty.\n @since 20"]
    pub fn OH_ImagePackerNative_GetSupportedFormats(
        supportedFormats: *mut *mut Image_MimeType,
        length: *mut usize,
    ) -> Image_ErrorCode;
}
#[doc = " @brief Defines an <b>OH_ImageReceiverNative</b> object.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_ImageReceiverNative {
    _unused: [u8; 0],
}
#[doc = " @brief Defines an image receiver options object.\n\n @since 12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_ImageReceiverOptions {
    _unused: [u8; 0],
}
#[doc = " @brief Defines the callbacks for images.\n\n @since 12"]
pub type OH_ImageReceiver_OnCallback =
    ::std::option::Option<unsafe extern "C" fn(receiver: *mut OH_ImageReceiverNative)>;
#[cfg(feature = "api-20")]
#[doc = " @brief Defines the callback for the ImageArrive event.\n\n @since 20"]
pub type OH_ImageReceiver_ImageArriveCallback = ::std::option::Option<
    unsafe extern "C" fn(
        receiver: *mut OH_ImageReceiverNative,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Creates an <b>OH_ImageReceiverOptions</b> object at the application layer.\n\n @param options Indicates the pointer to the <b>OH_ImageReceiverOptions</b> object obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n returns {@link Image_ErrorCode} IMAGE_ALLOC_FAILED - if alloc failed.\n @since 12"]
    pub fn OH_ImageReceiverOptions_Create(
        options: *mut *mut OH_ImageReceiverOptions,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get size of an {@link OH_ImageReceiverOptions} object.\n\n @param options Indicates the pointer to an {@link OH_ImageReceiverOptions} object.\n @param size Indicates the value of the {@Link Image_Size} object will be obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageReceiverOptions_GetSize(
        options: *mut OH_ImageReceiverOptions,
        size: *mut Image_Size,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set size of an {@link OH_ImageReceiverOptions} object.\n\n @param options Indicates the pointer to an {@link OH_ImageReceiverOptions} object.\n @param size Indicates the value of the {@link Image_Size} object will be seted.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageReceiverOptions_SetSize(
        options: *mut OH_ImageReceiverOptions,
        size: Image_Size,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Get capacity from an {@link OH_ImageReceiverOptions} object.\n\n @param options Indicates the pointer to an {@link OH_ImageReceiverOptions} object.\n @param capacity Indicates the pointer to capacity will be obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageReceiverOptions_GetCapacity(
        options: *mut OH_ImageReceiverOptions,
        capacity: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Set capacity of an {@link OH_ImageReceiverOptions} object.\n\n @param options Indicates the pointer to an {@link OH_ImageReceiverOptions} object.\n @param capacity Indicates the value of capacity will be seted.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @since 12"]
    pub fn OH_ImageReceiverOptions_SetCapacity(
        options: *mut OH_ImageReceiverOptions,
        capacity: i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases an {@link OH_ImageReceiverOptions} object.\n It is used to release the object {@link OH_ImageReceiverOptions}.\n\n @param options Indicates the pointer to an {@link OH_ImageReceiverOptions} object.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @see OH_ImageReceiverOptions\n @since 12"]
    pub fn OH_ImageReceiverOptions_Release(
        options: *mut OH_ImageReceiverOptions,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Creates an <b>OH_ImageReceiverNative</b> object at the application layer.\n\n @param options Indicates the options for setting the <b>OH_ImageReceiverNative</b> object.\n @param receiver Indicates the pointer to the <b>OH_ImageReceiverNative</b> object obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n returns {@link Image_ErrorCode} IMAGE_ALLOC_FAILED - if alloc failed.\n @since 12"]
    pub fn OH_ImageReceiverNative_Create(
        options: *mut OH_ImageReceiverOptions,
        receiver: *mut *mut OH_ImageReceiverNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the receiver ID through an {@link OH_ImageReceiverNative} object.\n\n @param receiver Indicates the pointer to an {@link OH_ImageReceiverNative} object.\n @param surfaceId Indicates the pointer to the surfaceID will be obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error.\n @see OH_ImageReceiverNative\n @since 12"]
    pub fn OH_ImageReceiverNative_GetReceivingSurfaceId(
        receiver: *mut OH_ImageReceiverNative,
        surfaceId: *mut u64,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the latest image through an {@link OH_ImageReceiverNative} object.\n\n @param receiver Indicates the pointer to an {@link OH_ImageReceiverNative} object.\n @param image Indicates the pointer to an <b>OH_ImageNative</b> object at the application layer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error.\n returns {@link Image_ErrorCode} IMAGE_ALLOC_FAILED - if alloc failed.\n @see OH_ImageReceiverNative, OH_ImageNative\n @since 12"]
    pub fn OH_ImageReceiverNative_ReadLatestImage(
        receiver: *mut OH_ImageReceiverNative,
        image: *mut *mut OH_ImageNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the next image through an {@link OH_ImageReceiverNative} object.\n\n @param receiver Indicates the pointer to an {@link OH_ImageReceiverNative} object.\n @param image Indicates the pointer to an <b>OH_ImageNative</b> object at the application layer.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n returns {@link Image_ErrorCode} IMAGE_UNKNOWN_ERROR - inner unknown error.\n returns {@link Image_ErrorCode} IMAGE_ALLOC_FAILED - if alloc failed.\n @see OH_ImageReceiverNative, OH_ImageNative\n @since 12"]
    pub fn OH_ImageReceiverNative_ReadNextImage(
        receiver: *mut OH_ImageReceiverNative,
        image: *mut *mut OH_ImageNative,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Registers an {@link OH_ImageReceiver_OnCallback} callback event.\n\n This callback event is triggered whenever a new image is received.\n\n @param receiver Indicates the pointer to an {@link OH_ImageReceiverNative} object.\n @param callback Indicates the {@link OH_ImageReceiver_OnCallback} callback event to register.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @see OH_ImageReceiverNative, OH_ImageReceiver_OnCallback\n @since 12"]
    pub fn OH_ImageReceiverNative_On(
        receiver: *mut OH_ImageReceiverNative,
        callback: OH_ImageReceiver_OnCallback,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Unregisters the {@link OH_ImageReceiver_OnCallback} callback event.\n\n Turn off the callback witch triggered by {@link OH_ImageReceiverNative_On}.\n\n @param receiver Indicates the pointer to an {@link OH_ImageReceiverNative} object.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @see OH_ImageReceiverNative, OH_ImageReceiverNative_On\n @since 12"]
    pub fn OH_ImageReceiverNative_Off(receiver: *mut OH_ImageReceiverNative) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " Registers an {@link OH_ImageReceiver_ImageArriveCallback} callback.\n\n @param receiver Pointer to an OH_ImageReceiverNative object that processes the callback.\n @param callback OH_ImageReceiver_ImageArriveCallback to register.\n @param userData Pointer to the user data passed to the callback.\n @return Result code. {@link Image_ErrorCode} IMAGE_SUCCESS is returned if the operation is successful.\n {@link Image_ErrorCode} IMAGE_RECEIVER_INVALID_PARAMETER is returned if receiver or callback is null.\n @since 20"]
    pub fn OH_ImageReceiverNative_OnImageArrive(
        receiver: *mut OH_ImageReceiverNative,
        callback: OH_ImageReceiver_ImageArriveCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " Unregisters an {@link OH_ImageReceiver_ImageArriveCallback} callback.\n\n @param receiver Pointer to an <b>OH_ImageReceiverNative</b> object that processes the callback.\n @param callback <b>OH_ImageReceiver_ImageArriveCallback</b> callback to unregister.\n @return {@link Image_ErrorCode} IMAGE_SUCCESS - Operation succeeded.\n {@link Image_ErrorCode} IMAGE_RECEIVER_INVALID_PARAMETER - <b>receiver</b> is empty or <b>callback</b> is not\n registered.\n @since 20"]
    pub fn OH_ImageReceiverNative_OffImageArrive(
        receiver: *mut OH_ImageReceiverNative,
        callback: OH_ImageReceiver_ImageArriveCallback,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the size of the image receiver through an {@link OH_ImageReceiverNative} object.\n\n @param receiver Indicates the pointer to an {@link OH_ImageReceiverNative} object.\n @param size Indicates the pointer to the {@link Image_Size} object will be obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @see OH_ImageReceiverNative, Image_Size\n @since 12"]
    pub fn OH_ImageReceiverNative_GetSize(
        receiver: *mut OH_ImageReceiverNative,
        size: *mut Image_Size,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Obtains the capacity of the image receiver through an {@link OH_ImageReceiverNative} object.\n\n @param receiver Indicates the pointer to an {@link OH_ImageReceiverNative} object.\n @param capacity Indicates the pointer to the capacity will be obtained.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @see OH_ImageReceiverNative\n @since 12"]
    pub fn OH_ImageReceiverNative_GetCapacity(
        receiver: *mut OH_ImageReceiverNative,
        capacity: *mut i32,
    ) -> Image_ErrorCode;
}
extern "C" {
    #[doc = " @brief Releases an {@link OH_ImageReceiverNative} object.\n\n This API is not used to release an <b>ImageReceiver2</b> object at the application layer.\n\n @param receiver Indicates the pointer to an {@link OH_ImageReceiverNative} object.\n @return Returns {@link Image_ErrorCode} IMAGE_SUCCESS - if the operation is successful.\n returns {@link Image_ErrorCode} IMAGE_BAD_PARAMETER - if bad parameter.\n @see OH_ImageReceiverNative\n @since 12"]
    pub fn OH_ImageReceiverNative_Release(receiver: *mut OH_ImageReceiverNative)
        -> Image_ErrorCode;
}
